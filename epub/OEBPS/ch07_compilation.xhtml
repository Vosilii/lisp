<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru"></p>

<p><body>
\chapter{Компиляция}\label{chapter:compilation}</p>

<p>\initial{0.75ex}{0.0ex}{В}{\kern1ex предыдущей главе} был изложен метод перевода
программ со Scheme на древовидный язык, содержащий около двадцати инструкций.
В этой главе мы покажем, как преобразовать результат данной предварительной
обработки в последовательность байтов — специализированный
машинный язык. По пути будут рассмотрены следующие темы: создание виртуальной
машины, компиляция в её внутренний язык, реализация различных расширений Scheme
вроде переходов, динамических переменных, исключений.</p>

<p>\begin{table}[!h]%
\def\I{<i>i</i>}
\def\J{<i>j</i>}
\def\M{<i>m</i>}
\def\V{<i>v</i>}
\def\MU{<i>m</i>{\normalfont\textsubscript{1}}}
\def\MD{<i>m</i>{\normalfont\textsubscript{2}}}
\def\MT{<i>m</i>{\normalfont\textsubscript{3}}}
\def\MP{<i>m</i>{\normalfont+}}
\def\MS{<i>m</i>{\normalfont\textasteriskcentered}}
\def\AR{<i>арность</i>}
\def\AD{<i>адрес</i>}
\def\II{<i>индекс</i>}
\def\SZ{<i>размер</i>}
\setlength{\tabcolsep}{0.5em}
\small\centering
\begin{tabular}{|l|l|}
\hline
\rule[1.25em]{0pt}{\baselineskip}%
<code>(SHALLOW-ARGUMENT-REF \J)</code>        & <code>(PREDEFINED \I)</code>                \\
<code>(DEEP-ARGUMENT-REF \I\ \J)</code>       & <code>(SHALLOW-ARGUMENT-SET! \J\ \M)</code> \\
<code>(DEEP-ARGUMENT-SET! \I\ \J\ \M)</code>  & <code>(GLOBAL-REF \I)</code>                \\
<code>(CHECKED-GLOBAL-REF \I)</code>          & <code>(GLOBAL-SET! \I\ \M)</code>           \\
<code>(CONSTANT \V)</code>                    & <code>(ALTERNATIVE \MU\ \MD\ \MT)</code>    \\
<code>(SEQUENCE \M\ \MP)</code>               & <code>(TR-FIX-LET \MS\ \MP)</code>          \\
<code>(FIX-LET \MS\ \MP)</code>               & <code>(CALL0 \AD)</code>                    \\
<code>(CALL1 \AD\ \MU)</code>                 & <code>(CALL2 \AD\ \MU\ \MD)</code>          \\
<code>(CALL3 \AD\ \MU\ \MD\ \MT)</code>       & <code>(FIX-CLOSURE \MP\ \AR)</code>         \\
<code>(NARY-CLOSURE \MP\ \AR)</code>          & <code>(TR-REGULAR-CALL \M\ \MS)</code>      \\
<code>(REGULAR-CALL \M\ \MS)</code>           & <code>(STORE-ARGUMENT \M\ \MS\ \II)</code>  \\
<code>(CONS-ARGUMENT \M\ \MS\ \AR)</code>     & <code>(ALLOCATE-FRAME \SZ)</code>           \\
<code>(ALLOCATE-DOTTED-FRAME \AR)</code>      & \rule[-0.6em]{0pt}{\baselineskip}   \\
\hline
\end{tabular}%
\caption{Все 25 инструкций промежуточного языка. {\M}, {\MU}, {\MD}, {\MT},
{\MP} и {\V} — значения; {\MS} — запись активации; {\II}, {\AR}, {\SZ},
{\I} и {\J} — натуральные числа (с нулём); {\AD} представляет примитивную
функцию, принимающую и возвращающую значения.}%
\label{compilation/tbl:intermediate}%
\end{table}</p>


<!--\indexR{язык!промежуточный}-->
<!--\indexR{промежуточное представление}-->
<p>\phantomlabel{compilation/par:disasm}
В результате компиляции обычно получается последовательность весьма
низкоуровневых инструкций. Это отнюдь не так для нашего предобработчика: мы
получаем на выходе структурированную древовидную программу. Рассмотрим
следующий красноречивый пример. Пусть у нас есть программа:</p>


<!--\indexC{fact}-->
<pre>((lambda (fact) (fact 5 fact (lambda (x) x)))
 (lambda (n f k) (if (= n 0) (k 1)
                     (f (- n 1) f (lambda (r) (k (* n r)))) )) )</pre>

<p>\noindent
После обработки она превращается в следующую:</p>

<pre>(TR-FIX-LET
 (STORE-ARGUMENT
  (FIX-CLOSURE
   (ALTERNATIVE
    (CALL2 #<=> (SHALLOW-ARGUMENT-REF 0) (CONSTANT 0))
    (TR-REGULAR-CALL (SHALLOW-ARGUMENT-REF 2)
                     (STORE-ARGUMENT (CONSTANT 1)
                                     (ALLOCATE-FRAME 1) 0) )
    (TR-REGULAR-CALL (SHALLOW-ARGUMENT-REF 1)
     (STORE-ARGUMENT (CALL2 #<-> (SHALLOW-ARGUMENT-REF 0) (CONSTANT 1))
      (STORE-ARGUMENT (SHALLOW-ARGUMENT-REF 1)
       (STORE-ARGUMENT (FIX-CLOSURE
                        (TR-REGULAR-CALL (DEEP-ARGUMENT-REF 1 2)
                         (STORE-ARGUMENT (CALL2 #<*>
                                          (DEEP-ARGUMENT-REF 1 0)
                                          (SHALLOW-ARGUMENT REF 0) )
                          (ALLOCATE-FRAME 1)
                          0 ) )
                        1 )
        (ALLOCATE-FRAME 3)
        2 )
       1 )
      0 ) ) )
   3 )
  (ALLOCATE-FRAME 1)
  0 )
 (TR-REGULAR-CALL (SHALLOW-ARGUMENT-REF 0)
  (STORE-ARGUMENT (CONSTANT 5)
   (STORE-ARGUMENT (SHALLOW-ARGUMENT-REF 0)
    (STORE-ARGUMENT (FIX-CLOSURE (SHALLOW-ARGUMENT-REF 0) 1)
     (ALLOCATE-FRAME 3)
     2 )
    1 )
   0 ) ) )</pre>

<p>Не шедевр удобочитаемости, но очень точно выражает необходимые действия.
Цель данной главы — показать, что данная форма ещё далека от окончательной.
Даже не форма — после выполнения преобразований вроде линеаризации и
байт-кодирования мы получим совершенно новый язык. Тот же язык,
инструкции-генераторы которого собраны
в таблице \ref{compilation/tbl:intermediate}, на самом деле будет служить
нам лишь промежуточным этапом, трамплином, от которого мы оттолкнёмся,
чтобы улететь в дальние миры.</p>

<p>Предварительная обработка (выполняемая третьим интерпретатором из предыдущей
главы) будет первым проходом компилятора. Соответственно, компилятор должен
понимать лишь эти двадцать пять инструкций. На самом деле, мы их даже немного
улучшим, заточив под целевой язык виртуальной машины. Подобное разделение труда
возможно благодаря тому, что промежуточный язык уже является исполнимым. Это
позволяет протестировать предобработчик отдельно и полностью сконцентрироваться
на второй фазе компиляции.</p>


<!--\indexR{байт-код}-->
<p>Для начала мы займёмся собственно компиляцией под виртуальную машину. Это будет
простая, но типичная виртуальная машина, программируемая с помощью машинного
языка. Её инструкции представляются байтами, целыми числами от 0 до 255. Такой
способ представления программ называется <em class="term">байт-кодом</em>. Изобретён он был
незадолго до 1980 года, судя по \cite{deu80,row80}. С тех пор байт-код нередко
используется для иллюстрации процесса компиляции; как пример: <span class="cite">[<a href="z1_bibliography.xhtml#hen80">hen80</a>]</span>.
Получаемый код является довольно компактным — качество, очень полезное на
машинах с ограниченной памятью или кешем. Именно компиляция в байт-код
применяется для PC-Scheme <span class="cite">[<a href="z1_bibliography.xhtml#bj86">bj86</a>]</span> и Caml Light <span class="cite">[<a href="z1_bibliography.xhtml#lw93">lw93</a>]</span>.</p>

<p>Концептуально байт-кодирование устроено довольно просто: прошедшая предобработку
программа компилируется в последовательность байт-кодов, которая уже исполняется
интерпретатором, эмулирующим виртуальную машину на реальной. Так как байт-коды
проще, чем высокоуровневые языки, то интерпретатор тратит значительно меньше
времени на их разбор и в итоге работает быстрее.</p>

<h2 id="compilation/sect:bytes">Компиляция в байт-код</h2>

<p>Задача на сейчас: шаг за шагом разработать специализированную машину,
исполняющую байт-коды. Мы определим эту машину, определив для неё смысл
(операционную семантику) двадцати пяти инструкций промежуточного языка.
Часть из них трактуются очевидным образом, другие потребуют некоторой
изобретательности. К счастью, виртуальная машина и её язык создаются
одновременно, что даёт неоценимую гибкость разработки. Для нас не будет
проблемой в любой момент добавить ещё один регистр или, например, дополнить
архитектуру стеком.</p>


<!--\indexR{линеаризация}-->
<p>Чтобы получить желаемую последовательность байт-кодов, потребуется вытянуть
в прямую линию изначальное дерево инструкций промежуточного языка,
<em class="term">линеаризовать</em> его. В данный момент эти инструкции обмениваются
информацией через аргументы и возвращаемые значения, но возможности передачи
информации между машинным инструкциями ограничены регистрами и стеком. Сейчас
наша машина имеет лишь один регистр: <code><span class="func">*env*</span></code>, содержащий текущее состояние
лексического окружения, но вскоре эта слегка спартанская архитектура обрастёт
жирком.</p>

<p>
\subsection{\texorpdfstring{Знакомьтесь, регистр \protect<code><span class="func">*val*</span></code>}%
{Знакомьтесь, регистр *val*}}%
\label{compilation/bytes/ssect:*val*}</p>


<!--\indexR{инструкции!производители}-->
<!--\indexR{инструкции!потребители}-->
<p>Некоторые инструкции промежуточного языка производят значения, например,
<code><span class="func">SHALLOW-ARGUMENT-REF</span></code> или <code><span class="func">CONSTANT</span></code>. Другие же, подобные <code><span class="func">FIX-LET</span></code>
или <code><span class="func">ALTERNATIVE</span></code>, только управляют ходом вычислений. Помимо них есть и
третья разновидность инструкций, которые потребляют значения, производимые
первыми. Давайте внимательно рассмотрим инструкцию <code><span class="func">GLOBAL-SET!</span></code>,
определяемую следующим образом:</p>

<pre>(define (GLOBAL-SET! i m)
  (lambda () (global-update! i (m))) )</pre>


<!--\indexC*{val}{*val*}-->
<!--\indexR{регистры!val@\protect<code><span class="func">*val*</span></code>}-->
<p>Для того, чтобы передать инструкции <code><span class="func">global-update!</span></code> результат
вычисления <code>(m)</code>, необходим дополнительный регистр. Назовём его <code><span class="func">*val*</span></code>.
Инструкции-производители, соответственно, кладут возвращаемые значения в этот
регистр, а инструкции-потребители — забирают их оттуда. В итоге, типичный
производитель <code><span class="func">CONSTANT</span></code> теперь записывается вот так:</p>


<!--\indexC{CONSTANT}-->
<pre>(define (CONSTANT value)
  (lambda ()
    (set! *val* value) ) )</pre>

<p>\noindent
а потребители значений вроде <code><span class="func">GLOBAL-SET!</span></code> становятся такими:</p>


<!--\indexC{GLOBAL-SET"!}-->
<pre>(define (GLOBAL-SET! i m)
  (lambda ()
    (m)
    (global-update! i *val*) ) )</pre>

<p>Итого, форма <code>(m)</code> размещает новое значение переменной в регистре <code><span class="func">*val*</span></code>,
затем его оттуда забирает <code><span class="func">global-update!</span></code> и переносит в глобальное
окружение. Заметьте, что <code><span class="func">global-update!</span></code> не изменяет значение регистра
<code><span class="func">*val*</span></code>, ведь это потребовало бы как минимум одной лишней инструкции.
Следовательно, возвращаемым значением этой формы присваивания является только
что присвоенное глобальной переменной значение.</p>

<p>По этому примеру довольно легко догадаться, как преобразовать остальные
инструкции. Например, <code><span class="func">SEQUENCE</span></code> вообще не требует изменений:</p>


<!--\indexC{SEQUENCE}-->
<pre>(define (SEQUENCE m m+)
  (lambda () (m) (m+)) )</pre>

<p>\noindent
а <code><span class="func">FIX-LET</span></code> принимает следующий вид:</p>


<!--\indexC{FIX-LET}-->
<pre>(define (FIX-LET m* m+)
  (lambda ()
    (m*)
    (set! *env* (sr-extend* *env* *val*))
    (m+)
    (set! *env* (activation-frame-next *env*)) ) )</pre>

<h3 id="compilation/bytes/ssect:stack">Изобретение стека</h3>

<p>На данный момент часть инструкций уже линеаризована с помощью регистра
<code><span class="func">*val*</span></code>, но некоторые из них так просто не поддаются. Например,
<code><span class="func">STORE-ARGUMENT</span></code> сейчас имеет такое определение:</p>


<!--\indexC{STORE-ARGUMENT}-->
<pre>(define (STORE-ARGUMENT m m* index)
  (lambda ()
    (m)
    (let ((v *val*))
      (m*)
      (set-activation-frame-argument! *val* index v) ) ) )</pre>


<!--\indexR{стек}-->
<p>Эта инструкция использует <code><span class="func">let</span></code>, чтобы сохранить, а затем восстановить
значение регистра <code><span class="func">*val*</span></code>. Форма <code><span class="func">let</span></code> сохраняет значение в «анонимном
регистре» <code><span class="func">v</span></code> на время, пока вычисляется <code>(m*)</code>. Под <code><span class="func">v</span></code> не получится
выделить реальный машинный регистр, так как нам может потребоваться произвольное
количество таких <code><span class="func">v</span></code> одновременно — ведь, например, внутри <code><span class="func">m*</span></code> вполне
может быть ещё несколько вложенных <code><span class="func">STORE-ARGUMENT</span></code>. Следовательно, здесь
необходимо нечто, где можно хранить несколько значений между инструкциями. Для
этой цели уместно будет использовать стек, так как он прекрасно отображает идею
сбалансированных сохранений-восстановлений. Определяется он элементарно:</p>


<!--\indexC*{stack}{*stack*}-->
<!--\indexC*{stack-push}{*stack-push*}-->
<!--\indexC*{stack-pop}{*stack-pop*}-->
<!--\indexC*{stack-index}{*stack-index*}-->
<pre>(define *stack* (make-vector 1000))
(define *stack-index* 0)</p>

<p>(define (stack-push v)
  (vector-set! *stack* *stack-index* v)
  (set! *stack-index* (+ *stack-index* 1)) )</p>

<p>(define (stack-pop)
  (set! *stack-index* (- *stack-index* 1))
  (vector-ref *stack* *stack-index*) )</pre>

<p>Обретя данную революционную технологию, мы тут же используем её для радикального
преобразования инструкции <code><span class="func">STORE-ARGUMENT</span></code>. Теперь временные значения можно
сохранить в стеке перед началом других вычислений, чтобы после их окончания
достать оттуда всё в целости и сохранности. Правда, это сработает только при
условии, что форма <code>(m*)</code> оставит стек в том же состоянии, в каком он был до
её исполнения. Следовательно, необходимо быть аккуратным и везде следить за
соблюдением данного инварианта.</p>


<!--\indexC{STORE-ARGUMENT}-->
<pre>(define (STORE-ARGUMENT m m* index)
  (lambda ()
    (m)
    (stack-push *val*)
    (m*)
    (set-activation-frame-argument! *val* index (stack-pop)) ) )</pre>

<p>Модификация <code><span class="func">REGULAR-CALL</span></code> аналогична, только здесь требуется хранить сразу
два значения: саму функцию на время вычисления аргументов, а также текущее
окружение на время выполнения функции. Сейчас эта инструкция выглядит так:</p>

<pre>(define (REGULAR-CALL m m*)
  (lambda ()
    (m)
    (let ((f *val*))
      (m*)
      (let ((sr *env*))
        (invoke f *val*)
        (set! *env* sr) ) ) ) )</pre>


<!--\indexC*{fun}{*fun*}-->
<!--\indexR{регистры!fun@\protect<code><span class="func">*fun*</span></code>}-->
<p>После добавления нового регистра для функций — <code><span class="func">*fun*</span></code>, — определение
преобразуется в следующее:</p>


<!--\indexC{REGULAR-CALL}-->
<pre>(define (REGULAR-CALL m m*)
  (lambda ()
    (m)
    (stack-push *val*)
    (m*)
    (set! *fun* (stack-pop))
    (stack-push *env*)
    (invoke *fun*)
    (set! *env* (stack-pop)) ) )</pre>

<p>Заигравшись, мы мимоходом изменили протокол вызова функций. Теперь функции
принимают свою запись активации не через аргумент, а ожидают её в регистре
<code><span class="func">*val*</span></code>. Это поведение закрепляется в определении <code><span class="func">FIX-CLOSURE</span></code>:</p>


<!--\indexC{FIX-CLOSURE}-->
<pre>(define (FIX-CLOSURE m+ arity)
  (let ((arity+1 (+ 1 arity)))
    (lambda ()
      (define (the-function sr)
        (if (= (activation-frame-argument-length *val*) arity+1)
            (begin (set! *env* (sr-extend* sr *val*))
                   (m+) )
            (wrong "Incorrect arity") ) )
      (set! *val* (make-closure the-function *env*)) ) ) )</pre>


<!--\indexC*{arg1}{*arg1*}-->
<!--\indexC*{arg2}{*arg2*}-->
<!--\indexR{регистры!arg1@\protect<code><span class="func">*arg1*</span></code>}-->
<!--\indexR{регистры!arg2@\protect<code><span class="func">*arg2*</span></code>}-->
<p>Добавив ещё регистров, мы сможем линеаризовать и вызовы примитивов. Введём два
новых регистра: <code><span class="func">*arg1*</span></code> и <code><span class="func">*arg2*</span></code>. Один из них может физически совпадать
с <code><span class="func">*fun*</span></code>, который всё равно не используется одновременно с ними. Эти
регистры позволяет определить <code><span class="func">CALL3</span></code> следующим образом:</p>


<!--\indexC*{CALL0}{CALL\protect<i>n</i>}-->
<pre>(define (CALL3 address m1 m2 m3)
  (lambda (m)
    (m1)
    (stack-push *val*)
    (m2)
    (stack-push *val*)
    (m3)
    (set! *arg2* (stack-pop))
    (set! *arg1* (stack-pop))
    (set! *val* (address *arg1* *arg2* *val*)) ) )</pre>

<h3 id="compilation/bytes/ssect:customize">Дорабатываем инструкции</h3>


<!--\indexR{счётчик команд}-->
<!--\indexR{инструкции!сложность}-->
<p>В данный момент рассмотренные двадцать пять инструкций генерируют замыкания,
внутри которых находятся последовательности составных операций над регистрами.
Такие сложные инструкции нам не подходят — машине нужны маленькие и
однозначные инструкции, выполняющие простые действия: изменить один регистр,
положить одно значение в стек и т. п. Поэтому мы развернём большие инструкции,
превратив их в последовательности из маленьких. Так как в такой куче команд
легко запутаться, то давайте введём специализированный регистр для хранения
следующей инструкции  — <em class="term">счётчик команд</em>. Заодно он позволит нам
в дальнейшем точнее определить протокол вызова функций, а также всевозможные
управляющие формы, в том числе и <code><span class="func">call/cc</span></code>.</p>

<p>
\subsubsection{Линеаризация присваиваний}%
\label{compilation/bytes/customize/sssect:lin-assignment}</p>

<p>Рассмотрим для примера инструкцию <code><span class="func">SHALLOW-ARGUMENT-SET!</span></code>. Определялась она
вот так:</p>

<pre>(define (SHALLOW-ARGUMENT-SET! j m)
  (lambda ()
    (m)
    (set-activation-frame-argument! *env* j *val*) ) )</pre>

<p>Чтобы разбить её на последовательность операций, введём вспомогательную функцию:</p>


<!--\indexC{SHALLOW-ARGUMENT-SET"!}-->
<!--\indexC{SET-SHALLOW-ARGUMENT"!}-->
<pre>(define (SHALLOW-ARGUMENT-SET! j m)
  (append m (SET-SHALLOW-ARGUMENT! j)) )</p>

<p>(define (SET-SHALLOW-ARGUMENT! j)
  (list (lambda () (set-activation-frame-argument! *env* j *val*))) )</pre>

<p>Главная функция только возвращает список необходимых операций, расположенных
в правильной последовательности. Вспомогательная же возвращает замыкание,
выполняющее простую операцию изменения записи активации.</p>

<p>
\subsubsection{Линеаризация вызовов функций}%
\label{compilation/bytes/customize/sssect:lin-invocation}</p>

<p><code><span class="func">REGULAR-CALL</span></code> является весьма показательной инструкцией в этом плане. Для её
линеаризации потребуются следующие машинные команды: <code><span class="func">PRESERVE-ENV</span></code>,
<code><span class="func">RESTORE-ENV</span></code>, <code><span class="func">PUSH-VALUE</span></code>, <code><span class="func">POP-FUNCTION</span></code> и <code><span class="func">FUNCTION-INVOKE</span></code>.</p>

<p>Вот их определения:</p>


<!--\indexC{REGULAR-CALL}-->
<!--\indexC{PUSH-VALUE}-->
<!--\indexC{POP-FUNCTION}-->
<!--\indexC{PRESERVE-ENV}-->
<!--\indexC{FUNCTION-INVOKE}-->
<!--\indexC{RESTORE-ENV}-->
<pre>(define (REGULAR-CALL m m*)
  (append m (PUSH-VALUE)
          m* (POP-FUNCTION) (PRESERVE-ENV)
             (FUNCTION-INVOKE) (RESTORE-ENV) ) )</p>

<p>(define (PUSH-VALUE)
  (list (lambda () (stack-push *val*))) )</p>

<p>(define (POP-FUNCTION)
  (list (lambda () (set! *fun* (stack-pop)))) )</p>

<p>(define (PRESERVE-ENV)
  (list (lambda () (stack-push *env*))) )</p>

<p>(define (FUNCTION-INVOKE)
  (list (lambda () (invoke *fun*))) )</p>

<p>(define (RESTORE-ENV)
  (list (lambda () (set! *env* (stack-pop)))) )</pre>


<!--\indexR{исполнитель (\protect<code><span class="func">run</span></code>)}-->
<p>Как мы и хотели, результатом компиляции теперь является список элементарных
машинных инструкций. Его, однако, нельзя непосредственно исполнить, для этого
придётся написать исполнитель самостоятельно. Назовём его <code><span class="func">run</span></code>.</p>


<!--\indexC{run}-->
<pre>(define (run)
  (let ((instruction (car *pc*)))
    (set! *pc* (cdr *pc*))
    (instruction)
    (run) ) )</pre>


<!--\indexE{pc@\protect<code><span class="func">*pc*</span></code>}-->
<!--\indexR{регистры!pc@\protect<code><span class="func">*pc*</span></code>}-->
<p>Полученный в результате компиляции список команд должен быть помещён
в регистр <code><span class="func">*pc*</span></code> — это наш счётчик команд (\english{program counter}).
Функция <code><span class="func">run</span></code> олицетворяет процессор виртуальной машины, который считывает
команду, сдвигает счётчик на следующую, исполняет считанную команду и повторяет
всё сначала. Кстати, именно поэтому все машинные инструкции представляются
замыканиями вида <code>(lambda () ...)</code>.</p>

<p>
\subsubsection{Линеаризация ветвлений}%
\label{compilation/bytes/customize/sssect:lin-conditional}</p>


<!--\indexR{линеаризация!ветвлений}-->
<!--\indexR{переходы (jumps)!машинные инструкции}-->
<p>Способ линеаризации ветвления не так очевиден, ведь из него возможны два выхода.
Как же представить такое поведение последовательностью? Для этого мы
(пере)изобретём две важные машинные инструкции, позволяющие влиять на счётчик
команд: <code><span class="func">JUMP-FALSE</span></code> и <code><span class="func">GOTO</span></code>. Всем известная <code><span class="func">GOTO</span></code> выполняет
безусловный переход. В свою очередь, <code><span class="func">JUMP-FALSE</span></code> переход выполняет лишь
в случае, когда в регистре <code><span class="func">*val*</span></code> находится ложь. Обе эти инструкции
изменяют исключительно <code><span class="func">*pc*</span></code> и ничего другого.</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>


<!--\indexC{JUMP-FALSE}-->
<!--\indexC{GOTO}-->
<pre>(define (JUMP-FALSE i)
  (list (lambda () (if (not *val*) (set! *pc* (list-tail *pc* i))))) )</p>

<p>(define (GOTO i)
  (list (lambda () (set! *pc* (list-tail *pc* i)))) )</pre>

<p>\begin{figure}[t]\begin{center}
\input{figures/fig7.1}
\end{center}%
\caption{Линеаризованное ветвление.}%
\label{compilation/bytes/customize/lin-conditional/pic:subj}%
\end{figure}</p>

<p>С использованием этих двух инструкций ветвление линеаризуется следующим
образом. (На рисунке \ref{compilation/bytes/customize/lin-conditional/pic:subj}
показано нагляднее.)</p>


<!--\indexC{ALTERNATIVE}-->
<pre>(define (ALTERNATIVE m1 m2 m3)
  (append m1 (JUMP-FALSE (+ 1 (length m2))) m2 (GOTO (length m3)) m3) )</pre>

<p>\ForLayout{display}{\endgroup}</p>

<p>Условие вычисляется, а затем проверяется <code><span class="func">JUMP-FALSE</span></code>. Если оно оказалось
истиной, то выполняются инструкции, непосредственно следующие за
<code><span class="func">JUMP-FALSE</span></code>, после чего <code><span class="func">GOTO</span></code> перебрасывает управление через
альтернативную ветку к коду, следующему за ветвлением. Если же условие ложно,
то управление просто передаётся альтернативной ветке. Как видим, для реализации
ветвления нам пришлось опуститься до уровня ассемблера. Кстати, обратите
внимание, что переходы выполняются относительно текущего значения счётчика
команд, а не по абсолютным адресам.</p>

<p>
\subsubsection{Линеаризация абстракций}%
\label{compilation/bytes/customize/sssect:lin-abstraction}</p>


<!--\indexR{линеаризация!абстракций}-->
<!--\indexR{представление!замыканий!в машинном коде}-->
<p>Последней из инструкций с нетривиальной линеаризацией остаётся конструктор
замыканий. Проблема здесь в том, как разместить код собственно функции и код,
замыкающий текущее окружение. Причём функцию не надо сразу же исполнять после
создания замыкания. Для реализации такого поведения снова используются переходы
(см. рисунок \ref{compilation/bytes/customize/lin-abstraction/pic:subj}). Вот
так создаются замыкания с переменной арностью:</p>


<!--\indexC{NARY-CLOSURE}-->
<!--\indexC{CREATE-CLOSURE}-->
<!--\indexC{PACK-FRAME"!}-->
<pre>(define (NARY-CLOSURE m+ arity)
  (define the-function
    (append (ARITY>=? (+ arity 1)) (PACK-FRAME! arity)
            (EXTEND-ENV) m+ (RETURN) ) )
  (append (CREATE-CLOSURE 1) (GOTO (length the-function))
          the-function ) )</p>

<p>(define (CREATE-CLOSURE offset)
  (list (lambda () (set! *val* (make-closure (list-tail *pc* offset)
                                             *env* )))) )
(define (PACK-FRAME! arity)
  (list (lambda () (listify! *val* arity))) )</pre>

<p>\begin{figure}[t]\centering
\input{figures/fig7.2}%
\caption{Линеаризованная абстракция.}%
\label{compilation/bytes/customize/lin-abstraction/pic:subj}%
\ForLayout{display}{\vskip-1.2\baselineskip}
\end{figure}</p>

<p>Новая машинная инструкция <code><span class="func">CREATE-CLOSURE</span></code> создаёт замыкание с телом,
расположенным сразу же за <code><span class="func">GOTO</span></code>. Созданное замыкание кладётся в регистр
<code><span class="func">*val*</span></code>, после чего мы перепрыгиваем через его код к следующей инструкции
программы.</p>

<h3 id="compilation/bytes/ssect:call-proto">Протокол вызова функций</h3>


<!--\indexR{протокол вызова функций}-->
<!--\indexR{функции!протокол вызова}-->
<p>Вызовы функций выполняются с помощью инструкций <code><span class="func">TR-REGULAR-CALL</span></code> и
<code><span class="func">REGULAR-CALL</span></code>, рассмотренных ранее.
\seePage[compilation/bytes/customize/sssect:lin-invocation]
Функция <code><span class="func">invoke</span></code> реализует протокол вызова функций:</p>


<!--\indexC{invoke}-->
<pre>(define (invoke f)
  (cond ((closure? f)
         (stack-push *pc*)
         (set! *env* (closure-closed-environment f))
         (set! *pc* (closure-code f)) )
        ... ) )</pre>

<p>Перед вызовом функции в стек заталкивается адрес инструкции, следующей за
<code>(FUNCTION-INVOKE)</code>. Затем извлекается сохранённое в замыкании окружение и
устанавливается в регистр <code><span class="func">*env*</span></code>. Наконец, в регистр <code><span class="func">*pc*</span></code> заносится
адрес первой инструкции тела замыкания, что передаёт ему управление. Текущее
окружение здесь не сохраняется: за управление ним отвечают непосредственно
<code><span class="func">REGULAR-CALL</span></code> и <code><span class="func">TR-REGULAR-CALL</span></code>.</p>

<p>Следующей инструкцией, исполненной <code><span class="func">run</span></code>, будет первая инструкция вызванной
функции. Она проверяет арность и, в случае успеха, расширяет текущее окружение
записью активации функции, в тот момент уже находящейся в регистре <code><span class="func">*val*</span></code>.
Теперь всё готово для исполнения тела функции. После его завершения в регистре
<code><span class="func">*val*</span></code> будет находиться значение, которое требуется передать тому, кто
вызывал эту функцию. Возврат управления выполняет инструкция <code><span class="func">RETURN</span></code>. Ей
надо лишь восстановить значение <code><span class="func">*pc*</span></code>, ранее сохранённое в стеке.</p>


<!--\indexC{RETURN}-->
<pre>(define (RETURN)
  (list (lambda () (set! *pc* (stack-pop)))) )</pre>

<h4 id="compilation/bytes/sssect:jumps">О переходах</h4>


<!--\indexR{позиционно-независимый код}-->
<p>Если вы знакомы с программированием на языке ассемблера, то наверняка обратили
внимание на то, что все переходы выполняются только вперёд по коду. Более того,
переходы являются относительными, равно как и адресация при создании замыканий.
Следовательно, получаемый машинный код никак не зависит от своего фактического
расположения в памяти, он <em class="term">позиционно-независим</em>.</p>

<h2 id="compilation/sect:lang-and-target">Язык и целевая машина</h2>


<!--\indexR{виртуальная машина!архитектура}-->
<p>Пришло время зафиксировать архитектуру целевой виртуальной машины, под которую
будут компилироваться программы, а также машинный язык, с помощью которого ей
можно управлять. Как видно из
рисунка \ref{compilation/lang-and-target/pic:subj}, машина имеет пять регистров:
<code><span class="func">*env*</span></code>, <code><span class="func">*val*</span></code>, <code><span class="func">*fun*</span></code>, <code><span class="func">*arg1*</span></code> и <code><span class="func">*arg2*</span></code>, счётчик команд
<code><span class="func">*pc*</span></code>, а также стек.</p>

<p>\begin{figure}[tp]\begin{center}
\input{figures/fig7.3}\end{center}%
\caption{Архитектура целевой виртуальной машины.}%
\label{compilation/lang-and-target/pic:subj}%
\end{figure}</p>


<!--\indexC{FINISH}-->
<p>Машинный язык состоит из тридцати четырёх инструкций. Все они собраны
в таблице \ref{compilation/lang-and-target/table:instructions}. Вдобавок к ранее
рассмотренным, мы ввели инструкцию <code><span class="func">FINISH</span></code>, которая завершает исполнение
программы (фактически, выходит из функции <code><span class="func">run</span></code>) и возвращает управление
тому, кто запустил нашу виртуальную машину.</p>


<!--\indexR{инструкции!простые и составные}-->
<p>Все двадцать пять инструкций-генераторов промежуточного языка можно разделить
на две группы: простые инструкции и составные. Простые инструкции имеют
непосредственные аналоги в машинном языке, они отмечены звёздочками
в таблице \ref{compilation/lang-and-target/table:instructions}.
В противоположность им, шестнадцать составных инструкций промежуточного языка
определяются через оставшиеся двадцать пять машинных. Мы могли бы разбивать
инструкции на машинные команды более агрессивно, например, разделив
<code><span class="func">CHECKED-GLOBAL-REF</span></code> на <code><span class="func">GLOBAL-REF</span></code> и отдельную инструкцию, проверяющую,
действительно ли в <code><span class="func">*val*</span></code> лежит значение инициализированной переменной, но
это бы замедлило интерпретацию. Так что скорее наоборот, некоторые инструкции
имеет смысл объединить, например: <code><span class="func">POP-ARG2</span></code> используется только
в <code><span class="func">CALL3</span></code>, причём за <code><span class="func">POP-ARG2</span></code> всегда следует <code><span class="func">POP-ARG1</span></code>, поэтому
данную пару вполне можно превратить в отдельную инструкцию.</p>

<p>\begin{table}[!htb]%
<!--\indexR{виртуальная машина!язык}%-->
<!--\indexR{язык!машинный}%-->
\def\I{<i>i</i>} \def\J{<i>j</i>} \def\V{<i>v</i>}
\def\star{\textsubscript{<code><span class="func">*</span></code>}}
\def\P{\normalfont\:+\:1}
\def\botstrut{\rule[-0.6em]{0pt}{\baselineskip}}
\def\topstrut{\rule[1.25em]{0pt}{\baselineskip}}
\setlength{\tabcolsep}{0.5em}
\begin{center}\begin{tabular}{|l|l|}
\hline\topstrut%
<code>(SHALLOW-ARGUMENT-REF \J)</code>\star  & <code>(PREDEFINED \I)</code>\star              \\
<code>(DEEP-ARGUMENT-REF \I\ \J)</code>\star & <code>(SET-SHALLOW-ARGUMENT! \J)</code>        \\
<code>(SET-DEEP-ARGUMENT! \I\ \J)</code>     & <code>(GLOBAL-REF \I)</code>\star              \\
<code>(CHECKED-GLOBAL-REF \I)</code>\star    & <code>(SET-GLOBAL! \I)</code>                  \\
<code>(CONSTANT \V)</code>\star              & \ic{(JUMP-FALSE <i>смещение</i>)}        \\
\ic{(GOTO <i>смещение</i>)}            & <code>(EXTEND-ENV)</code>                      \\
<code>(UNLINK-ENV)</code>                    & \ic{(CALL0 <i>адрес</i>)}\star           \\
\ic{(INVOKE1 <i>адрес</i>)}            & <code>(PUSH-VALUE)</code>                      \\
\ic{(INVOKE2 <i>адрес</i>)}            & <code>(POP-ARG1)</code>                        \\
\ic{(INVOKE3 <i>адрес</i>)}            & <code>(POP-ARG2)</code>                        \\
\ic{(CREATE-CLOSURE <i>смещение</i>)}  & \ic{(ARITY=? <i>арность</i>\P)}          \\
<code>(RETURN)</code>                        & \ic{(ARITY>=? <i>арность</i>\P)}         \\
\ic{(PACK-FRAME! <i>арность</i>)}      & <code>(POP-FUNCTION)</code>                    \\
<code>(FUNCTION-INVOKE)</code>               & <code>(PRESERVE-ENV)</code>                    \\
<code>(RESTORE-ENV)</code>                   & \ic{(POP-FRAME! <i>индекс</i>)}          \\
\ic{(POP-CONS-FRAME! <i>арность</i>)}  & \ic{(ALLOCATE-FRAME <i>размер</i>)}\star \\
\ic{(ALLOCATE-DOTTED-FRAME <i>арность</i>)}\star & <code>(FINISH)</code>\botstrut       \\
\hline
\end{tabular}\end{center}%
\caption{Символьная форма машинных инструкций.}%
\label{compilation/lang-and-target/table:instructions}%
\end{table}</p>

<p>Тривиальной части составных инструкций мы не касались, но их определения
на машинном языке всё же стоит привести. Они собраны ниже, без каких-либо
пояснений. Некоторые из машинных инструкций из
таблицы \ref{compilation/lang-and-target/table:instructions} тоже не были
определены, ими мы займёмся чуть позже.</p>


<!--\indexC{DEEP-ARGUMENT-SET"!}-->
<!--\indexC{GLOBAL-SET"!}-->
<!--\indexC{SEQUENCE}-->
<!--\indexC{TR-FIX-LET}-->
<!--\indexC{FIX-LET}-->
<!--\indexC*{CALL0}{CALL\protect<i>n</i>}-->
<!--\indexC{FIX-CLOSURE}-->
<!--\indexC{TR-REGULAR-CALL}-->
<!--\indexC{STORE-ARGUMENT}-->
<!--\indexC{CONS-ARGUMENT}-->
<pre>(define (DEEP-ARGUMENT-SET! i j m)
  (append m (SET-DEEP-ARGUMENT! i j)) )</p>

<p>(define (GLOBAL-SET! i m)
  (append m (SET-GLOBAL! i)) )</p>

<p>(define (SEQUENCE m m+)
  (append m m+) )</p>

<p>(define (TR-FIX-LET m* m+)
  (append m* (EXTEND-ENV) m+) )</p>

<p>(define (FIX-LET m* m+)
  (append m* (EXTEND-ENV)
          m+ (UNLINK-ENV) ) )</p>

<p>(define (CALL1 address m1)
  (append m1 (INVOKE1 address)) )</p>

<p>(define (CALL2 address m1 m2)
  (append m1 (PUSH-VALUE)
          m2 (POP-ARG1)
          (INVOKE2 address) ) )</p>

<p>(define (CALL3 address m1 m2 m3)
  (append m1 (PUSH-VALUE)
          m2 (PUSH-VALUE)
          m3 (POP-ARG2) (POP-ARG1)
          (INVOKE3 address) ) )</p>

<p>(define (FIX-CLOSURE m+ arity)
  (define the-function
    (append (ARITY=? (+ arity 1))
            (EXTEND-ENV) m+
            (RETURN) ) )
  (append (CREATE-CLOSURE 1)
          (GOTO (length the-function))
          the-function ) )</p>

<p>(define (TR-REGULAR-CALL m m*)
  (append m (PUSH-VALUE)
          m* (POP-FUNCTION)
          (FUNCTION-INVOKE) ) )</p>

<p>(define (STORE-ARGUMENT m m* index)
  (append m (PUSH-VALUE)
          m* (POP-FRAME! index) ) )</p>

<p>(define (CONS-ARGUMENT m m* arity)
  (append m (PUSH-VALUE)
          m* (POP-CONS-FRAME! arity) ) )</pre>

<p>\phantomlabel{compilation/lang-and-target/par:slowpoke}
<!--\indexR{однопроходная компиляция}-->
<!--\indexR{компиляция!однопроходная}-->
<!--\indexR{линеаризация!кодогенерации}-->
Вызовы <code><span class="func">append</span></code>, коими кишат наши определения, довольно ощутимо замедляют
кодогенерацию. Хорошим решением будет собирать машинные инструкции
в последовательность за один проход. Именно так мы и поступим при разработке
компилятора в Си. \seePage[cc/gen/ssect:exprs] Для реализации подобного подхода
потребуется вдобавок к линеаризации самого машинного кода также линеаризовать и
его генераторы. Например, <code><span class="func">CALL2</span></code> должна работать в такой последовательности:</p>

<p>\begin{enumerate}
  \item сгенерировать и вывести код <code><span class="func">m1</span></code>;
  \item вывести код <code>(PUSH-VALUE)</code>;
  \item сгенерировать и вывести код <code><span class="func">m2</span></code>;
  \item вывести код <code>(POP-ARG1)</code>;
  \item вывести код \ic{(INVOKE2 <i>адрес</i>)}.
\end{enumerate}</p>


<!--\indexCS{GOTO}{правки задним числом}-->
<!--\indexCS{JUMP-FALSE}{правки задним числом}-->
<!--\indexE{backpatching}-->
<p>\phantomlabel{compilation/lang-and-target/par:backtracking}
Подобные изменения легко сделать всюду, кроме <code><span class="func">GOTO</span></code> и <code><span class="func">JUMP-FALSE</span></code>, так
как теперь не получится заранее вычислить смещения при генерации кода для
<code><span class="func">ALTERNATIVE</span></code>, <code><span class="func">FIX-CLOSURE</span></code> и <code><span class="func">NARY-CLOSURE</span></code>. Это затруднение
можно решить правкой смещений задним числом (такой приём называется
<em class="term">backpatching</em>). Например, для <code><span class="func">FIX-CLOSURE</span></code> следует делать так:</p>

<p>\begin{enumerate}
  \item вывести инструкцию <code><span class="func">CREATE-CLOSURE</span></code>;

  \item вывести инструкцию <code><span class="func">GOTO</span></code>, но без смещения, запомнив при этом
        текущее состояние счётчика команд;

  \item сгенерировать и вывести код тела функции;

  \item зная текущее значение счётчика команд и помня сохранённое ранее,
        вычислить величину смещения для <code><span class="func">GOTO</span></code>;

  \item записать это число на зарезервированное\footnote{Вот здесь могут
        возникнуть некоторые проблемы, потому что смещение может оказаться
        как меньшим 256, так и превышать это значение, то есть занимать
        один или два байта. Это может оказаться причиной определённых
        потерь производительности.} внутри <code><span class="func">GOTO</span></code> место.
\end{enumerate}</p>

<p>В результате получится более аккуратная и эффективная процедура генерации кода,
чем есть сейчас, но пока мы всё же оставим текущий вариант из-за его простоты.</p>

<p>
\subsection{Дизассемблирование}%
\label{compilation/lang-and-target/ssect:disassembly}</p>

<p>В начале этой главы \seePage[compilation/par:disasm] была показана промежуточная
форма следующей небольшой программки:</p>


<!--\indexC{fact}-->
<pre>((lambda (fact) (fact 5 fact (lambda (x) x)))
 (lambda (n f k) (if (= n 0) (k 1)
                     (f (- n 1) f (lambda (r) (k (* n r)))) )) )</pre>

<p>Теперь, наконец, мы сможем увидеть, как она выглядит на настоящем машинном
языке. Сложно не заметить сходство
таблицы \ref{compilation/lang-and-target/disassembly/table:subj} с ассемблерным
листингом.</p>

<p>\begin{table}[pt]\setlength{\tabcolsep}{1.5em}%
\begin{center}\begin{tabular}{l|@{\extracolsep{1.25em}}l}
<code>(CREATE-CLOSURE 2)</code>          &   <code><span class="func">(INVOKE2 \#<*>)</span></code>            \\
<code>(GOTO 82)</code>                   &   <code>(PUSH-VALUE)</code>               \\
<code>(ARITY=? 4)</code>                 &   <code>(ALLOCATE-FRAME 1)</code>         \\
<code>(EXTEND-ENV)</code>                &   <code>(POP-FRAME! 0)</code>             \\
<code>(SHALLOW-ARGUMENT-REF 0)</code>    &   <code>(POP-FUNCTION)</code>             \\
<code>(PUSH-VALUE)</code>                &   <code>(FUNCTION-INVOKE)</code>          \\
<code>(CONSTANT 0)</code>                &   <code>(RETURN)</code>                   \\
<code>(POP-ARG1)</code>                  &   <code>(PUSH-VALUE)</code>               \\
<code><span class="func">(INVOKE2 \#<=>)</span></code>             &   <code>(ALLOCATE-FRAME 3)</code>         \\
<code>(JUMP-FALSE 13)</code>             &   <code>(POP-FRAME! 2)</code>             \\
<code>(SHALLOW-ARGUMENT-REF 2)</code>    &   <code>(POP-FRAME! 1)</code>             \\
<code>(PUSH-VALUE)</code>                &   <code>(POP-FRAME! 0)</code>             \\
<code>(CONSTANT 1)</code>                &   <code>(POP-FUNCTION)</code>             \\
<code>(PUSH-VALUE)</code>                &   <code>(FUNCTION-INVOKE)</code>          \\
<code>(ALLOCATE-FRAME 1)</code>          &   <code>(RETURN)</code>                   \\
<code>(POP-FRAME! 0)</code>              &   <code>(PUSH-VALUE)</code>               \\
<code>(POP-FUNCTION)</code>              &   <code>(ALLOCATE-FRAME 1)</code>         \\
<code>(FUNCTION-INVOKE)</code>           &   <code>(POP-FRAME! 0)</code>             \\
<code>(GOTO 54)</code>                   &   <code>(EXTEND-ENV)</code>               \\
<code>(SHALLOW-ARGUMENT-REF 1)</code>    &   <code>(SHALLOW-ARGUMENT-REF 0)</code>   \\
<code>(PUSH-VALUE)</code>                &   <code>(PUSH-VALUE)</code>               \\
<code>(SHALLOW-ARGUMENT-REF 0)</code>    &   <code>(CONSTANT 5)</code>               \\
<code>(PUSH-VALUE)</code>                &   <code>(PUSH-VALUE)</code>               \\
<code>(CONSTANT 1)</code>                &   <code>(SHALLOW-ARGUMENT-REF 0)</code>   \\
<code>(POP-ARG1)</code>                  &   <code>(PUSH-VALUE)</code>               \\
<code><span class="func">(INVOKE2 \#<->)</span></code>             &   <code>(CREATE-CLOSURE 2)</code>         \\
<code>(PUSH-VALUE)</code>                &   <code>(GOTO 6)</code>                   \\
<code>(SHALLOW-ARGUMENT-REF 1)</code>    &   <code>(ARITY=? 2)</code>                \\
<code>(PUSH-VALUE)</code>                &   <code>(EXTEND-ENV)</code>               \\
<code>(CREATE-CLOSURE 2)</code>          &   <code>(SHALLOW-ARGUMENT-REF 0)</code>   \\
<code>(GOTO 24)</code>                   &   <code>(RETURN)</code>                   \\
<code>(ARITY=? 2)</code>                 &   <code>(PUSH-VALUE)</code>               \\
<code>(EXTEND-ENV)</code>                &   <code>(ALLOCATE-FRAME 3)</code>         \\
<code>(DEEP-ARGUMENT-REF 1 2)</code>     &   <code>(POP-FRAME! 2)</code>             \\
<code>(PUSH-VALUE)</code>                &   <code>(POP-FRAME! 1)</code>             \\
<code>(DEEP-ARGUMENT-REF 1 0)</code>     &   <code>(POP-FRAME! 0)</code>             \\
<code>(PUSH-VALUE)</code>                &   <code>(POP-FUNCTION)</code>             \\
<code>(SHALLOW-ARGUMENT-REF 0)</code>    &   <code>(FUNCTION-INVOKE)</code>          \\
<code>(POP-ARG1)</code>                  &   <code>(RETURN)</code>
\end{tabular}\end{center}%
\caption{Результат компиляции.}%
\label{compilation/lang-and-target/disassembly/table:subj}%
\end{table}</p>

<h2 id="compilation/sect:coding">Кодирование инструкций</h2>


<!--\indexR{байт-код}-->
<p>Почти на каждой странице этой главы упоминаются байты, но до сих пор мы
не видели ни одного из них живьём. К счастью, чтобы они появились, достаточно
лишь по-другому понимать инструкции
таблицы \ref{compilation/lang-and-target/table:instructions}: теперь это
не непосредственно исполнимые команды, а генераторы последовательностей байтов
— исходного кода для другой, более быстрой функции <code><span class="func">run</span></code>. Сейчас мы
сконцентрируемся именно на этом аспекте байт-кода: его компактности и скорости
интерпретации.</p>


<!--\indexR{макросы!применения}-->
<p>Байт-кодирование требует особой осторожности: за каждой инструкцией должно быть
закреплено уникальное число, по которому определяется её поведение внутри
<code><span class="func">run</span></code>, длина операндов этой инструкции, а также многое другое. Поэтому, чтобы
в процессе ничего не напутать, инструкции будут определяться с помощью макроса
<code><span class="func">define-instruction</span></code>. При этом предполагается, что все определения машинных
инструкций на самом деле обёрнуты в макрос <code><span class="func">define-instruction-set</span></code>, который
кроме собственно формы <code><span class="func">define-instruction</span></code> определяет также несколько
вспомогательных функций.</p>


<!--\indexC{define-instruction-set}-->
<!--\indexC{run}-->
<!--\indexC{instruction-size}-->
<!--\indexC{instruction-decode}-->
<!--\indexC{run-clause}-->
<!--\indexC{size-clause}-->
<pre>(define-syntax define-instruction-set
  (syntax-rules (define-instruction)
    ((define-instruction-set
       (define-instruction (name . args) n . body) ... )
     (begin
       (define (run)
         (let ((instruction (fetch-byte)))
           (case instruction
             ((n) (run-clause args body)) ... ) )
         (run) )</p>

<p>       (define (instruction-size code pc)
         (let ((instruction (vector-ref code pc)))
           (case instruction
             ((n) (size-clause args)) ... ) ) )</p>

<p>       (define (instruction-decode code pc)
         (define (fetch-byte)
           (let ((byte (vector-ref code pc)))
             (set! pc (+ pc 1))
             byte ) )
         (let-syntax
             ((decode-clause
               (syntax-rules ()
                 ((decode-clause iname ())
                  '(iname) )
                 ((decode-clause iname (a))
                  (let ((a (fetch-byte)))
                    (list 'iname a) ) )
                 ((decode-clause iname (a b))
                  (let* ((a (fetch-byte))
                         (b (fetch-byte)) )
                    (list 'iname a b) ) ) ) ))
           (let ((instruction (fetch-byte)))
             (case instruction
               ((n) (decode-clause name args)) ... ) ) ) ) ) ) ) )</p>

<p>(define-syntax run-clause
  (syntax-rules ()
    ((run-clause () body)
     (begin . body) )
    ((run-clause (a) body)
     (let ((a (fetch-byte)))
       . body ) )
    ((run-clause (a b) body)
     (let* ((a (fetch-byte))
            (b (fetch-byte)) )
       . body ) ) ) )</p>

<p>(define-syntax size-clause
  (syntax-rules ()
    ((size-clause ())    1)
    ((size-clause (a))   2)
    ((size-clause (a b)) 3) ) )</pre>

<p>Макрос <code><span class="func">define-instruction</span></code> одновременно определяет сразу три функции:
функцию <code><span class="func">run</span></code>, исполняющую байт-коды; функцию <code><span class="func">instruction-size</span></code>,
возвращающую размер инструкций; и функцию <code><span class="func">instruction-decode</span></code>,
переводящую байт-код обратно в символьную форму. Очевидно,
<code><span class="func">instruction-decode</span></code>, будет весьма полезной при отладке. Рассмотрим пример:</p>

<pre>(define-instruction (SHALLOW-ARGUMENT-REF j) 5
  (set! *val* (activation-frame-argument *env* j)) )</pre>

<p>Эта форма добавляет в определение <code><span class="func">run</span></code> обработку инструкции, кодируемой
числом <code><span class="func">5</span></code>:</p>

<pre>(define (run)
  (let ((instruction (fetch-byte)))
    (case instruction
      ...
      ((5) (let ((j (fetch-byte)))
             (set! *val* (activation-frame-argument *env* j)) ))
      ... ) )
  (run) )</pre>


<!--\indexC{fetch-byte}-->
<p>Функция <code><span class="func">fetch-byte</span></code> используется для извлечения операндов инструкции из
потока байтов. Она очень просто определяется и имеет один побочный эффект: сдвиг
<code><span class="func">*pc*</span></code> на одну позицию вперёд.</p>

<pre>(define (fetch-byte)
  (let ((byte (vector-ref *code* *pc*)))
    (set! *pc* (+ 1 *pc*))
    byte ) )</pre>


<!--\indexR{счётчик команд}-->
<p>Также <code><span class="func">fetch-byte</span></code> используется функцией <code><span class="func">run</span></code> для считывания следующей
инструкции. Кстати, обратите внимание, что счётчик команд всегда указывает на
<em>следующую</em> инструкцию, а не на текущую исполняемую. Точно такое же решение
применяется и во многих настоящих процессорах.</p>


<!--\indexCS{case}{таблица переходов}-->
<p>Для достижения действительно высокой скорости интерпретации (другими словами,
чтобы получить быструю <code><span class="func">run</span></code>) следует уделить особое внимание используемой
здесь форме <code><span class="func">case</span></code>. Благодаря тому, что дискриминант <code><span class="func">case</span></code> может быть
только числом от 0 до 255, становится возможным реализовать <code><span class="func">case</span></code> через
таблицу переходов, что позволит выполнять выбор нужной ветви за постоянное
время. Если же <code><span class="func">case</span></code> раскрывается в цепочку <code>(if (eqv? ...) ...)</code>, то
выбор выполняется за линейное время — прощай, производительность! Лишь
некоторые из компиляторов Лиспа умеют выполнять такую оптимизацию автоматически
(среди них Sqil <span class="cite">[<a href="z1_bibliography.xhtml#sen91">sen91</a>]</span> и Bigloo <span class="cite">[<a href="z1_bibliography.xhtml#ser93">ser93</a>]</span>).</p>

<p><code><span class="func">define-instruction</span></code> также принимает участие в определении функции
<code><span class="func">instruction-size</span></code>: туда она добавляет информацию о том, что инструкция
<code><span class="func">SHALLOW-ARGUMENT-REF</span></code> занимает два байта. Аналогично, здесь <code><span class="func">case</span></code> можно
заменить вектором, хранящим те же самые числа.</p>

<pre>(define (instruction-size code pc)
  (let ((instruction (vector-ref code pc)))
    (case instruction
      ...
      ((5) 2)
      ... ) ) )</pre>


<!--\indexC{fetch-byte}-->
<p>Наконец, <code><span class="func">define-instruction</span></code> добавляет в <code><span class="func">instruction-decode</span></code>,
ветку для обработки инструкции <code><span class="func">SHALLOW-ARGUMENT-REF</span></code>. Функция
<code><span class="func">instruction-decode</span></code> использует свою личную реализацию <code><span class="func">fetch-byte</span></code>,
чтобы вести себя подобно <code><span class="func">run</span></code>, но не влиять на глобальный счётчик команд.</p>

<pre>(define (instruction-decode code pc)
  (define (fetch-byte)
    (let ((byte (vector-ref code pc)))
      (set! pc (+ pc 1))
      byte ) )
  (let ((instruction (vector-ref code pc)))
    (case instruction
      ...
      ((5) (let ((j (fetch-byte)))
             (list 'SHALLOW-ARGUMENT-REF j) ))
      ... ) ) )</pre>

<h2 id="compilation/sect:instructions">Инструкции</h2>


<!--\indexR{инструкции!распределение арности}-->
<!--\indexR{арность}-->
<!--\indexR{байт-код!использование излишков}-->
<!--\indexR{специализация!машинных инструкций}-->
<p>Всего существует 256 возможных кодов инструкций, мы же используем только 34 из
них. Настало время задействовать эти резервы; вспомните, как мы предлагали
объединять инструкции, которые часто используются вместе. Кроме того очевиден
<span class="cite">[<a href="z1_bibliography.xhtml#cha80">cha80</a>]</span> тот факт, что большинство функций имеет небольшое число аргументов.
Действительно, достаточно лишь посмотреть на функции, использованные в данной
книге. Их анализ показывает следующие результаты: лишь 16 функций имеют
переменную арность; распределение арности остальных 1988 приведено
в таблице \ref{compilation/instructions/table:probs}.</p>

<p>\begin{table}[!ht]\renewcommand*{\arraystretch}{1.15}
\begin{center}\begin{tabular}{lccccccccc}
\hline%
арность        &  0 &  1 &  2 &  3 &  4 &  5 &  6 &  7 &   8 \\
\hline%
доля, \%       & 35 & 30 & 18 &  9 &  4 &  1 &  0 &  0 &   0 \\
накопление, \% & 35 & 66 & 84 & 93 & 97 & 99 & 99 & 99 & 100
\end{tabular}\end{center}%
\caption{Распределение функций по количеству аргументов.}%
\label{compilation/instructions/table:probs}%
\end{table}</p>

<p>Как видим, подавляющее большинство функций имеет не более четырёх аргументов.
При обобщении этих результатов следует учесть, что настолько большие числа для
нулевой арности получены в основном благодаря шестой главе. Итого, однозначно
имеет смысл оптимизировать вызовы функций, принимающих менее четырёх аргументов.
Этим мы и займёмся, используя избыточные коды инструкций для создания
специализированных вариантов.</p>

<h3 id="compilation/instructions/ssect:locals">Локальные переменные</h3>


<!--\indexC{LAMBDA-PARAMETERS-LIMIT}-->
<!--\indexC{check-byte}-->
<!--\indexR{функции!максимальное количество аргументов}-->
<p>Пожалуй, давайте начнём с <code><span class="func">SHALLOW-ARGUMENT-REF</span></code>. Эта инструкция имеет один
операнд: $j$, а её действие заключается в том, что регистр <code><span class="func">*val*</span></code> получает
значение $j$-й локальной переменной текущей записи активации, хранящейся
в регистре <code><span class="func">*env*</span></code>. Здесь можно ввести специализации для случаев $j = 0, 1,
2, 3$, сделав каждый из них отдельной инструкцией со своим кодом. Также для
простоты можно ввести ограничение\footnote{В <span class="logo">Common Lisp</span> даже есть специальная
константа <code><span class="func">LAMBDA-PARAMETERS-LIMIT</span></code>, хранящая максимально возможно количество
аргументов функции. По стандарту оно не может быть меньше 50. Стандарт Scheme
ничего не говорит о подобных ограничениях, но его молчание можно толковать
по-разному.\par Как бы то ни было, вопрос представления чисел интересен сам по
себе. В большинстве систем, поддерживающих длинную арифметику, максимально
представимое число немного меньше, чем $256^{2^{32}}$. (Чуть-чуть не хватило до
бесконечности.) Хитрость в том, что перед длинным числом записывается его длина
в байтах. Аналогичное решение можно применить и здесь.} в 256 аргументов
функции — это позволит всегда кодировать индекс аргумента одним-единственным
байтом. Функция <code><span class="func">check-byte</span></code>\footnote{В последующих определениях мы не будем
упоминать <code><span class="func">check-byte</span></code> ради краткости.} убеждается в соблюдении этого
ограничения. Итак, вот определение <code><span class="func">SHALLOW-ARGUMENT-REF</span></code>. Эта инструкция
является генератором байт-кодов — она возвращает список\footnote{Да-да,
<code><span class="func">list</span></code>, <code><span class="func">append</span></code>, неэффективно,
страница \pageref{compilation/lang-and-target/par:slowpoke}. Извините.} байтов,
соответствующих кодируемой инструкции. Этот список состоит из одного или двух
байтов, в зависимости от операнда.</p>


<!--\indexCS{SHALLOW-ARGUMENT-REF}{специализация}-->
<!--\indexC{check-byte}-->
<pre>(define (SHALLOW-ARGUMENT-REF j)
  (check-byte j)
  (case j
    ((0 1 2 3) (list (+ 1 j)))
    (else      (list 5 j)) ) )</p>

<p>(define (check-byte j)
  (unless (<= 0 j 255)
    (static-wrong "Cannot pack a number within a byte" j) ) )</pre>

<p>А вот определения собственно пяти\footnote{Инструкции с кодом <code><span class="func">0</span></code>
не существует — бедный ноль и без того особенный.} специализаций:</p>

<pre>(define-instruction (SHALLOW-ARGUMENT-REF0) 1
  (set! *val* (activation-frame-argument *env* 0)) )
(define-instruction (SHALLOW-ARGUMENT-REF1) 2
  (set! *val* (activation-frame-argument *env* 1)) )
(define-instruction (SHALLOW-ARGUMENT-REF2) 3
  (set! *val* (activation-frame-argument *env* 2)) )
(define-instruction (SHALLOW-ARGUMENT-REF3) 4
  (set! *val* (activation-frame-argument *env* 3)) )
(define-instruction (SHALLOW-ARGUMENT-REF j) 5
  (set! *val* (activation-frame-argument *env* j)) )</pre>

<p><code><span class="func">SET-SHALLOW-ARGUMENT!</span></code> тоже работает с локальными переменными, так что
определяется аналогично. (Пропущенные здесь специализации легко определить
самостоятельно.)</p>


<!--\indexCS{SET-SHALLOW-ARGUMENT"!}{специализация}-->
<pre>(define (SET-SHALLOW-ARGUMENT! j)
  (case j
    ((0 1 2 3) (list (+ 21 j)))
    (else      (list 25 j)) ) )</p>

<p>(define-instruction (SET-SHALLOW-ARGUMENT!2) 23
  (set-activation-frame-argument! *env* 2 *val*) )
(define-instruction (SET-SHALLOW-ARGUMENT! j) 25
  (set-activation-frame-argument! *env* j *val*) )</pre>


<!--\indexCS{DEEP-ARGUMENT-REF}{специализация}-->
<!--\indexCS{SET-DEEP-ARGUMENT"!}{специализация}-->
<p>Что касается свободных переменных, то мы предполагаем,\footnote*{Вообще-то это
не совсем верное предположение, ведь мы только что убедились в том, что $j$ чаще
всего оказывается меньше четырёх. Но так как свободные переменные используются
значительно реже локальных и глобальных, то можно не особо спешить с ускорением
доступа к ним.} что их индексы равновероятны, поэтому для них специализаций
не будет:</p>

<pre>(define (DEEP-ARGUMENT-REF i j) (list 6 i j))
(define (SET-DEEP-ARGUMENT! i j) (list 26 i j))</p>

<p>(define-instruction (DEEP-ARGUMENT-REF i j) 6
  (set! *val* (deep-fetch *env* i j)) )
(define-instruction (SET-DEEP-ARGUMENT! i j) 26
  (deep-update! *env* i j *val*) )</pre>

<h3 id="compilation/instructions/ssect:globals">Глобальные переменные</h3>


<!--\indexR{глобальные переменные}-->
<!--\indexR{переменные!глобальные}-->
<!--\indexR{представление!глобальных переменных}-->
<!--\indexR{глобальное окружение!машинная реализация}-->
<!--\indexR{окружение!глобальное}-->
<p>Про распределение глобальных изменяемых переменных, определяемых пользователем,
виртуальная машина ничего знать не может в принципе, так что они тоже будут
кодироваться без специализаций. Для простоты предположим, что глобальных
переменных может быть не более 256, что позволит закодировать их адрес одним
байтом. Таким образом, имеем следующее:</p>


<!--\indexCS{GLOBAL-REF}{специализация}-->
<!--\indexCS{CHECKED-GLOBAL-REF}{специализация}-->
<!--\indexCS{SET-GLOBAL"!}{специализация}-->
<pre>(define (GLOBAL-REF i) (list 7 i))
(define (CHECKED-GLOBAL-REF i) (list 8 i))
(define (SET-GLOBAL! i) (list 27 i))</p>

<p>(define-instruction (GLOBAL-REF i) 7
  (set! *val* (global-fetch i)) )</p>

<p>(define-instruction (CHECKED-GLOBAL-REF i) 8
  (set! *val* (global-fetch i))
  (when (eq? *val* undefined-value)
    (signal-exception #t (list "Uninitialized global variable" i)) ) )</p>

<p>(define-instruction (SET-GLOBAL! i) 27
  (global-update! i *val*) )</pre>

<p>Случай предопределённых неизменяемых переменных более интересен, так как доступ
к наиболее часто используемым из них можно немного ускорить. В список таких
переменных включены <code><span class="func">t</span></code>, <code><span class="func">f</span></code>, <code><span class="func">nil</span></code>, <code><span class="func">cons</span></code>, <code><span class="func">car</span></code> и некоторые
другие.</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>


<!--\indexCS{PREDEFINED}{специализация}-->
<pre>(define (PREDEFINED i)
  (check-byte i)
  (case i
    ;; <code><span class="func">0</span></code>${}={}$<code><span class="func">\#t</span></code>, <code><span class="func">1</span></code>${}={}$<code><span class="func">\#f</span></code>, <code><span class="func">2</span></code>${}={}$<code>()</code>,%
    {} <code><span class="func">3</span></code>${}={}$<code><span class="func">cons</span></code>, <code><span class="func">4</span></code>${}={}$<code><span class="func">car</span></code>,
    ;; <code><span class="func">5</span></code>${}={}$<code><span class="func">cdr</span></code>, <code><span class="func">6</span></code>${}={}$<code><span class="func">pair?</span></code>,%
    {} <code><span class="func">7</span></code>${}={}$<code><span class="func">symbol?</span></code>, <code><span class="func">8</span></code>${}={}$<code><span class="func">eq?</span></code>
    ((0 1 2 3 4 5 6 7 8) (list (+ 10 i)))
    (else                (list 19 i)) ) )</p>

<p>(define-instruction (PREDEFINED0) 10    ; <code><span class="func">\#t</span></code>
  (set! *val* #t) )
(define-instruction (PREDEFINED i) 19
  (set! *val* (predefined-fetch i)) )</pre>


<!--\indexE{constants@\protect<code><span class="func">*constants*</span></code>}-->
<!--\indexR{регистры!constants@\protect<code><span class="func">*constants*</span></code>}-->
<!--\indexR{цитаты}-->
<p>Раз уж некоторые константы трактуются по-особому, то давайте так же поступим и
с цитатами. Предположим, в машине имеется регистр <code><span class="func">*constants*</span></code>, содержащий
вектор всех используемых в программе цитат, тогда доступ к ним можно получить
с помощью функции <code><span class="func">quotation-fetch</span></code>:</p>


<!--\indexC{quotation-fetch}-->
<pre>(define (quotation-fetch i)
  (vector-ref *constants* i) )</pre>

<p>Комбинатор <code><span class="func">CONSTANT</span></code> собирает все цитаты в переменной <code><span class="func">*quotations*</span></code>
во время компиляции. Перед исполнением программы все используемые цитаты
загружаются в регистр <code><span class="func">*constants*</span></code>. Цитаты не равновероятны: некоторые из
них используются чаще других, поэтому им будут выданы собственные инструкции.
Часть из них по очевидным причинам совпадает с предопределёнными константами
вроде <code><span class="func">PREDEFINED0</span></code>. Наконец, мы предположим, что цитировать напрямую
в машинном коде можно только целые числа от 0 до 255, остальные будут на общих
правах размещаться в <code><span class="func">*constants*</span></code>.\footnote*{Это досадно, но где-то же
должна проходить граница между обычными числами и длинными.}</p>


<!--\indexCS{CONSTANT}{специализация}-->
<!--\indexC{SHORT-NUMBER}-->
<!--\indexC{EXPLICIT-CONSTANT}-->
<pre>(define (CONSTANT value)
  (cond ((eq? value #t)    (list 10))
        ((eq? value #f)    (list 11))
        ((eq? value '())   (list 12))
        ((equal? value -1) (list 80))
        ((equal? value 0)  (list 81))
        ((equal? value 1)  (list 82))
        ((equal? value 2)  (list 83))
        ((equal? value 3)  (list 84))
        ((and (integer? value)   ; непосредственное значение
              (<= 0 value 255) )
         (list 79 value) )
        (else (EXPLICIT-CONSTANT value)) ) )</p>

<p>(define (EXPLICIT-CONSTANT value)
  (set! *quotations* (append *quotations* (list value)))
  (list 9 (- (length *quotations*) 1)) )</p>

<p>(define-instruction (CONSTANT-1) 80
  (set! *val* -1) )
(define-instruction (CONSTANT0) 81
  (set! *val* 0) )
(define-instruction (SHORT-NUMBER value) 79
  (set! *val* value) )</pre>

<p>\ForLayout{display}{\endgroup}</p>

<p>\subsection{Переходы}\label{compilation/instruction/ssect:jumps}</p>


<!--\indexR{переходы (jumps)!произвольная дальность}-->
<p>Если вы думаете, что расставленные то тут, то там ограничения чересчур суровы,
тогда этот раздел для вас. Очевидно, что не стоит ограничивать <code><span class="func">GOTO</span></code> или
<code><span class="func">JUMP-FORWARD</span></code> прыжками максимум на 256 байтов вперёд,\footnote*{На некоторых
старых машинах, основанных на процессоре i8086, такое ограничение действительно
существовало.} так как код без проблем может превысить эти размеры. Поэтому мы
будем различать случаи, когда длина прыжка записывается одним или двумя байтами.
Введём две отдельные инструкции\footnote{Очевидно, что подобное разделение на
<code><span class="func">SHORT</span></code>- и <code><span class="func">LONG</span></code>-версию может быть применено, например, к <code><span class="func">GLOBAL-REF</span></code>
с компанией, чтобы количество изменяемых глобальных переменных больше не было
ограничено 256-ю.}: <code><span class="func">SHORT-GOTO</span></code> и <code><span class="func">LONG-GOTO</span></code>. Думаем, этого будет
достаточно на время; наш компилятор пока не метит в олимпийские чемпионы, чтобы
прыгать дальше 64 килобайт.</p>


<!--\indexCS{GOTO}{специализация}-->
<!--\indexCS{JUMP-FALSE}{специализация}-->
<pre>(define (GOTO offset)
  (cond ((< offset 256) (list 30 offset))
        ((< offset 65536)
         (let ((offset1 (modulo offset 256))
               (offset2 (quotient offset 256)) )
           (list 28 offset1 offset2) ) )
        (else (static-wrong "Too long jump" offset)) ) )</p>

<p>(define (JUMP-FALSE offset)
  (cond ((< offset 256) (list 31 offset))
        ((< offset 65536)
         (let ((offset1 (modulo offset 256))
               (offset2 (quotient offset 256)) )
           (list 29 offset1 offset2) ) )
        (else (static-wrong "Too long jump" offset)) ) )</p>

<p>(define-instruction (SHORT-GOTO offset) 30
  (set! *pc* (+ *pc* offset)) )</p>

<p>(define-instruction (SHORT-JUMP-FALSE offset) 31
  (if (not *val*) (set! *pc* (+ *pc* offset))) )</p>

<p>(define-instruction (LONG-GOTO offset1 offset2) 28
  (let ((offset (+ offset1 (* 256 offset2))))
    (set! *pc* (+ *pc* offset)) ) )</pre>

<h3 id="compilation/instruction/ssect:invocations">Вызовы функций</h3>

<p>Для начала разберёмся с обычными вызовами, а потом перейдём ко встраиваемым.
Наблюдение о преимущественно небольшой арности используемых функций будет
полезным и здесь. Выделив ещё немного байт-кодов, мы можем специализировать
создание записей активаций для малого числа аргументов:</p>


<!--\indexCS{ALLOCATE-FRAME}{специализация}-->
<pre>(define (ALLOCATE-FRAME size)
  (case size
    ((0 1 2 3 4) (list (+ 50 size)))
    (else        (list 55 (+ size 1))) ) )</p>

<p>(define-instruction (ALLOCATE-FRAME1) 50
  (set! *val* (allocate-activation-frame 1)) )
(define-instruction (ALLOCATE-FRAME size+1) 55
  (set! *val* (allocate-activation-frame size+1)) )</pre>

<p>Раскладывание значений аргументов по записям тоже можно улучшить для небольших
арностей:</p>


<!--\indexCS{POP-FRAME"!}{специализация}-->
<pre>(define (POP-FRAME! index)
  (case index
    ((0 1 2 3) (list (+ 60 index)))
    (else      (list 64 index)) ) )</p>

<p>(define-instruction (POP-FRAME!0) 60
  (set-activation-frame-argument! *val* 0 (stack-pop)) )
(define-instruction (POP-FRAME! index) 64
  (set-activation-frame-argument! *val* index (stack-pop)) )</pre>


<!--\indexR{функции!встраиваемые}-->
<!--\indexR{встраивание!функций}-->
<!--\indexR{встраивание!примитивов}-->
<!--\indexR{примитивы!встраивание}-->
<p>Встраиваемые вызовы встречаются очень часто, поэтому им стоит выдать личные
коды. Например, комбинатор <code><span class="func">INVOKE1</span></code> отвечает за унарные предопределённые
функции:</p>


<!--\indexE{INVOKE0@\protect<code><span class="func">INVOKE</span></code>\protect<i>n</i>!специализация}-->
<pre>(define (INVOKE1 address)
  (case address
    ((car)     (list 90))
    ((cdr)     (list 91))
    ((pair?)   (list 92))
    ((symbol?) (list 93))
    ((display) (list 94))
    (else
     (static-wrong "Cannot inline" address) ) ) )</p>

<p>(define-instruction (CALL1-car) 90
  (set! *val* (car *val*)) )
(define-instruction (CALL1-cdr) 91
  (set! *val* (cdr *val*)) )</pre>

<p>Естественно, аналогичные действия выполняются также для арностей 0, 2 и 3.
Функция <code><span class="func">display</span></code> сделана встраиваемой исключительно ради облегчения отладки.
Вообще ей там не место, учитывая её сложность и скорость работы. Лучше потратить
байт-коды на что-то более полезное, например: <code><span class="func">cadr</span></code>, <code><span class="func">cddr</span></code>, <code><span class="func">cdddr</span></code>
(в порядке убывания полезности).</p>

<p>Конечно, и сами проверки арности тоже можно специализировать для наиболее часто
встречающихся случаев:</p>


<!--\indexC{ARITY="?}-->
<pre>(define (ARITY=? arity+1)
  (case arity+1
    ((1 2 3 4) (list (+ 70 arity+1)))
    (else      (list 75 arity+1)) ) )</p>

<p>(define-instruction (ARITY=?2) 72
  (unless (= (activation-frame-argument-length *val*) 2)
    (signal-exception
     #f (list "Incorrect arity for unary function") ) ) )</p>

<p>(define-instruction (ARITY=? arity+1) 75
  (unless (= (activation-frame-argument-length *val*) arity+1)
    (signal-exception #f (list "Incorrect arity") ) ) )</pre>

<p>Учитывая весьма небольшую долю функций с переменной арностью, для них особого
выигрыша подобные специализации не дадут.</p>


<!--\indexR{циклические структуры данных}-->
<p>Сейчас встраиваются лишь простые и быстрые функции. Если у нас останутся
свободные байты, то можно начать встраивать и функции посложнее, вроде <code><span class="func">memq</span></code>
или <code><span class="func">equal?</span></code>. Единственное возможное неудобство заключается в том, что вызов
<code><span class="func">memq</span></code> может никогда не завершиться (или же просто будет выполняться очень
долго), если просматриваемый ей список имеет циклы. MacScheme <span class="cite">[<a href="z1_bibliography.xhtml#85m85">85m85</a>]</span>,
к примеру, ограничивает для <code><span class="func">memq</span></code> максимальную просматриваемую длину списка несколькими
тысячами элементов.</p>

<h3 id="compilation/instruction/ssect:misc">Прочее</h3>

<p>Ещё у нас остаются несколько простых инструкций, не имеющих операндов и
кодируемых одним-единственным байтом. Генераторы байт-кодов для них одинаковы,
так что хватит и одного примера:</p>

<pre>(define (RESTORE-ENV) (list 38))</pre>

<p>\noindent
А вот и их определения:</p>


<!--\indexC{EXTEND-ENV}     -->
<!--\indexC{UNLINK-ENV}-->
<!--\indexC{PUSH-VALUE}     -->
<!--\indexC{POP-ARG1}-->
<!--\indexC{POP-ARG2}       -->
<!--\indexC{CREATE-CLOSURE}-->
<!--\indexC{RETURN}         -->
<!--\indexC{FUNCTION-GOTO}-->
<!--\indexC{FUNCTION-INVOKE}-->
<!--\indexC{POP-FUNCTION}-->
<!--\indexC{PRESERVE-ENV}   -->
<!--\indexC{RESTORE-ENV}-->
<pre>(define-instruction (EXTEND-ENV) 32
  (set! *env* (sr-extend* *env* *val*)) )</p>

<p>(define-instruction (UNLINK-ENV) 33
  (set! *env* (activation-frame-next *env*)) )</p>

<p>(define-instruction (PUSH-VALUE) 34
  (stack-push *val*) )</p>

<p>(define-instruction (POP-ARG1) 35
  (set! *arg1* (stack-pop)) )</p>

<p>(define-instruction (POP-ARG2) 36
  (set! *arg2* (stack-pop)) )</p>

<p>(define-instruction (CREATE-CLOSURE offset) 40
  (set! *val* (make-closure (+ *pc* offset) *env*)) )</p>

<p>(define-instruction (RETURN) 43
  (set! *pc* (stack-pop)) )</p>

<p>(define-instruction (FUNCTION-GOTO) 46
  (invoke *fun* #t) )</p>

<p>(define-instruction (FUNCTION-INVOKE) 45
  (invoke *fun* #f) )</p>

<p>(define-instruction (POP-FUNCTION) 39
  (set! *fun* (stack-pop)) )</p>

<p>(define-instruction (PRESERVE-ENV) 37
  (preserve-environment) )</p>

<p>(define-instruction (RESTORE-ENV) 38
  (restore-environment) )</pre>

<p>Сохранение и восстановление окружения реализуется следующей парой функций:</p>


<!--\indexC{preserve-environment}-->
<!--\indexC{restore-environment}-->
<pre>(define (preserve-environment)
  (stack-push *env*) )</p>

<p>(define (restore-environment)
  (set! *env* (stack-pop)) )</pre>


<!--\indexR{вызов!хвостовой}-->
<!--\indexR{хвостовые вызовы}-->
<p>Возможны два способа вызова функций: <code><span class="func">FUNCTION-GOTO</span></code> для выполнения вызовов
из хвостовой позиции и <code><span class="func">FUNCTION-INVOKE</span></code> для всего остального. При вызове из
хвостовой позиции функция просто использует тот адрес возврата, который в момент
её вызова лежал на верхушке стека. При нормальном вызове поток исполнения
необходимо вернуть к инструкции, следующей за <code>(FUNCTION-INVOKE)</code>, поэтому
она должна самостоятельно сохранить состояние счётчика команд в стеке. Хвостовой
вызов же по определению эквивалентен <code><span class="func">FUNCTION-INVOKE</span></code>, за которой сразу же
следует <code><span class="func">RETURN</span></code>, а так любая функция всегда завершается инструкцией
<code><span class="func">RETURN</span></code>, то достаточно просто оставить в стеке старый адрес возврата, чтобы
<code><span class="func">RETURN</span></code> вызываемой функции перешла куда следует — ведь вызывающей функции
всё равно ничего больше делать не надо. Именно так и поступает
<code><span class="func">FUNCTION-GOTO</span></code>. Обобщённая функция <code><span class="func">invoke</span></code> реализует оба варианта
поведения.</p>


<!--\indexC{invoke}-->
<!--\indexCS{invoke}{<code><span class="func">closure</span></code>}-->
<pre>(define-generic (invoke (f) tail?)
  (signal-exception #f (list "Not a function" f)) )</p>

<p>(define-method (invoke (f closure) tail?)
  (unless tail? (stack-push *pc*))
  (set! *env* (closure-closed-environment f))
  (set! *pc* (closure-code f)) )</pre>

<p>Так как <code><span class="func">invoke</span></code> является обобщённой, это позволяет распространить её и на
другие объекты: например, на примитивы, представляемые замыканиями.</p>


<!--\indexCS{invoke}{<code><span class="func">primitive</span></code>}-->
<pre>(define-method (invoke (f primitive) tail?)
  (unless tail? (stack-push *pc*))
  ((primitive-address f)) )</pre>

<p>Естественно, значение <code><span class="func">tail?</span></code> надо учитывать при любом вызове функции. Для
примитивов тоже важно, прерываются ли данным вызовом вычисления или же наоборот,
сводятся к нему.</p>

<p>
\section{Запускаем компилятор-интерпретатор}%
\label{compilation/instruction/ssect:starting}</p>


<!--\indexE{REPL}-->
<!--\indexR{интерактивная сессия (REPL)}-->
<!--\indexR{виртуальная машина!инициализация}-->
<p>Для реализации REPL (что мы делали во всех предыдущих главах) потребуется
слаженное взаимодействие компилятора и виртуальной машины. Функция
<code><span class="func">standalone-producer-c7</span></code> принимает программу и инициализирует компилятор.
Под инициализацией здесь понимается создание начального глобального окружения
и перечня используемых цитат. Результатом функции <code><span class="func">meaning</span></code> теперь является
список байтов, который укладывается в вектор между инструкциями <code><span class="func">FINISH</span></code>
в начале и <code><span class="func">RETURN</span></code> в конце. Начальным состоянием счётчика программ будет
единица — адрес первой инструкции после пролога. По известным причинам
\seeEx[fast/ex:symbol-table], с которыми мы столкнёмся позже, эта функция также
инициализирует поимённый список глобальных переменных и цитат. В конце концов
мы получаем замыкание, представляющее наши вычисления и ожидающее последний
важный параметр — необходимый размер стека.</p>


<!--\indexC{chapter7-interpreter}-->
<!--\indexC{make-code-segment}-->
<!--\indexC{code-prologue}-->
<!--\indexC{standalone-producer-c7}-->
<pre>(define (chapter7-interpreter)
  (define (toplevel)
    (display ((standalone-producer-c7 (read)) 100))
    (toplevel) )
  (toplevel) )</p>

<p>(define (standalone-producer-c7 e)
  (set! g.current (original.g.current))
  (set! *quotations* '())
  (let* ((code (make-code-segment (meaning e r.init #t)))
         (start-pc (length (code-prologue)))
         (global-names (map car (reverse g.current)))
         (constants (apply vector *quotations*)) )
    (lambda (stack-size)
      (run-machine stack-size start-pc code
                   constants global-names ) ) ) )</p>

<p>(define (make-code-segment m)
  (apply vector (append (code-prologue) m (RETURN))) )</p>

<p>(define (code-prologue)
  (set! finish-pc 0)
  (FINISH) )</pre>


<!--\indexR{виртуальная машина!остановка работы}-->
<p>Функция <code><span class="func">run-machine</span></code> инициализирует состояние виртуальной машины и запускает
её. Она должна создать вектор глобальных изменяемых переменных, запомнить их
имена, создать стек и инициализировать регистры. Вроде бы ничего
не забыли\textdots\ стоп! а как нам остановить машину? Откомпилированная
программа представляется в виде огромной функции, которую виртуальная машина
вызывает из хвостовой позиции, то есть последней выполняемой инструкцией
программы будет <code><span class="func">RETURN</span></code>. Чтобы всё отработало как надо, в стеке должен
лежать адрес возврата для этой инструкции. Теперь понятно, зачем в самом начале
вектора кода располагается инструкция <code><span class="func">FINISH</span></code>? Сама она определяется так:</p>


<!--\indexC{FINISH}-->
<pre>(define-instruction (FINISH) 20
  (*exit* *val*) )</pre>

<p>Её задачей будет остановить виртуальную машину и передать наверх значение
регистра <code><span class="func">*val*</span></code> на момент завершения работы. Такого поведения мы добиваемся
с помощью ловкой активации продолжения функции <code><span class="func">run-machine</span></code>.</p>


<!--\indexC{run-machine}-->
<pre>(define (run-machine stack-size pc code constants global-names)
  (set! sg.current (make-vector (length global-names) undefined-value))
  (set! sg.current.names global-names)
  (set! *constants*   constants)
  (set! *code*        code)
  (set! *env*         sr.init)
  (set! *stack*       (make-vector stack-size))
  (set! *stack-index* 0)
  (set! *val*         'anything)
  (set! *fun*         'anything)
  (set! *arg1*        'anything)
  (set! *arg2*        'anything)
  (stack-push finish-pc)         ; точка выхода из программы
  (set! *pc*          pc)
  (call/cc (lambda (exit)
             (set! *exit* exit)
             (run) )) )</pre>

<h3 id="compilation/instruction/ssect:catch-breath">Передышка</h3>

<p>Напоследок, после тщательного рассмотрения инструкций нашей виртуальной машины,
давайте ещё раз взглянем на результат компиляции примера с факториалом, теперь
уже под новый диалект машинного языка. И оформленный, естественно, не в виде
байтов, а как читабельный дизассемблерный листинг. Прошу любить и жаловать:
таблица \ref{compilation/instruction/catch-breath/pic:disasm}.</p>

<p>\begin{table}[pt]\setlength{\tabcolsep}{1.5em}%
\begin{center}\begin{tabular}{l|@{\extracolsep{1.25em}}l}
<code>(CREATE-CLOSURE 2)</code>        &  <code>(CALL2-*)</code>                 \\
<code>(SHORT-GOTO 60)</code>           &  <code>(PUSH-VALUE)</code>              \\
<code>(ARITY=?4)</code>                &  <code>(ALLOCATE-FRAME2)</code>         \\
<code>(EXTEND-ENV)</code>              &  <code>(POP-FRAME!0)</code>             \\
<code>(SHALLOW-ARGUMENT-REF0)</code>   &  <code>(POP-FUNCTION)</code>            \\
<code>(PUSH-VALUE)</code>              &  <code>(FUNCTION-GOTO)</code>           \\
<code>(CONSTANT0)</code>               &  <code>(RETURN)</code>                  \\
<code>(POP-ARG1)</code>                &  <code>(PUSH-VALUE)</code>              \\
<code>(CALL2-=)</code>                 &  <code>(ALLOCATE-FRAME4)</code>         \\
<code>(SHORT-JUMP-FALSE 10)</code>     &  <code>(POP-FRAME!2)</code>             \\
<code>(SHALLOW-ARGUMENT-REF2)</code>   &  <code>(POP-FRAME!1)</code>             \\
<code>(PUSH-VALUE)</code>              &  <code>(POP-FRAME!0)</code>             \\
<code>(CONSTANT1)</code>               &  <code>(POP-FUNCTION)</code>            \\
<code>(PUSH-VALUE)</code>              &  <code>(FUNCTION-GOTO)</code>           \\
<code>(ALLOCATE-FRAME2)</code>         &  <code>(RETURN)</code>                  \\
<code>(POP-FRAME!0)</code>             &  <code>(PUSH-VALUE)</code>              \\
<code>(POP-FUNCTION)</code>            &  <code>(ALLOCATE-FRAME2)</code>         \\
<code>(FUNCTION-GOTO)</code>           &  <code>(POP-FRAME!0)</code>             \\
<code>(SHORT-GOTO 40)</code>           &  <code>(EXTEND-ENV)</code>              \\
<code>(SHALLOW-ARGUMENT-REF1)</code>   &  <code>(SHALLOW-ARGUMENT-REF0)</code>   \\
<code>(PUSH-VALUE)</code>              &  <code>(PUSH-VALUE)</code>              \\
<code>(SHALLOW-ARGUMENT-REF0)</code>   &  <code>(SHORT-NUMBER 5)</code>          \\
<code>(PUSH-VALUE)</code>              &  <code>(PUSH-VALUE)</code>              \\
<code>(CONSTANT1)</code>               &  <code>(SHALLOW-ARGUMENT-REF0)</code>   \\
<code>(POP-ARG1)</code>                &  <code>(PUSH-VALUE)</code>              \\
\ic{(CALL2-{}-)}               &  <code>(CREATE-CLOSURE 2)</code>        \\
<code>(PUSH-VALUE)</code>              &  <code>(SHORT-GOTO 4)</code>            \\
<code>(SHALLOW-ARGUMENT-REF1)</code>   &  <code>(ARITY=?2)</code>                \\
<code>(PUSH-VALUE)</code>              &  <code>(EXTEND-ENV)</code>              \\
<code>(CREATE-CLOSURE 2)</code>        &  <code>(SHALLOW-ARGUMENT-REF0)</code>   \\
<code>(SHORT-GOTO 19)</code>           &  <code>(RETURN)</code>                  \\
<code>(ARITY=?2)</code>                &  <code>(PUSH-VALUE)</code>              \\
<code>(EXTEND-ENV)</code>              &  <code>(ALLOCATE-FRAME4)</code>         \\
<code>(DEEP-ARGUMENT-REF 1 2)</code>   &  <code>(POP-FRAME!2)</code>             \\
<code>(PUSH-VALUE)</code>              &  <code>(POP-FRAME!1)</code>             \\
<code>(DEEP-ARGUMENT-REF 1 0)</code>   &  <code>(POP-FRAME!0)</code>             \\
<code>(PUSH-VALUE)</code>              &  <code>(POP-FUNCTION)</code>            \\
<code>(SHALLOW-ARGUMENT-REF0)</code>   &  <code>(FUNCTION-GOTO)</code>           \\
<code>(POP-ARG1)</code>                &  <code>(RETURN)</code>
\end{tabular}\end{center}%
\caption{Откомпилированная программа.}%
\label{compilation/instruction/catch-breath/pic:disasm}%
\end{table}</p>

<h2 id="compilation/sect:continue">Продолжения</h2>


<!--\indexCS{call/cc}{каноническая реализация}-->
<!--\indexR{полноценные объекты!продолжения}-->
<!--\indexR{продолжения (continuations)!как полноценные объекты}-->
<p>Мы уже знаем, что <code><span class="func">call/cc</span></code> — это магический оператор, реифицирующий
контекст исполнения программы, превращающий его в полноценный объект языка,
который можно сохранить в переменной, а потом восстановить обратно. Настало
время объяснить, как именно он работает. Предлагаемая реализация является
канонической. Более эффективные, но и более сложные варианты можно найти
в \cite{cho88,hdb90,mb93}.</p>


<!--\indexR{программы!контекст исполнения}-->
<!--\indexR{стек!контекст исполнения}-->
<!--\indexR{контекст вычислений}-->
<!--\indexR{вычисления!контекст}-->
<p>Контекст исполнения программы — это стек и ничего, кроме стека.
Действительно, регистры <code><span class="func">*fun*</span></code>, <code><span class="func">*arg1*</span></code> и <code><span class="func">*arg2*</span></code> используются лишь
хранения промежуточных результатов вычислений, их значения лишены смысла между
выражениями компилируемого языка. (Нельзя\footnote{Говоря в общем, это всё же
возможно при обработке асинхронных вызовов вроде сигналов \UNIX. В таком случае,
очевидно, следует использовать время от времени проверяемый флаг, как
в <span class="cite">[<a href="z1_bibliography.xhtml#dev85">dev85</a>]</span>, или иной механизм синхронизации.} вызвать <code><span class="func">call/cc</span></code> или
что-нибудь ещё во время процесса обработки вызова функции, когда эти регистры
используются.)</p>

<p>Регистр <code><span class="func">*val*</span></code> используется для передачи значений самим продолжениям, так
что тут нечего сохранять. Регистр <code><span class="func">*env*</span></code> тоже бессмысленно смысла
запоминать, потому как <code><span class="func">call/cc</span></code> — это не встраиваемый примитив; если
окружение надо было сохранить, то это уже сделано в силу самого вызова
<em>функции</em> <code><span class="func">call/cc</span></code>. Таким образом, остаётся сохранить только стек.
Следующие функции помогут работать с ним:</p>


<!--\indexC{save-stack}-->
<!--\indexC{restore-stack}-->
<!--\indexC{vector-copy"!}-->
<pre>(define (save-stack)
  (let ((copy (make-vector *stack-index*)))
    (vector-copy! *stack* copy 0 *stack-index*)
    copy ) )</p>

<p>(define (restore-stack copy)
  (set! *stack-index* (vector-length copy))
  (vector-copy! copy *stack* 0 *stack-index*) )</p>

<p>(define (vector-copy! old new start end)
  (let copy ((i start))
    (when (< i end)
          (vector-set! new i (vector-ref old i))
          (copy (+ i 1)) ) ) )</pre>

<p>Продолжения имеют личный класс значений и особый протокол вызова. При
активации продолжения следует восстановить стек, положить переданное значение
в регистр <code><span class="func">*val*</span></code>, а затем выполнить <code><span class="func">RETURN</span></code>, который перейдёт
к инструкции, следующей за вызовом <code><span class="func">call/cc</span></code>. Очевидно, для этого
<code><span class="func">call/cc</span></code> должна вызываться исключительно с помощью <code><span class="func">FUNCTION-INVOKE</span></code>, а
значит, следующей исполняемой инструкцией обязательно будет <code><span class="func">RESTORE-ENV</span></code>.
(Можете убедиться в этом, перечитав определение <code><span class="func">REGULAR-CALL</span></code>.)
\seePage[compilation/bytes/customize/sssect:lin-invocation]</p>


<!--\indexC{continuation}-->
<!--\indexCS{invoke}{<code><span class="func">continuation</span></code>}-->
<pre>(define-class continuation Object
  ( stack ) )</p>

<p>(define-method (invoke (f continuation) tail?)
  (if (= (+ 1 1) (activation-frame-argument-length *val*))
      (begin
        (restore-stack (continuation-stack f))
        (set! *val* (activation-frame-argument *val* 0))
        (set! *pc* (stack-pop)) )
      (signal-exception #f (list "Incorrect arity" 'continuation)) ) )</pre>


<!--\indexCS{call/cc}{огранизация стека}-->
<p>Для правильной работы продолжений <code><span class="func">call/cc</span></code> должна организовать стек таким
образом, чтобы после активации продолжения начал исполняться код, следующий за
самой <code><span class="func">call/cc</span></code>. То есть форма \ic{(call/cc <i>f</i>)} с точки зрения стека
должна быть идентична вызову функции <i>f</i> из хвостовой позиции (если забыть
про <code><span class="func">dynamic-wind</span></code>). Следующее определение добивается этого, выполняя
хвостовой вызов вручную. Функция <code><span class="func">call/cc</span></code> сама создаёт нужную запись
активации для своего аргумента-замыкания, сохраняет в ней продолжение, помещает
эту запись в обход стека сразу же в <code><span class="func">*val*</span></code> и вызывает <i>f</i> напрямую.</p>


<!--\indexC{call/cc}-->
<pre>(definitial call/cc
  (let* ((arity 1)
         (arity+1 (+ 1 arity)) )
    (make-primitive
      (lambda ()
        (if (= arity+1 (activation-frame-argument-length *val*))
            (let ((f (activation-frame-argument *val* 0))
                  (frame (allocate-activation-frame (+ 1 1))) )
              (set-activation-frame-argument!
               frame 0 (make-continuation (save-stack)) )
              (set! *val* frame)
              (set! *fun* f)       ; полезно для отладки
              (invoke f #t) )
            (signal-exception #t (list "Incorrect arity"
                                       'call/cc )) ) ) ) ) )</pre>

<p>Итого, каноническая реализация <code><span class="func">call/cc</span></code> выполняет одно полное копирование
стека при своём вызове, а также по дополнительному копированию при каждой
активации сохранённых продолжений. Естественно, существуют стратегии поумнее,
но они более сложны для понимания и реализации. Основываются они на том, что
у захватываемых продолжений нередко <span class="cite">[<a href="z1_bibliography.xhtml#dan87">dan87</a>]</span> имеются общие части, которые
бессмысленно дублировать, поэтому можно оптимизировать <code><span class="func">call/cc</span></code>, если
использовать более разумный способ представления продолжений, нежели полные
независимые снимки стека.</p>

<h2 id="compilation/sect:escapes">Переходы</h2>


<!--\indexR{переходы (escapes)!реализация}-->
<!--\indexCS{bind-exit}{машинная реализация}-->
<p>Несмотря на то, что стоимость <code><span class="func">call/cc</span></code> можно уменьшить, обычные переходы
(escapes) всё ещё остаются гораздо более эффективными. Мы упоминали об этом
в третьей главе, так что сейчас было бы нечестным не показывать, как они
реализуются технически. Для иллюстрации была выбрана конструкция <code><span class="func">bind-exit</span></code>.
\seePage[escape/comparing/par:bind-exit] Родом она из диалекта Dylan, её
аналогами являются <code><span class="func">let/cc</span></code> в <span class="logo">EuLisp</span>, <code><span class="func">block</span></code>\slash<code><span class="func">return-from</span></code>
в <span class="logo">Common Lisp</span>, <code><span class="func">escape</span></code> в VLISP <span class="cite">[<a href="z1_bibliography.xhtml#cha80">cha80</a>]</span>.</p>

<p>Наперекор традициям Scheme, она будет реализована в виде специальной формы, а
не функции. Во-первых, в данном случае легче реализовать именно специальную
форму, так как это избавит нас от излишней работы по соблюдению протокола вызова
функций; во-вторых, главной задачей этой главы является демонстрация внутреннего
строения компилятора, а не следование догмам. Если вас эти слова не убедили, то
вспомните, что подобную специальную форму можно выразить через аналогичную
функцию и наоборот, так что это лишь вопрос внешнего вида, а не сути.</p>

<p>Форма <code><span class="func">bind-exit</span></code> имеет следующий синтаксис:</p>

<pre>(bind-exit (<i>переменная</i>) <i>формы</i>...)</pre>


<!--\indexC{call/ep}-->
<p><i>Переменная</i> связывается с продолжением формы <code><span class="func">bind-exit</span></code>, после чего
последовательно вычисляются <i>формы</i>. Захваченным продолжением можно
воспользоваться только во время этих вычислений. Если у нас есть <code><span class="func">bind-exit</span></code>,
то можно легко определить функцию <code><span class="func">call/ep</span></code> и наоборот:</p>

<p>{\def\E{\hbox to 0pt{\kern0.15em\eq}}
\def\K{<i>k</i>}
\def\B{<i>тело</i>}
\begin{code:lisp}
(define (call/ep f)
  (bind-exit (k) (f k)) )</p>

<p>(bind-exit (|\K|) |\B|) |\E|   (call/ep (lambda (|\K|) |\B|))
\end{code:lisp}}</p>

<p>Переходы представляются объектами класса <code><span class="func">escape</span></code>. Его единственное поле
хранит высоту стека, какой она была на момент начала вычисления формы
<code><span class="func">bind-exit</span></code>.</p>


<!--\indexC{escape}-->
<pre>(define-class escape Object
  ( stack-index ) )</pre>

<p>Для определения специальной формы сперва необходимо добавить соответствующую
обработку в функцию <code><span class="func">meaning</span></code>, синтаксический анализатор компилируемых форм.
Её задачей является распознавание наших нововведений:</p>

<pre>... ((bind-exit) (meaning-bind-exit (caadr e) (cddr e) r tail?)) ...</pre>

<p>Затем определяется способ предобработки данных форм:</p>


<!--\indexC{meaning-bind-exit}-->
<pre>(define (meaning-bind-exit n e+ r tail?)
  (let* ((r2 (r-extend* r (list n)))
         (m+ (meaning-sequence e+ r2 #t)) )
    (ESCAPER m+) ) )</pre>

<p>Обработка заключается в объединении форм, составляющих тело <code><span class="func">bind-exit</span></code>,
в последовательность, которая вычисляется в лексическом окружении, расширенном
локальной переменной, вводимой формой <code><span class="func">bind-exit</span></code>. Генерацией байт-кода
будет заниматься функция <code><span class="func">ESCAPER</span></code>. Для её реализации нам потребуется пара
новых инструкций: <code><span class="func">PUSH-ESCAPER</span></code> и <code><span class="func">POP-ESCAPER</span></code>.</p>


<!--\indexC{ESCAPER}-->
<!--\indexC{PUSH-ESCAPER}-->
<!--\indexC{POP-ESCAPER}-->
<!--\indexC{escape-tag}-->
<pre>(define (ESCAPER m+)
  (append (PUSH-ESCAPER (+ 1 (length m+)))
          m+ (RETURN) (POP-ESCAPER)) )</p>

<p>(define (POP-ESCAPER) (list 250))
(define (PUSH-ESCAPER offset) (list 251 offset))</p>

<p>(define escape-tag (list '*ESCAPE*))</p>

<p>(define-instruction (POP-ESCAPER) 250
  (let* ((tag (stack-pop))
         (escape (stack-pop)) )
    (restore-environment) ) )</p>

<p>(define-instruction (PUSH-ESCAPER offset) 251
  (preserve-environment)
  (let* ((escape (make-escape (+ *stack-index* 3)))
         (frame (allocate-activation-frame 1)) )
    (set-activation-frame-argument! frame 0 escape)
    (set! *env* (sr-extend* *env* frame))
    (stack-push escape)
    (stack-push escape-tag)
    (stack-push (+ *pc* offset)) ) )</pre>

<p>\ForLayout{display}{\smallskip}</p>


<!--\indexR{переходы (escapes)!огранизация стека}-->
<!--\indexR{дескрипторы!переходов}-->
<!--\indexR{стековые фреймы!переходы}-->
<p>Иллюстрация принципа работы инструкции <code><span class="func">PUSH-ESCAPER</span></code> приведена
на рисунке \ref{compilation/escapes/pic:push-escaper}. Вот что она делает:</p>

<p>\begin{enumerate}
  \item Сохраняет в стеке текущее окружение.</p>

<p>  \item Создаёт дескриптор перехода, указывающий на
        три ячейки выше текущего положения верхушки стека.</p>

<p>  \item Создаёт запись активации с единственным полем, в которое
        укладывает созданный ранее дескриптор, после чего расширяет
        текущее окружение полученной записью.</p>

<p>  \item Кладёт в стек дескриптор перехода, затем странную
        метку <code>(*ESCAPE*)</code> и, наконец, адрес инструкции
        <code><span class="func">POP-ESCAPER</span></code>, соответствующей создаваемому
        переходу.
\end{enumerate}</p>

<p>\begin{figure}[tb]\centering
\input{figures/fig7.4}
\caption{Состояние стека до и после инструкции \protect<code><span class="func">PUSH-ESCAPER</span></code>.}%
\label{compilation/escapes/pic:push-escaper}%
\end{figure}</p>


<!--\indexR{переходы (escapes)!допустимость}-->
<p>Процедура выполнения перехода несколько усложняется из-за того, что необходимо
проверять, можно ли его вообще выполнить. Переход допустим, если 1) он
выполняется вниз по стеку; 2) искомая ячейка стека действительно содержит
настоящий дескриптор перехода; 3) это именно тот дескриптор, который нам нужен.
Соблюдение всех этих условий обеспечивается предикатом <code><span class="func">escape-valid?</span></code>.</p>


<!--\indexCS{invoke}{<code><span class="func">escape</span></code>}-->
<!--\indexC{escape-valid"?}-->
<pre>(define-method (invoke (f escape) tail?)
  (if (= (+ 1 1) (activation-frame-argument-length *val*))
      (if (escape-valid? f)
          (begin (set! *stack-index* (escape-stack-index f))
                 (set! *val* (activation-frame-argument *val* 0))
                 (set! *pc* (stack-pop)) )
          (signal-exception #f (list "Escape out of extent" f)) )
      (signal-exception #f (list "Incorrect arity" 'escape)) ) )</p>

<p>(define (escape-valid? f)
  (let ((index (escape-stack-index f)))
    (and (>= *stack-index* index)
         (eq? f (vector-ref *stack* (- index 3)))
         (eq? escape-tag (vector-ref *stack* (- index 2))) ) ) )</pre>

<p>При выполнении перехода сначала проверяется арность соответствующей формы,
затем стек откатывается до состояния, которое он имел при входе в форму
<code><span class="func">bind-exit</span></code>, после этого аргумент перебрасывается в регистр <code><span class="func">*val*</span></code> и,
наконец, выполняется аналог <code><span class="func">RETURN</span></code> для выхода из тела формы <code><span class="func">bind-exit</span></code>.
Следующей исполняемой инструкцией будет <code><span class="func">POP-ESCAPER</span></code>, которая уберёт
со стека теперь уже ненужный дескриптор перехода и восстановит окружение.</p>

<p>На случай, если во время вычисления тела формы <code><span class="func">bind-exit</span></code> переход
инициирован не будет, в конце располагается настоящая инструкция <code><span class="func">RETURN</span></code>,
что в итоге приводит к такому же поведению и завершающему состоянию стека, как
если бы переход был выполнен.</p>


<!--\indexCS{bind-exit}{эффективность}-->
<p>Вход в форму <code><span class="func">bind-exit</span></code> вызывает создание двух объектов и занимает четыре
ячейки стека. Выполнение перехода стоит одной проверки на допустимость и
нескольких операций с регистрами. Дескрипторы переходов создаются и сохраняются
явно, так как переменные, создаваемые <code><span class="func">bind-exit</span></code>, могут быть захвачены
замыканиями, что даст им неограниченное время жизни (но не соответствующим
переходам). Если бы эти переменные гарантированно не захватывались, то можно
было бы ограничиться запоминанием высоты стека в каком-нибудь регистре.
Приведённая реализация, признаем, является довольно простой и прямолинейной,
поэтому, естественно, и менее эффективной по сравнению с результатами хорошей
компиляции. Однако, даже такая реализация оказывается значительно быстрее
канонического варианта <code><span class="func">call/cc</span></code>.</p>

<p>Специальная форма <code><span class="func">bind-exit</span></code> (вместе с динамическими переменными, которые
мы рассмотрим далее) облегчает написание аналогов <code><span class="func">catch</span></code>\slash<code><span class="func">throw</span></code>.
\seePage[escape/forms/ssect:dynamic] Также напомним, что если в языке
реализована форма <code><span class="func">unwind-protect</span></code>, то <code><span class="func">bind-exit</span></code> уже не обязательно
гарантирует сверхбыстрые переходы, так как во время их выполнения необходимо
выполнять и установленные <code><span class="func">unwind-protect</span></code> формы-уборщики. Это значит, что
нам придётся полностью просматривать часть стека, которую текущая реализация
просто игнорирует.</p>

<h2 id="compilation/sect:dynamic">Динамические переменные</h2>


<!--\indexR{дальнее (deep) связывание}-->
<!--\indexR{связывание!дальнее (deep)}-->
<!--\indexR{динамические переменные}-->
<!--\indexR{переменные!динамические}-->
<p>Мы уже не раз упоминали значимость идеи динамических переменных для языков
программирования. Проще всего они реализуются с помощью дальнего связывания. Как
и ранее, \seePage[denotational/dynamic/par:two-forms], мы введём две специальные
формы для создания и использования подобных переменных. Вот их синтаксис:</p>


<!--\indexC{dynamic}-->
<!--\indexC{dynamic-let}-->
<pre>(dynamic-let (<i>переменная</i> <i>значение</i>) <i>тело</i>)
(dynamic <i>переменная</i>)</pre>

<p>Форма <code><span class="func">dynamic-let</span></code> связывает <i>переменную</i> со <i>значением</i> на время
вычисления <i>тела</i>. Текущее значение динамической переменной можно получить
с помощью формы <code><span class="func">dynamic</span></code>. Естественно, если переменная не была ранее связана
с каким-либо значением, то возникает ошибка.</p>

<p>Итак, добавляем две новые формы в синтаксический анализатор <code><span class="func">meaning</span></code>:</p>

<pre>...
((dynamic)     (meaning-dynamic-reference (cadr e) r tail?))
((dynamic-let) (meaning-dynamic-let (car (cadr e))
                                    (cadr (cadr e))
                                    (cddr e) r tail? ))
...</pre>

<p>Реализуем их обработку:</p>


<!--\indexC{meaning-dynamic-let}-->
<!--\indexC{meaning-dynamic-reference}-->
<pre>(define (meaning-dynamic-let n e e+ r tail?)
  (let ((index (get-dynamic-variable-index n))
        (m (meaning e r #f))
        (m+ (meaning-sequence e+ r #f)) )
    (append m (DYNAMIC-PUSH index) m+ (DYNAMIC-POP)) ) )</p>

<p>(define (meaning-dynamic-reference n r tail?)
  (let ((index (get-dynamic-variable-index n)))
    (DYNAMIC-REF index) ) )</pre>

<p>В результате получаем три новых генератора:</p>


<!--\indexC{DYNAMIC-PUSH}-->
<!--\indexC{DYNAMIC-POP}-->
<!--\indexC{DYNAMIC-REF}-->
<pre>(define (DYNAMIC-PUSH index) (list 242 index))
(define (DYNAMIC-POP)        (list 241))
(define (DYNAMIC-REF index)  (list 240 index))</pre>

<p>Эти генераторы соответствуют трём новым инструкциям виртуальной машины:</p>

<pre>(define-instruction (DYNAMIC-PUSH index) 242
  (push-dynamic-binding index *val*) )</p>

<p>(define-instruction (DYNAMIC-POP) 241
  (pop-dynamic-binding) )</p>

<p>(define-instruction (DYNAMIC-REF index) 240
  (set! *val* (find-dynamic-value index)) )</pre>


<!--\indexR{принцип нулевых издержек}-->
<!--\indexR{регистры!dynenv@\protect<code><span class="func">*dynenv*</span></code>}-->
<!--\indexE{dynenv@\protect<code><span class="func">*dynenv*</span></code>}-->
<p>Итак, как же нам представить окружение динамических переменных? Первая же идея,
которая приходит в голову, — это ввести новый регистр, скажем, <code><span class="func">*dynenv*</span></code>,
хранящий ассоциативный список имён и значений динамических переменных. Вернее,
цепочку <em class="term">фреймов</em>, подобную стеку записей активаций. К сожалению, в таком
случае этот регистр будет являться частью состояния машины, за сохранение\slash
восстановление которого отвечают инструкции <code><span class="func">PRESERVE-ENV</span></code>
и <code><span class="func">RESTORE-ENV</span></code>. Так как эти инструкции встречаются повсеместно, то введение
<code><span class="func">*dynenv*</span></code> скажется на производительности даже тех частей программы, где
динамические переменные вовсе не используются. Очень важным является принцип, по
которому за услуги платит только тот, кто их заказывает; следовательно, если
какие-либо возможности языка не используются, то они не должны вызывать
накладных расходов. С этой точки зрения введение дополнительного регистра
является плохой идеей.</p>

<p>\begin{figure}[tb]\begin{center}
\input{figures/fig7.5}
\end{center}%
\caption{Состояние стека до и после инструкции \protect<code><span class="func">DYNAMIC-PUSH</span></code>.}%
\label{compilation/dynamic/pic:subj}%
\end{figure}</p>


<!--\indexR{динамические переменные!организация стека}-->
<!--\indexR{стековые фреймы!динамические переменные}-->
<p>Поэтому вместо добавления общего для всех регистра мы реализуем иной подход,
позволяющий сохранять необходимую информацию только тем, кто нуждается в ней и
действительно будет пользоваться динамическими переменными. Конечно, расходы при
этом будут немного выше, но они никогда не падут на непричастных. Динамические
переменные будут храниться в особым образом сформированных фреймах стека,
подобно переходам (см. рисунок \ref{compilation/dynamic/pic:subj}). Функция
<code><span class="func">search-dynenv-index</span></code> ищет в стеке самый верхний фрейм, содержащий
динамическую переменную, — именно эту информацию должен был хранить регистр
<code><span class="func">*dynenv*</span></code>.</p>


<!--\indexC{dynenv-tag}-->
<!--\indexC{search-dynenv-index}-->
<!--\indexC{pop-dynamic-binding}-->
<!--\indexC{push-dynamic-binding}-->
<pre>(define dynenv-tag (list '*dynenv*))</p>

<p>(define (search-dynenv-index)
  (let search ((i (- *stack-index* 1)))
    (if (< i 0) i
        (if (eq? (vector-ref *stack* i) dynenv-tag)
            (- i 1)
            (search (- i 1)) ) ) ) )</p>

<p>(define (pop-dynamic-binding)
  (stack-pop)
  (stack-pop)
  (stack-pop)
  (stack-pop) )</p>

<p>(define (push-dynamic-binding index value)
  (stack-push (search-dynenv-index))
  (stack-push value)
  (stack-push index)
  (stack-push dynenv-tag) )</pre>


<!--\indexR{символы!адреса при компиляции}-->
<p>Единственная не совсем очевидная деталь — это как именно компилировать
обращения к динамическим переменным. Очевидно, что просто так у нас не получится
скомпилировать выражение <code>(dynamic foo)</code> в байты, потому что символ <code><span class="func">foo</span></code>
— это не число. Та же проблема у нас была с глобальными переменными, тогда мы
стали их нумеровать по мере появления. Почему бы не поступить аналогично
и сейчас? Этим будет заниматься функция <code><span class="func">get-dynamic-variable-index</span></code>:</p>


<!--\indexC*{dynamic-variables}{*dynamic-variables*}-->
<!--\indexC{get-dynamic-variable-index}-->
<pre>(define *dynamic-variables* '())</p>

<p>(define (get-dynamic-variable-index n)
  (let ((where (memq n *dynamic-variables*)))
    (if where (length where)
        (begin
          (set! *dynamic-variables* (cons n *dynamic-variables*))
          (length *dynamic-variables*) ) ) ) )</pre>

<p>Каждой динамической переменной ставится в соответствие индекс, по которому её
можно отыскать в окружении динамических переменных, располагаемом в стеке.
Переменная <code><span class="func">*dynamic-variables*</span></code> в принципе нужна только для компиляции, но
возможность вывести имя переменной в случае ошибки — тоже вещь хорошая.
Определение функции <code><span class="func">find-dynamic-value</span></code> оставляется вам в качестве
упражнения.</p>

<p>В этом разделе приведена реализация динамических переменных с помощью пары
специальных форм. Функциональная реализация лучше соотносится с духом Scheme,
но она не полностью эквивалентна текущей. Аргументы функций могут быть как
непосредственными значениями, так и выражениями, тогда как специальным формам
позволяется вводить особые требования к синтаксису. Очевидно, что мы не сможем
заранее пронумеровать динамические переменные, если их поддержка реализуется
с помощью функций, так как это даёт возможность вычислять символы во время
исполнения программы.
\seePage[lisp1-2-omega/namespaces/ssect:dyn-vars-no-special] В этом случае уже
придётся, по-видимому, как-то использовать сами символы напрямую, но поддержка
модулей, пространств имён и различные оптимизации могут повлиять на семантику
сравнения символов, что в свою очередь скажется на динамических переменных.</p>

<h2 id="compilation/sect:exception">Исключения</h2>

<p>В любом сколь-нибудь развитом языке программирования обязательно присутствует
система обработки ошибок. Возможность обработки ошибок — это ключ к написанию
устойчивых, надёжных приложений. К сожалению, в стандарте {\RnRS} подобная
система не описана, поэтому давайте создадим её самостоятельно; просто чтобы
показать, насколько она может быть полезной и удобной.</p>


<!--\indexR{ошибки!и исключения}-->
<!--\indexR{обработка ошибок}-->
<p>Понятие ошибки имеет несколько значений. Во-первых, это предотвратимые, но
почему-то не предусмотренные ситуации. Например, ошибки типизации:
<code>(car 33)</code>, недопустимые значения аргументов: <code>(quotient 111 0)</code>, или
их неправильное количество: <code>(cons)</code>. Подобных логических ошибок можно
избежать, вовремя выполняя соответствующие проверки. Другой класс ошибок
составляют непредотвратимые, исключительные ситуации, например, ошибка открытия
файла. Для их обработки необходимы следующие механизмы:</p>

<p>\begin{enumerate}
  \item Способ создания объекта, описывающего ошибку и поддающегося
        программной обработке.</p>

<p>  \item Возможность передать этот объект определённой функции,
        которую пользователь назначил обработчиком ошибок.
\end{enumerate}</p>


<!--\indexR{исключения}-->
<p>Если в языке присутствуют эти механизмы, то пользователи языка закономерно
захотят их применять. Так ошибки становятся <em class="term">исключениями</em>, и появляется
возможность описывать логику программ с их помощью: реализовывать только
корректное, нормальное поведение, а всевозможные аномальные прерывания
вычислений оставлять на откуп обработчику исключительных ситуаций.</p>


<!--\indexR{динамическое связывание!и исключения}-->
<!--\indexR{обработка ошибок!динамические переменные}-->
<!--\indexR{дескрипторы!исключений}-->
<p>Существует несколько моделей обработки исключений. В основном они базируются на
идее динамического времени жизни. Если мы хотим обрабатывать ошибки, возникающие
во время определённых вычислений, то очевидно, что на время проведения этих
вычислений с ними связывается определённая функция-обработчик. Если вычисления
выполнились без проблем, то обработчик становится ненужным и автоматически
утилизируется. В противном случае создаётся объект, описывающий произошедшую
ошибку, и к нему применяется обработчик. Если ошибку первым заметил
пользовательский код, то он же её и описывает. Если же ошибка была обнаружена
системой, то возникает системное исключение.</p>


<!--\indexC{cerror}-->
<!--\indexR{исключения!возобновление}-->
<!--\indexR{возобновляемые исключения}-->
<!--\indexR{обработка ошибок!с возобновлением}-->
<!--\indexR{исключения!модели обработки}-->
<!--\indexR{модель обработки исключений}-->
<p>Некоторые модели обработки поддерживают возможность возобновления прерванных
вычислений. В случае возникновения некоторых ошибок (в частности,
предусмотренных заранее программистом, вроде вызываемых формой <code><span class="func">cerror</span></code>
в <span class="logo">Common Lisp</span>) можно попытаться повторить вычисления ещё раз, начиная с того
места, где они были прерваны. Во многих других случаях, к сожалению,
единственным возможным и наиболее адекватным поведением будет переход
куда-нибудь в безопасное место, дабы не усугублять и так непростую ситуацию.</p>


<!--\indexR{раскрутка стека (unwinding)}-->
<p>Модель исключений <span class="logo">Common Lisp</span> более чем полна, но её масштабность не особо
сочетается с данной книгой, чьей задачей является рассмотрение сути вещей.
Модель ML не поддерживает возобновление после ошибок; если где-то возникает
исключение, то это вызывает необратимую раскрутку стека до ближайшего
обработчика. Возможно только перебросить исключение дальше, раскручивая стек до
следующего обработчика. В нашем случае подобная модель не подходит, так как при
возникновении ошибки теряется динамическое окружение переменных, а ведь проблема
могла быть именно в нём. Поэтому мы пойдём другим путём. (На его выбор сильное
влияние оказал \EuLisp.) Сначала мы неформально опишем идею, а затем плавно
перейдём к её реализации.</p>

<p>\phantomlabel{compilation/exception/par:monitor}
<!--\indexC{monitor}-->
<!--\indexR{специальные формы!monitor@\protect<code><span class="func">monitor</span></code>}-->
Специальная форма <code><span class="func">monitor</span></code> устанавливает функцию-обработчик исключений на
время вычислений, представляемых её телом. Таким образом, она имеет следующий
синтаксис:</p>

<pre>(monitor <i>обработчик</i> <i>формы</i>...)</pre>

<p>Соответственно, в синтаксическом анализаторе <code><span class="func">meaning</span></code> появляется новое
правило:</p>

<pre>... ((monitor) (meaning-monitor (cadr e) (cddr e) r tail?)) ...</pre>

<p><i>Обработчик</i> вычисляется и становится текущим обработчиком исключений.
<i>Формы</i>, составляющие тело <code><span class="func">meaning</span></code>, последовательно вычисляются
внутри неявной формы <code><span class="func">begin</span></code>. Если во время вычислений ничего плохого
не произошло, то <code><span class="func">monitor</span></code> возвращает значение последней вычисленной формы и
устанавливает обратно предыдущий обработчик.</p>


<!--\indexR{исключения!цепочка обработчиков}-->
<!--\indexR{исключения!терминальный обработчик}-->
<!--\indexR{терминальный обработчик исключений}-->
<p>Если же возникает исключительная ситуация, то сначала отыскивается текущий
обработчик, то есть обработчик, ассоциированный с динамически ближайшей формой
<code><span class="func">monitor</span></code>. (На машинном языке это читается как «ближайший к верхушке
стека».) Найденная функция вызывается с двумя аргументами: логическим
значением, показывающим, может ли она возобновить вычисления после завершения
обработки, и объектом, описывающим проблему. Вызов осуществляется специальным
образом, оставляя стек неизменным. Естественно, в самом обработчике также
могут возникнуть ошибки — за них отвечает предыдущий обработчик. Вычисления,
выполняемые при обработке, могут или нормально вернуть значение, или же
прерваться переходом. Если исключение является возобновляемым, то возвращённое
значение становится значением формы, вызвавшей исключение. Если возобновление
запрещено, а значение всё равно возвращается, то возникает новое
(невозобновляемое) исключение, сигнализирующее об этой проблеме. Если же
обработка заканчивается переходом, то наблюдение за ошибками автоматически
передаётся обработчику, ближайшему к новой текущей верхушке стека. В самом низу
стека находится терминальный обработчик исключений. Если по каким-либо причинам
исключение доходит до него, то он останавливает вирутальную машину и возвращает
управление операционной системе.</p>

<p>\begin{figure}[!ht]\begin{center}
\input{figures/fig7.6}
\end{center}%
\caption{Процесс обработки исключения.}%
\label{compilation/exception/pic:subj}%
\end{figure}</p>

<p>\ForLayout{display}{\clearpage}</p>

<p>Предобработка превращает форму <code><span class="func">monitor</span></code> в комбинацию двух новых инструкций,
отвечающих за работу со стеком обработчиков исключений:</p>


<!--\indexC{meaning-monitor}-->
<pre>(define (meaning-monitor e e+ r tail?)
  (let ((m (meaning e r #f))
        (m+ (meaning-sequence e+ r #f)) )
    (append m (PUSH-HANDLER) m+ (POP-HANDLER)) ) )</p>

<p>(define (PUSH-HANDLER) (list 246))
(define (POP-HANDLER)  (list 247))</pre>

<p>Для обработки случаев возобновления невозобновляемого вводится дополнительная
инструкция:</p>

<pre>(define (NON-CONT-ERR) (list 245))</pre>

<p>Инструкции <code><span class="func">PUSH-HANDLER</span></code> и <code><span class="func">POP-HANDLER</span></code> можно реализовать по-разному,
так что сразу выделим их в отдельные функции:</p>


<!--\indexC{PUSH-HANDLER}-->
<!--\indexC{POP-HANDLER}-->
<pre>(define-instruction (PUSH-HANDLER) 246
  (push-exception-handler) )</p>

<p>(define-instruction (POP-HANDLER) 247
  (pop-exception-handler) )</pre>

<p>Вот теперь примемся за работу. Определить, какой из обработчиков ближе всех
к верхушке стека, не составляет проблем: это типичная задача, решаемая с помощью
динамических переменных. Заодно мы получаем приятный подарок: под стек
обработчиков не потребуется специальный регистр. Вместо этого обработчики можно
расположить в динамической переменной с индексом <code><span class="func">0</span></code>, так как функция
<code><span class="func">get-dynamic-variable-index</span></code> не может выдать этот индекс обычным динамическим
переменным. Хитрость здесь лишь в том, как сделать так, чтобы при выполнении
текущего обработчика возникающие в нём ошибки перенаправлялись предыдущему. Эта
проблема решается связыванием в список значений динамических переменных,
хранимых по индексу <code><span class="func">0</span></code>, что даёт возможность получить доступ к предыдущему
обработчику, не снимая со стека текущий.</p>


<!--\indexC{search-exception-handlers}-->
<!--\indexC{push-exception-handler}-->
<!--\indexC{pop-exception-handler}-->
<pre>(define (search-exception-handlers)
  (find-dynamic-value 0) )</p>

<p>(define (push-exception-handler)
  (let ((handlers (search-exception-handlers)))
    (push-dynamic-binding 0 (cons *val* handlers)) ) )</p>

<p>(define (pop-exception-handler)
  (pop-dynamic-binding) )</pre>

<p>Если вычисления проходят гладко, то находящиеся в стеке обработчики
не вмешиваются в работу программы. Но при возникновении исключительной
ситуации вызывается функция <code><span class="func">signal-exception</span></code>, которая является заменой
старой доброй <code><span class="func">wrong</span></code>.</p>


<!--\indexC{signal-exception}-->
<pre>(define (signal-exception continuable? exception)
  (let ((handlers (search-exception-handlers))
        (v* (allocate-activation-frame (+ 2 1))) )
    (set-activation-frame-argument! v* 0 continuable?)
    (set-activation-frame-argument! v* 1 exception)
    (set! *val* v*)
    (stack-push *pc*) (preserve-environment)
    (push-dynamic-binding 0 (if (null? (cdr handlers)) handlers
                                (cdr handlers) ))
    (if continuable?
      (stack-push 2)   ; выполнится <code>(POP-HANDLER)\,(RESTORE-ENV)\,(RETURN)</code>
      (stack-push 0) ) ; выполнится <code>(NON-CONT-ERR)</code>
    (invoke (car handlers) #t) ) )</pre>


<!--\indexR{исключения!дескрипторы}-->
<p>Функция <code><span class="func">signal-exception</span></code> принимает два аргумента: флаг, указывающий,
допускается ли возобновление выполнения после успешного завершения обработчика,
и значение, описывающее исключение. Это значение может быть абсолютно любым:
например, предопределённые исключения представляются списками из
человекочитаемой строки и дополнительных данных. <span class="logo">Common Lisp</span> и <span class="logo">EuLisp</span>
допускают передачу только объектов специальных классов.</p>

<p>Обработка исключения происходит так. Сначала из динамического окружения
достаётся список активных обработчиков, затем вручную формируется запись
активации, которая будет передана первому из них. После этого специальным
образом подготавливается стек, так как обработчику для правильной работы
необходимо передать некоторую информацию, которой не место в записи активации.
А именно, в стек заталкиваются текущее состояние счётчика команд и окружение (на
случай, если придётся возвращаться). Далее, текущий обработчик исключений хитрым
образом заменяется предыдущим: в динамической переменной сохраняется урезанный
список активных обработчиков, что позволяет элегантно организовать передачу
обязанностей предыдущего обработчика следующему. Так как в этом списке всегда
должен оставаться как минимум один обработчик, то последний из них никогда
не отбрасывается. Естественно, этот терминальный обработчик сам не должен
вызывать исключений; и это действительно так, потому что он лишь сообщает
об ошибке и завершает исполнение программы — тут нечему ломаться.</p>


<!--\indexR{исключения!возобновление!реализация}-->
<p>Итак, как же реализуется возможность возобновления управления после завершения
обработки? Существует простое решение, но оно требует наличия в памяти
определённых инструкций, расположенных по строго определённым абсолютным
адресам. Мы уже расположили <code><span class="func">FINISH</span></code> именно таким образом в прологе,
почему бы не добавить туда ещё немного кода?</p>


<!--\indexC{code-prologue}-->
<p>{\def\/{<code><span class="func">\,\,</span></code>}% строка очень некрасиво вылазила в конце страницы :(
\begin{code:lisp}
(define (code-prologue)
  (set! finish-pc 1)
  (append|\/|(NON-CONT-ERR)|\:|(FINISH)|\:|(POP-HANDLER)|\:|(RESTORE-ENV)|\:|(RETURN))|\/|)
\end{code:lisp}}</p>

<p>Теперь проблема возврата решается просто: перед вызовом обработчика достаточно
положить в стек необходимый адрес возврата. Таким образом, <code><span class="func">RETURN</span></code>,
выполненная функцией-обработчиком, перейдёт в ту или иную ветку. Адрес <code><span class="func">0</span></code>
приводит к исполнению инструкции <code><span class="func">NON-CONT-ERR</span></code>, вызывающей новое исключение;
адрес <code><span class="func">2</span></code> приводит к очистке стека от информации об исключении, которую
<code><span class="func">signal-exception</span></code> туда положила, восстановлению сохранённого ранее окружения
и возврату управления назад в то место, где произошла ошибка.</p>


<!--\indexC{NON-CONT-ERR}-->
<pre>(define-instruction (NON-CONT-ERR) 245
  (signal-exception #f (list "Non continuable exception continued")) )</pre>

<p>Вот и всё, осталось только показать, как запускать виртуальную машину с учётом
данных нововведений. Функция <code><span class="func">run-machine</span></code> теперь должна корректным образом
устанавливать терминальный обработчик исключений. Его можно реализовать,
например, так, чтобы он выводил состояние машины и останавливал её. Без
лишних слов:</p>


<!--\indexC{run-machine}-->
<!--\indexC{base-error-handler}-->
<pre>(define (run-machine stack-size pc code constants global-names dynamics)
  (define base-error-handler-primitive
    (make-primitive base-error-handler) )
  (set! sg.current (make-vector (length global-names) undefined-value))
  (set! sg.current.names global-names)
  (set! *constants*         constants)
  (set! *dynamic-variables* dynamics)
  (set! *code*              code)
  (set! *env*               sr.init)
  (set! *stack*             (make-vector stack-size))
  (set! *stack-index*       0)
  (set! *val*               'anything)
  (set! *fun*               'anything)
  (set! *arg1*              'anything)
  (set! *arg2*              'anything)
  (push-dynamic-binding 0 (list base-error-handler-primitive))
  (stack-push finish-pc)
  (set! *pc* pc)
  (call/cc (lambda (exit)
             (set! *exit* exit)
             (run) )) )</p>

<p>(define (base-error-handler)
  (show-registers "Panic error! Contents of registers:")
  (wrong "Abort") )</pre>

<p>Функция <code><span class="func">signal-exception</span></code> легко превращается в доступный пользователям языка
примитив, что позволяет использовать её (вместе с <code><span class="func">monitor</span></code>) подобно
<code><span class="func">cerror</span></code>\slash<code><span class="func">error</span></code> в <span class="logo">Common Lisp</span> и <span class="logo">EuLisp</span> для обработки
пользовательских исключений. Однако, ввиду относительно высокой стоимости
вызова, стоит ограничить применения данного механизма действительно
<em>исключительными</em> ситуациями.</p>

<div class="bigskip"/>

<p>В этом разделе была определена система обработки исключений. Рассмотренная
модель позволяет вернуться из обработчика обратно и попробовать выполнить
вычисления ещё раз. Также обработчик вызывается в том же динамическом окружении,
где произошло исключение, что даёт больше возможностей для определения причин
возникшей аномалии. Например, с помощью данной системы мы можем написать
следующую весьма нестандартную версию факториала:</p>


<!--\indexC{fact}-->
<pre>(monitor (lambda (c e) ((dynamic foo) 1))
  (let fact ((n 5))
    (if (= n 0) (/ 11 0)
        (* n (bind-exit (k)
               (dynamic-let (foo k)
                 (fact (- n 1)) ) )) ) ) )</pre>

<p>Не следует вызывать переходы из ошибочного контекста в попытке быстро исправить
ситуацию. Лучше сообщить об ошибке с помощью исключения и иметь в результате
больше доступной информации о проблеме.</p>


<!--\indexR{инструкции!и исключения}-->
<!--\indexR{исключения!и атомарность инструкций}-->
<p>В силу того, что наша виртуальная машина — это лишь интерпретатор байт-кодов,
система обработки исключений получилась относительно простой. Дело в том, что
у нас ошибки могут возникнуть только в процессе исполнения какой-либо
инструкции, а сами инструкции являются независимыми друг от друга. По крайней
мере, состояние машины чётко определено в промежутках времени между исполнением
инструкций. Для реальной машины это отнюдь не так и существует множество
возможностей оставить её в неопределённом состоянии, например, какое-нибудь
неожиданно полученное асинхронное прерывание.</p>


<!--\indexR{исключения!возобновление!и системные ошибки}-->
<p>У вас может возникнуть вопрос, почему некоторые предопределённые исключения
являются возобновляемыми, а другие нет. Как уже было сказано, виртуальная машина
работает с завидной аккуратностью, так что возобновить исполнение программы
принципиально возможно после любого исключения, так как у нас всегда будет на
руках точное значение счётчика команд. И снова, всё гораздо усложняется
в реальности, где процессоры могут переупорядочивать исполняемые инструкции, а
какое-нибудь деление на ноль, например, может быть обработано только постфактум.
Безопаснее всего предполагать, что только для пользовательских исключений можно
обеспечить переносимую и корректную логику работы после возобновления исполнения
прерванного кода. Маловероятно, что программа сможет исправить ошибку, возникшую
в самой системе.</p>

<p>Кстати, с этим связан ещё один интересный момент. Вспомните, что все ошибки
предобработки теперь вызывают <code><span class="func">signal-exception</span></code>, иногда даже допуская
возобновление. И в этом действительно есть определённый смысл: компилятор,
используя специальный обработчик исключений, получает возможность самостоятельно
исправлять некоторые недосмотры предобработки на лету.</p>

<h2 id="compilation/sect:separate">Раздельная компиляция</h2>


<!--\indexR{компиляция!раздельная}-->
<p>Программы на языках вроде Си и Паскаля обычно компилируются и сохраняются
в файлах. Лисп ничем не хуже, так что в этом разделе мы создадим подобный
компилятор, а также компоновщик, собирающий отдельные кусочки кода воедино,
и загрузчик, запускающий полученные программы.</p>

<h3 id="compilation/separate/ssect:files">Компилируем файлы</h3>

<p>Откомпилировать программу, хранящуюся в файле, проще простого. Этим занимается
функция <code><span class="func">compile-file</span></code>, показанная ниже. Сначала она инициализирует списки
глобальных переменных <code><span class="func">g.current</span></code> и цитат <code><span class="func">*quotations*</span></code>, а также список
<code><span class="func">*dynamic-variables*</span></code>. Затем выражения, считанные из файла, компилируются
так, как будто бы все они находятся в огромной форме <code><span class="func">begin</span></code>, а
результат компиляции записывается в другой файл вместе со значениями трёх
вышеупомянутых переменных.</p>


<!--\indexC{read-file}-->
<!--\indexC{compile-file}-->
<!--\indexC{write-result-file}-->
<pre>(define (read-file filename)
  (call-with-input-file filename
    (lambda (in)
      (let gather ((e (read in)) (content '()))
        (if (eof-object? e)
            (reverse content)
            (gather (read in) (cons e content)) ) ) ) ) )</p>

<p>(define (compile-file filename)
  (set! g.current '())
  (set! *quotations* '())
  (set! *dynamic-variables* '())
  (let* ((complete-filename (string-append filename ".scm"))
         (e                 `(begin . ,(read-file complete-filename)))
         (code              (make-code-segment (meaning e r.init #t)))
         (global-names      (map car (reverse g.current)))
         (constants         (apply vector *quotations*))
         (dynamics          *dynamic-variables*)
         (ofilename         (string-append filename ".so")) )
    (write-result-file ofilename
                       (list ";;; Bytecode object file for "
                             complete-filename )
                       dynamics global-names constants code
                       (length (code-prologue)) ) ) )</p>

<p>(define (write-result-file ofilename comments dynamics
                           global-names constants code entry )
  (call-with-output-file ofilename
    (lambda (out)
      (for-each (lambda (comment) (display comment out))
                comments ) (newline out) (newline out)

      (display ";;; Dynamic variables" out) (newline out)
      (write dynamics out) (newline out) (newline out)

      (display ";;; Global modifiable variables" out) (newline out)
      (write global-names out) (newline out) (newline out)

      (display ";;; Quotations" out) (newline out)
      (write constants out) (newline out) (newline out)

      (display ";;; Bytecode" out) (newline out)
      (write code out) (newline out) (newline out)

      (display ";;; Entry point" out) (newline out)
      (write entry out) (newline out) ) ) )</pre>


<!--\indexC{*.scm}-->
<!--\indexC{*.so}-->
<!--\indexR{объектные файлы}-->
<p>Дабы не завязнуть в трясине различий файловых систем и способов записи путей,
предполагается, что имена файлов записываются простыми строками. Компилятор
понимает переданную ему строку как полное название файла. (Под названием
подразумевается часть имени без обычного расширения <code><span class="func">.scm</span></code>.) Программа
читается из <code><span class="func">*.scm</span></code>-файла, а результат компиляции сохраняется
в <code><span class="func">*.so</span></code>-файл. Этот результат состоит из байт-кода, списка глобальных
изменяемых переменных, списка динамических переменных, вектора цитат и точки
входа — начального значения счётчика команд. Всё это записывается в файл без
особых изысков с помощью стандартной функции <code><span class="func">write</span></code>. Также там оставляется
немного комментариев, чтобы облегчить чтение результата человеком.</p>

<p>Итого, компиляция такого исходного файла:</p>


<!--\indexC{fact}-->
<p>\begin{code:lisp-framed}[title={\snippet{si/example.scm}}]
(set! fact
      ((lambda (fact) (lambda (n)
                        (if (< n 0)
                            "Toctoc la tete!"
                            (fact n fact (lambda (x) x)) ) ))
       (lambda (n f k)
         (if (= n 0)
             (k 1)
             (f (- n 1) f (lambda (r) (k (* n r)))) ) ) ) )
\end{code:lisp-framed}\medskip</p>

<p>\noindent
создаёт следующий объектный файл:</p>

<p>\begin{code:lisp-framed}[title={\snippet{si/example.so}}]
;;; Bytecode object file for si/example.scm</p>

<p>;;; Dynamic variables
()</p>

<p>;;; Global modifiable variables
(FACT)</p>

<p>;;; Quotations
#("Toctoc la tete!")</p>

<p>;;; Bytecode
#(245 20 247 38 43 40 30 59 74 32 1 34 81 35 106 31 10 3 34 82 34 51
  60 39 46 30 39 2 34 1 34 82 35 105 34 2 34 40 30 19 72 32 6 1 2 34
  6 1 0 34 1 35 109 34 51 60 39 46 43 34 53 62 61 60 39 46 43 34 51
  60 32 40 30 38 72 32 1 34 81 35 107 31 4 9 0 30 24 6 1 0 34 1 34 6
  1 0 34 40 30 4 72 32 1 43 34 53 62 61 60 39 46 43 33 27 0 43)</p>

<p>;;; Entry point
5
\end{code:lisp-framed}</p>

<h3 id="compilation/separate/ssect:build">Собираем приложение</h3>


<!--\indexC{ld}-->
<!--\indexR{компоновка}-->
<!--\indexR{линкер}-->
<!--\indexR{линкер|see{компоновка}}-->
<p>Возможность компилировать отдельные файлы — это, конечно, здорово, но неплохо
было бы запускать всё приложение целиком! Вторая утилита, которую мы создадим,
соответствует тому, что называется <em class="term">компоновщиком</em> (линкером, <code><span class="func">ld</span></code>
в \UNIX). Её задачей является связывание нескольких отдельных объектных файлов
в единый исполнимый файл. Функция <code><span class="func">build-application</span></code> принимает имя
результирующего исполнимого файла, а затем имена компонуемых объектных файлов.</p>


<!--\indexC{build-application}-->
<pre>(define (build-application application-name ofilename . ofilenames)
  (set! sg.current.names    '())
  (set! *dynamic-variables* '())
  (set! sg.current          (vector))
  (set! *constants*         (vector))
  (set! *code*              (vector))
  (let install ((filenames (cons ofilename ofilenames))
                (entry-points '()) )
    (if (pair? filenames)
        (let ((ep (install-object-file! (car filenames))))
          (install (cdr filenames) (cons ep entry-points)) )
        (write-result-file application-name
                           (cons ";;; Bytecode application containing "
                                 (cons ofilename ofilenames) )
                           *dynamic-variables*
                           sg.current.names
                           *constants*
                           *code*
                           entry-points ) ) ) )</pre>


<!--\indexR{исполнимый файл}-->
<p>Большая часть работы поручается функции <code><span class="func">install-object-file!</span></code>, которая
формирует пять переменных, необходимых для обеспечения корректной работы машины:</p>

<p>\begin{itemize}
  \item <code><span class="func">sg.current.names</span></code> — имена изменяемых глобальных переменных;</p>

<p>  \item <code><span class="func">*dynamic-variables*</span></code> — имена динамических переменных;</p>

<p>  \item <code><span class="func">sg.current</span></code> — значения изменяемых глобальных переменных;</p>

<p>  \item <code><span class="func">*constants*</span></code> — значения цитат;</p>

<p>  \item <code><span class="func">*code*</span></code> — вектор байт-кодов.
\end{itemize}</p>

<p>\noindent
После сборки всех объектных файлов остаётся только создать записать результат
в исполнимый файл. Его формат совпадает с форматом объектных файлов во всём,
кроме точки входа: теперь это будет список точек входа.</p>

<p>Функция <code><span class="func">install-object-file!</span></code> добавляет один скомпилированный файл
в приложение и возвращает адрес его первой инструкции в едином векторе
байт-кодов. Дописать немного кода в вектор <code><span class="func">*code*</span></code> просто. Гораздо сложнее
защитить то, что является личной собственностью отдельных файлов, и разделить
между всеми файлами то, что должно быть общим. В следующем коде эту нелёгкую
работу выполняют функции, начинающиеся на <code><span class="func">relocate</span></code>.</p>

<p>\ForLayout{display}{\begingroup\lstset{belowskip=\smallskipamount}}</p>


<!--\indexC{install-object-file"!}-->
<!--\indexC{install-code"!}-->
<pre>(define (install-object-file! filename)
  (let ((ofilename (string-append filename ".so")))
    (if (probe-file ofilename)
        (call-with-input-file ofilename
          (lambda (in)
            (let* ((dynamics     (read in))
                   (global-names (read in))
                   (constants    (read in))
                   (code         (read in))
                   (entry        (read in)) )
              (close-input-port in)
              (relocate-globals! code global-names)
              (relocate-constants! code constants)
              (relocate-dynamics! code dynamics)
              (+ entry (install-code! code)) ) ) )
        (signal-exception #f
          (list "No such file" ofilename) ) ) ) )</p>

<p>(define (install-code! code)
  (let ((start (vector-length *code*)))
    (set! *code* (vector-append *code* code))
    start ) )</pre>

<p>\ForLayout{display}{\begingroup\lstset{aboveskip=\smallskipamount}}</p>


<!--\indexR{компоновка!цитат}-->
<p>Цитаты, например, у каждого файла свои собственные, они не должны совпадать даже
физически. Но в каждом файле они заново нумеруются с нуля, что обязательно
приведёт к коллизиям, если ничего не предпринять. Общий учёт используемых цитат
ведётся в переменной <code><span class="func">*constants*</span></code>, но новые цитаты добавляются туда
не сразу, а после аккуратного обновления их номеров, являющихся адресами
соответствующих значений в общем векторе. Номер цитаты, как вы помните,
располагается сразу же за кодом инструкции <code><span class="func">CONSTANT</span></code>. Следующая функция
пробегает по всему вектору байт-кодов, отыскивает все нужные инструкции и
заменяет старые адреса новыми:</p>


<!--\indexC{relocate-constants"!}-->
<pre>(define CONSTANT-code 9)</p>

<p>(define (relocate-constants! code constants)
  (define n (vector-length *constants*))
  (let ((code-size (vector-length code)))
    (let scan ((pc 0))
      (when (< pc code-size)
        (let ((instr (vector-ref code pc)))
          (when (= instr CONSTANT-code)
            (let* ((i (vector-ref code (+ pc 1)))
                   (quotation (vector-ref constants i)) )
              (vector-set! code (+ pc 1) (+ n i)) ) )
          (scan (+ pc (instruction-size code pc))) ) ) ) )
  (set! *constants* (vector-append *constants* constants)) )</pre>


<!--\indexR{компоновка!глобальных переменных}-->
<p>Глобальные переменные, напротив, должны разделяться. Два файла, использующих
<code><span class="func">foo</span></code>, должны обращаться к одной и той же переменной <code><span class="func">foo</span></code>. Эти переменные
нумеруются в каждом файле независимо, поэтому при компоновке необходимо
согласовать их адреса. Эти адреса представляются числами, следующими за
инструкциями <code><span class="func">GLOBAL-REF</span></code>, <code><span class="func">CHECKED-GLOBAL-REF</span></code> и <code><span class="func">SET-GLOBAL!</span></code>. Каждое
найденное число соответствует имени переменной; этому же имени соответствует
другое число — адрес переменной в собираемой программе. Остаётся только
заменить везде первое вторым.</p>


<!--\indexC{relocate-globals"!}-->
<pre>(define GLOBAL-REF-code         7)
(define CHECKED-GLOBAL-REF-code 8)
(define SET-GLOBAL!-code       27)</p>

<p>(define (relocate-globals! code global-names)
  (define (get-index name)
    (let ((where (memq name sg.current.names)))
      (if where (- (length where) 1)
          (begin (set! sg.current.names (cons name sg.current.names))
                 (get-index name) ) ) ) )
  (let ((code-size (vector-length code)))
    (let scan ((pc 0))
      (when (< pc code-size)
        (let ((instr (vector-ref code pc)))
          (when (or (= instr GLOBAL-REF-code)
                    (= instr CHECKED-GLOBAL-REF-code)
                    (= instr SET-GLOBAL!-code) )
            (let* ((i (vector-ref code (+ pc 1)))
                   (name (list-ref global-names i)) )
              (vector-set! code (+ pc 1) (get-index name)) ) )
          (scan (+ pc (instruction-size code pc))) ) ) ) )
  (let ((v (make-vector (length sg.current.names) undefined-value)))
    (vector-copy! sg.current v 0 (vector-length sg.current))
    (set! sg.current v) ) )</pre>

<p>\ForLayout{display}{\endgroup\endgroup}% \lstset</p>


<!--\indexR{компоновка!динамических переменных}-->
<p>Аналогично поступаем с динамическими переменными:</p>


<!--\indexC{relocate-dynamics"!}-->
<pre>(define DYNAMIC-REF-code 240)
(define DYNAMIC-PUSH-code 242)</p>

<p>(define (relocate-dynamics! code dynamics)
  (for-each get-dynamic-variable-index dynamics)
  (let ((dynamics (reverse dynamics))
        (code size (vector-length code)) )
    (let scan ((pc 0))
      (when (< pc code-size)
        (let ((instr (vector-ref code pc)))
          (when (or (= instr DYNAMIC-REF-code)
                    (= instr DYNAMIC-PUSH-code) )
            (let* ((i (vector-ref code (+ pc 1)))
                   (name (list-ref dynamics (- i 1))) )
              (vector-set! code (+ pc 1)
                           (get-dynamic-variable-index name) ) ) )
          (scan (+ pc (instruction-size code pc))) ) ) ) ) )</pre>

<p>Обратите внимание на то, как и почему здесь используется
<code><span class="func">instruction-size</span></code>. Также стоит отметить, что глупо просматривать вектор
кода три раза подряд, вполне можно выполнить всю работу и за один проход.</p>

<p>\phantomlabel{compilation/separate/build/par:linker-dsl}
<!--\indexR{компиляция!модулей}-->
<!--\indexR{язык!описания модулей}-->
<!--\indexR{модули}-->
Выбранный формат представления скомпилированных программ позволяет множество
вариаций. Например, можно понимать список глобальных изменяемых переменных как
интерфейс к модулю, которым является файл. Такой модуль экспортирует все свои
глобальные переменные для внешнего использования под теми именами, которые они
имеют внутри данного модуля. Однако, нехорошо выставлять напоказ всё подряд,
так что вдобавок к этому можно, например, разрешить экспортировать не все
переменные или же дать возможность переименовывать их при экспорте. Можно даже
представить себе специализированный язык для описания способов сборки модулей,
управления именованием переменных и т. д. Поясним эту идею на примере языка,
предлагаемого в <span class="cite">[<a href="z1_bibliography.xhtml#qp91a">qp91a</a>]</span> для <span class="logo">EuLisp</span>. Следующая директива описывает
экспортируемые переменные модуля <code><span class="func">mod</span></code>:</p>

<pre>(ordered-union
  (only (fact) (expose "fact"))
  (union (except-pattern ("fib*") (expose "fib"))
         (rename ((call/cc call-with-current-continuation))
           (expose "scheme") )
         (expose "numeric") ) )</pre>

<p>Предположим, запись <code><span class="func">foo@mod</span></code> означает переменную с именем <code><span class="func">foo</span></code> в модуле
<code><span class="func">mod</span></code>. Также допустим, что модуль <code><span class="func">fact</span></code> определяет переменные <code><span class="func">fact</span></code> и
<code><span class="func">fact100</span></code> (последняя содержит значение <code>(fact 100)</code>, которое очень часто
бывает необходимым); модуль <code><span class="func">fib</span></code> определяет переменные <code><span class="func">fib</span></code>, <code><span class="func">fib20</span></code>
и <code><span class="func">Fibonacci</span></code>. Модуль <code><span class="func">numeric</span></code> среди множества определяемых им функций
содержит также <code><span class="func">fact</span></code> и <code><span class="func">fib</span></code>, а модуль <code><span class="func">scheme</span></code> определяет все
стандартные функции \RnRS. Тогда создаваемый данной директивой модуль состоит из
следующих частей: переменной <code><span class="func">fact@fact</span></code> (а переменная <code><span class="func">fact100@fact</span></code>,
экспортируемая директивой <code>(expose "fact")</code>, отбрасывается директивой
<code><span class="func">only</span></code>); переменной <code><span class="func">Fibonacci@fib</span></code> (все остальные фильтруются по шаблону
с помощью <code><span class="func">except-pattern</span></code>). Экспортируемая переменная
<code><span class="func">call-with-current-continuation@scheme</span></code> становится просто
<code><span class="func">call/cc@scheme</span></code>. Так как объединение, определяющее <code><span class="func">mod</span></code>, объявлено
как упорядоченное (\english{ordered union}), то модуль <code><span class="func">fact</span></code> загружается
перед остальными (<code><span class="func">fib</span></code>, <code><span class="func">numeric</span></code> и <code><span class="func">scheme</span></code>), порядок обработки
которых не указывается, но должен соответствовать их определениям. Например,
модуль <code><span class="func">numeric</span></code> наверняка использует возможности <code><span class="func">scheme</span></code>, поэтому его
следует обрабатывать одним из последних.</p>

<h3 id="compilation/separate/ssect:execute">Запускаем приложение</h3>


<!--\indexR{загрузчик}-->
<p>Исполнимый файл создаётся, конечно же, для того, чтобы его исполняли. Благо,
все сложности уже позади и написать загрузчик не составляет труда. Нужна только
внимательность, чтобы не забыть проинициализировать какой-нибудь регистр.</p>


<!--\indexC{run-application}-->
<pre>(define (run-application stack-size filename)
  (if (probe-file filename)
      (call-with-input-file filename
        (lambda (in)
          (let* ((dynamics     (read in))
                 (global-names (read in))
                 (constants    (read in))
                 (code         (read in))
                 (entry-points (read in)) )
            (close-input-port in)
            (set! sg.current.names    global-names)
            (set! *dynamic-variables* dynamics)
            (set! sg.current (make-vector (length sg.current.names)
                                          undefined-value ))
            (set! *constants*         constants)
            (set! *code*              (vector))
            (install-code! code)
            (set! *env*               sr.init)
            (set! *stack*             (make-vector stack-size))
            (set! *stack-index*       0)
            (set! *val*               'anything)
            (set! *fun*               'anything)
            (set! *arg1*              'anything)
            (set! *arg2*              'anything)
            (push-dynamic-binding
             0 (list (make-primitive (lambda ()
                                       (show-exception)
                                       (*exit* 'aborted) ))) )
            (stack-push 1)
            (if (pair? entry-points)
                (for-each stack-push entry-points)
                (stack-push entry-points) ) )
          (set! *pc* (stack-pop))
          (call/cc (lambda (exit)
                     (set! *exit* exit)
                     (run) )) ) )
      (static-wrong "No such file" filename) ) )</pre>


<!--\indexC{show-exception}-->
<!--\indexR{дескрипторы!исключений}-->
<p>Прежде всего, конечно же, необходимо прочитать файл с загружаемой программой.
Входной порт закрывается сразу же, как становится ненужным. Далее, подобно
<code><span class="func">run-machine</span></code>, инициализируются переменные состояния машины. После
установки терминального обработчика исключений в стек заталкиваются точки входа
всех объектных файлов, составляющих приложение. Такой подход позволяет запускать
единичный объектный файл аналогично цельному приложению. Стандартный обработчик
исключений останавливает исполнение программы при возникновении исключительной
ситуации; для этого захватывается продолжение функции <code><span class="func">run-application</span></code> и
сохраняется в переменной <code><span class="func">*exit*</span></code>. Функция <code><span class="func">show-exception</span></code> отвечает за
вывод понятных и выразительных\footnote{Вроде <code><span class="func">"Bus error: core not
dumped"</span></code>.} сообщений об ошибках на основе дескриптора исключения, находящегося
в тот момент в регистре <code><span class="func">*val*</span></code>. Остаётся только не забыть об инструкции
<code><span class="func">RETURN</span></code> в конце каждого объектного файла, которая обеспечивает передачу
управления следующему файлу в цепочке.</p>


<!--\indexR{стек!обработка переполнения}-->
<p>Функция <code><span class="func">run-application</span></code> принимает максимальный размер стека как аргумент.
Это отдельная и весьма важная проблема реализации: не допустить переполнения
стека. Было бы слишком дорого выполнять проверку границ при каждом вызове
<code><span class="func">stack-push</span></code>. Иногда возможно использовать механизм страничной виртуальной
памяти, предоставляемый операционной системой, чтобы избавиться от проверок и
увеличивать размер стека при необходимости на лету. Наша эмуляция памяти
вряд ли является эффективной, так как о стоимости выражения \ic{(vector-ref
<i>v</i> <i>i</i>)} нельзя сказать ничего определённого; здесь наверняка каждый раз
будет выполняться проверка, что <i>v</i> это действительно вектор, а
<i>i</i> является неотрицательным целым числом, меньшим, чем длина вектора <i>v</i>.</p>

<p>Функция <code><span class="func">run-application</span></code> требует весьма немного приспособлений для
исполнения скомпилированных приложений. Ей нужен всего лишь интерпретатор
байт-кодов (<code><span class="func">run</span></code>), а также функции для работы с векторами, списками и
другими классами вроде <code><span class="func">primitive</span></code> и <code><span class="func">continuation</span></code>. Ещё потребуется
функция <code><span class="func">read</span></code> для чтения файлов. Всё это слабо зависит от конкретного
компилятора, создающего объектные файлы (что, правда, не особо помогает при
отладке), а ведь именно подобное отделение языка от исполнимых программ и есть
целью компиляции!</p>

<h2 id="compilation/sect:conclusions">Заключение</h2>

<p>До полной реализации Scheme нашему компилятору не хватает множества функций
стандартной библиотеки, а также поддержки оставшихся типов данных. С этим
не должно возникнуть каких-либо принципиальных проблем, кроме разве что
сложностей с реализацией проверки типов и допустимости значений.</p>


<!--\indexR{интерпретация!связь с компиляцией}-->
<!--\indexR{компиляция!связь с интерпретацией}-->
<p>Описанная реализация является довольно простой, но достигается эта простота
игнорированием огромного числа всевозможных оптимизаций. Однако, основной упор
в ней делается на том, чтобы использовать предыдущие наработки —
оптимизированный интерпретатор, уже частично превращённый в компилятор.
Действительно, существует глубокая связь между интерпретацией и компиляцией
(рассмотренная подробнее в <span class="cite">[<a href="z1_bibliography.xhtml#nei84">nei84</a>]</span>). Интерпретатор непосредственно
исполняет программу, тогда как компилятор превращает программу в нечто, что
будет исполнено потом. Следовательно, они отличаются лишь способом трактовки
инструкций языка: исполнять ли соответствующие действия или генерировать
соответствующий код. Мы воспользовались данной связью, чтобы легко превратить
имеющийся интерпретатор в компилятор.</p>


<!--\indexR{промежуточное представление!недостатки}-->
<!--\indexR{записи активации}-->
<!--\indexR{стек}-->
<p>Основной недостаток такого подхода в том, что здесь используется лишь
информация, сохранённая в промежуточном языке, а её явно недостаточно для
качественной компиляции. Мы ничего не знаем, к примеру, об используемых
локальных переменных; несомненно, это один из главных источников информации,
необходимой для проведения различных оптимизаций. Мы не знаем, изменяются ли
значения переменных, захватываются ли они замыканиями, захватываются ли
несколькими или только одним, изменяются ли захваченные копии и т. д. Во многих
случаях подобные статические сведения о переменных позволяют избавиться от
записей активаций и пользоваться одним только стеком — а это, очевидно,
положительно сказывается на скорости работы. Записи активаций действительно
полезны лишь для сохранения значений переменных, захваченных замыканиями;
комбинаторы вполне могут обойтись и без них. Так как значения передаваемых
аргументов уже находятся в стеке, то их можно там и оставить, не создавая при
этом объектов-посредников и экономя таким образом значительное количество
времени.</p>


<h2 id="compilation/sect:exercises">Упражнения</h2>

<h5 class="exercise" id="compilation/ex:dynamic">Упражнение <span class="seq">0.0</span></h5>
<p>Реализуйте поддержку динамических переменных с помощью регистра <code><span class="func">*dynenv*</span></code>
для компилятора и виртуальной машины из этой главы.
\seePage[compilation/sect:dynamic]</p>


<h5 class="exercise" id="compilation/ex:load">Упражнение <span class="seq">0.0</span></h5>
<!--\indexC{load}-->
<p>Определите функцию <code><span class="func">load</span></code>, которая загружает и исполняет скомпилированные
программы. Например, если у нас есть файл <code><span class="func">fact.so</span></code>, полученный из файла
<code><span class="func">fact.scm</span></code>, то следующая программа должна успешно компилироваться и выдавать
ожидаемое число 120:</p>

<pre>(begin (load "fact")
       (fact 5) )
\end{code:lisp}</p>


<h5 class="exercise" id="compilation/ex:global-value">Упражнение <span class="seq">0.0</span></h5>
<p>Реализуйте функцию <code><span class="func">global-value</span></code>, принимающую имя глобальной переменной
и возвращающую её текущее значение.</p>


<h5 class="exercise" id="compilation/ex:shallow-dynamic">Упражнение <span class="seq">0.0</span></h5>
<!--\indexR{ближнее (shallow) связывание}-->
<!--\indexR{связывание!ближнее (shallow)}-->
<p>Переопределите инструкции, отвечающие за работу с динамическими переменными,
реализовав их с помощью ближнего связывания.
\seePage[basics/representing-functions/ssect:deep-or-shallow]</p>


<h5 class="exercise" id="compilation/ex:export-rename">Упражнение <span class="seq">0.0</span></h5>
<p>\seePage[compilation/separate/build/par:linker-dsl]
Напишите функцию, переименовывающую экспортируемые глобальные переменные. Если
<code><span class="func">fact.so</span></code> это объектный файл, то следующая программа должна создать новый
модуль <code><span class="func">nfact.so</span></code>, где переменная <code><span class="func">fact</span></code> имеет имя <code><span class="func">factorial</span></code>:</p>

<pre>(build-application-with-renaming-variables
 "fact.so" "nfact.so" '((fact factorial)) )
\end{code:lisp}</p>


<h5 class="exercise" id="compilation/ex:unchecked-ref">Упражнение <span class="seq">0.0</span></h5>
<p>\seePage[fast/fast/classify/static-err/par:self-modify]
<!--\indexR{мемоизация}-->
Измените инструкцию <code><span class="func">CHECKED-GLOBAL-REF</span></code> так, чтобы после определения
соответствующей переменной она автоматически изменялась на <code><span class="func">GLOBAL-REF</span></code>.</p>

<p>\begin{project}
Многие реализации Лиспа и Scheme имеют компиляторы в байт-код. Возьмём,
например, GNU Emacs Lisp <span class="cite">[<a href="z1_bibliography.xhtml#llst93">llst93</a>]</span> и xscheme <span class="cite">[<a href="z1_bibliography.xhtml#bet91">bet91</a>]</span>. Реализуйте
соответствующие виртуальные машины для них.
\end{project}</p>

<p>
\section*{Рекомендуемая литература}\label{compilation/sect:recommended-reading}</p>

<p>Литературы на тему основ компиляции весьма немного. Собственно, это одна из
причин появления данной книги. Как бы то ни было, вам стоит взглянуть на
<span class="cite">[<a href="z1_bibliography.xhtml#all78">all78</a>]</span> и <span class="cite">[<a href="z1_bibliography.xhtml#hen80">hen80</a>]</span>. Об общих принципах компиляции функциональных языков
неплохо написано в <span class="cite">[<a href="z1_bibliography.xhtml#dil88">dil88</a>]</span>. В следующих книгах тоже есть несколько
интересных компиляторов с комментариями: \cite{ste78,as85,fwh92}.</p>

<p></body>
</html>
