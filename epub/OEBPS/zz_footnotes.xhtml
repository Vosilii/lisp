<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru">

<head>
    <link rel="stylesheet" type="text/css" href="zz_lisp.css"/>
</head>

<body id="chapter:to_the_reader">

<h1>К читателю</h1>

<div class="footnote" id="foot0.tr-1">
  <p><span class="num"><sup>*</sup></span>
    Sophie Anglade, Josy Byron, Kathleen Callaway, Jérôme Chaillox, Jean-Marie
    Geffroy, Christian Jullien, Jean-Jacques Lacrampe, Michel Lemaître, Luc
    Moreau, Jean-François Perrot, Daniel Ribbens, Bernard Serpette, Manuel
    Serrano, Pierre Weis, Claire N. — <em>Прим. перев.</em></p>
</div>

<div class="footnote" id="foot0.1">
  <p><span class="num"><sup>1</sup></span>
    Le_Lisp является торговой маркой INRIA.</p>
</div>

<div class="footnote" id="foot0.tr-2">
<p><span class="num"><sup>**</sup></span>
    Если возможны разночтения, то слово <em class="term">знак</em> будет
    использоваться в смысле «печатный символ» (character), а слово
    <em class="term">символ</em> — в привычном для Лиспа значении
    (symbol). — <em>Прим. перев.</em></p>
</div>

<div  class="footnote" id="foot0.tr-3">
  <p><span class="num"><sup>***</sup></span>
    Кроме того, лично я хотел бы посоветовать замечательную книгу <i>Franklyn Turbak
    and David Gifford with Mark A. Sheldon.</i> Design Concepts in Programming
    Languages. — The MIT Press, 2008. — 1352 p. — <em>Прим. перев.</em></p>
</div>


<h1><span class="seq">Глава 1.</span> Основы интерпретации</h1>

<div class="footnote" id="foot1.1">
  <p><span class="num"><sup>1</sup></span>
    Интерпретатор, описываемый в этой главе, занимает около 150 строк.</p>
</div>

<div class="footnote" id="foot1.2">
  <p><span class="num"><sup>2</sup></span>
    Как вы знаете, «родная» функция-вычислитель Scheme называется <code><span
    class="func">eval</span></code>. Чтобы их
    не путать, нашу функцию мы назовём <code><span class="func">evaluate</span></code>.
    По тем же причинам местный аналог <code><span class="func">apply</span></code>
    будет называться <code><span class="func">invoke</span></code>. Меньше перекрытий имён —
    меньше проблем.</p>
</div>

<div class="footnote" id="foot1.3">
  <p><span class="num"><sup>3</sup></span>
    Лично я не люблю называть функции приведения типов
    <code><span class="func"><i>x</i>-&gt;<i>y</i></span></code>,
    потому что так сложнее понимать цепочки преобразований. Запись
    <code>(<span class="func"><i>y</i>-&gt;<i>z</i></span>(<span class="func"><i>x</i>-&gt;<i>y</i></span> ...))}</code> не так очевидна, как <code>(<span class="func"><i>z</i>&lt;-<i>y</i></span>(<span class="func"><i>y</i>&lt;-<i>x</i></span> ...))</code>.
    Хотя, с другой стороны, одиночная запись <code><span class="func"><i>z</i>&lt;-<i>y</i></span></code> не так легко читается, как <code><span class="func"><i>y</i>-&gt;<i>z</i></span></code>.
    Приходится выбирать.</p>
</div>

<div class="footnote" id="foot1.4">
  <p><span class="num"><sup>4</sup></span>
    Заметьте, не «функцию <code><span class="func">wrong</span></code>». Варианты её
    реализации подробнее рассматриваются в разделе <a href="ch07_compilation.xhtml#compilation/sect:exception">7.9</a>.</p>
</div>

<div class="footnote" id="foot1.5">
  <p><span class="num"><sup>5</sup></span>
    <code><span class="special">if</span></code> не обязательно принимает условие и ровно две
    альтернативы. К примеру, в Scheme и <span class="logo">Common Lisp</span> <code><span
    class="special">if</span></code> может принимать как
    два, так и три аргумента; <code><span class="special">if</span></code> в
    <span class="logo">EuLisp</span> и <span class="logo">ISLisp</span> исключительно
    тернарный; Le_Lisp в случае, если условие ложно, вычисляет остаток
    формы <code><span class="special">if</span></code>, обернув его в
    <code><span class="special">begin</span></code>.</p>
</div>

<div class="footnote" id="foot1.6">
  <p><span class="num"><sup>6</sup></span>
    Напомним: в Scheme запись <code>#(...)</code> означает процитированный вектор.</p>
</div>

<div class="footnote" id="foot1.7">
  <p><span class="num"><sup>7</sup></span>
    Переменная <i>void</i> не должна быть свободной
    в <span class="math"><span class="var">β</span></span>. Это условие выполняется, если <i>void</i> никогда не встречается
    в <span class="math"><span class="var">β</span></span>. Обычно в таком случае используется
    <code><span class="func">gensym</span></code>, чтобы получить
    гарантированно уникальное имя переменной.
    <span class="see">[см. упр. <a href="ch01_basics.xhtml#basics/ex:no-gensym">1.11</a>]</span></p>
</div>

<div class="footnote" id="foot1.8">
  <p><span class="num"><sup>8</sup></span>
    В соответствии с принятым в Scheme соглашением, имена функций с побочными эффектами
    оканчиваются на восклицательный знак.</p>
</div>

<div class="footnote" id="foot1.9">
  <p><span class="num"><sup>9</sup></span>
    Как известно, <code><span class="syntax">let</span></code> —
    это всего лишь простой макрос: <code>(<span class="syntax">let</span>
    ((<span class="math"><span class="var">x</span></span>
    <span class="math"><span class="var">π</span><sub>1</sub></span>))
    <span class="math"><span class="var">π</span><sub>2</sub></span>)
    <span class="math"><span class="binop">≡</span></span>
    ((<span class="special">lambda</span> (<span class="math"><span class="var">x</span></span>)
    <span class="math"><span class="var">π</span><sub>2</sub></span>)
    <span class="math"><span class="var">π</span><sub>1</sub></span>)</code>.</p>
</div>

<div class="footnote" id="foot1.10">
  <p><span class="num"><sup>10</sup></span>
    Первый — это синтаксические ошибки (раздел <a href="ch01_basics.xhtml#basic/atoms/para:the-first-error">1.3</a>).</p>
</div>

<div class="footnote" id="foot1.11">
  <p><span class="num"><sup>11</sup></span>
    Память (вместе с подсистемами ввода-вывода) всё ещё остаётся одной из наиболее дорогих
    частей компьютера, хоть и постоянно дешевеет.</p>
</div>

<div class="footnote" id="foot1.12">
  <p><span class="num"><sup>12</sup></span>
    Некоторые лисп-системы, вроде <span class="logo">Common Lisp</span>, поддались соблазну
    расширить синтаксис перечня аргументов ключевыми словами вроде
    <code><span class="syntax">&amp;aux</span></code>,
    <code><span class="syntax">&amp;key</span></code>,
    <code><span class="syntax">&amp;rest</span></code>. Но это сильно усложняет синтаксический
    разбор и связывание. Иные системы позволяют даже обобщённое указание аргументов с помощью
    шаблонов <span class="cite">[<a href="z1_bibliography.xhtml#sj93">SJ93</a>]</span>.</p>
</div>

<div class="footnote" id="foot1.13">
  <p><span class="num"><sup>13</sup></span>
    Функция могла бы потом ещё проверять на правильность типы переданных аргументов, но это
    не имеет отношения к механизму вызова.</p>
</div>

<div class="footnote" id="foot1.14">
  <p><span class="num"><sup>14</sup></span>
    На самом деле, здесь можно использовать любое необходимое
    окружение. См. про форму <code><span class="special">closure</span></code> в разделе
    <a href="ch04_assignment_and_side_effects.xhtml#assignement/assignement/para:closure">4.1</a>.</p>
</div>

<div class="footnote" id="foot1.15">
  <p><span class="num"><sup>15</sup></span>
    В объектно-ориентированных языках под динамическим
    связыванием обычно понимается механизм выбора метода объекта на основе его
    реального типа во время исполнения программы, в противоположность статическому
    связыванию, при котором метод выбирается компилятором исходя из типа переменной,
    которая хранит рассматриваемый объект.</p>
</div>

<div  class="footnote" id="foot1.tr-1">
  <p><span class="num"><sup>*</sup></span>
    Начиная с Emacs Lisp v.\,24 и Perl 5, эти языки имеют и лексические переменные.</p>
</div>

<div class="footnote" id="foot1.16">
  <p><span class="num"><sup>16</sup></span>
    О происхождении <em>foo</em> см. <span class="cite">[<a href="z1_bibliography.xhtml#ray91">Ray91</a>]</span>.</p>
</div>

<div class="footnote" id="foot1.17">
  <p><span class="num"><sup>17</sup></span>
    Наша имитация не совсем точна, так как существует немало диалектов Лиспа (вроде CLtL1
    <span class="cite">[<a href="z1_bibliography.xhtml#ste84">Ste84</a>]</span>), где
    <code><span class="special">lambda</span></code> — это не специальный оператор, а только ключевое слово-маркер
    вроде <code><span class="syntax">else</span></code> внутри <code><span class="syntax">cond</span></code> и <code><span class="syntax">case</span></code>. В этом случае <code><span class="func">d.evaluate</span></code>
    может вообще не знать ни о какой <code><span class="special">lambda</span></code>. Иногда даже накладываются
    ограничения на положение <code><span class="special">lambda</span></code>-форм, разрешающие им находиться только
    внутри <code><span class="special">function</span></code> и в определениях функций.</p>
</div>

<div class="footnote" id="foot1.18">
  <p><span class="num"><sup>18</sup></span>
    В терминах λ-исчисления подобная замена имён называется α-конверсией.</p>
</div>

<div class="footnote" id="foot1.19">
  <p><span class="num"><sup>19</sup></span>
    К счастью, статистика показывает, что переменные, располагающиеся ближе к началу списка,
    используются чаще тех, что находятся глубоко внутри. Кстати, ещё стоит отметить, что
    лексические окружения в среднем меньше по размеру, чем динамические, так как
    последним необходимо хранить все переменные, участвующие в вычислениях, включая
    одноимённые <span class="cite">[<a href="z1_bibliography.xhtml#bak92a">Bak92a</a>]</span>.</p>
</div>

<div class="footnote" id="foot1.20">
  <p><span class="num"><sup>20</sup></span>
    Здесь мы не реализуем присваивание переменным, захваченным замыканиями. Об этом можно
    почитать в <span class="cite">[<a href="z1_bibliography.xhtml#bcsj86">BCSJ86</a>]</span>.</p>
</div>

<div class="footnote" id="foot1.21">
  <p><span class="num"><sup>21</sup></span>
    Это поле названо в честь <code><span class="var">apval</span></code> из
    <span class="cite">[<a href="z1_bibliography.xhtml#mae+62">MAE<sup>+</sup>62</a>]</span>.
    <span class="see">[см. <a href="ch02_lisp_1_2_omega.xhtml#lisp1-2-omega/par:apval">2 главу</a>]</span>
    Тогда значения полей действительно хранились в наивных P-списках.</p>
</div>

<div class="footnote" id="foot1.22">
  <p><span class="num"><sup>22</sup></span>
    Эти функции проходят по списку свойств символа (его P-списку,
    от property) до тех пор, пока не найдут нужное. Скорость поиска, соответственно,
    линейно зависит от длины списка, если только не применяются хеш-таблицы.</p>
</div>

<div class="footnote" id="foot1.23">
  <p><span class="num"><sup>23</sup></span>
    Согласитесь, было бы странным втискивать всю книгу в первую главу.</p>
</div>

<div class="footnote" id="foot1.24">
  <p><span class="num"><sup>24</sup></span>
    К сожалению, сейчас они ещё и инициализируются. Эта ошибка будет исправлена позже.</p>
</div>

<div class="footnote" id="foot1.25">
  <p><span class="num"><sup>25</sup></span>
    Можно только порадоваться за наш выбор не называть
    <code><span class="func">invoke</span></code>
    «<code><span class="func">apply</span></code>».</p>
</div>

<div class="footnote" id="foot1.26">
  <p><span class="num"><sup>26</sup></span>
    После того, как мы раскроем все
    используемые макросы и сокращения вроде <code><span class="syntax">let</span></code>,
    <code><span class="syntax">case</span></code>, <code><span class="special">define</span></code>
    и т. д. Потом надо будет ещё поместить в глобальное окружение функции
    <code><span class="func">evaluate</span></code>,
    <code><span class="func">evlis</span></code> и др.</p>
</div>

</body>
</html>
