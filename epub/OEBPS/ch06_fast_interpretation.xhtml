<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru"></p>

<p><body>
\chapter{Быстрая интерпретация}\label{chapter:fast}</p>

<p>\initial{0.25ex}{0.0ex}{Д}{\kern0.3ex енотационный} интерпретатор из предыдущей
главы чрезвычайно точно определяет язык, но работает невероятно медленно. В этой
главе мы разберём причины его неторопливости и разработаем несколько новых
интерпретаторов, исправляющих данный недостаток с помощью предобработки
программ. Короче говоря, в этой главе будет создан зачаточный компилятор.
В процессе мы проанализируем представление лексических окружений, соглашения
вызова функций и реализацию продолжений. Предварительная обработка программ
будет заключаться в нахождении и устранении вычислений, которые могут быть
выполнены заранее, ещё до начала исполнения программы; в результате в наших
программах останутся только необходимые вычисления. Эти вычисления будут
представляться специальными комбинаторами, играющими роль промежуточного языка,
похожего на язык ассемблера (высокоуровневой) виртуальной машины.</p>

<div class="bigskip"/>

<p>В предыдущей главе мы добились восхитительной точности работы интерпретатора.
Теперь пришло время исправить его отвратительную медлительность. Естественно,
мы не будем рубить с плеча, а продолжим неспешно и тщательно дорабатывать
существующие решения. Отчасти потому, что денотационный интерпретатор установил
планку точности описания языка, ниже которой опускаться не следует. Поэтому мы
рассмотрим один за другим три интерпретатора, постепенно принося в жертву
некоторые их возможности ради удобства и простоты реализации.</p>

<h2 id="fast/sect:fast">Быстрый интерпретатор</h2>


<!--\indexR{память}-->
<p>Ради эффективности предположим, что язык реализации содержит некоторый
минимальный набор средств, в частности, память. Первой на покой уйдёт наша
инкрементальная память из четвёртой главы. \seePage[chapter:assignment] Она
была введена исключительно как иллюстрация концепции, а не в роли практической
рекомендации. Конечно, связывание при этом никуда не денется, но память будет
использоваться лишь для хранения привязок. Теперь это проблемы <code><span class="func">cons</span></code>, где и
как размещать содержимое точечных пар, то же самое касается <code><span class="func">vector</span></code>,
<code><span class="func">lambda</span></code> и прочих. Память интерпретатора больше не будет жуткой свалкой из
аргументов функций, кусков структур данных, замыканий, меток переходов и т. п.
Отныне там будут лежать исключительно привязки, упакованные в записи активаций.</p>

<h3 id="fast/fast/ssect:migration">Миграция денотаций</h3>


<!--\indexR{миграция!кода}-->
<!--\indexE{lambda@$\lambda$-hoisting}-->
<!--\indexE{lambda@$\lambda$-drifting}-->
<p>Одной из главных причин неэффективности нашего интерпретатора является
чрезмерное использование абстракций для детализации конструкций языка, что вкупе
с подходом Scheme к вычислению аргументов приводит к огромной доле вычислений,
выполняемых в неподходящее время. Сейчас нас устраивает достигнутый уровень
точности, так что можно перенести вычисления немного вперёд, чтобы выполнять их
раньше <span class="cite">[<a href="z1_bibliography.xhtml#deu89">deu89</a>]</span>. Такой перенос называется <em class="term">миграцией</em> кода, также
известной под именами <em class="term">$\lambda$-hoisting</em> <span class="cite">[<a href="z1_bibliography.xhtml#tak88">tak88</a>]</span> и
<em class="term">$\lambda$-drifting</em> <span class="cite">[<a href="z1_bibliography.xhtml#roz92">roz92</a>]</span>. Конечно, в Scheme его надо применять
осторожно, чтобы не вызвать какие-либо побочные эффекты в неправильное время, а
то и неправильное количество раз. Также при переносе могут возникнуть проблемы
с бесконечными циклами. Действительно, выражение <code><span class="func">(lambda (x)
($\omega$ $\omega$))</span></code>, где вычисление <code><span class="func">($\omega$ $\omega$)</span></code> никогда
не закончится, не является эквивалентом <code><span class="func">(let ((tmp ($\omega$ $\omega$)))
(lambda (x) tmp))</span></code>. Однако, обе эти проблемы принципиально отсутствуют
в денотационном интерпретаторе, так как в λ-исчислении нет побочных
эффектов, а те денотации, которые имеет смысл переносить, являются
композициональными и получаются из программ конечных размеров, так что они
гарантированно вычислимы за конечное время.</p>

<p>В качестве примера рассмотрим новую версию абстракции. Денотация тела функции
<code><span class="func">(meaning*-sequence e+)</span></code> и количество её аргументов <code><span class="func">(length n*)</span></code> теперь
определяются лишь однажды:</p>


<!--\indexC{meaning-abstraction}-->
<p>\begin{code:lisp}
(define (meaning-abstraction n* e+)
  (let ((m (meaning*-sequence e+))
        (arity (length n*)) )
    (lambda (r k s)
      (k (inValue (lambda (v* k1 s1)
                    (if (= (length v*) arity)
                        (allocate s1 arity
                                  (lambda (s2 a*)
                                    (m (extend* r n* a*)
                                       k1
                                       (extend* s2 a* v*) ) ) )
                        (wrong "Incorrect arity") ) ))
         s ) ) ) )
\end{code:lisp}</p>

<h3 id="fast/fast/ssect:activations">Записи активаций</h3>

<p>Очевидно, что оптимизировав потребление памяти, мы сможем существенно повысить
скорость интерпретации. Одной из наиболее прожорливых частей денотационного
интерпретатора является протокол вызова функций. Имеется в виду механизм,
с помощью которого функции получают доступ к своим аргументам. В денотационном
интерпретаторе аргументы функции представляются списками, а окружения —
списками списков аргументов. Единственное оправдание настолько наивного
механизма передачи аргументов — это то, что мы разрабатывали прототип. Для
серьёзного, быстрого интерпретатора такое нагромождение списков неприемлемо.</p>


<!--\indexR{записи активации}-->
<!--\indexR{фреймы стека}-->
<!--\indexR{фреймы стека|seealso{записи активации}}-->
<!--\indexR{стековые фреймы}-->
<!--\indexR{стековые фреймы|seealso{записи активации}}-->
<p>Некоторые выделения памяти явно излишни, но есть и неизбежные расходы. Для
разработчика естественно желание избавиться от первых за счёт вторых. При вызове
функции нам обязательно надо передать ей аргументы, так что нельзя не выделять
память под них: это могут быть занятые регистры, кусочек стека или же
<em class="term">запись активации</em>. Запись активации функции — это некий объект,
хранящий конкретный набор аргументов, переданных функции при вызове (при её
активации). Чаще всего эти записи фактически располагаются в аппаратном стеке,
поэтому их также называют стековыми кадрами (фреймами). Пока что представим,
что они определяются так:</p>

<p>\begin{code:lisp}
(define-class activation-frame Object     |\dialect{Временно}|
  ( (* argument) ) )
\end{code:lisp}</p>


<!--\indexE{*@<code><span class="func">*</span></code> (в \protect\Meroon)}-->
<!--\indexR{индексированные поля}-->
<!--\indexR{поля!индексированные}-->
<p>\noindent
В этом определении используется новая возможность нашей объектной системы:
звёздочка <code><span class="func">*</span></code> обозначает <em>индексированное</em> поле; такие поля содержат
не одно значение, а упорядоченный набор значений, размер которого определяется
при создании объекта. (См. раздел \ref{objects/sect:repr-obj} за подробностями.)</p>

<p>Такое представление эффективнее расходует память, когда аргументов больше двух.
Также оно позволяет получить прямой доступ к элементам, тогда как в списке время
доступа к произвольному элементу линейно зависит от размера списка. Конечно,
введение записей активаций не должно мешать нам расширять окружения. Можно,
например, представлять окружения списками записей активаций, как на
рисунке \ref{fast/fast/activations/fig:env-lists}.</p>

<p>\begin{figure}[ht]\begin{center}
\input{figures/fig6.1}
\end{center}%
\caption{Окружение как список записей активаций.}%
\label{fast/fast/activations/fig:env-lists}%
\end{figure}</p>

<p>Можно сделать ещё лучше, введя специальное поле, с помощью которого записи
активаций будут связываться в список. Так как время на выделение памяти
в среднем слабо зависит от размера объекта (если закрыть глаза на
инициализацию), то выделить память для одной записи активации с лишним полем
выходит быстрее, чем для записи активации и точечной пары отдельно. Так и
поступим (рисунок \ref{fast/fast/activations/fig:env-linked}), сделав подобное
поле первым, чтобы его расположение не зависело от количества хранимых в записи
переменных.</p>


<!--\indexC{activation-frame}-->
<!--\indexC{environment}-->
<p>\begin{code:lisp}
(define-class environment Object
  ( next ) )</p>

<p>(define-class activation-frame environment
  ( (* argument) ) )
\end{code:lisp}</p>


<!--\indexR{лексическое окружение}-->
<!--\indexR{окружение!лексическое}-->
<p>Значения, образующие лексическое окружение, хранятся в связном списке записей
активаций. Функция <code><span class="func">sr-extend*</span></code> позволяет добавить в окружение новую запись:</p>


<!--\indexC{sr-extend*}-->
<p>\begin{code:lisp}
(define (sr-extend* sr v*)
  (set-environment-next! v* sr)
  v* )
\end{code:lisp}</p>

<p>Как видите, записи активаций физически модифицируются при расширении окружения,
так что функции не могут разделять их между собой. Каждый вызов функции создаёт
собственные привязки, а значит, новую запись активации.</p>


<!--\indexR{адрес переменной}-->
<!--\indexR{переменные!адреса}-->
<p>Теперь вспомним, как представляются лексические окружения в денотационном
интерпретаторе: они состоят из двух отдельных частей: $\rho$ и $\sigma$.
Окружение $\rho$ связывает имена переменных с адресами их значений
в памяти $\sigma$. Но у нас сейчас практически не осталось памяти как таковой.
Адресом переменной является её положение в цепочке записей активаций, которое
описывается двумя числами: номером записи активации и индексом переменной в ней.
Следующие две функции определяют чтение и модификацию таких переменных.</p>


<!--\indexC{deep-fetch}-->
<!--\indexC{deep-update"!}-->
<p>\begin{code:lisp}
(define (deep-fetch sr i j)
  (if (= i 0)
      (activation-frame-argument sr j)
      (deep-fetch (environment-next sr) (- i 1) j) ) )</p>

<p>(define (deep-update! sr i j v)
  (if (= i 0)
      (set-activation-frame-argument! sr j v)
      (deep-update! (environment-next sr) (- i 1) j v) ) )
\end{code:lisp}</p>

<p>\begin{figure}[ht]\begin{center}
\input{figures/fig6.2}
\end{center}%
\caption{Окружение как непосредственно связный список.}%
\label{fast/fast/activations/fig:env-linked}%
\end{figure}</p>


<!--\indexE{r @\protect<code><span class="func">r</span></code> (лексическое окружение)}-->
<!--\indexE{s r@\protect<code><span class="func">sr</span></code> (записи активаций)}-->
<!--\indexR{лексические индексы}-->
<!--\indexR{индексы!лексические}-->
<p>Записи активаций представляют связи между адресами и значениями, а окружения
— между именами и адресами переменных. Поэтом теперь память (от прямой
манипуляции которой мы хотим избавиться) фактически хранит исключительно записи
активаций. Окружения по аналогии с $\rho$ мы будем называть <code><span class="func">r</span></code>. Память
является <em>состоянием</em> всех окружений, поэтому она именуется <code><span class="func">sr</span></code>. Сами
окружения, по-хорошему, стоило бы представлять подобно памяти, но знакомые вам
«гирлянды» из списков \seeEx[basics/ex:new-extend] являются вполне приемлемым
вариантом. Окружения расширяются функцией <code><span class="func">r-extend*</span></code> (не путать
с <code><span class="func">sr-extend*</span></code>); кроме неё нам потребуется «полупредикат»
<code><span class="func">local-variable?</span></code>, возвращающий <em class="term">лексические индексы</em> переменных.</p>


<!--\indexC{r-extend*}-->
<!--\indexC{local-variable"?}-->
<p>\begin{code:lisp}
(define (r-extend* r n*)
  (cons n* r) )</p>

<p>(define (local-variable? r i n)
  (and (pair? r)
       (let scan ((names (car r))
                  (j 0) )
         (cond ((pair? names)
                (if (eq? n (car names))
                    `(local ,i . ,j)
                    (scan (cdr names) (+ 1 j)) ) )
               ((null? names)
                (local-variable? (cdr r) (+ i 1) n) )
               ((eq? n names) `(local ,i . ,j)) ) ) ) )
\end{code:lisp}</p>

<p>Всё это сделано для того, чтобы привести структуру памяти к строго
иерархическому виду. Сейчас адрес переменной — это не абсолютный номер ячейки
памяти, а пара <em>относительных</em> координат в текущем списке записей
активаций. Таким образом, сами адреса являются статическими и могут мигрировать
на этапе предварительной обработки, а значения переменных определяются как
обычно: динамически с помощью адресов и текущего состояния памяти.</p>

<p>Подобное разделение лексического окружения на статическую и динамическую части
не зависит от реализации памяти. На самом деле, это глубинное свойство самих
лексических окружений, которое стало явным только сейчас. Реализация памяти
в денотационном интерпретаторе тоже позволяет предсказывать «положение»
значения переменной в памяти (считая положением количество сравнений адресов
при поиске) по окружению, так как окружения представляются цепочками замыканий
вида \ic{(lambda (u) (if (eq? u \ii{x}) \ii{y} (\ii{f} u)))}.</p>

<h3 id="fast/fast/ssect:begin">Интерпретатор: начало</h3>

<p>Сейчас мы уже знаем достаточно для того, чтобы набросать ядро интерпретатора и
реализовать несколько специальных форм. Ожидаемо, начнём мы работу с функции
<code><span class="func">meaning</span></code>, имеющей следующий тип:
%
\begin{multline*}
\text{<code><span class="func">meaning</span></code>:} \quad
  \underbrace{\Vset{Программа} \times
            \Vset{Окружение}}_{\text{статическая часть}}\to{} \\
  {} \to \underbrace{(\Vset{ЗаписиАктиваций}^* \times
            \Vset{Продолжение} \to \Vset{Значение})}_{\text{динамическая часть}}
\end{multline*}</p>


<!--\indexR{предобработка программ}-->
<p>Здесь чётко видно, как именно лексические окружения разделяются на две части:
статические привязки имён к адресам в \Vset{Окружениях} и динамические привязки
адресов к значениям в \Vset{ЗаписяхАктиваций}. Программа, прошедшая подобную
<em class="term">предобработку</em>, превращается в функцию, ожидающую связный список записей
активаций (состояние памяти) и продолжение для того, чтобы вычислить результат.
Такой необычный способ представления программ весьма далёк от изначальных
S-выражений, но принципиально остаётся тем же.</p>


<!--\indexR{соглашения именования}-->
<!--\indexE{e @\protect<code><span class="func">e</span></code> (выражения)}-->
<!--\indexE{r @\protect<code><span class="func">r</span></code> (лексическое окружение)}-->
<!--\indexE{s r@\protect<code><span class="func">sr</span></code> (записи активаций)}-->
<!--\indexE{k @\protect<code><span class="func">k</span></code> (продолжения)}-->
<!--\indexE{v @\protect<code><span class="func">v</span></code> (значения)}-->
<!--\indexE{f @\protect<code><span class="func">f</span></code> (функции)}-->
<!--\indexE{n @\protect<code><span class="func">n</span></code> (идентификаторы)}-->
<p>Как обычно, ради упрощения синтаксического анализа разбираемые программы
считаются синтаксически корректными. Вспомним наши соглашения именования
сущностей:

\begin{center}\begin{tabular}{rl}
          <code><span class="func">e</span></code> & выражения, формы  \\
          <code><span class="func">r</span></code> & окружения         \\
<code><span class="func">sr</span></code>, <code><span class="func">v*</span></code> & записи активаций  \\
 <code><span class="func">k</span></code>, <code><span class="func">kk</span></code> & продолжения       \\
          <code><span class="func">v</span></code> & значения          \\
          <code><span class="func">f</span></code> & функции           \\
          <code><span class="func">n</span></code> & идентификаторы
\end{tabular}\end{center}</p>

<p>Отлично, вот синтаксический анализатор:</p>


<!--\indexC{meaning}-->
<p>\begin{code:lisp}
(define (meaning e r)
  (if (atom? e)
      (if (symbol? e) (meaning-reference e r)
                      (meaning-quotation e r) )
      (case (car e)
        ((quote)  (meaning-quotation (cadr e) r))
        ((lambda) (meaning-abstraction (cadr e) (cddr e) r))
        ((if)     (meaning-alternative (cadr e) (caddr e) (cadddr e) r))
        ((begin)  (meaning-sequence (cdr e) r))
        ((set!)   (meaning-assignment (cadr e) (caddr e) r))
        (else     (meaning-application (car e) (cdr e) r)) ) ) )
\end{code:lisp}</p>

<p>Цитирование в этот раз тривиально:</p>


<!--\indexC{meaning-quotation}-->
<p>\begin{code:lisp}
(define (meaning-quotation v r)
  (lambda (sr k)
    (k v) ) )
\end{code:lisp}</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>

<p>Ветвление показывает хороший пример миграции кода. Предварительную обработку
проходят обе ветки независимо от того, какая из них будет выбрана
в действительности.</p>


<!--\indexC{meaning-alternative}-->
<p>\begin{code:lisp}
(define (meaning-alternative e1 e2 e3 r)
  (let ((m1 (meaning e1 r))
        (m2 (meaning e2 r))
        (m3 (meaning e3 r)) )
    (lambda (sr k)
      (m1 sr (lambda (v)
               ((if v m2 m3) sr k) )) ) ) )
\end{code:lisp}</p>

<p>Упорядочиваются формы как обычно, с помощью рассмотрения двух возможных
вариантов списка форм.</p>


<!--\indexC{meaning-sequence}-->
<p>\begin{code:lisp}
(define (meaning-sequence e+ r)
  (if (pair? e+)
      (if (pair? (cdr e+))
          (meaning*-multiple-sequence (car e+) (cdr e+) r)
          (meaning*-single-sequence (car e+) r) )
      (static-wrong "Illegal syntax: (begin)") ) )</p>

<p>(define (meaning*-single-sequence e r)
  (meaning e r) )</p>

<p>(define (meaning*-multiple-sequence e e+ r)
  (let ((m1 (meaning e r))
        (m+ (meaning-sequence e+ r)) )
    (lambda (sr k)
      (m1 sr (lambda (v)
               (m+ sr k) )) ) ) )
\end{code:lisp}</p>

<p>Сложности начинаются с аппликацией. Для неё нам придётся точнее описать протокол
вызова функций.</p>

<h4 id="fast/fast/begin/ssect:application">Аппликация</h4>


<!--\indexR{протокол вызова функций}-->
<!--\indexR{функции!протокол вызова}-->
<p>Для обработки аппликаций необходимо определить несколько вещей: как выделяется
память под аргументы, как она заполняется и как передаётся, — короче говоря,
как используются записи активаций. Предварительная обработка функционального
терма аппликации проблем не представляет, аргументы требуют чуть больше
внимания, так что для их обработки мы введём функцию <code><span class="func">meaning*</span></code>. Наконец,
тела функций для простоты реализуются с помощью родных замыканий Scheme.</p>


<!--\indexC{meaning-regular-application}-->
<p>\begin{code:lisp}
(define (meaning-regular-application e e* r)
  (let* ((m (meaning e r))
         (m* (meaning* e* r (length e*))) )
    (lambda (sr k)
      (m sr (lambda (f)
              (if (procedure? f)
                  (m* sr (lambda (v*) (f v* k)))
                  (wrong "Not a function" f) ) )) ) ) )
\end{code:lisp}</p>

<p>\ForLayout{display}{\endgroup}% \lstset *skipamount</p>

<p>\phantomlabel{fast/fast/begin/application/par:call/cc}
<!--\indexR{записи активации!момент создания}-->
В наших интересах выполнить как можно больше вычислений на этапе предобработки.%
\footnote*{Именно ради этого разработчики языков программирования стараются
сделать как можно больше вещей доступными статически.} Например, определить
размер необходимой записи активации. Сейчас это сделать элементарно, зная длину
списка аргументов. В противоположность этому, гораздо сложнее сказать,
<em>когда</em> создавать запись. Есть два возможных момента времени:</p>

<p>\begin{enumerate}
  \item Создавать запись активации до вычисления аргументов. В этом
        случае вычисленные аргументы кладутся сразу же на нужное место.</p>

<p>  \item Создавать запись активации после вычисления всех аргументов.
        В таком случае, конечно же, аргументы надо будет где-то хранить
        до того, как они будут размещены в нужной записи активации.
\end{enumerate}</p>

<p>\phantomlabel{fast/fast/begin/application/par:act-rec-before}
<!--\indexR{записи активации!и call/cc@и \protect<code><span class="func">call/cc</span></code>}-->
<!--\indexR{продолжения (continuations)!множественные возвраты}-->
<!--\indexR{возвращаемые значения!многократно}-->
Первый вариант кажется более эффективным, так как потребляет меньше памяти.
К сожалению, в Scheme есть <code><span class="func">call/cc</span></code>, из-за которой этот вариант может
работать неверно. Он работает правильно только в Лиспе. Причина лежит в том,
что неограниченные продолжения Scheme можно активировать несколько раз.
\seePage[escape/forms/immortal/par:reincarnate] Если сначала создать запись
активации для вызываемой функции, а потом в процессе вычисления её аргументов
захватить продолжение, то все параллельные активации данного продолжения будут
пользоваться физически одной и той же записью, — а ведь каждый вызов функции
должен иметь свою собственную. Для пояснения проблемы рассмотрим следующий
пример. Ожидается, что эта программа вернёт <code><span class="func">(2 1)</span></code>, но фактически она
возвращает <code><span class="func">(2 2)</span></code> в случае разделяемых записей активаций.\footnote*{%
Мануэль Серрано (Manuel Serrano) обнаружил, что данная программа зависит от
порядка вычисления аргументов: форма <code><span class="func">cons</span></code> должна вычисляться слева направо.
Поэтому и используется <code><span class="func">let</span></code>.} Дело в том, что <code><span class="func">call/cc</span></code> захватывает
аппликацию <code><span class="func">((lambda (a) ...) ...)</span></code> и её запись активации, если она была
создана заранее. Так как продолжение используется дважды, то оба созданных
замыкания <code><span class="func">(lambda () a)</span></code> ссылаются на физически одну и ту же
переменную <code><span class="func">a</span></code>, а значит, активация продолжения <code><span class="func">(k 2)</span></code> сделает её
(в обоих местах) равной двум.</p>

<p>\begin{code:lisp}
(let ((k 'wait)
      (f '()) )
  (set! f (let ((g ((lambda (a) (lambda () a))
                    (call/cc (lambda (nk) (set! k nk) (nk 1))) )))
            (cons g f) ))
  ;; $\text{<code><span class="func">f</span></code>} \approx \text{<code><span class="func">(list $\lambda.$1)</span></code>}$
  (if (null? (cdr f)) (k 2))
  ;; $\text{<code><span class="func">f</span></code>} \approx \text{<code><span class="func">(list $\lambda.$2 $\lambda.$1)</span></code>}$
  (list ((car f)) ((cadr f))) )
\end{code:lisp}</p>


<!--\indexC{call/cc}-->
<p>Но ещё не всё потеряно! Записи активаций можно эффективно создавать до
вычисления аргументов функции, но тогда <code><span class="func">call/cc</span></code> придётся самостоятельно
делать копии записей активаций при каждой активации продолжения. К сожалению,
сейчас она не может этого делать вообще, так как продолжения представляются
родными замыканиями языка реализации и извлечь замкнутые в них записи нельзя.
Вот ещё один пример того, насколько сильно <code><span class="func">call/cc</span></code> влияет на реализацию.</p>

<p>Таким образом, функция <code><span class="func">meaning*</span></code> принимает дополнительный аргумент,
указывающий размер необходимой записи активации, которая будет создана после
вычисления всех аргументов. \seeEx[fast/ex:act-rec-before] По причинам, которые
будут разобраны в разделе \ref{fast/fast/ssest:varargs} вместе с реализацией
функций переменной арности \seePage[fast/fast/ssest:varargs], записи активаций
получают на одно поле больше, чем надо обычным функциям, но это не повлияет на
их эффективность, так как данное поле не инициализируется.</p>


<!--\indexC{meaning*}-->
<!--\indexC{meaning-no-arguments}-->
<p>\begin{code:lisp}
(define (meaning* e* r size)
  (if (pair? e*)
      (meaning-some-arguments (car e*) (cdr e*) r size)
      (meaning-no-arguments r size) ) )</p>

<p>(define (meaning-no-arguments r size)
  (let ((size+1 (+ size 1)))
    (lambda (sr k)
      (let ((v* (allocate-activation-frame size+1)))
        (k v*) ) ) ) )
\end{code:lisp}</p>

<p>Заметьте, что <code><span class="func">size+1</span></code> вычисляется во время предобработки — это значение
неизменно во время исполнения, поэтому его можно вычислить сразу же. Также
обратите внимание на «оседлость» формы, создающей запись активации: она
действительно должна вызываться при каждой аппликации.</p>

<p>Будущее расположение аргументов в записи активации легко вычисляется заранее,
так что значение каждого аргумента после создания записи тут же укладывается
в свою забронированную ячейку.</p>


<!--\indexC{meaning-some-arguments}-->
<p>\begin{code:lisp}
(define (meaning-some-arguments e e* r size)
  (let ((m (meaning e r))
        (m* (meaning* e* r size))
        (index (- size (+ (length e*) 1))) )
    (lambda (sr k)
      (m sr (lambda (v)
              (m* sr (lambda (v*)
                       (set-activation-frame-argument! v* index v)
                       (k v*) )) )) ) ) )
\end{code:lisp}</p>

<p>Вот теперь мы, наконец, можем определить абстракцию, в точности зная, что
происходит с аргументами. Для проверки арности используется длина записи
активации, но правильное значение известно заранее, а фактическое к моменту
вызова функции уже вычислено и размещено по известному смещению, так что сейчас
нам остаётся только сравнить два готовых числа.</p>


<!--\indexC{meaning-fix-abstraction}-->
<p>\begin{code:lisp}
(define (meaning-fix-abstraction n* e+ r)
  (let* ((arity (length n*))
         (arity+1 (+ 1 arity))
         (r2 (r-extend* r n*))
         (m+ (meaning-sequence e+ r2)) )
    (lambda (sr k)
      (k (lambda (v* k1)
           (if (= (activation-frame-argument-length v*) arity+1)
               (m+ (sr-extend* sr v*) k1)
               (wrong "Incorrect arity") ) )) ) ) )
\end{code:lisp}</p>

<h3 id="fast/fast/ssest:classify">Классы переменных</h3>


<!--\indexR{переменные!классификация}-->
<p>Предыдущими определениями поддерживаются только локальные переменные, то есть
переменные внутри <code><span class="func">lambda</span></code>-форм. Но ведь ещё остались глобальные переменные,
а среди них — предопределённые \hbox{и/или} неизменяемые вроде <code><span class="func">cons</span></code> или
<code><span class="func">car</span></code>. Сейчас возможно их поместить разве что в самую дальнюю запись
активации, но вы представляете, какой тогда будет скорость доступа к ним.
Поэтому мы воспользуемся возможностью статически классифицировать переменные.</p>


<!--\indexC{g.current}-->
<!--\indexC{g.init}-->
<!--\indexR{дескрипторы!переменных}-->
<p>Пусть глобальная переменная <code><span class="func">g.current</span></code> содержит список изменяемых глобальных
переменных обрабатываемой программы, а переменная <code><span class="func">g.init</span></code> — фиксированный
список предопределённых неизменяемых переменных: <code><span class="func">cons</span></code>, <code><span class="func">car</span></code> и т. д.
Функция <code><span class="func">compute-kind</span></code> определяет класс переменной и возвращает
соответствующий дескриптор.</p>


<!--\indexC{compute-kind}-->
<!--\indexC{global-variable"?}-->
<p>\begin{code:lisp}
(define (compute-kind r n)
  (or (local-variable? r 0 n)
      (global-variable? g.current n)
      (global-variable? g.init n) ) )</p>

<p>(define (global-variable? g n)
  (let ((var (assq n g)))
    (and (pair? var) (cdr var)) ) )
\end{code:lisp}</p>

<p>\phantomlabel{fast/fast/classify/par:redefine}
<!--\indexR{предопределённые переменные!переопределение}-->
<code><span class="func">g.current</span></code> проверяется перед <code><span class="func">g.init</span></code>, чтобы оставить возможность при
необходимости «переопределять» предопределённые переменные. Естественно,
значения этих переменных нельзя и не следует изменять, но стандартом допускается
возможность определения одноимённых глобальных переменных при условии, что это
не повлияет на работу примитивов. То есть можно определить, например, глобальную
переменную <code><span class="func">car</span></code>, но <code><span class="func">map</span></code>, которая наверняка использует функцию <code><span class="func">car</span></code>,
должна продолжать работать по-старому. Только явно определяемые в этой же
программе функции смогут пользоваться новым значением предопределённой
переменной. Одной <code><span class="func">compute-kind</span></code> достаточно для использования готовых
переопределений, но для создания новых придётся ввести дополнительную
специальную форму, скажем, <code><span class="func">redefine</span></code>. \seeEx[fast/ex:redefine]</p>

<p>Создаются глобальные переменные с помощью функций <code><span class="func">g.init-extend!</span></code>
и <code><span class="func">g.current-extend!</span></code>.</p>


<!--\indexC{g.current-extend"!}-->
<!--\indexC{g.init-extend"!}-->
<p>\begin{code:lisp}
(define (g.current-extend! n)
  (let ((level (length g.current)))
    (set! g.current (cons (cons n `(global . ,level)) g.current))
    level ) )</p>

<p>(define (g.init-extend! n)
  (let ((level (length g.init)))
    (set! g.init (cons (cons n `(predefined . ,level)) g.init))
    level ) )
\end{code:lisp}</p>

<p>Окружения <code><span class="func">g.current</span></code> и <code><span class="func">g.init</span></code> содержат лишь адреса, собственно значения
будут располагаться в специально отведённом месте для глобальных переменных —
двух векторах, доступных посредством переменных <code><span class="func">sg.current</span></code> и <code><span class="func">sg.init</span></code>.
Префикс <code><span class="func">s</span></code> здесь потому, что данные векторы — это всё же кусочек памяти.
Теперь определим эти контейнеры\footnote{Для простоты количество глобальных
переменных пока что ограничено одной сотней. Данное ограничение будет снято
в разделе \ref{fast/fast/ssect:variations}.} и функции-аксессоры к ним.
(Конечно, без <code><span class="func">predefined-update!</span></code>, так как примитивы неизменяемы.)</p>


<!--\indexC{sg.current}-->
<!--\indexC{sg.init}-->
<!--\indexC{global-fetch}-->
<!--\indexC{global-update"!}-->
<!--\indexC{predefined-fetch}-->
<p>\begin{code:lisp}
(define sg.current (make-vector 100))
(define sg.init (make-vector 100))</p>

<p>(define (global-fetch i)     (vector-ref sg.current i))
(define (predefined-fetch i) (vector-ref sg.init i))
(define (global-update! i v) (vector-set! sg.current i v))
\end{code:lisp}</p>

<p>Как обычно, мы определим пару вспомогательных функций <code><span class="func">g.current-initialize!</span></code>
и <code><span class="func">g.init-initialize!</span></code>, чтобы облегчить наполнение глобальных окружений.
Они будут синхронно обновлять глобальные окружения, следя за тем, чтобы
определяемая переменная (изначально) находилась только в одном из них.</p>


<!--\indexC{g.current-initialize"!}-->
<!--\indexC{g.init-initialize"!}-->
<p>\begin{code:lisp}
(define (g.current-initialize! name)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((global)
           (vector-set! sg.current (cdr kind) undefined-value) )
          (else (static-wrong "Wrong redefinition" name)) )
        (let ((index (g.current-extend! name)))
          (vector-set! sg.current index undefined-value) ) ) )
  name )</p>

<p>(define (g.init-initialize! name value)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((predefined) (vector-set! sg.init (cdr kind) value))
          (else (static-wrong "Wrong redefinition" name)) )
        (let ((index (g.init-extend! name)))
          (vector-set! sg.init index value) ) ) )
  name )
\end{code:lisp}</p>


<!--\indexR{предопределённые переменные!встраивание}-->
<!--\indexR{встраивание!предопределённых переменных}-->
<!--\indexR{переменные!предопределённые}-->
<p>Теперь у нас есть полный арсенал функций для реализации предварительной
обработки обращений к переменным и присваиваний. Оба обработчика имеют весьма
схожую структуру: выяснить класс переменной и подать правильный аксессор.
Заметьте, что функции <code><span class="func">deep-fetch</span></code> и <code><span class="func">deep-update!</span></code> не используются, если
переменная находится на верхушке стека записей активаций — в этом случае
значения получаются и изменяются напрямую. Также здесь применяется одна
искусная, но спорная уловка: предопределённые переменные считаются чем-то вроде
цитат: обращения к ним сразу же заменяются соответствующими значениями, а
не выполняют вызовы аксессоров.</p>


<!--\indexC{meaning-reference}-->
<p>\begin{code:lisp}
(define (meaning-reference n r)
  (let ((kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)) )
             (if (= i 0)
                 (lambda (sr k)
                   (k (activation-frame-argument sr j)) )
                 (lambda (sr k)
                   (k (deep-fetch sr i j)) ) ) ) )
          ((global)
           (let ((i (cdr kind)))
             (if (eq? (global-fetch i) undefined-value)
                 (lambda (sr k)
                   (let ((v (global-fetch i)))
                     (if (eq? v undefined-value)
                         (wrong "Uninitialized variable" n)
                         (k v) ) ) )
                 (lambda (sr k)
                   (k (global-fetch i)) ) ) ) )
          ((predefined)
           (let* ((i (cdr kind))
                  (value (predefined-fetch i)) )
             (lambda (sr k) (k value)) ) ) )
        (static-wrong "No such variable" n) ) ) )
\end{code:lisp}</p>

<p>Присваивание аналогично:</p>


<!--\indexC{meaning-assignment}-->
<p>\begin{code:lisp}
(define (meaning-assignment n e r)
  (let ((m (meaning e r))
        (kind (compute-kind r n)) )
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)) )
             (if (= i 0)
                 (lambda (sr k)
                   (m sr (lambda (v)
                           (k (set-activation-frame-argument!
                               sr j v )) )) )
                 (lambda (sr k)
                   (m sr (lambda (v)
                           (k (deep-update! sr i j v)) )) ) ) ) )
          ((global)
           (let ((i (cdr kind)))
             (lambda (sr k)
               (m sr (lambda (v)
                       (k (global-update! i v)) )) ) ) )
          ((predefined)
           (static-wrong "Immutable predefined variable" n) ) )
        (static-wrong "No such variable" n) ) ) )
\end{code:lisp}</p>

<p>
\subsubsection{Статические ошибки}\label{fast/fast/classify/sssect:static-err}</p>


<!--\indexR{ошибки!статические}-->
<!--\indexR{ошибки!динамические}-->
<p>Одна из целей предварительной обработки программ — это заранее отыскать все
глупые ошибки вроде обращений к явно несуществующим переменным или попыток
изменения значений предопределённых переменных. Ведь без обработки они остаются
незамеченными, пока ошибочный код не вызывается. О таких ошибках сигнализирует
форма <code><span class="func">static-wrong</span></code>, тогда как <code><span class="func">wrong</span></code> служит для ошибок времени
исполнения, которые нельзя предвидеть заранее. Идея статических ошибок (ошибок
времени компиляции) очень полезна, но в то же время проводит чёткую границу
между либеральными языками вроде Лиспа и большей частью остальных. К примеру,
любая корректная программа на ML гарантированно лишена ошибок типизации.
В Лиспе же всё наоборот: только гарантированно ошибочные программы считаются
некорректными. Рассмотрим следующую функцию:</p>


<!--\indexC{fact}-->
<p>\begin{code:lisp}
(define (statically-strange n)
  (if (integer? n)
      (if (= n 0) 1 (* n (statically-strange (- n 1))))
      (cons) ) )
\end{code:lisp}</p>

<p>Несмотря на то, что статически (в общем случае) эта функция ошибочна, она может
быть весьма полезной, если ей передавать целые числа (особенно положительные!).
Разрешать подобные определения или нет — это вопрос духа языка, это
компромисс между желаемой безопасностью и отдаваемой за неё свободой. Очевидно,
что о возможных ошибках лучше быть извещённым как можно раньше — ML возводит
эту максиму в абсолют, — однако, как показывает Лисп, вполне можно жить пусть
и с постоянной опасностью ошибиться, но получая взамен неимоверную гибкость
языка.</p>


<!--\indexC{static-wrong}-->
<p>Поэтому функция <code><span class="func">static-wrong</span></code> должна, конечно же, сообщать об ошибке, но при
этом обязана возвращать нормальный результат предобработки. Конечно, вся его
работа сводится к сообщению о том, что мы таки наступили на грабли.
Предупреждение можно вывести заранее, но <em>возникнуть</em> ошибка может только
во время исполнения программы. Мы явно описываем желаемое поведение
в определении <code><span class="func">static-wrong</span></code>:</p>

<p>\begin{code:lisp}
(define (static-wrong message . culprits)
  (display `(*static-error*
             ,message . ,culprits) )
  (newline)
  (lambda (sr k)
    (apply wrong message culprits) ) )
\end{code:lisp}</p>

<p>\noindent
Как говорится, и рыбку съели, и косточкой не подавились.</p>

<p>\phantomlabel{fast/fast/classify/static-err/par:self-modify}
<!--\indexR{глобальные переменные!инициализированность}-->
Кстати, вспомните, что при доступе к глобальным переменным необходимо проверять
их инициализированность, чего не требуется делать для локальных и
предопределённых. Следовательно, есть некоторая дополнительная стоимость
обращения к глобальным изменяемым переменным. В случае компиляции на лету
(например, при выполнении чего-то вроде <code><span class="func">(display (compile-and-run
(read)))</span></code>) мы могли бы немного оптимизировать обращения к инициализированным
глобальным переменным. В действительности, у нас даже сейчас есть подобная
оптимизация\footnote{Если бы у нас была возможность изменять скомпилированный
код на лету, то можно было бы пойти и дальше: после инициализации переменной
просто выкинуть код проверок на инициализированность изо всех обращений к ней.
Например, так делает Bigloo <span class="cite">[<a href="z1_bibliography.xhtml#ser94">ser94</a>]</span>.} в <code><span class="func">meaning-reference</span></code>.
\seeEx[compilation/ex:unchecked-ref]</p>

<h3 id="fast/fast/ssest:starting">Запускаем интерпретатор</h3>

<p>Интерпретатор читает выражение, обрабатывает его, затем исполняет и повторяет
всё сначала. Таким образом, мы получаем компилирующий REPL.</p>


<!--\indexC{chapter6.1-interpreter}-->
<p>\begin{code:lisp}
(define  r.init '())
(define sr.init '())</p>

<p>(define (chapter6.1-interpreter)
  (define (compile e) (meaning e r.init))
  (define (run c) (c sr.init display))
  (define (toplevel)
    (run (compile (read)))
    (toplevel) )
  (toplevel) )
\end{code:lisp}</p>

<p>Конечно, перед его запуском стоит всё же хоть немного наполнить базовое
окружение. Как обычно, предполагается, что у нас есть готовые макросы,
которые выполнят всю чёрную рутинную работу, позволяя сфокусироваться на
главном. Вот несколько подобных определений; среди них, конечно же, и наша
ненаглядная <code><span class="func">call/cc</span></code>.</p>


<!--\indexC{call/cc}-->
<p>\begin{code:lisp}
(definitial t #t)
(definitial f #f)
(definitial nil '())</p>

<p>(defprimitive cons cons 2)
(defprimitive car car 1)</p>

<p>(definitial call/cc
  (let* ((arity 1)
         (arity+1 (+ 1 arity)) )
    (lambda (v* k)
      (if (= arity+1 (activation-frame-argument-length v*))
          ((activation-frame-argument v* 0)
           (let ((frame (allocate-activation-frame (+ 1 1))))
             (set-activation-frame-argument!
              frame 0
              (lambda (values kk)
                (if (= (activation-frame-argument-length values)
                       arity+1 )
                    (k (activation-frame-argument values 0))
                    (wrong "Incorrect arity" 'continuation) ) ) )
             frame )
           k )
          (wrong "Incorrect arity" 'call/cc) ) ) ) )
\end{code:lisp}</p>

<h3 id="fast/fast/ssest:varargs">Функции с переменной арностью</h3>


<!--\indexR{функции!с переменной арностью}-->
<!--\indexR{арность!переменная}-->
<!--\indexR{переменная арность}-->
<p>В нашем интерпретаторе всё ещё не поддерживаются функций с переменной арностью.
Как всегда, реализация подобных функций представляет некоторые трудности. Наши
записи активаций хранят значения аргументов, но они же фактически являются и
вместилищем привязок. Функции переменной арности нарушают правило «один
аргумент — одна привязка». Например, функция, чьи аргументы описываются
списком <code><span class="func">(a b . c)</span></code>, может принять два, три, четыре или десять аргументов, но
привязок во всех случаях будет ровно три. По этой причине в записи активации
такой функции должно быть как минимум три поля. Аналогично для аппликации
\ic{(\ii{f} \ii{a} \ii{b})} тоже надо создавать запись активации с тремя полями,
чтобы ей могла воспользоваться любая функция, которая может принять два
аргумента: то есть функции со списками аргументов вида <code><span class="func">(x y)</span></code>, <code><span class="func">(x y .
z)</span></code>, <code><span class="func">(x . y)</span></code>, или даже просто <code><span class="func">x</span></code>.</p>

<p>Соответственно, функции с переменной арностью просто сбрасывают в список все
«лишние» аргументы, которые они найдут в записях активаций. Такую обработку
будет выполнять специально обученная функция <code><span class="func">listify!</span></code>. Она несложная, но,
требует определённой эквилибристики с перераспределением переменных. Её параметр
<code><span class="func">arity</span></code> указывает минимальное количество принимаемых функцией аргументов.</p>


<!--\indexC{meaning-dotted-abstraction}-->
<!--\indexC{listify"!}-->
<p>\begin{code:lisp}
(define (meaning-dotted-abstraction n* n e+ r)
  (let* ((arity (length n*))
         (arity+1 (+ 1 arity))
         (r2 (r-extend* r (append n* (list n))))
         (m+ (meaning-sequence e+ r2)) )
    (lambda (sr k)
      (k (lambda (v* k1)
           (if (>= (activation-frame-argument-length v*) arity+1)
               (begin (listify! v* arity)
                      (m+ (sr-extend* sr v*) k1) )
               (wrong "Incorrect arity") ) )) ) ) )</p>

<p>(define (listify! v* arity)
  (let loop ((index (- (activation-frame-argument-length v*) 1))
             (result '()) )
    (if (= arity index)
        (set-activation-frame-argument! v* arity result)
        (loop (- index 1)
              (cons (activation-frame-argument v* (- index 1))
                    result ) ) ) ) )
\end{code:lisp}</p>

<p>Наконец, всё готово для предобработки обоих видов <code><span class="func">lambda</span></code>-форм. Выбор
необходимого обработчика легко выполняется статически:</p>


<!--\indexC{meaning-abstraction}-->
<p>\begin{code:lisp}
(define (meaning-abstraction nn* e+ r)
  (let parse ((n* nn*)
              (regular '()) )
    (cond
     ((pair? n*) (parse (cdr n*) (cons (car n*) regular)))
     ((null? n*) (meaning-fix-abstraction nn* e+ r))
     (else (meaning-dotted-abstraction (reverse regular) n* e+ r)) ) ) )
\end{code:lisp}</p>

<h3 id="fast/fast/ssect:reducible">Приводимые выражения</h3>


<!--\indexR{редексы}-->
<!--\indexR{приводимые!формы}-->
<!--\indexR{форма!приводимая}-->
<!--\indexR{функции!переменной арности}-->
<p>Давайте реализуем в нашем интерпретаторе известную оптимизацию, касающуюся
приводимых форм (редексов): аппликаций, первым термом которых является
<code><span class="func">lambda</span></code>-форма. В этом случае не требуется создавать замыкание, достаточно
только ввести на время новые локальные переменные как в блоках Алгола. В конце
концов, <code><span class="func">((lambda (...) ...) ...)</span></code> — это не что иное, как <code><span class="func">let</span></code>-форма:
всего лишь блок кода с локальными переменными. И снова, для функций
фиксированной арности всё легко и просто, чего не скажешь об арности
переменной.\footnote*{Это уже который раз мы такое говорим? Надеюсь, теперь вам
понятно, почему во многих языках подобные функции не реализованы вообще,
несмотря на всю их полезность.} Кстати, в этом случае неправильное количество
аргументов является статически обнаруживаемой ошибкой.</p>


<!--\indexC{meaning-closed-application}-->
<!--\indexC{meaning-fix-closed-application}-->
<p>\begin{code:lisp}
(define (meaning-closed-application e ee* r)
  (let ((nn* (cadr e)))
    (let parse ((n* nn*)
                (e* ee*)
                (regular '()) )
      (cond ((pair? n*)
             (if (pair? e*)
                 (parse (cdr n*) (cdr e*) (cons (car n*) regular))
                 (static-wrong "Too few arguments" e ee*) ) )
            ((null? n*)
             (if (null? e*)
                 (meaning-fix-closed-application
                  nn* (cddr e) ee* r )
                 (static-wrong "Too many arguments" e ee*) ) )
            (else
             (meaning-dotted-closed-application
              (reverse regular) n* (cddr e) ee* r ) ) ) ) ) )</p>

<p>(define (meaning-fix-closed-application n* body e* r)
  (let* ((m* (meaning* e* r (length e*)))
         (r2 (r-extend* r n*))
         (m+ (meaning-sequence body r2)) )
    (lambda (sr k)
      (m* sr (lambda (v*)
               (m+ (sr-extend* sr v*) k) )) ) ) )
\end{code:lisp}</p>

<p>Для функций с переменной арностью можно не вызывать <code><span class="func">listify!</span></code>, так как
минимальная арность и фактическое число аргументов известны статически.
Специальный вариант <code><span class="func">meaning*</span></code>, названный <code><span class="func">meaning-dotted*</span></code>, отвечает за
обработку данного случая. Он работает подобно <code><span class="func">meaning*</span></code> для обязательных
аргументов, а дополнительные на лету собирает в список, искусно расставляя
<code><span class="func">cons</span></code>. Конечно, это не дёшево, но за удобства надо платить. Также придётся
вручную инициализировать последний элемент записи активации значением <code><span class="func">()</span></code>.
В общем, он выполняет вот такое преобразование:</p>

<p>{\def\a{$\alpha$}\def\b{$\beta$}\def\g{$\gamma$}\def\d{$\delta$}%
\def\E{\hbox to 0pt{\kern0.15em$\leadsto$}}
\begin{code:lisp}
((lambda (a b . c) ...) |\E|   ((lambda (a b c) ...)
 |\a| |\b| |\g| |\d| ...)               |\a| |\b| (cons |\g| (cons |\d| ...)) )
\end{code:lisp}}</p>

<p>\noindent
с помощью вот таких функций:</p>


<!--\indexC{meaning-dotted-closed-application}-->
<!--\indexC{meaning-dotted*}-->
<!--\indexC{meaning-some-dotted-arguments}-->
<!--\indexC{meaning-no-dotted-arguments}-->
<p>\begin{code:lisp}
(define (meaning-dotted-closed-application n* n body e* r)
  (let* ((m* (meaning-dotted* e* r (length e*) (length n*)))
         (r2 (r-extend* r (append n* (list n))))
         (m+ (meaning-sequence body r2)) )
    (lambda (sr k)
      (m* sr (lambda (v*)
               (m+ (sr-extend* sr v*) k) )) ) ) )</p>

<p>(define (meaning-dotted* e* r size arity)
  (if (pair? e*)
      (meaning-some-dotted-arguments (car e*) (cdr e*) r size arity)
      (meaning-no-dotted-argument r size arity) ) )</p>

<p>(define (meaning-some-dotted-arguments e e* r size arity)
  (let ((m (meaning e r))
        (m* (meaning-dotted* e* r size arity))
        (index (- size (+ (length e*) 1))) )
    (if (< index arity)
        (lambda (sr k)
          (m sr (lambda (v)
                  (m* sr (lambda (v*)
                           (set-activation-frame-argument! v* index v)
                           (k v*) )) )) )
        (lambda (sr k)
          (m sr (lambda (v)
                  (m* sr (lambda (v*)
                           (set-activation-frame-argument!
                            v* arity
                            (cons v (activation-frame-argument
                                     v* arity )) )
                           (k v*) )) )) ) ) ) )</p>

<p>(define (meaning-no-dotted-argument r size arity)
  (let ((arity+1 (+ 1 arity)))
    (lambda (sr k)
      (let ((v* (allocate-activation-frame arity+1)))
        (set-activation-frame-argument! v* arity '())
        (k v*) ) ) ) )
\end{code:lisp}</p>

<h3 id="fast/fast/ssect:integrating">Интеграция примитивов</h3>


<!--\indexR{примитивы}-->
<!--\indexR{функции!примитивы}-->
<p>Мы можем серьёзно ускорить интерпретацию, особым образом реализовав
предобработку вызовов примитивных предопределённых функций. Сейчас аппликация
вроде <code><span class="func">(car $\alpha$)</span></code> вызывает ужасно расточительную кучу действий:</p>

<p>\begin{enumerate}
  \item Разыменовать глобальную переменную <code><span class="func">car</span></code>.</p>

<p>  \item Вычислить $\alpha$.</p>

<p>  \item Создать запись активации с двумя полями.</p>

<p>  \item Положить в первое поле записи значение $\alpha$.</p>

<p>  \item Убедиться, что значением <code><span class="func">car</span></code> действительно является
        функция.</p>

<p>  \item Убедиться, что эта функция действительно может принять
        один аргумент.</p>

<p>  \item Применить значение <code><span class="func">car</span></code> к значению $\alpha$. Вдобавок
        функция <code><span class="func">car</span></code> ещё проверяет, что её аргумент действительно
        является точечной парой.
\end{enumerate}</p>

<p>Некоторые из этих шагов не нужны в статически типизированных языках, именно
поэтому такие языки очень быстрые. Но при определённых усилиях можно избавиться
от некоторых проверок и в Лиспе, выполняя их во время предобработки. Так как
<code><span class="func">car</span></code> это глобальная переменная, чьё значение нельзя изменить, то мы
избавляемся от шага 5 (убедиться, что это функция) и шага 6 (проверить арность).
Можно сэкономить ещё больше, если не создавать запись активации (шаги 3 и 4), а
сразу вставить код вызываемого примитива в программу (шаг 1).</p>

<p>\phantomlabel{fast/fast/integrating/par:inlining}
<!--\indexR{примитивы!встраивание}-->
<!--\indexR{инлайнинг}-->
<!--\indexR{встраивание}-->
<!--\indexR{проверки типов}-->
<!--\indexR{миграция!проверок типов}-->
Подобный способ использования примитивов — прямое исполнение кода в обход
протокола вызова функций — называется <em class="term">инлайнинг</em>. В этом случае
остаётся выполнить только шаги 2 и 7. Вдобавок, хороший компилятор будет
выполнять седьмой шаг по-умному, избегая дублирования проверок типов. Например,
в выражении <code><span class="func">(if (pair? e) (car e) ...)</span></code> бессмысленно проверять тип <code><span class="func">e</span></code>
внутри <code><span class="func">car</span></code>, так как он очевидно и гарантированно правильный. Один из
способов реализации такого поведения следующий: считать \ic{(car \ii{x})}
макросом, раскрывающимся в \ic{(let ((\ii{v} \ii{x})) (if (pair? \ii{v})
(unsafe-car \ii{v}) (error ...)))}, где <code><span class="func">unsafe-car</span></code>\footnote{Большинство
реализаций предоставляют подобные небезопасные примитивы, оказывающиеся весьма
полезными для различных преобразований программ. Естественно, эти преобразования
должны гарантировать использование <code><span class="func">unsafe</span></code>-примитивов только в безопасном
контексте. Компилятор часто способен уследить за типами значений, хранимых
в переменных, поэтому данные примитивы очень важны для эффективной компиляции.}
работает как <code><span class="func">car</span></code>, если её аргумент это точечная пара, и имеет
неопределённое поведение в противном случае. Теперь остаётся только перенести
все проверки типов как можно выше, оставив таким образом лишь неизбежные и
избавившись от очевидных повторений. С миграцией проверок типов проблем нет, так
как сами по себе они не вызывают ошибок и бесконечных циклов.</p>


<!--\indexC{desc.init}-->
<!--\indexR{дескрипторы!примитивов}-->
<p>При настоящей компиляции мы не имеем непосредственного доступа к значениям
предопределённых переменных: они обычно лежат где-то в библиотеке времени
исполнения. Однако, для предварительной обработки программ эти значения
не особо-то и нужны, достаточно будет знать, функция ли это и сколько
аргументов она может принять. Поэтому мы добавим новое окружение: окружение
дескрипторов глобальных предопределённых переменных <code><span class="func">desc.init</span></code>. В нём будут
храниться описания предопределённых примитивных функций, представляемые
списками. Первый элемент такого списка — это символ <code><span class="func">function</span></code>, второй
— «адрес» примитива (то, что вызывается), а за ним следует описание
арности. Макрос <code><span class="func">defprimitive</span></code> используется для определения примитивов.
Здесь приведён только один из его подмакросов: <code><span class="func">defprimitive3</span></code>, определения
остальных аналогичны.</p>


<!--\indexC{defprimitive}-->
<p>\begin{code:lisp}
(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value 0) (defprimitive0 name value))
    ((defprimitive name value 1) (defprimitive1 name value))
    ((defprimitive name value 2) (defprimitive2 name value))
    ((defprimitive name value 3) (defprimitive3 name value)) ) )</p>

<p>(define-syntax defprimitive3
  (syntax-rules ()
    ((defprimitive3 name value)
     (definitial name
       (letrec ((arity+1 (+ 3 1))
                (behavior
                 (lambda (v* k)
                   (if (= (activation-frame-argument-length v*)
                          arity+1 )
                       (k (value (activation-frame-argument v* 0)
                                 (activation-frame-argument v* 1)
                                 (activation-frame-argument v* 2) ))
                       (wrong "Incorrect arity" 'name) ) ) ) )
         (description-extend!
          'name `(function ,value a b c))
         behavior ) ) ) ) )
\end{code:lisp}</p>

<p>Управление новым окружением возлагается на следующие функции:</p>


<!--\indexC{description-extend"!}-->
<!--\indexC{get-description}-->
<p>\begin{code:lisp}
(define desc.init '())</p>

<p>(define (description-extend! name description)
  (set! desc.init (cons (cons name description) desc.init))
  name )</p>

<p>(define (get-description name)
  (let ((p (assq name desc.init)))
    (and (pair? p) (cdr p)) ) )
\end{code:lisp}</p>

<p>Вот теперь можно действительно полностью определить обработку аппликаций.
Она сводится к определению класса вызываемой функции и передаче аппликации
соответствующему специфичному обработчику. Заметьте, что согласованность арности
для примитивов тоже проверяется статически.</p>


<!--\indexC{meaning-application}-->
<p>\begin{code:lisp}
(define (meaning-application e e* r)
  (cond
   ((and (symbol? e)
         (let ((kind (compute-kind r e)))
           (and (pair? kind)
                (eq? 'predefined (car kind))
                (let ((desc (get-description e)))
                  (and desc
                       (eq? 'function (car desc))
                       (if (= (length (cddr desc)) (length e*))
                           (meaning-primitive-application e e* r)
                           (static-wrong "Incorrect arity" e) ) ) ) ) ) ))
   ((and (pair? e)
         (eq? 'lambda (car e)) )
    (meaning-closed-application e e* r) )
   (else (meaning-regular-application e e* r)) ) )
\end{code:lisp}</p>

<p>Аппликации примитивов обрабатываются следующим образом:</p>


<!--\indexC{meaning-primitive-application}-->
<p>\begin{code:lisp}
(define (meaning-primitive-application e e* r)
  (let* ((desc (get-description e)) ; <code><span class="func">desc</span></code>${}={}$\ic{(function \ii{адрес} . \ii{аргументы})}
         (address (cadr desc))
         (size (length e*)) )
    (case size
     ((0) (lambda (sr k) (k (address))))
     ((1) (let ((m1 (meaning (car e*) r)))
            (lambda (sr k)
              (m1 sr (lambda (v)
                       (k (address v)) )) ) ))
     ((2) (let ((m1 (meaning (car e*) r))
                (m2 (meaning (cadr e*) r)) )
            (lambda (sr k)
              (m1 sr (lambda (v1)
                (m2 sr (lambda (v2)
                         (k (address v1 v2)) )) )) ) ))
     ((3) (let ((m1 (meaning (car e*) r))
                (m2 (meaning (cadr e*) r))
                (m3 (meaning (caddr e*) r)) )
            (lambda (sr k)
              (m1 sr (lambda (v1)
                (m2 sr (lambda (v2)
                  (m3 sr (lambda (v3)
                           (k (address v1 v2 v3)) )) )) )) ) ))
     (else (meaning-regular-application e e* r)) ) ) )
\end{code:lisp}</p>


<!--\indexR{примитивы!арность}-->
<!--\indexR{арность!примитивов}-->
<p>Данный вариант поддерживает только примитивы фиксированной арности. Большая
часть примитивов, обладающих переменной арностью, вроде <code><span class="func">append</span></code>,
<code><span class="func">for-each</span></code>, <code><span class="func">list</span></code>, <code><span class="func">map</span></code>, <code><span class="func">*</span></code>, <code><span class="func">+</span></code> и многие другие (но
не <code><span class="func">apply</span></code>), могут считаться чем-то вроде макросов: например, <code><span class="func">(append
$\pi_1$ $\pi_2$ $\pi_3$)</span></code> раскрывается в <code><span class="func">(append $\pi_1$ (append $\pi_2$
$\pi_3$))</span></code>. Такая трансформация позволяет передавать произвольное число
аргументов, но спасает не всегда. Например, в случае <code><span class="func">(apply append $\pi$)</span></code>
примитивная функция <code><span class="func">append</span></code> уже вынуждена поддерживать произвольное число
аргументов самостоятельно.</p>

<p>Мы заменяем инлайн-версиями только аппликации с тремя и менее аргументами.
Причина такого решения банальна: в Scheme просто нет примитивных функций
с фиксированной арностью, принимающих больше трёх аргументов!</p>

<h3 id="fast/fast/ssect:variations">Вариации на тему окружений</h3>


<!--\indexR{свободные переменные!варианты реализации}-->
<!--\indexR{дисплеи}-->
<p>В данный момент время доступа к глубоко расположенным локальным переменным
(к тем, которые не находятся в первой записи активации) линейно зависит от
их расположения, так как мы вынуждены каждый раз заново проходить по списку
записей активаций. Существует простой способ получать доступ ко всем переменным
за постоянное время: поместить в каждую запись активации <em class="term">дисплей</em>,
хранящий прямые ссылки на все записи, расположенные глубже
(см. рисунок \ref{fast/fast/variations/pic:display}). В таком случае достаточно
будет одной косвенной адресации (через ячейку дисплея до записи) и одного сдвига
(до нужного значения в индексированном поле записи). Ценой за повышение скорости
обращений является увеличение потребления памяти, а также замедление создания
новых записей активаций. Конечно, в дисплее можно хранить ссылки не на все
записи, а только на те, которые действительно используются, но это требует
соответствующего анализа всех обращений к переменным. К сожалению, мы не можем
прямо воспользоваться этим приёмом в нашем интерпретаторе, так как сейчас размер
записи активации фиксируется до вызова функции, а при использовании дисплеев он
будет известен только во время исполнения. Необходимо или хранить дисплеи
отдельно от записей, или ограничить максимально возможную высоту стека (что
не особо в духе Лиспа).</p>

<p>\begin{figure}[!h]
\begin{center}
\input{figures/fig6.3}
\end{center}
\caption{Структура дисплеев.}\label{fast/fast/variations/pic:display}
\end{figure}</p>

<p>
\subsubsection{Плоские окружения}\label{fast/fast/variations/ssect:flat}</p>


<!--\indexR{плоские окружения}-->
<!--\indexR{окружение!плоское}-->
<!--\indexR{коробки}-->
<p>Другой вариант решения проблемы скорости доступа: избавиться от полноценного
стека окружений. Для каждого создаваемого замыкания можно не просто слепо
сохранять внутри всё состояние окружения <code><span class="func">sr</span></code>, а формировать для него
специальную запись активации, в которой собираются все его свободные переменные.
В этом случае, конечно, чуть возрастает стоимость создания замыканий, но все
свободные переменные будут доступны за постоянное время, так как в окружениях
будет всего по две записи активации: одна с собственными локальными переменными
активного замыкания, а другая — со свободными. Конечно, на случай, если
потребуется разделять какую-либо переменную между несколькими замыканиями, имеет
смысл реализовать коробки. \seePage[assignment/assignment/boxes/p:boxing]</p>

<p>В идеале, естественно, стоит использовать все возможные варианты, применяя
каждый из них в тех случаях, для которых он работает лучше остальных. Чтобы
осуществлять такое адаптивное поведение, требуется более тщательный анализ
программ. Это работа для настоящего компилятора, а не для простого
интерпретатора с небольшой предобработкой вроде нашего.</p>

<p>
\subsubsection{Определение глобальных переменных}%
\label{fast/fast/variations/ssect:global-define}</p>


<!--\indexR{переменные!глобальные}-->
<p>Наш интерпретатор считает, что переменная глобальная, если она находится
в списке глобальных изменяемых или же предопределённых переменных.
Следовательно, перед использованием переменную надо поместить в один из этих
списков, иными словами: объявить. Внутри интерпретатора это выполняется
с помощью макроса <code><span class="func">defvariable</span></code>:</p>


<!--\indexC{defvariable}-->
<p>\begin{code:lisp}
(define-syntax defvariable
  (syntax-rules ()
    ((defvariable name)
     (g.current-initialize! 'name) ) ) )
\end{code:lisp}</p>


<!--\indexR{глобальные переменные!объявление}-->
<p>Многие языки имеют что-то подобное для явного объявления переменных, но
в большинстве диалектов Лиспа принят другой подход. Здесь правильным считается
автоматическое создание всех используемых глобальных переменных. Один из
наиболее простых способов этого добиться: поместить механизм создания глобальных
переменных прямиком в функцию <code><span class="func">compute-kind</span></code>:</p>


<!--\indexC{adjoin-global-variable"!}-->
<!--\indexC{compute-kind}-->
<p>\begin{code:lisp}
(define (compute-kind r n)
  (or (local-variable? r 0 n)
      (global-variable? g.current n)
      (global-variable? g.init n)
      [(adjoin-global-variable! n)] ) )</p>

<p>(define (adjoin-global-variable! name)
  (let ((index (g.current-extend! name)))
    (vector-set! sg.current index undefined-value)
    (cdr (car g.current)) ) )
\end{code:lisp}</p>


<!--\indexR{глобальные переменные!предрождение}-->
<p>Но так делать не совсем хорошо, потому что тогда предобработка берёт на себя
слишком много. Получается, что глобальные переменные создаются во время неё, а
не во время исполнения программы. Приемлемо ли такое предрождение? Давайте ещё
раз разберём, что именно происходит при упоминании новой переменной.</p>

<p>\begin{enumerate}
  \item Её имя добавляется в окружение глобальных изменяемых переменных
        (известное как <code><span class="func">g.current</span></code>), а также с переменной связывается
        уникальный номер.</p>

<p>  \item Для хранения значения переменной выделяется ячейка памяти
        с адресом, соответствующим её номеру.
\end{enumerate}</p>

<p>Держа это в уме, рассмотрим следующую программу:</p>

<p>\begin{code:lisp}
(begin (define foo (lambda () (bar)))
       (define bar (lambda () (if #t 33 hux))) )
\end{code:lisp}</p>

<p>Так как в процессе её предобработки были встречены неизвестные переменные
с именами <code><span class="func">foo</span></code>, <code><span class="func">bar</span></code> и <code><span class="func">hux</span></code>, то они все получают свои номера, ячейки
памяти и добавляются в окружение. Но как их существование соотносится
с семантикой обрабатываемой программы? Почему определение <code><span class="func">foo</span></code> игнорирует
явно заданный порядок вычисления форм? Зависит ли существование <code><span class="func">hux</span></code> от
истинности условия?</p>

<p>Как бы то ни было, во время исполнения программы значения всех используемых
глобальных переменных должны находиться в глобальном окружении. Идеальный момент
для их добавления туда — это непосредственно перед началом исполнения
программы. Вернее, это единственно возможный момент. Лишь тогда размер
глобального окружения можно окончательно подогнать под требуемое количество
глобальных переменных, а также выдать им начальные значения. Это выполняет
функция <code><span class="func">standalone-producer</span></code>, которая обрабатывает программу, возвращая
обычное замыкание <code><span class="func">(lambda (sr k) ...)</span></code>, первым действием которого является
создание личного глобального окружения необходимых размеров.</p>


<!--\indexC{standalone-producer}-->
<p>\begin{code:lisp}
(define (standalone-producer e)
  (set! g.current (original.g.current))
  (let* ((m (meaning e r.init))
         (size (length g.current)) )
    (lambda (sr k)
      (set! sg.current (make-vector size undefined-value))
      (m sr k) ) ) )
\end{code:lisp}</p>


<!--\indexC{original.g.current}-->
<!--\indexR{переменные!предопределённые}-->
<!--\indexR{предопределённые переменные!для общения с системой}-->
<p>В глобальном окружении могут быть и предопределённые изменяемые переменные,
служащие механизмом обмена информацией между программой и внешней системой. Они
могут содержать разнообразные настройки вроде основания счисления для вывода
чисел. Предполагается, что такие переменные содержатся в окружении, возвращаемом
<code><span class="func">original.g.current</span></code>.</p>


<!--\indexR{глобальные переменные!объявление}-->
<!--\indexE{Scheme!глобальные переменные}-->
<p>Итого, при такой реализации для создания переменной достаточно лишь упомянуть
её имя. Можно было бы поступить наоборот, как сделано в Scheme, где глобальные
переменные создаются исключительно формой <code><span class="func">define</span></code>. В этом случае
предобработка примера с <code><span class="func">foo</span></code> должна выдать ошибку, так как <code><span class="func">hux</span></code> —
это неопределённая переменная с точки зрения предобработки, и не важно, что
фактически к ней никогда даже не обратятся. Переменная <code><span class="func">bar</span></code> проблем
не вызывает, так как её определение в программе присутствует (пусть и чуть
дальше).</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>

<p>Для пояснения принципа работы <code><span class="func">define</span></code> мы добавим новую специальную форму
в <code><span class="func">meaning</span></code>:</p>

<p>\begin{code:lisp}
... ((define) (meaning-define (cadr e) (caddr e) r)) ...
\end{code:lisp}</p>

<p>При обработке форм <code><span class="func">define</span></code> обнаруживаются все повторные определения
переменных. Хоть переопределение переменных не является ошибкой, но лучше
предупредить пользователя. Так как все глобальные переменные уже будут
существовать перед выполнением программы, то все определения можно просто
заменять присваиваниями.</p>


<!--\indexC{meaning-define}-->
<p>\begin{code:lisp}
(define (meaning-define n e r)
  (let ((b (memq n *defined*)))
    (if (pair? b)
        (static-wrong "Already defined variable" n)
        (set! *defined* (cons n *defined*)) ) )
  (meaning-assignment n e r) )
\end{code:lisp}</p>

<p>Также на предобработку возлагается дополнительная задача: проверить, все ли
упоминаемые глобальные переменные были определены и получили значения.
Естественно, в список определённых входят также и предопределённые переменные.</p>


<!--\indexC{set-difference}-->
<!--\indexC{standalone-producer}-->
<p>\begin{code:lisp}
(define (standalone-producer e)
  (set! g.current (original.g.current))
  (let ((originally-defined (append (map car g.current)
                                    (map car g.init) )))
    (set! *defined* originally-defined)
    (let* ((m (meaning e r.init))
           (size (length g.current))
           (anormals (set-difference (map car g.current) *defined*)) )
      (if (null? anormals)
          (lambda (sr k)
            (set! sg.current (make-vector size undefined-value))
            (m sr k) )
          (static-wrong "Undefined global variables" anormals) ) ) ) )</p>

<p>(define (set-difference set1 set2)
  (if (pair? set1)
      (if (memq (car set1) set2)
          (set-difference (cdr set1) set2)
          (cons (car set1) (set-difference (cdr set1) set2)) )
      '() ) )
\end{code:lisp}</p>

<p>\ForLayout{display}{\endgroup}% \lstset *skipamount</p>


<!--\indexCS{define}{семантика}-->
<p>Подводя итог, необходимо чётко разделять предобработку и исполнение программ.
Во время исполнения программы определения эквивалентны присваиваниям. Но
во время предобработки они требуют больших усилий, проверок и так далее. Обычные
специальные формы (не <code><span class="func">define</span></code>) действуют исключительно во время исполнения
программ. Их семантика динамическая. Определение переменных — это статический
процесс (благодаря предобработке), потому как все глобальные переменные должны
быть определены с помощью специальной формы <code><span class="func">define</span></code>, чьё наличие можно
проверить статически, а отсутствие считается ошибкой.</p>

<p>Кроме того, как мы упоминали ранее в разговоре о <code><span class="func">letrec</span></code>
\seePage[lisp1-2-omega/recusion/ssect:uninitialized], важно понимать, что
создание и инициализация переменных — это не одно и то же. Переменная может
существовать, но не иметь при этом значения. Вот вам пример такой переменной:</p>

<p>\begin{code:lisp}
(begin (define foo bar)
       (define bar (lambda () 33)) )
\end{code:lisp}</p>

<p>В случае компилирующего интерпретатора (нечто вроде инкрементального
компилятора, сразу же вычисляющего скомпилированные им выражения) большая часть
рассмотренных проблем пропадает сама собой благодаря тому, что программа
выполняется сразу же после её обработки и, что самое главное, с тем состоянием
памяти, которое было на конец обработки. Поэтому здесь первый вариант
<code><span class="func">adjoin-global-variable!</span></code>, сразу же добавляющий переменные в память,
в принципе подходит и работает правильно. То же касается и улучшения
в <code><span class="func">meaning-reference</span></code>, удаляющего проверки на инициализированность для уже
инициализированных переменных.</p>

<p>
\subsection{Выводы: интерпретатор с миграцией вычислений}%
\label{fast/fast/ssect:conclusions}</p>

<p>Довольно сложно точно измерить достигнутое увеличение эффективности, но оно
составляет порядка 10"-- 50 раз. Предварительная обработка выполняется
достаточно быстро, но возможности для оптимизации ещё остаются (самое очевидное:
представлять окружения не списками, а хеш-таблицами). Кроме того, немаловажен и
новый подход с разделением вычислений на статическую и динамическую части.
Хороший компилятор должен как можно больше всего выполнять статически, чтобы
во время исполнения программа делала как можно меньше ненужных действий.
Естественно, непрестанно ведутся исследования, нацеленные на поиск новых
статических свойств программ, которые могли бы улучшить качество
предварительной обработки. Вот лишь некоторые из них: абстрактная интерпретация
в работе <span class="cite">[<a href="z1_bibliography.xhtml#cc77">cc77</a>]</span>, частичные вычисления из <span class="cite">[<a href="z1_bibliography.xhtml#jgs93">jgs93</a>]</span>, анализ потока
исполнения в <span class="cite">[<a href="z1_bibliography.xhtml#shi91">shi91</a>]</span>. Ещё одним аспектом, влияющим на эффективность,
является выбор используемых структур данных, как можно было увидеть из нашей
дискуссии о представлении записей активаций.</p>

<p>Предварительная обработка позволяет отловить некоторые ошибки заранее, до того,
как они возникнут при исполнении программы. Это первый шаг на пути к более
безопасному и эффективному программированию: меньше возможных ошибок — меньше
явных проверок. Рассмотренная здесь обработка довольно примитивна, как минимум
её можно научить проверять типы, как это сделано в ML.</p>

<p>Полученный интерпретатор очень напоминает рассмотренный в третьей главе, разве
что замыкания в нашем языке реализуются напрямую с помощью родных замыканий
Scheme. Несмотря на то, что объекты и замыкания во многом схожи, замыкания
всё же недостаточно выразительны для данного случая: у них только один метод
— вызов; их внутренняя структура покрыта мраком; их поведение невозможно
уточнить или изменить, не говоря уже о более сложных вещах вроде рефлексии.</p>

<h2 id="fast/sect:reject">Отказ от окружений</h2>


<!--\indexE{env@\protect<code><span class="func">*env*</span></code>}-->
<p>Каждое выражение вычисляется в так или иначе уникальном окружении, у нас ему
соответствует значение параметра <code><span class="func">sr</span></code>. Так как окружение изменяется
исключительно при вызовах функций — они восстанавливают окружение своего
создания, после чего расширяют его локальными переменными, — то, вероятно,
имеет смысл ввести явное понятие текущего состояния окружения, храня его
в глобальной переменной (или регистре) <code><span class="func">*env*</span></code>. Это позволило бы избежать
передачи окружения через аргумент всем замыканиям, получающимся в результате
предобработки. Иными словами, в таком случае предварительная обработка будет
возвращать замыкания всего с одним параметром: <code><span class="func">(lambda (k) ...)</span></code>.</p>

<p>На первый взгляд, для выполнения подобного преобразования, заменяющего локальные
переменные функций <code><span class="func">sr</span></code> одной глобальной переменной <code><span class="func">*env*</span></code>, достаточно
внести лишь косметические изменения:</p>

<p>\begin{enumerate}
  \item Отныне локальные переменные следует искать в <code><span class="func">*env*</span></code>,
        а не в <code><span class="func">sr</span></code>.</p>

<p>  \item Замыкания сохраняют расширенные окружения своего определения
        и при своём вызове просто устанавливают в <code><span class="func">*env*</span></code> нужное им
        значение.
\end{enumerate}</p>


<!--\indexR{стек!вызовов}-->
<!--\indexR{окружение!при вызовах функций}-->
<!--\indexR{хвостовые вызовы}-->
<!--\indexR{вызов!хвостовой}-->
<p>Однако мы пропустили одну маленькую, но существенную деталь: время от времени
необходимо восстанавливать старое окружение, а именно, когда происходит возврат
к вычислениям, прерванным вызовом функции. Решение в лоб: функция при вызове
сохраняет текущее значение <code><span class="func">*env*</span></code>, а при возврате восстанавливает его. Но
вот здесь возникает проблема с тем, что Scheme требует оптимизации хвостовых
вызовов, то есть иногда <code><span class="func">*env*</span></code> восстанавливать <em>не надо</em>, потому что
хвостовые вызовы должны выполняться с неизменным продолжением.</p>


<!--\indexR{протокол вызова функций}-->
<!--\indexR{функции!протокол вызова}-->
<p>Эта проблема напоминает проблему выбора протокола вызова функций на самом
низком, машинном уровне. При вызове необходимо сохранять и восстанавливать
регистры процессора, но кто это должен делать?</p>

<p>\begin{itemize}
  \item Вызываемая подпрограмма точно знает, какие регистры ей
        понадобятся, так что может сохранять только их. Сложность тут
        в том, что восстановление регистров необходимо выполнять
        непосредственно перед возвратом управления из подпрограммы.
        Другими словам, это становится частью её продолжения.</p>

<p>  \item Вызывающий подпрограмму в свою очередь знает, какие регистры
        понадобятся ему, поэтому может сохранить их самостоятельно.
        В этом случае подпрограмма должна лишь выполниться и положить
        результат туда, где его ждут. Никаких проблем с продолжениями,
        и если вызывающему не важно состояние регистров, то можно вообще
        ничего не делать. Правда, подпрограмме может быть нужна лишь пара
        регистров, но вызывающему об этом она никак не скажет.
\end{itemize}</p>


<!--\indexR{регистры!как стеки}-->
<p>В <span class="cite">[<a href="z1_bibliography.xhtml#ss80">ss80</a>]</span> предлагается следующее решение: вызывающий помечает регистры
метками «сохранить при использовании» и «можно свободно изменять», а
вызываемый может сохранять только то, что действительно надо сохранять, помечая
регистры как «восстановить при возврате» и «значение не менялось». Тогда
регистры становятся фактически стеками значений, где верхнее значение является
текущим, а под ним лежат дожидающиеся восстановления старые значения. Во время
возврата управления специальная машинная инструкция обновляет значения регистров
в соответствии с расставленными метками.</p>

<p>Очень важно, чтобы хвостовые вызовы проводились с неизменным продолжением
(то есть не вызывали роста стека), это позволяет эффективно реализовывать
итерацию через рекурсию, не ограничивая возможную длину цикла размером стека.
Поэтому мы будем использовать вторую стратегию: ответственным за сохранение (или
несохранение) окружения является тот, кто вызывает функцию.</p>


<!--\indexC{tail"?}-->
<p>К счастью, найти все вызовы из хвостовых позиций можно статически, так что
функция <code><span class="func">meaning</span></code> получает дополнительный аргумент: булево значение
<code><span class="func">tail?</span></code>, показывающее, расположено ли вычисляемое выражение в хвостовой
позиции или нет. Если да, то можно не восстанавливать окружение после завершения
вычислений. (Естественно, в таком случае его и сохранять не обязательно.)</p>


<!--\indexR{хвостовые вызовы!способ нахождения}-->
<!--\indexR{вызов!хвостовой!способ нахождения}-->
<p>Так где же у выражений хвост? Для ответа на этот вопрос следует обратиться
к денотациям: всё, что вычисляется с продолжением, отличным от продолжения
внешней формы, находится не в хвостовой позиции. В присваивании \ic{(set! \ii{x}
$\pi$)} форма $\pi$ имеет продолжение, отличное от такового у формы <code><span class="func">set!</span></code>,
так как ещё остаётся записать её значение в переменную \ii{x}. Следовательно,
это не хвостовой вызов. Аналогично, форма $\pi_0$ в ветвлении <code><span class="func">(if $\pi_0$
$\pi_1$ $\pi_2$)</span></code> тоже не является последним вычислением. В последовательности
\ic{(begin $\pi_0$ ... $\pi_{n - 1}$ $\pi_n$)} формы $\pi_0, \ldots, \pi_{n-1}$
требуется вычислять, передавая изменяющееся окружение от одной к следующей, так
что это не хвостовые вызовы. В аппликации <code><span class="func">($\pi_0$ ... $\pi_n$)</span></code> ни одна
форма не находится в хвостовой позиции, так как ещё остаётся собственно вызов
функции. Однако вычисление тела функции, равно как и выполнение всей программы,
находятся как раз в хвостовой позиции, потому что ни тело функции само по себе,
ни вся программа не должны восстанавливать окружение после своего завершения.</p>

<p>Вот ядро нашего интерпретатора: новая функция <code><span class="func">meaning</span></code> и главный цикл
<code><span class="func">toplevel</span></code>.</p>


<!--\indexC{meaning}-->
<!--\indexC{chapter6.2-interpreter}-->
<p>\begin{code:lisp}[label=fast/reject/src:meaning]
(define (meaning e r tail?)
  (if (atom? e)
      (if (symbol? e) (meaning-reference e r tail?)
                      (meaning-quotation e r tail?) )
      (case (car e)
        ((quote)  (meaning-quotation (cadr e) r tail?))
        ((lambda) (meaning-abstraction (cadr e) (cddr e) r tail?))
        ((if)     (meaning-alternative (cadr e) (caddr e) (cadddr e)
                                       r tail? ))
        ((begin)  (meaning-sequence (cdr e) r tail?))
        ((set!)   (meaning-assignment (cadr e) (caddr e) r tail?))
        (else     (meaning-application (car e) (cdr e) r tail?)) ) ) )</p>

<p>(define *env* sr.init)
(define (chapter6.2-interpreter)
  (define (toplevel)
    (set! *env* sr.init)
    ((meaning (read) r.init #t) display)
    (toplevel) )
  (toplevel) )
\end{code:lisp}</p>

<h3 id="fast/reject/ssect:ref">Обращения к переменным</h3>

<p>Для определения значения переменной теперь используется регистр <code><span class="func">*env*</span></code>. Мы
не будем приводить определение присваивания, так как изменения в нём вполне
очевидны.</p>


<!--\indexC{meaning-reference}-->
<p>\begin{code:lisp}
(define (meaning-reference n r tail?)
  (let ((kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)) )
             (if (= i 0)
                 (lambda (k)
                   (k (activation-frame-argument *env* j)) )
                 (lambda (k)
                   (k (deep-fetch *env* i j)) ) ) ) )
          ((global)
           (let ((i (cdr kind)))
             (if (eq? (global-fetch i) undefined-value)
                 (lambda (k)
                   (let ((v (global-fetch i)))
                     (if (eq? v undefined-value)
                         (wrong "Uninitialized variable" n)
                         (k v) ) ) )
                 (lambda (k)
                   (k (global-fetch i)) ) ) ) )
          ((predefined)
           (let* ((i (cdr kind))
                  (value (predefined-fetch i)) )
             (lambda (k)
               (k value) ) ) ) )
        (static-wrong "No such variable" n) ) ) )
\end{code:lisp}</p>

<h3 id="fast/reject/ssect:alternatives">Ветвление</h3>

<p>Цитирование мы тоже пропустим, так как ему без разницы, где находиться. Что
касается условного оператора, то вы помните, что условие должно вычисляться
с восстановлением окружения.</p>


<!--\indexC{meaning-alternative}-->
<p>\begin{code:lisp}
(define (meaning-alternative e1 e2 e3 r tail?)
  (let ((m1 (meaning e1 r #f))        ; хвост чуть дальше!
        (m2 (meaning e2 r tail?))
        (m3 (meaning e3 r tail?)) )
    (lambda (k)
      (m1 (lambda (v)
            ((if v m2 m3) k) )) ) ) )
\end{code:lisp}</p>

<h3 id="fast/reject/ssect:sequence">Последовательность</h3>

<p>Последнее выражение в последовательности должно сохранять окружение, если вся
последовательность должна это делать. Остальные обязаны его сохранять и
восстанавливать, но только если они сами его изменяют — а изменять окружение
могут только аппликации абстракций. Например, в последовательности <code><span class="func">(begin a
(car x) ...)</span></code> окружение можно не сохранять, так как ни <code><span class="func">a</span></code>, ни <code><span class="func">(car x)</span></code>
не способны его изменить.</p>


<!--\indexC{meaning-sequence}-->
<p>\begin{code:lisp}
(define (meaning-sequence e+ r tail?)
  (if (pair? e+)
      (if (pair? (cdr e+))
          (meaning*-multiple-sequence (car e+) (cdr e+) r tail?)
          (meaning*-single-sequence (car e+) r tail?) )
      (static-wrong "Illegal syntax: (begin)") ) )</p>

<p>(define (meaning*-single-sequence e r tail?)
  (meaning e r tail?) )</p>

<p>(define (meaning*-multiple-sequence e e+ r tail?)
  (let ((m1 (meaning e r #f))
        (m2 (meaning-sequence e+ r tail?)) )
    (lambda (k)
      (m1 (lambda (v)
            (m+ k) )) ) ) )
\end{code:lisp}</p>

<h3 id="fast/reject/ssect:abstraction">Абстракция</h3>


<!--\indexR{абстракция}-->
<!--\indexR{замыкания (closures)}-->
<p>Замыкания захватывают окружение своего создания. Они же обязаны установить
захваченное окружение текущим, расширить его локальными переменными и передать
управление телу функции. Тело функции не должно восстанавливать окружение. Здесь
мы рассмотрим только функции с фиксированной арностью, обработка точечных
аргументов не влияет на концепцию хвостовых вызовов.</p>


<!--\indexC{meaning-fix-abstraction}-->
<p>\begin{code:lisp}
(define (meaning-fix-abstraction n* e+ r tail?)
  (let* ((arity (length n*))
         (arity+1 (+ 1 arity))
         (r2 (r-extend* r n*))
         (m+ (meaning-sequence e+ r2 #t)) )
    (lambda (k)
      (let ((sr *env*))
        (k (lambda (v* k1)
             (if (= (activation-frame-argument-length v*) arity+1)
                 (begin (set! *env* (sr-extend* sr v*))
                        (m+ k1) )
                 (wrong "Incorrect arity") ) )) ) ) ) )
\end{code:lisp}</p>

<h3 id="fast/reject/ssect:application">Аппликация</h3>


<!--\indexR{аппликация}-->
<p>Единственная хоть сколь-нибудь сложная вещь — это аппликация, так как именно
в этот момент решается, надо ли восстанавливать окружение или нет.</p>


<!--\indexC{meaning-regular-application}-->
<p>\begin{code:lisp}
(define (meaning-regular-application e e* r tail?)
  (let* ((m (meaning e r #f))
         (m* (meaning* e* r (length e*) #f)) )
    (if tail? (lambda (k)
                (m (lambda (f)
                     (if (procedure? f)
                         (m* (lambda (v*)
                               (f v* k) ))              ; не трогаем
                         (wrong "Not a function" f) ) )) )
        (lambda (k)
          (m (lambda (f)
               (if (procedure? f)
                   (m* (lambda (v*)
                         (let ((sr *env*))              ; сохраняем
                           (f v* (lambda (v)
                                   (set! *env* sr)      ; возвращаем
                                   (k v) )) ) ))
                   (wrong "Not a function" f) ) )) ) ) ) )</p>

<p>(define (meaning* e* r size tail?)
  (if (pair? e*)
      (meaning-some-arguments (car e*) (cdr e*) r size tail?)
      (meaning-no-arguments r size tail?) ) )</p>

<p>(define (meaning-some-arguments e e* r size tail?)
  (let ((m (meaning e r #f))
        (m* (meaning* e* r size tail?))
        (index (- size (+ (length e*) 1))) )
    (lambda (k)
      (m (lambda (v)
           (m* (lambda (v*)
                 (set-activation-frame-argument! v* index v)
                 (k v*) )) )) ) ) )</p>

<p>(define (meaning-no-arguments r size tail?)
  (let ((size+1 (+ 1 size)))
    (lambda (k)
      (let ((v* (allocate-activation-frame size+1)))
        (k v*) ) ) ) )
\end{code:lisp}</p>

<p>Таким образом, мы получаем интерпретатор с окружением, передаваемым через
регистр, и оптимизацией хвостовых вызовов. Начальное состояние глобального
окружения остаётся неизменным.</p>

<p>
\subsection{Выводы: интерпретатор с окружением в регистре}%
\label{fast/reject/ssect:conclusions}</p>

<p>Такое преобразование не всегда является полезным. Например, если мы захотим
добавить в язык параллелизм, то возникают соответствующие проблемы
синхронизации: глобальная переменная <code><span class="func">*env*</span></code> общая для всех потоков, но ведь
у каждого из них своё личное окружение. Тем не менее, постоянно доступное
окружение очень полезно, например, для рефлексии.</p>

<p>Новый интерпретатор ничуть не быстрее предыдущего. Да, функции теперь имеют на
один аргумент меньше, но ценой постоянных обращений к изменяемой глобальной
переменной, значение которой предсказывать сложнее. Однако, мы всё же прояснили
немаловажное понятие хвостовых вызовов, а также рассмотрели несколько других
вопросов, которые пригодятся в следующем интерпретаторе.</p>

<h2 id="fast/sect:dilute">Укрощение продолжений</h2>


<!--\indexR{продолжения (continuations)}-->
<!--\indexC{call/cc}-->
<p>Язык, используемый для реализации, зачастую предоставляет некоторый доступ
к продолжениям напрямую, что избавляет нас от необходимости явной работы с ними.
Использование данных возможностей — это вполне разумный подход. Наличие
готового компилятора Scheme значительно облегчает написание интерпретатора:
достаточно написать его на Scheme и откомпилировать, при этом <code><span class="func">call/cc</span></code> и
другие встроенные функции просто берутся из библиотеки времени исполнения
этого компилятора. Для простого кода на Лиспе вообще будет достаточно примитивов
<code><span class="func">setjmp</span></code>\slash<code><span class="func">longjmp</span></code>, присутствующих в библиотеке языка Си. В обоих
случаях в определяемом языке <code><span class="func">call/cc</span></code> становится магической данностью, что
позволяет призывать продолжения лишь тогда, когда они действительно необходимы.
Без <code><span class="func">call/cc</span></code>, спущенной свыше, мы обязаны постоянно создавать продолжения
самостоятельно, просто потому, что они <em>могут</em> понадобиться. Очевидно, это
сказывается на производительности интерпретатора.</p>


<!--\indexR{комбинаторы}-->
<p>Следующий интерпретатор, соответственно, не будет использовать явные
продолжения. Параллельно с этим улучшением будут реализованы ещё два других:</p>

<p>\begin{enumerate}
  \item Явное представление функций с помощью объектов.</p>

<p>  \item Результатом предварительной обработки станут комбинаторы
        (чьи имена записываются \textsc{прописными буквами}),
        напоминающие инструкции гипотетической виртуальной машины.
\end{enumerate}</p>

<p>Естественно, все оптимизации из предыдущего раздела (встраивание примитивов,
приводимые формы и т. д.) останутся, разве что будут переписаны на новый лад.</p>

<h3 id="fast/dilute/ssect:closures">Замыкания</h3>


<!--\indexR{представление!замыканий}-->
<!--\indexR{замыкания (closures)!явное представление}-->
<p>Замыкания представляются так же, как и ранее в третьей главе, — объектами
с двумя полями: одно для кода, другое для окружения определения. Для вызова
таких замыканий вводится специальная функция <code><span class="func">invoke</span></code>.</p>


<!--\indexC{closure}-->
<!--\indexC{invoke}-->
<p>\begin{code:lisp}
(define-class closure Object
  ( code
    closed-environment ) )</p>

<p>(define (invoke f v*)
  (if (closure? f)
      ((closure-code f) v* (closure-closed-environment f))
      (wrong "Not a function" f) ) )
\end{code:lisp}</p>

<p>Интерпретируемый код функций представляется замыканиями, принимающими два
аргумента: запись активации и некоторое окружение. Благодаря этому мы сможем при
надобности расширять окружение определения дополнительными переменными. Каждое
замыкание, соответственно, должно вызываться исключительно с помощью
<code><span class="func">invoke</span></code>.</p>

<h3 id="fast/dilute/ssect:pretreater">Предобработчик</h3>


<!--\indexC{meaning}-->
<!--\indexR{шитый код}-->
<p>Предварительная обработка программ выполняется всё той же функцией <code><span class="func">meaning</span></code>.
Однако, теперь вместо <code><span class="func">(lambda (k) ...)</span></code> она возвращает замыкания вида
<code><span class="func">(lambda () ...)</span></code>, которые можно понимать как адреса, на которые достаточно
просто перейти для «вызова». (Forth язык в корнями уходит способ подобный.)
Фактически, мы получаем обещание исполнения обработанной программы. Более того,
если немного видоизменить протокол вызова функций, то для выполнения данных
обещаний можно реализовать очень эффективный оператор <code><span class="func">GOTO</span></code>.
\seeEx[fast/ex:boost-thunks]</p>

<p>Определение <code><span class="func">meaning</span></code> идентично приведённому
на странице \pageref{fast/reject/src:meaning}.</p>

<h3 id="fast/dilute/ssect:quoting">Цитирование</h3>

<p>Цитаты остаются неизменными, но теперь их определение более читабельно благодаря
комбинатору <code><span class="func">CONSTANT</span></code>:</p>


<!--\indexC{meaning-quotation}-->
<!--\indexC{CONSTANT}-->
<p>\begin{code:lisp}
(define (meaning-quotation v r tail?)
  (CONSTANT v) )</p>

<p>(define (CONSTANT value)
  (lambda () value) )
\end{code:lisp}</p>

<h3 id="fast/dilute/ssect:refs">Обращения к переменным</h3>

<p>Обработка переменных сводится к определению их класса и вызову соответствующих
функций-аксессоров. Данные аксессоры являются комбинаторами, что повышает
удобочитаемость и понятность.</p>


<!--\indexC{meaning-reference}-->
<!--\indexC{SHALLOW-ARGUMENT-REF}-->
<!--\indexC{PREDEFINED}-->
<!--\indexC{DEEP-ARGUMENT-REF}-->
<!--\indexC{GLOBAL-REF}-->
<!--\indexC{CHECKED-GLOBAL-REF}-->
<p>\begin{code:lisp}
(define (meaning-reference n r tail?)
  (let ((kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)) )
             (if (= i 0)
                 (SHALLOW-ARGUMENT-REF j)
                 (DEEP-ARGUMENT-REF i j) ) ) )
          ((global)
           (let ((i (cdr kind)))
             (CHECKED-GLOBAL-REF i) ) )
          ((predefined)
           (let ((i (cdr kind)))
             (PREDEFINED i) ) ) )
        (static-wrong "No such variable" n) ) ) )</p>

<p>(define (SHALLOW-ARGUMENT-REF j)
  (lambda () (activation-frame-argument *env* j)) )</p>

<p>(define (PREDEFINED i)
  (lambda () (predefined-fetch i)) )</p>

<p>(define (DEEP-ARGUMENT-REF i j)
  (lambda () (deep-fetch *env* i j)) )</p>

<p>(define (GLOBAL-REF i)
  (lambda () (global-fetch i)) )</p>

<p>(define (CHECKED-GLOBAL-REF i)
  (lambda ()
    (let ((v (global-fetch i)))
      (if (eq? v undefined-value)
          (wrong "Uninitialized variable")
          v ) ) ) )
\end{code:lisp}</p>

<p>\phantomlabel{fast/dilute/refs/par:meaningful}
<!--\indexR{таблица символов}-->
Заметьте, что в случае, если переменная окажется неинициализированной,
комбинатор <code><span class="func">CHECKED-GLOBAL-REF</span></code> будет иметь в распоряжении только её адрес
в <code><span class="func">sg.current</span></code>, так что красивое сообщение об ошибке с именем переменной
вывести не получится. Чтобы иметь возможность так делать, во время исполнения
программы необходимо хранить то, что называется <em class="term">таблицей символов</em>:
структуру данных, устанавливающую соответствия между адресами и именами
переменных (во время предобработки ей соответствует список <code><span class="func">g.current</span></code>).
\seeEx[fast/ex:symbol-table] Тогда в случае нахождения дефектной переменной мы
сможем выдать и её имя, а не только непонятный адрес.</p>

<h3 id="fast/dilute/ssect:conditional">Ветвление</h3>

<p>Условный оператор тоже становится гораздо яснее благодаря комбинатору
<code><span class="func">ALTERNATIVE</span></code>, принимающему результаты предварительной обработки всех трёх
подформ оператора.</p>


<!--\indexC{meaning-alternative}-->
<!--\indexC{ALTERNATIVE}-->
<p>\begin{code:lisp}
(define (meaning-alternative e1 e2 e3 r tail?)
  (let ((m1 (meaning e1 r #f))
        (m2 (meaning e2 r tail?))
        (m3 (meaning e3 r tail?)) )
    (ALTERNATIVE m1 m2 m3) ) )</p>

<p>(define (ALTERNATIVE m1 m2 m3)
  (lambda ()
    (if (m1) (m2) (m3))) )
\end{code:lisp}</p>

<h3 id="fast/dilute/ssect:assignment">Присваивание</h3>

<p>Присваивание нового значения переменной напоминает получение её текущего
значения, за исключением того, что здесь ещё надо вычислить дополнительную
форму. Эта подформа будет передаваться во все нуждающиеся в ней комбинаторы.</p>


<!--\indexC{meaning-assignment}-->
<!--\indexC{SHALLOW-ARGUMENT-SET"!}-->
<!--\indexC{DEEP-ARGUMENT-SET"!}-->
<!--\indexC{GLOBAL-SET"!}-->
<p>\begin{code:lisp}
(define (meaning-assignment n e r tail?)
  (let ((m (meaning e r #f))
        (kind (compute-kind r n)) )
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)) )
             (if (= i 0)
                 (SHALLOW-ARGUMENT-SET! j m)
                 (DEEP-ARGUMENT-SET! i j m) ) ) )
          ((global)
           (let ((i (cdr kind)))
             (GLOBAL-SET! i m) ) )
          ((predefined)
           (static-wrong "Immutable predefined variable" n) ) )
        (static-wrong "No such variable" n) ) ) )</p>

<p>(define (SHALLOW-ARGUMENT-SET! j m)
  (lambda () (set-activation-frame-argument! *env* j (m))) )</p>

<p>(define (DEEP-ARGUMENT-SET! i j m)
  (lambda () (deep-update! *env* i j (m))) )</p>

<p>(define (GLOBAL-SET! i m)
  (lambda () (global-update! i (m))) )
\end{code:lisp}</p>

<h3 id="fast/dilute/ssect:sequence">Последовательность</h3>

<p>Последовательное вычисление форм выражается с помощью комбинатора <code><span class="func">SEQUENCE</span></code>,
являющегося бинарным аналогом <code><span class="func">begin</span></code>.</p>


<!--\indexC{meaning-sequence}-->
<!--\indexC{SEQUENCE}-->
<p>\begin{code:lisp}
(define (meaning-sequence e+ r tail?)
  (if (pair? e+)
      (if (pair? (cdr e+))
          (meaning*-multiple-sequence (car e+) (cdr e+) r tail?)
          (meaning*-single-sequence (car e+) r tail?) )
      (static-wrong "Illegal syntax: (begin)") ) )</p>

<p>(define (meaning*-single-sequence e r tail?)
  (meaning e r tail?) )</p>

<p>(define (meaning*-multiple-sequence e e+ r tail?)
  (let ((m1 (meaning e r #f))
        (m+ (meaning-sequence e+ r tail?)) )
    (SEQUENCE m1 m+) ) )</p>

<p>(define (SEQUENCE m m+)
  (lambda () (m) (m+)) )
\end{code:lisp}</p>

<h3 id="fast/dilute/ssect:abstraction">Абстракция</h3>

<p>Замыкания создают комбинаторы <code><span class="func">FIX-CLOSURE</span></code> и <code><span class="func">NARY-CLOSURE</span></code>. Различаются
они предикатами, проверяющими арность, а также подходами к формированию списка
аргументов.</p>


<!--\indexC{meaning-abstraction}-->
<!--\indexC{meaning-fix-abstraction}-->
<!--\indexC{meaning-dotted-abstraction}-->
<!--\indexC{FIX-CLOSURE}-->
<!--\indexC{NARY-CLOSURE}-->
<p>\begin{code:lisp}
(define (meaning-abstraction nn* e+ r tail?)
  (let parse ((n* nn*)
              (regular '()) )
    (cond
     ((pair? n*) (parse (cdr n*) (cons (car n*) regular)))
     ((null? n*) (meaning-fix-abstraction nn* e+ r tail?))
     (else       (meaning-dotted-abstraction
                  (reverse regular) n* e+ r tail? )) ) ) )</p>

<p>(define (meaning-fix-abstraction n* e+ r tail?)
  (let* ((arity (length n*))
         (r2 (r-extend* r n*))
         (m+ (meaning-sequence e+ r2 #t)) )
    (FIX-CLOSURE m+ arity) ) )</p>

<p>(define (meaning-dotted-abstraction n* n e+ r tail?)
  (let* ((arity (length n*))
         (r2 (r-extend* r (append n* (list n))))
         (m+ (meaning-sequence e+ r2 #t)) )
    (NARY-CLOSURE m+ arity) ) )</p>

<p>(define (FIX-CLOSURE m+ arity)
  (let ((arity+1 (+ 1 arity)))
    (lambda ()
      (define (the-function v* sr)
        (if (= (activation-frame-argument-length v*) arity+1)
            (begin (set! *env* (sr-extend* sr v*))
                   (m+) )
            (wrong "Incorrect arity") ) )
      (make-closure the-function *env*) ) ) )</p>

<p>(define (NARY-CLOSURE m+ arity)
  (let ((arity+1 (+ 1 arity)))
    (lambda ()
      (define (the-function v* sr)
        (if (>= (activation-frame-argument-length v*) arity+1)
            (begin
              (listify! v* arity)
              (set! *env* (sr-extend* sr v*))
              (m+) )
            (wrong "Incorrect arity") ) )
      (make-closure the-function *env*) ) ) )
\end{code:lisp}</p>

<h3 id="fast/dilute/ssect:application">Аппликация</h3>

<p>Осталось разобраться только с вызовами функций. <code><span class="func">meaning-application</span></code>
анализирует форму аппликации и умеет определять приводимые формы, обращения
к примитивам и все виды обычных аппликаций.</p>


<!--\indexC{meaning-appliction}-->
<p>\begin{code:lisp}
(define (meaning-application e e* r tail?)
  (cond ((and (symbol? e)
              (let ((kind (compute-kind r e)))
                (and (pair? kind)
                     (eq? 'predefined (car kind))
                     (let ((desc (get-description e)))
                       (and desc
                            (eq? 'function (car desc))
                            (or (= (length (cddr desc)) (length e*))
                                (static-wrong
                                 "Incorrect arity for primitive" e )
                                ) ) ) ) ) )
         (meaning-primitive-application e e* r tail?) )
        ((and (pair? e)
              (eq? 'lambda (car e)) )
         (meaning-closed-application e e* r tail?) )
        (else (meaning-regular-application e e* r tail?)) ) )
\end{code:lisp}</p>

<p>Все обычные аппликации обрабатываются с помощью четырёх комбинаторов. Термы
вычисляются как всегда слева направо.</p>


<!--\indexC{meaning-regular-application}-->
<!--\indexC{meaning*}-->
<!--\indexC{ALLOCATE-FRAME}-->
<!--\indexC{TR-REGULAR-CALL}-->
<!--\indexC{REGULAR-CALL}-->
<!--\indexC{STORE-ARGUMENT}-->
<p>\begin{code:lisp}
(define (meaning-regular-application e e* r tail?)
  (let* ((m (meaning e r #f))
         (m* (meaning* e* r (length e*) #f)) )
    (if tail? (TR-REGULAR-CALL m m*) (REGULAR-CALL m m*)) ) )</p>

<p>(define (meaning* e* r size tail?)
  (if (pair? e*)
      (meaning-some-arguments (car e*) (cdr e*) r size tail?)
      (meaning-no-arguments r size tail?) ) )</p>

<p>(define (meaning-some-arguments e e* r size tail?)
  (let ((m (meaning e r #f))
        (m* (meaning* e* r size tail?))
        (index (- size (+ (length e*) 1))) )
    (STORE-ARGUMENT m m* index) ) )</p>

<p>(define (meaning-no-arguments r size tail?)
  (ALLOCATE-FRAME size) )</p>

<p>(define (TR-REGULAR-CALL m m*)
  (lambda ()
    (let ((f (m)))
      (invoke f (m*)) ) ) )</p>

<p>(define (REGULAR-CALL m m*)
  (lambda ()
    (let* ((f  (m))
           (v* (m*))
           (sr *env*)
           (result (invoke f v*)) )
      (set! *env* sr)
      result ) ) )</p>

<p>(define (STORE-ARGUMENT m m* index)
  (lambda ()
    (let* ((v  (m))
           (v* (m*)) )
      (set-activation-frame-argument! v* index v)
      v* ) ) )</p>

<p>(define (ALLOCATE-FRAME size)
  (let ((size+1 (+ 1 size)))
    (lambda ()
      (allocate-activation-frame size+1) ) ) )
\end{code:lisp}</p>

<h3 id="fast/dilute/ssect:reducible">Приводимые формы</h3>

<p>Для обработки явно указанных в аппликациях <code><span class="func">lambda</span></code>-форм потребуется четыре
новых комбинатора. <code><span class="func">CONS-ARGUMENT</span></code> собирает избыточные аргументы в список.
<code><span class="func">ALLOCATE-DOTTED-FRAME</span></code> создаёт запись активации, аналогичную создаваемой
<code><span class="func">ALLOCATE-FRAME</span></code>, но с последним элементом, равным <code><span class="func">()</span></code> (тогда как
<code><span class="func">ALLOCATE-FRAME</span></code> не выполняет инициализацию из соображений
производительности).</p>


<!--\indexC{meaning-dotted-closed-application}-->
<!--\indexC{meaning-dotted*}-->
<!--\indexC{ALLOCATE-DOTTED-FRAME}-->
<!--\indexC{FIX-LET}-->
<!--\indexC{TR-FIX-LET}-->
<!--\indexC{CONS-ARGUMENT}-->
<p>\begin{code:lisp}
(define (meaning-dotted-closed-application n* n body e* r tail?)
  (let* ((m* (meaning-dotted* e* r (length e*) (length n*) #f))
         (r2 (r-extend* r (append n* (list n))))
         (m+ (meaning-sequence body r2 tail?)) )
    (if tail? (TR-FIX-LET m* m+)
              (FIX-LET m* m+) ) ) )</p>

<p>(define (meaning-dotted* e* r size arity tail?)
  (if (pair? e*)
      (meaning-some-dotted-arguments (car e*) (cdr e*)
                                     r size arity tail? )
      (meaning-no-dotted-arguments r size arity tail?) ) )</p>

<p>(define (meaning-some-dotted-arguments e e* r size arity tail?)
  (let ((m (meaning e r #f))
        (m* (meaning-dotted* e* r size arity tail?))
        (index (- size (+ (length e*) 1))) )
    (if (< index arity)
        (STORE-ARGUMENT m m* index)
        (CONS-ARGUMENT m m* arity) ) ) )</p>

<p>(define (meaning-no-dotted-arguments r size arity tail?)
  (ALLOCATE-DOTTED-FRAME arity) )</p>

<p>(define (FIX-LET m* m+)
  (lambda ()
    (set! *env* (sr-extend* *env* (m*)))
    (let ((result (m+)))
      (set! *env* (environment-next *env*))
      result ) ) )</p>

<p>(define (TR-FIX-LET m* m+)
  (lambda ()
    (set! *env* (sr-extend* *env* (m*)))
    (m+) ) )</p>

<p>(define (CONS-ARGUMENT m m* arity)
  (lambda ()
    (let* ((v  (m))
           (v* (m*)) )
      (set-activation-frame-argument! v* arity
       (cons v (activation-frame-argument v* arity)) )
      v* ) ) )</p>

<p>(define (ALLOCATE-DOTTED-FRAME arity)
  (let ((arity+1 (+ 1 arity)))
    (lambda ()
      (let ((v* (allocate-activation-frame arity+1)))
        (set-activation-frame-argument! v* arity '())
        v* ) ) ) )
\end{code:lisp}</p>

<p>
Комбинатор <code><span class="func">FIX-LET</span></code> должен восстанавливать текущее окружение — а это
значит, что оно должно быть где-то сохранено, чтобы его можно было оттуда
восстановить. К счастью, есть элегантное решение: так как записи активаций
связаны, то по самой верхней записи (бывшей текущей) можно легко определить
предыдущую.</p>

<h3 id="fast/dilute/ssect:primitives">Примитивы</h3>

<p>Осталось рассмотреть последний случай (по порядку, отнюдь не по важности): когда
функциональным термом аппликации является имя глобальной неизменяемой
переменной. В таком случае протокол вызова функций игнорируется, запись
активации не создаётся и <code><span class="func">invoke</span></code> не вызывается. Аппликация просто заменяется
прямым вызовов нужного примитива.</p>


<!--\indexC{meaning-primitive-application}-->
<!--\indexC*{CALL0}{CALL\protect\ii{n}}-->
<p>\begin{code:lisp}
(define (meaning-primitive-application e e* r tail?)
  (let* ((desc (get-description e))
         ;; <code><span class="func">desc</span></code>${}={}$\ic{(function \ii{адрес} . \ii{аргументы})}
         (address (cadr desc))
         (size (length e*)) )
    (case size
      ((0) (CALL0 address))
      ((1)
       (let ((m1 (meaning (car e*) r #f)))
         (CALL1 address m1) ) )
      ((2)
       (let ((m1 (meaning (car e*) r #f))
             (m2 (meaning (cadr e*) r #f)) )
        (CALL2 address m1 m2) ) )
      ((3)
       (let ((m1 (meaning (car e*) r #f))
             (m2 (meaning (cadr e*) r #f))
             (m3 (meaning (caddr e*) r #f)) )
        (CALL3 address m1 m2 m3) ) )
      (else
       (meaning-regular-application e e* r tail?) ) ) ) )</p>

<p>(define (CALL0 address)
  (lambda () (address)) )</p>

<p>(define (CALL3 address m1 m2 m3)
  (lambda () (let* ((v1 (m1))
                    (v2 (m2))
                    (v3 (m3)) )
               (address v1 v2 v3) )) )
\end{code:lisp}</p>

<p>Аргументы <code><span class="func">CALL3</span></code> явно вычисляются слева направо, чтобы не нарушать ранее
установленный порядок.</p>

<h3 id="fast/dilute/ssect:starting">Запускаем интерпретатор</h3>

<p>Так как продолжения теперь присутствуют в интерпретаторе неявно, то структура
определения примитивов слегка изменилась. Здесь показан только новый вариант
макроса <code><span class="func">defprimitive2</span></code>:</p>


<!--\indexC{defprimitive}-->
<p>\begin{code:lisp}
(define-syntax defprimitive2
  (syntax-rules ()
    ((defprimitive2 name value)
     (definitial name
       (letrec ((arity+1 (+ 2 1))
                (behavior
                 (lambda (v* sr)
                   (if (= arity+1 (activation-frame-argument-length v*))
                       (value (activation-frame-argument v* 0)
                              (activation-frame-argument v* 1) )
                       (wrong "Incorrect arity" 'name) ) ) ) )
         (description-extend! 'name `(function ,value a b))
         (make-closure behavior sr.init) ) ) ) ) )
\end{code:lisp}</p>

<p>Запускается интерпретатор следующим образом:</p>


<!--\indexC{chapter6.3-interpreter}-->
<p>\begin{code:lisp}
(define (chapter6.3-interpreter)
  (define (toplevel)
    (set! *env* sr.init)
    (display ((meaning (read) r.init #t)))
    (toplevel) )
  (toplevel) )
\end{code:lisp}</p>

<p>
\subsection{\texorpdfstring{Функция \protect<code><span class="func">call/cc</span></code>}{Функция call/cc}}%
\label{fast/dilute/ssect:call/cc}</p>

<p><code><span class="func">call/cc</span></code> в этом интерпретаторе является магией, так что для её определения
необходима <code><span class="func">call/cc</span></code> из библиотеки языка реализации. Это возвращает нас
к тавтологическим определениям из первых глав.</p>


<!--\indexC{call/cc}-->
<p>\begin{code:lisp}
(definitial call/cc
  (let* ((arity 1)
         (arity+1 (+ 1 arity)) )
    (make-closure
      (lambda (v* sr)
        (if (= arity+1 (activation-frame-argument-length v*))
            (call/cc
             (lambda (k)
               (invoke
                (activation-frame-argument v* 0)
                (let ((frame (allocate-activation-frame (+ 1 1))))
                  (set-activation-frame-argument!
                   frame 0
                   (make-closure
                    (lambda (values r)
                      (if (= (activation-frame-argument-length values)
                             arity+1 )
                          (k (activation-frame-argument values 0))
                          (wrong "Incorrect arity" 'continuation) ) )
                    sr.init ) )
                  frame ) ) ) )
            (wrong "Incorrect arity" 'call/cc) ) )
      sr.init ) ) )
\end{code:lisp}</p>

<p>\ForLayout{display}{\smallskip}</p>

<p>
\subsection{\texorpdfstring{Функция \protect<code><span class="func">apply</span></code>}{Функция apply}}%
\label{fast/dilute/ssect:apply}</p>

<p>Выходя за пределы обычного круга обсуждаемых вопросов, давайте определим функцию
<code><span class="func">apply</span></code>. Её всегда довольно непросто написать, так как она сильно зависит от
представления функций и протокола их вызова. Однако, этим нас не испугать.</p>


<!--\indexC{apply}-->
<p>\begin{code:lisp}
(definitial apply
  (let* ((arity 2)
         (arity+1 (+ 1 arity)) )
    (make-closure
     (lambda (v* sr)
       (if (>= (activation-frame-argument-length v*) arity+1)
           (let* ((proc (activation-frame-argument v* 0))
                  (last-arg-index
                   (- (activation-frame-argument-length v*) 2) )
                  (last-arg
                   (activation-frame-argument v* last-arg-index) )
                  (size (+ last-arg-index (length last-arg)))
                  (frame (allocate-activation-frame size)) )
             (do ((i 1 (+ i 1)))
                 ((= i last-arg-index))
               (set-activation-frame-argument!
                frame (- i 1) (activation-frame-argument v* i) ) )
             (do ((i (- last-arg-index 1) (+ i 1))
                  (last-arg last-arg (cdr last-arg)) )
                 ((null? last-arg))
               (set-activation-frame-argument! frame i (car last-arg)) )
             (invoke proc frame) )
         (wrong "Incorrect arity" 'apply) ) )
     sr.init ) ) )
\end{code:lisp}</p>


<!--\indexCS{apply}{стоимость}-->
<p>Этот примитив сначала проверяет, что ему передано по крайней мере два аргумента,
затем проходит по записи своей активации, чтобы выяснить точное количество
аргументов, передаваемых вызываемой функции. Для этого необходимо учесть длину
списка, хранимого в последнем элементе записи активации <code><span class="func">apply</span></code>. Как только
у <code><span class="func">apply</span></code> есть это число, можно создать запись активации правильного размера
для вызываемой функции. Затем обычные аргументы переносятся напрямую из одной
записи в другую, а список «лишних» аргументов приходится распарывать и
обрабатывать поэлементно. Условие окончания списка проверяется с помощью
<code><span class="func">null?</span></code>. Использование <code><span class="func">atom?</span></code> кажется более здравым, но это бы сделало
программу <code><span class="func">(apply list '(a b . c))</span></code> допустимой — вопреки требованиям
стандарта.</p>

<p>Как видим, <code><span class="func">apply</span></code> — это отнюдь не дешёвая операция, так как она вынуждена
создавать новую запись активации, а также проходить по списку, хранимому
в точечном аргументе.</p>

<p>
\subsection{Выводы: интерпретатор без продолжений}%
\label{fast/dilute/ssect:conclusions}</p>

<p>Новый интерпретатор приблизительно от двух до четырёх раз быстрее предыдущего,
в основном из-за отсутствия постоянно создаваемых замыканий с продолжениями.
Представление продолжений замыканиями не учитывает их важной особенности: обычно
продолжения не живут так же долго, как остальные значения. Эта особенность
позволяет очень эффективно размещать продолжения в аппаратном стеке, а также
значительно облегчает удаление ненужных продолжений: сдвинуть верхушку стека
можно за одну-единственную машинную инструкцию. Дабы не вводить вас
в заблуждение, поясним эту мысль: количество памяти, необходимое для размещения
продолжений, не зависит от того, будут ли они жить в стеке или в куче, но
благодаря обычно небольшому времени жизни продолжений их эффективнее размещать
именно на стеке. (В <span class="cite">[<a href="z1_bibliography.xhtml#app87">app87</a>]</span> есть иное мнение на этот счёт.) Как показано
в <span class="cite">[<a href="z1_bibliography.xhtml#mb93">mb93</a>]</span>, данное утверждение остаётся верным, даже если использовать
отдельную кучу специально для продолжений.</p>


<!--\indexR{шитый код}-->
<p>Способ использования обещаний, показанный в этой главе, известен как <em class="term">шитый
код</em> <span class="cite">[<a href="z1_bibliography.xhtml#bel73">bel73</a>]</span> и широко применяется при реализации языка Forth <span class="cite">[<a href="z1_bibliography.xhtml#hon93">hon93</a>]</span>.
Вдохновение при создании этого интерпретатора также черпалось из работы
Марка Филе и Гая Лапальма: <span class="cite">[<a href="z1_bibliography.xhtml#fl87">fl87</a>]</span>.</p>

<p>Комбинаторы фактически играют роль кодогенераторов. Они используются как простой
интерфейс представления кода, позволяющий легко изменять реализацию исполнителя
предобработанных программ. С их помощью довольно просто начать наконец
представлять код функций настоящими объектами, а не замыканиями. По сути,
компиляция, которую мы будем рассматривать в следующей главе, является лишь
серьёзной доработкой одного из упражнений: \seeEx[fast/ex:disassemble].</p>

<h2 id="fast/sect:conclusions">Заключение</h2>

<p>На первый взгляд, вся эта глава и её три интерпретатора — это огромный шаг
назад, лишивший нас всего приобретённого в первых четырёх. Действительно, память
практически исчезла (сократившись до управления записями активаций), продолжений
нет совсем. С другой стороны, мы подробно разобрали предварительную обработку
программ, которая является важным этапом компиляции. Кроме того, вычисления были
разделены на статические и динамические, что позволило реализовать множество
оптимизаций, ускоряющих интерпретацию. И мы действительно её ускорили —
примерно на два порядка по сравнению с денотационным интерпретатором.</p>

<p>Третий интерпретатор, рассмотренный в данной главе, реализует все специальные
формы Scheme и представляет собой квинтэссенцию практически любого языка.
Остаётся только снабдить его менеджером памяти, а также библиотеками для работы
с текстом, графикой, моделирования, физических расчётов, прототипирования
языков, виртуальной реальности и т. д. Конечно, нам легко сказать: «только»,
а на самом деле за этим словом скрывается неимоверная сложность разработки
удобного способа представления примитивных объектов в памяти, который бы
обеспечил возможность быстрой проверки типов <span class="cite">[<a href="z1_bibliography.xhtml#gud93">gud93</a>]</span> и эффективной сборки
мусора, не говоря уже о как минимум равной трудоёмкости задачи написания
прикладных библиотек.</p>

<p>Естественно, мы могли бы и дальше улучшать приведённые здесь интерпретаторы или,
например, расширить их другими специальными формами, но помните, что их главной
задачей является иллюстрация инкрементального подхода к разработке, позволяющего
сделать описание языка более компактным и понятным, а также формирующего
фундамент для нашего дальнейшего продвижения.</p>

<h2 id="fast/sect:exercises">Упражнения</h2>

<p>\begin{exercise}\label{fast/ex:symbol-table}
Доработайте комбинатор <code><span class="func">CHECKED-GLOBAL-REF</span></code>, научив его выводить более
осмысленные сообщения о неинициализированных переменных.
\seePage[fast/dilute/refs/par:meaningful]
\end{exercise}</p>

<p>\begin{exercise}\label{fast/ex:list}
Определите примитив <code><span class="func">list</span></code> для третьего интерпретатора из этой главы.
Подсказка: это можно сделать <em>очень</em> элегантно.
\end{exercise}</p>

<p>\begin{exercise}\label{fast/ex:disassemble}
<!--\indexC{disassemble}-->
Вместо исполнения программы мы могли бы выводить на экран результат
предварительной обработки. Как-то так это бы выглядело для факториала:</p>

<p>\begin{code:lisp}
? (disassemble
    '(lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))) )</p>

<p>= (FIX-CLOSURE
    (ALTERNATIVE
      (CALL2 #<=> (SHALLOW-ARGUMENT-REF 0) (CONSTANT 0))
      (CONSTANT 1)
      (CALL2 #<*> (SHALLOW-ARGUMENT-REF 0)
                  (REGULAR-CALL
                    (CHECKED-GLOBAL-REF 10)  ; $\leftarrow$ <code><span class="func">fact</span></code>
                    (STORE-ARGUMENT
                      (CALL2 #<-> (SHALLOW-ARGUMENT-REF 0)
                                  (CONSTANT 1) )
                      (ALLOCATE-FRAME 1)
                      0 ) ) ) )
    1 )
\end{code:lisp}</p>

<p>\noindent
Напишите подобный дизассемблер.
\end{exercise}</p>

<p>\begin{exercise}\label{fast/ex:act-rec-before}
Измените последний рассмотренный интерпретатор так, чтобы записи активаций
создавались перед вычислением аргументов. Тогда готовые аргументы можно будет
сразу же укладывать в ячейки записи активации.
\seePage[fast/fast/begin/application/par:act-rec-before]
\end{exercise}</p>

<p>\begin{exercise}\label{fast/ex:redefine}
<!--\indexC{redefine}-->
Определите специальную форму <code><span class="func">redefine</span></code>, позволяющую переопределять
глобальные неизменяемые переменные. Она должна принимать имя примитива и
создавать одноименную переменную в глобальном изменяемом окружении, которая,
как сказано на странице \pageref{fast/fast/classify/par:redefine}, скроет
оригинал. Пусть начальным значением этой переменной будет переопределяемый
примитив.
\end{exercise}</p>

<p>\begin{exercise}\label{fast/ex:boost-thunks}
Оптимизируйте предобработку функций без аргументов.
\seePage[fast/dilute/ssect:pretreater]
\end{exercise}</p>

<p>
\section*{Рекомендуемая литература}\label{fast/sect:recommended-reading}</p>

<p>Последний рассмотренный интерпретатор вдохновлён статьёй <span class="cite">[<a href="z1_bibliography.xhtml#fl87">fl87</a>]</span>. Идея
перехода от денотаций к комбинаторам взята из <span class="cite">[<a href="z1_bibliography.xhtml#cli84">cli84</a>]</span>. Если вам
действительно понравилось оптимизировать интерпретацию, то определённо стоит
изучить работы <span class="cite">[<a href="z1_bibliography.xhtml#cha80">cha80</a>]</span> и <span class="cite">[<a href="z1_bibliography.xhtml#sj93">sj93</a>]</span>.</p>

<p></body>
</html>
