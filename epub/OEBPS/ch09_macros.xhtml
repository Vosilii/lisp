<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru"></p>

<p><body>
% Увеличить место под номера разделов в оглавлении начиная с этой главы
\addtocontents{toc}{%
  \setlength{\cftsectionnumwidth}{2.7em}%
  \setlength{\cftsubsectionindent}{4.2em}%
  \setlength{\cftsubsectionnumwidth}{3.6em}%
}
\chapter{Макросы: употребление и злоупотребление}\label{chapter:macros}</p>


<!--\indexR{абстракция!и макросы}-->
<p>\initial{0.25ex}{0.0ex}{П}{\kern0.65ex резираемые,} неверно используемые,
несправедливо осуждаемые, недостаточно оправданные (теоретически) — как бы их
не клеймили, макросы остаются одним из столпов Лиспа и одной главных из причин
его долголетия. Если функции являются абстракцией вычислений, а объекты —
абстракцией данных, то макросы абстрагируют структуру программ. В этой главе мы
познакомимся с макросами и вызываемыми ими проблемами. Ввиду того, что макросы
являются одной из наименее изученных тем в Лиспе, существует огромное
разнообразие реализаций макросистем. Среди них сложно выделить канонические
решения, поэтому кода в этой главе будет весьма умеренное количество, а больше
внимания уделяется изучению эволюции этих своеобразных сущностей — макросов.</p>

<div class="bigskip"/>


<!--\indexR{макросы}-->
<!--\indexR{синтаксис!расширение}-->
<!--\indexR{язык!расширение}-->
<p>Изобретение макросов приписывается <span class="cite">[<a href="z1_bibliography.xhtml#sg93">sg93</a>]</span> Тимоти Харту, именно он придумал
их в 1963 году вскоре после выхода руководства по <span class="logo">Lisp 1.5</span>; с тех пор и поныне
они являются неотъемлемой частью диалектов Лиспа. Макросы позволяют
разработчикам проектировать и реализовывать языки, соответствующие решаемым
проблемам. Подобно математике, где обычным делом является введение обозначений
для новых понятий, макросы позволяют расширять язык новыми синтаксическими
конструкциями. Не поймите превратно: дело не в расширении возможностей языка
с помощью библиотек функций или чего-то подобного. Лисп с графической
библиотекой всё ещё остаётся Лиспом и не более чем Лиспом. Здесь же речь идёт
об увеличении выразительной силы языка с помощью введения новых синтаксических
форм.</p>

<p>\begingroup
\def\={=\nobreak\discretionary{}{\hbox{\ensuremath{=}}}{}}
Расширение языка подразумевает введение новой нотации, которая позволяет,
например, писать $\lim_{x \to x_0} f(x) \= A$, когда имеется в виду $\forall
\epsilon > 0\colon \exists \delta \= \delta(\epsilon)\colon \forall x\colon
0 < |x - x_0| < \delta \Rightarrow |f(x) - A| < \epsilon$. Естественно,
можно было бы каждый раз в деталях расписывать понятие предела, если бы не лень.
Но лень — двигатель прогресса. Подробные определения являются лишь обузой
для понимания более широких концепций, поэтому со временем заменяются подобной
краткой и удобной формой записи. Очень многие математические понятия настолько
глубоко проработаны, что ими совершенно невозможно пользоваться в полностью
развёрнутом виде, не прибегая к каким-либо сокращениям. Также ради гибкости
часто вводятся параметры: ведь когда мы пишем $\lim_{x \to x_0} f(x) \= A$, то
на самом деле имеем в виду параметризованное сокращение $L(f(x), x_0, A)$.
Макросы — это отнюдь не изящный хак, доступный лишь избранным, а невероятно
полезная возможность, позволяющая строить абстракции на уровне программ,
манипулируя их представлением.
\endgroup</p>


<!--\indexC{repeat}-->
<p>В большинстве императивных языков набор синтаксических конструкций фиксирован.
Например, в них наверняка есть цикл <code><span class="func">while</span></code>, кое-где есть и <code><span class="func">until</span></code>, но
если вам нужен какой-то особый цикл, то чаще всего вы лишены возможности
записывать его подобно другим циклам. Лисп же вполне возможно научить понимать
\ic{(repeat :while \ii{p} :unless \ii{q} :do \ii{тело}...)} как</p>

<pre>(let loop ()
  (if |\ii{p}| (begin (if (not |\ii{q}|) (begin |\ii{тело}|...))
               (loop) )) )</pre>


<!--\indexC{loop}-->
<p>Этот пример намеренно «расточителен»: в нём используются дополнительные
ключевые слова (начинающиеся с двоеточия), хоть в Scheme и принято
минимизировать подобный синтаксический шум. \seeEx[macros/ex:repeat] Кроме того,
данный макрос вводит локальную переменную <code><span class="func">loop</span></code>, которая может скрыть одну
из свободных переменных \ii{p}, \ii{q} или \ii{тела}. Истинным любителям циклов
стоит взглянуть на местный Эверест прогресса — макрос <code><span class="func">loop</span></code>, реализация
которого занимает не одну сотню строк, а описанию его посвящена целая глава
стандарта: \cite[глава 26]{ste90}.</p>

<p>К сожалению, как и множество других непростых и хитроумных концепций, макросы
легко могут стать неуправляемыми. Цель данной главы — осознать их недостатки
и обнаружить их преимущества. Для этого мы попытаемся логически воссоздать
макросы, чтобы добраться до корня их проблем и причин их разнообразия.</p>

<h2 id="macros/sect:preparation">Подготовка</h2>


<!--\indexR{подготовка программ}-->
<!--\indexR{исполнение программ}-->
<!--\indexR{программы!этапы обработки}-->
<p>Рассмотренные в предыдущих главах интерпретаторы разделяют обработку программ
на две фазы: <em class="term">подготовку</em> (в терминологии <span class="logo">ISLisp</span>) и <em class="term">исполнение</em>.
Таким образом, общая схема вычислений похожа на быстрый интерпретатор
\seePage[chapter:fast]: \ic{(run (prepare \ii{выражение}))}. Нечто подобное
выполняет и компилятор \seePage[chapter:compilation], который сначала
преобразует программы в деревья промежуточных инструкций и только по ним уже
генерирует байт-код. Более ранние реализации тоже вполне вписываются в эту
теорию: достаточно считать подготовку тождеством.</p>


<!--\indexR{макросимволы}-->
<p>Сама подготовка также может быть многофазной. Например, все считываемые
выражения изначально являются лишь строками символов, и во многих диалектах
Лиспа существует понятие макросимволов, способных влиять на процесс
синтаксического анализа этих строк и построения соответствующих S-выражений.
Известным примером такого символа является кавычка: она означает, что следующее
считанное выражение должно быть обёрнуто в форму <code><span class="func">quote</span></code>. Можно представить,
что внутри синтаксического анализатора кавычка вызывает выполнение выражения
<code><span class="func">(list (quote quote) (read))</span></code>.</p>


<!--\indexC{read}-->
<!--\indexR{компиляция!фронтенд}-->
<p>Если считывателем Лиспа можно управлять, то функция <code><span class="func">read</span></code> может
адаптироваться под любые нужды. Например, Bigloo <span class="cite">[<a href="z1_bibliography.xhtml#sw94">sw94</a>]</span> при компиляции
исходных файлов, написанных на Caml Light, просто использует соответствующую
функцию для их чтения; единственное требование к ней — она должна возвращать
корректные S-выражения. Фактически, данная функция <code><span class="func">read</span></code> является
фронтендом компилятора Caml Light <span class="cite">[<a href="z1_bibliography.xhtml#lw93">lw93</a>]</span>.</p>

<p>Мы не будем особо касаться макросимволов, так как они всё же являются встроенной
возможностью алгоритма чтения S-выражений, а не самостоятельной конструкцией.</p>

<p>Фаза подготовки нередко является составной частью фазы компиляции. В любом
случае, важно чётко отделять эту фазу от следующей за ней фазы исполнения.
Помните: тесным должно быть взаимодействие компонентов, а не зависимости между
ними. На этой почве возникают два различных варианта понимания подготовки:
<em class="term">многомировой</em> и <em class="term">унитарный</em>.</p>

<h3 id="macros/preparation/ssect:multiple">Множественные миры</h3>


<!--\indexR{подготовка программ!во множественных мирах}-->
<!--\indexR{множественные миры}-->
<!--\indexR{мир!множественный}-->
<!--\indexR{загрузчик}-->
<!--\indexR{компоновка}-->
<p>В этом случае результаты подготовки выражений сохраняются в файлах (обычно
<code><span class="func">*.o</span></code> или <code><span class="func">*.fasl</span></code>). Исполнять такие файлы помогает отдельное приложение
— загрузчик, который нередко по совместительству также занимается управлением
связями между независимо подготовленными выражениями, то есть является
компоновщиком. Большинство популярных языков программирования исповедуют именно
такую модель раздельной компиляции. Её преимуществом является возможность
обработки программ по частям, а также более естественное управление
пространствами имён с помощью разнообразных директив экспорта и импорта. Мы
говорим о множественных мирах, так как подготовленные выражения — это
единственное средство связи между предобработчиком программ и их исполнителем.
Исходные коды программ и исполняемые программы живут в отдельных мирах, которые
лишены возможности влиять друг на друга.
%
{\def\expr#1{\text{\ii{выражение}}_#1}%
\def\prep#1{\text{\ii{подготовленное-выражение}}_#1}%
\def\ARR{\xrightarrow{\:\text{<code><span class="func">prepare</span></code>}\:}}%
\[
    \left.\begin{array}{ccc}
        \expr 0 & \ARR & \prep 0 \\
        \expr 1 & \ARR & \prep 1 \\
        \cdots  & \ARR & \cdots  \\
        \expr n & \ARR & \prep n
    \end{array}\right\}<code><span class="func">run</span></code>
\]}</p>

<h3 id="macros/preparation/ssect:unique">Единый мир</h3>


<!--\indexR{подготовка программ!в едином мире}-->
<!--\indexR{единый мир}-->
<!--\indexR{мир!единый}-->
<!--\indexR{интерактивная сессия (REPL)}-->
<!--\indexE{REPL}-->
<!--\indexR{интерпретатор!командный}-->
<!--\indexR{командный интерпретатор}-->
<!--\indexC{compile-file}-->
<!--\indexC{load}-->
<p>В противоположность многомировой гипотезе, адепты секты единого мира считают
центром вселенной интерактивную сессию, поэтому все вычисления, начавшиеся
в ней, совместно существуют в общей памяти, где нет никаких преград для общения
посредством глобальных разделяемых ресурсов (переменных, списков свойств
и т. п.). Интерактивная сессия связывает воедино процессы чтения выражений, их
подготовки и исполнения. Она часто предстаёт в виде командного интерпретатора,
контролирующего данные процессы. Заметьте, уникальность мира вовсе не означает
строгую последовательность всех происходящих процессов: вполне возможно отложить
исполнение обработанной программы на потом. Во многих лисп-системах существует
функция <code><span class="func">compile-file</span></code>, которая считывает выражения из файла и сохраняет
результат компиляции в другой файл. Выполнить же подготовленные к исполнению
программы можно потом, загрузив их с помощью функции <code><span class="func">load</span></code> или чего-то
подобного. Таким образом, и здесь имеется возможность подготавливать программы
по частям.</p>


<!--\indexR{программы!как среда исполнения кода}-->
<p>Идея единого мира отнюдь не оторвана от реальности. Напротив, она является
взглядом на программы как на среду исполнения кода, подобную операционным
системам вроде \UNIX, где пользователь рассчитывает на некоторое внутреннее
состояние: файловую систему, всевозможные переменные окружения, псевдонимы
команд и т. д., а управляет всем этим с помощью командного интерпретатора
вроде <code><span class="func">bash</span></code> или <code><span class="func">zsh</span></code>.</p>


<!--\indexR{подготовка программ!повторяемость}-->
<p>Как бы то ни было, одним из основных требований к программным системам является
предсказуемость и воспроизводимость результатов. Ожидается, что из одного и
того же исходного кода при одинаковых условиях получается одинаковый исполнимый
код. Это базовая предпосылка, без которой невозможно нормальное использование
данной системы. Множественные независимые миры без проблем ей удовлетворяют:
достаточно проконтролировать все входные данные, а кроме них ничто больше
не может повлиять на систему. В случае единого мира неучтённым остаётся его
внутреннее состояние\footnote{Например, никто не может сказать загодя, какие
переменные окружения выведет <code><span class="func">printenv</span></code>, или что написано в конфигурационных
файлах операционной системы.} вместе со всевозможными способами его изменения.
Такой компилятор постоянно остаётся в памяти, понемногу накапливает вносимые
в него изменения, и мы постепенно теряем над ним контроль.</p>

<p>Подводя итог, подготовка программ обязана быть полностью контролируемым
процессом.</p>

<h2 id="macros/sect:expand">Раскрытие макросов</h2>


<!--\indexC{prepare}-->
<!--\indexC{macroexpand}-->
<!--\indexR{макросы!раскрытие}-->
<!--\indexR{экспандер|see{макроэкспандер}}-->
<!--\indexR{макроэкспандер}-->
<p>Итак, обработка сокращений-макросов выполняется во время подготовки программ,
перед их исполнением. Следовательно, логично будет разделить эту подготовку на
две части: 1) <em>раскрытие</em> макросов, 2) всё остальное. То есть выполнять её
как-то так: \ic{(really-prepare (macroexpand \ii{выражение}))}. Нас интересует
вот эта функция-<em class="term">экспандер</em> <code><span class="func">macroexpand</span></code>, отвечающая за обработку
макросов. Как именно задаётся алгоритм, который она реализует? Возможны два
способа её определения: <em class="term">экзогенный</em> и <em class="term">эндогенный</em>.</p>

<h3 id="macros/expand/ssect:exo">Экзогенный подход</h3>


<!--\indexR{макросы!раскрытие!экзогенное}-->
<!--\indexR{макроэкспандер!экзогенный}-->
<p>Экзогенное раскрытие, как его описывают \cite{qp91b,dps94b}, подразумевает, что
функция <code><span class="func">macroexpand</span></code> предоставляется <em>отдельно</em> от раскрываемого
выражения, например, с помощью специальных директив.\footnote*{Располагаемых,
к примеру, в самом начале файла.} Следовательно, функция <code><span class="func">prepare</span></code> в общих
чертах будет выглядеть так:</p>


<!--\indexCS{prepare}{экзогенная}-->
<pre>(define (prepare expression directives)
  (let ((macroexpand (generate-macroexpand directives)))
    (really-prepare (macroexpand expression)) ) )</pre>

<p>Возможны некоторые вариации этой идеи, которые мы разберём на примере
компилятора в байт-код. \seePage[compilation/separate/ssect:build] Предположим,
в нашем распоряжении есть загрузчик по имени <code><span class="func">run</span></code> и компоновщик
<code><span class="func">build-application</span></code>. Кроме того, пусть имеется исполнимый файл
<code><span class="func">compile.so</span></code>, содержащий компилятор, а экспандеры будем называть
<code><span class="func">expand.so</span></code>.</p>

<p>Раскрытие макросов может происходить каскадом, как показано на верхней части
рисунка \ref{macros/expand/exo/pic:subj}. В таком случае вызов «<code><span class="func">compile
file.scm expand.so</span></code>» соответствует следующей командной строке \UNIX-shell:</p>

<p>\begin{lstlisting}
run expand.so < file.scm | run compile.so > file.so
\end{lstlisting}</p>

<p>\phantomlabel{macros/expand/exo/par:compiler}
<!--\indexR{компиляция!специализация}-->
Также макросы может раскрывать новый, только что синтезированный компилятор
(здесь это <code><span class="func">tmp.so</span></code>), как на нижней половине
рисунка \ref{macros/expand/exo/pic:subj}. Тогда команде «<code><span class="func">compile file.scm
expand.so</span></code>» соответствует</p>

<p>\begin{lstlisting}
build-application compile.so expand.so -o tmp.so;
run tmp.so < file.scm > file.so
\end{lstlisting}</p>

<p>\begin{figure}\centering
\input{figures/fig9.1}
\caption{Два варианта экзогенной компиляции. Пятиугольники обозначают исполнимые
бинарные файлы.}%
\label{macros/expand/exo/pic:subj}
\end{figure}</p>


<!--\indexR{подготовка программ!обмен информацией}-->
<p>Среди нерешённых проблем остаётся ещё протокол обмена информацией между
экспандером и компилятором. Экспандер принимает исходную программу и возвращает
её с раскрытыми макросами. Он может принимать её буквально как значение, или же
как имя файла, в котором она хранится. Аналогично, возвращать результат
экспандер может как в виде непосредственных S-выражений, так и записав его
в файл и вернув имя этого файла. Обмениваться информацией посредством файлов
ничуть не абсурдно. Компилятор того же языка Си в процессе работы хранит готовые
объектные модули в файлах. Подобный подход позволяет избежать скрытой передачи
информации, так как любое общение выполняется явно и прозрачно через файлы.
В случае обмена информацией посредством S-выражений, для подготовки потребуется
динамически загружать экспандер в память с помощью <code><span class="func">load</span></code> или чего-то
подобного, потому как обмен информацией между программами выполняется напрямую.</p>


<!--\indexR{макросы!композициональность}-->
<!--\indexR{композициональность!макросов}-->
<!--\indexR{макроэкспандер!модульность}-->
<p>Также экспандер не обязательно должен быть монолитным, его вполне можно собрать
как конструктор из меньших блоков, обрабатывающих специфичные макросы. Для этого
потребуется расширить язык директив, чтобы он мог оперировать подобными блоками.
Ещё это означает, что макросы должны быть свободно компонуемыми, что в свою
очередь приводит к необходимости обеспечения ассоциативности и коммутативности
макроопределений.</p>


<!--\indexR{язык!макроэкспандера}-->
<p>Итого, экзогенный подход подразумевает использование отдельного независимого
макроэкспандера для обработки программ. В этом случае мы несомненно обладаем
полным контролем над процессом раскрытия макросов, а также можем быть уверены
в том, что в готовых программах не останется никакого мусора после их раскрытия.
Кстати, полное отделение раскрытия макросов от исполнения программ снимает любые
ограничения на форму и реализацию экспандеров, так как абсолютно не важно, как
они работают внутри, лишь бы возвращали корректные S-выражения. Вполне можно
писать экспандеры на Си++, M4, да хоть на Perl! Тем не менее, Лисп кажется
наиболее адекватным языком для описания алгоритмов обработки S-выражений.
Как видим, экзогенный подход не подразумевает сколь-либо тесной связи между
языком обрабатываемых программ и языком описания макросов. Макроэкспандеру
необходимо только уметь самостоятельно определять в обрабатываемой программе
местонахождение макросов, требующих раскрытия.</p>

<h3 id="macros/expand/ssect:endo">Эндогенный подход</h3>


<!--\indexR{макросы!раскрытие!эндогенное}-->
<!--\indexR{макроэкспандер!эндогенный}-->
<p>Эндогенное раскрытие подразумевает, что вся информация, необходимая для
обработки макросов, содержится <em>в самой</em> программе. Другими словами,
подготовка программ выглядит так:</p>


<!--\indexCS{prepare}{эндогенная}-->
<pre>(define (prepare expression)
  (really-prepare (macroexpand expression)) )</pre>


<!--\indexC{define-macros}-->
<!--\indexC{define-syntax}-->
<!--\indexC{eval}-->
<p>Фундаментальным отличием эндогенного подхода от экзогенного является
предопределённость алгоритма раскрытия макросов; им можно лишь управлять в той
или иной мере. Также задача осложняется тем, что при обработке программы
требуется отыскать в тексте не только макросы для их раскрытия, но и сами
правила раскрытия. Эти правила обычно задаются специальными S-выражениями,
чаще всего формами <code><span class="func">define-macros</span></code> или <code><span class="func">define-syntax</span></code>. Подобные
определения ещё предстоит превратить в функции-экспандеры, обрабатывающие
макросы соответствующим образом. Так, стоп, это что-то знакомое: мы динамически
превращаем исходный текст в исполнимую программу\textdots\ точно, <code><span class="func">eval</span></code>!
В таком подходе определённо есть нечто гениальное: не изобретать специальный
новый язык, а использовать для описания макросов уже готовый Лисп!</p>


<!--\indexE{fexpr@\protect<code><span class="func">fexpr</span></code>}-->
<p>Конечно, как и любая гениальная идея, она имеет свои подводные камни. В тёмные
времена одной из сложнейших для освоения дисциплин оккультных компьютерных
искусств была макрология.\trnote*{«\textsc{Макрология}, \textit{сущ., ж.}
(букв. \textit{многословие} или \textit{макрос} + \textit{учение})
\textbc{1.} Набор обыкновенно сложных или хитроумных макросов, напр., как
составная часть большой программной системы, написанной на Лиспе, TECO или
(реже) ассемблере. \textbc{2.} Искусство и наука постижения смысла макрологий
в значении 1 (ср. археология, экология, теология)» — The Jargon File.}
Фактически, именно это отождествление языков затрудняет понимание истинной
природы макросов. Долгое время они считались чем-то вроде особых функций,
имеющих странный протокол вызова, в соответствии с которым вычислению подлежали
не аргументы, а возвращаемое значение. Эта модель, несмотря на всё её удобство
при интерпретации, была отвергнута ввиду сложностей, которые она вызывает для
компиляторов, а также по иным причинам, описанным Кентом Питманом
в статье <span class="cite">[<a href="z1_bibliography.xhtml#pit80">pit80</a>]</span>. В современном понимании, макросы — это правила
преобразования определённых сокращений в соответствующие им полные конструкции
целевого языка.</p>


<!--\indexR{язык!макроэкспандера}-->
<!--\indexE{Scheme!язык описания экспандеров}-->
<!--\indexC{define-syntax}-->
<!--\indexC{syntax-rules}-->
<!--\indexC{define-abbreviation}-->
<p>Выбор Лиспа в качестве языка описания макросов оспаривается апологетами
ограниченного подхода, считающими, что макросы должны уметь лишь манипулировать
заранее написанным кодом, а не создавать его сами. Именно такие макросы
реализуют <code><span class="func">define-syntax</span></code>\slash<code><span class="func">syntax-rules</span></code> из \RnRS. Конечно, в таком
случае они обладают несколько меньшей выразительной силой, а некоторые
преобразования не могут описать в принципе, но зато простые макросы (коих
большинство) становятся гораздо понятнее. Несмотря на то, что в данной книге
более мощная форма <code><span class="func">define-abbreviation</span></code>\footnote{Столь экзотическое имя
выбрано с целью избежать противоречивых ассоциаций с конструкцией
<code><span class="func">define-macros</span></code>, присутствующей во многих реализациях Лиспа и Scheme.}
используется чаще, лишь 5 макроопределений из порядка 50 используют её
возможности, выходящие за рамки <code><span class="func">define-syntax</span></code>. И даже из этих пяти только
три макроса — фундаментальные определения {\Meroonet}: <code><span class="func">define-class</span></code>,
<code><span class="func">define-generic</span></code> и <code><span class="func">define-method</span></code>), — принципиально нельзя реализовать
по-другому.</p>

<p>Короче говоря, не важно, задаём ли мы алгоритм раскрытия явно или параметризуем
готовый, в обоих случаях Лисп кажется наиболее подходящим языком для описания
этого алгоритма. Но в отличие от экзогенного, эндогенный экспандер должен
содержать внутри себя вычислитель; это его характерная особенность. Однако
помните, что не следует смешивать язык описания макросов с языком обрабатываемой
программы: они связаны, но не тождественны. В старых руководствах часто
писалось, что макросы реализуются с помощью двукратных вычислений; их авторы
грешат упущением того, что эти вычисления проводятся различными вычислителями.</p>

<p>\begin{figure}\centering
\input{figures/fig9.2}
\caption{Экзогенное (слева) и эндогенное (справа) раскрытие макросов.}%
\label{macros/expand/endo/pic:comparison}
\end{figure}</p>

<h2 id="macros/sect:calling">Макровызовы</h2>


<!--\indexR{грамматика!расширяемость}-->
<p>Макроэкспандер должен отыскать в обрабатываемой программе все макросы, требующие
раскрытия. Некоторые языки (например, <span class="cite">[<a href="z1_bibliography.xhtml#car93">car93</a>]</span>) имеют тонко настраиваемые
синтаксические анализаторы, позволяющие дополнять грамматику языка новыми
формами напрямую. Добавить макрос там так же легко, как описать новый оператор:
всего пара строк с его символом и арностью, информацией о том, префиксный он,
инфиксный или постфиксный, плюс указание его приоритета.</p>


<!--\indexR{функциональный терм}-->
<!--\indexR{терм!функциональный}-->
<!--\indexR{макровызовы}-->
<!--\indexR{вызов!макроса}-->
<p>Программы на Лиспе состоят из форм, записываемых S-выражениями, где основную
смысловую нагрузку несёт их <code><span class="func">car</span></code> — функциональный терм, — поэтому
часто применяется следующий подход: список, первый элемент которого является
ключевым словом, считается вызовом одноимённого макроса. У такого подхода есть
множество преимуществ: он прост, расширяем и согласуется со всем остальным
синтаксисом. Имя сокращения (макроса) ассоциируется с функцией (экспандером).
В итоге получается весьма простой алгоритм раскрытия макросов: рекурсивно
обходим обрабатываемое выражение в поисках ключевых слов; если натыкаемся на
такое слово, то определяем соответствующий ему экспандер и применяем его
к S-выражению, требующему раскрытия. В <code><span class="func">cdr</span></code> этого S-выражения находится
всё, что надо экспандеру для успешной работы.</p>


<!--\indexR{макросимволы}-->
<p>Также можно вспомнить о макросимволах, присутствующих, например,
в <span class="logo">Common Lisp</span>. Они связывают вызов экспандера с одним символом, а не с целой
формой. Это позволяет избавиться от излишних скобок, если макрос применяется
к чему-то короткому вроде имени переменной.</p>


<!--\indexR{пространства имён}-->
<p>Таким образом, макрос можно понимать как функцию-экспандер, связанную
с некоторым именем, приводящим к её вызову. Похоже, для подобных привязок
потребуется собственное пространство имён. Однако помните, что макрос — это
не привязка, функция или ключевое слово сами по себе, это триединая сущность
внутри макроэкспандера. Кстати, раз это всё же пространство имён, нелишним будет
иметь возможность определять как глобальные макросы, так и локальные: например,
с помощью <code><span class="func">define-abbreviation</span></code> и <code><span class="func">let-abbreviation</span></code>.</p>


<!--\indexR{грамматика!для макроэкспандера}-->
<!--\indexR{макроэкспандер}-->
<!--\indexR{программы!как данные}-->
<!--\indexR{значения!как программы}-->
<p>Задачей функции-экспандера является превращение S-выражения в корректную
программу. Следовательно, она ищет макросы в S-выражениях, а не программах.
Конечно, некоторые части S-выражений действительно являются программами; да и
синтаксис вызова макросов напоминает вызов функции. Но по сути это лишь
S-выражения. Ничто не запрещает экспандеру трактовать некорректную форму
<code><span class="func">(foo . 5)</span></code> как сокращение для <code><span class="func">(vector-ref foo 5)</span></code>!</p>

<p>Проблема здесь в том, что грамматика S-выражений гораздо менее ограничена, чем
грамматика программ. Это вызывает некоторые затруднения, касающиеся приоритета
макросов над другими конструкциями. Если <code><span class="func">bar</span></code> это макрос, а <code><span class="func">lambda</span></code> нет,
то требует ли раскрытия форма <code><span class="func">(bar 34)</span></code> в выражении <code><span class="func">((lambda (bar)
(bar 34)) ...)</span></code>? Здесь источником проблем является локальная переменная
<code><span class="func">bar</span></code>. Должна ли она скрывать одноимённый макрос <code><span class="func">bar</span></code>? \RnRS, к примеру,
считает, что должна. Тот же вопрос касается цитат: надо ли раскрывать <code><span class="func">bar</span></code>
в выражении <code><span class="func">(quote (bar 34))</span></code>?</p>

<p>Таким образом, в алгоритм обхода S-выражений наверняка потребуется внести
определённые доработки, дабы ограничить места, где допустимо применение
макросов. Например, можно ли писать <code><span class="func">(let (foo) ...)</span></code>, где <code><span class="func">(foo)</span></code> —
это макровызов, генерирующий список локальных переменных? Или, к примеру,
<code><span class="func">(cond (foo) ...)</span></code>, или <code><span class="func">(case key (foo) ...)</span></code>? В Лиспе правила хорошего
тона предписывают определять и использовать макросы таким образом, чтобы они
были максимально похожи на функции. Тогда не особо важно, что именно скрывается
за <code><span class="func">(bar ...)</span></code> — макрос или функция.</p>

<h2 id="macros/sect:expandes">Экспандеры</h2>


<!--\indexR{макроэкспандер!варианты реализации}-->
<p>А что насчёт экспандеров? Какой контракт должны соблюдать они? Есть по меньшей
мере два возможных варианта.</p>


<!--\indexR{макроэкспандер!классический подход}-->
<p><em class="term">Классический</em> подход подразумевает, что выражения, возвращаемые
экспандером, всё ещё могут содержать нераскрытые макросы. Поэтому их необходимо
повторно прогонять через другие экспандеры до полного раскрытия. Если функция
<code><span class="func">find-expander</span></code> возвращает экспандер, соответствующий имени макроса, то
макровызов \ic{(foo . \ii{expr})} раскрывается следующим образом:</p>


<!--\indexCS{macroexpand}{классический}-->
<pre>(macroexpand '(foo . |\ii{expr}|)) |$\leadsto$|
   |$\leadsto$| (macroexpand ((find-expander 'foo) '(foo . |\ii{expr}|)))</pre>


<!--\indexE{EPS}-->
<!--\indexR{макроэкспандер!EPS-подход}-->
<p>Есть и другой, более сложный подход, называемый в <span class="cite">[<a href="z1_bibliography.xhtml#dfh88">dfh88</a>]</span> «<em>стилем
передачи раскрытий</em>» (\english{expansion passing style}, EPS) по аналогии
со стилем передачи продолжений. Идея в том, что экспандер обязан вернуть
полностью готовое выражение, лишённое нераскрытых макросов. Таким образом,
рекурсивные вызовы <code><span class="func">macroexpand</span></code> снаружи переносятся внутрь самих
экспандеров. Для этого, очевидно, экспандеры должны сами вызывать функцию
<code><span class="func">macroexpand</span></code>, а значит, им необходимо как-то получить к ней доступ. Можно
было бы просто сделать <code><span class="func">macroexpand</span></code> глобальной, но есть более искусное
решение, которое и является сутью EPS. Можно передавать <code><span class="func">macroexpand</span></code> как
аргумент экспандерам, что одновременно решает проблему рекурсивных вызовов, а
также значительно облегчает введение локальных макроопределений. В терминах
Лиспа это выглядит так:</p>


<!--\indexCS{macroexpand}{EPS}-->
<pre>(macroexpand '(foo . |\ii{expr}|)) |$\leadsto$|
   |$\leadsto$| ((find-expander 'foo) '(foo . |\ii{expr}|) macroexpand)</pre>


<!--\indexC{macrolet}-->
<!--\indexC{macroexpand}-->
<!--\indexR{макросы!локальные}-->
<p>Эти два подхода к раскрытию макросов — классический и EPS —
не эквивалентны. Очевидно, EPS более мощный, так как классическое раскрытие
можно выразить через EPS, но не наоборот. Существенным отличием между
ними является способ реализации локальных макросов. Допустим, мы хотим
определить макрос, локальный для какого-либо подвыражения. В EPS достаточно при
обработке этого подвыражения передать экспандеру расширенный вариант
<code><span class="func">macroexpand</span></code>, учитывающий новые определения. В языках, реализующих
классический подход (в <span class="logo">Common Lisp</span>, к примеру) эта задача решается сложнее:
специальный макрос <code><span class="func">macrolet</span></code> изменяет внутреннюю структуру <code><span class="func">macroexpand</span></code>,
добавляя туда локальные определения, затем он выполняет раскрытие подвыражения,
после чего вновь изменяет структуру <code><span class="func">macroexpand</span></code>, убирая оттуда введённые
ранее определения. Форма <code><span class="func">macrolet</span></code> является примитивом в том смысле, что её
невозможно определить самостоятельно, если её нет в языке изначально. Более
того, вся система становится гораздо более хрупкой, если не только <code><span class="func">macrolet</span></code>
позволено модифицировать <code><span class="func">macroexpand</span></code>. EPS не ведомы эти проблемы, так как
вводимые локальные макросы всегда остаются локальными и могут свободно скрывать
и переопределять внешние. Всё зависит только от новой функции, которая будет
передана внутрь вместо <code><span class="func">macroexpand</span></code>. В <span class="cite">[<a href="z1_bibliography.xhtml#dfh88">dfh88</a>]</span> приведено множество
примеров применения данного подхода для реализации каррирующих и трассирующих
макросов.</p>


<!--\indexR{преобразование!в коробочный стиль}-->
<!--\indexR{коробки!преобразование}-->
<!--\indexR{преобразование!локальность}-->
<p>Большая часть макросов действует локально, то есть выполняет простую замену
одного текста другим. Важным свойством EPS является возможность лёгкой
модификации текущего экспандера, что позволяет выражать некоторые трансформации
проще, чем при классическом подходе. Например, вспомните преобразование программ
в «коробочный стиль». \seePage[assignment/assignment/ssect:boxes] Это
преобразование легко реализуется с помощью двойного обхода кода: на первом
проходе составляем список локальных изменяемых переменных, а на втором заменяем
все обращения к ним соответствующими операции с коробками. EPS позволяет
записать это легко и просто, буквально используя два разных экспандера: первый
ничего не раскрывает, а только запоминает информацию для второго, который потом
выполнит всё работу. Классический же подход и его намертво вшитый экспандер
не позволяют такой гибкости, так что обход кода приходится реализовывать
вручную, а не использовать уже готовую инфраструктуру.</p>


<!--\indexC{with-quotations-extracted}-->
<p>Однако, EPS не всемогущ; существуют трансформации, которые и ему не по силам.
\seePage[assignment/quotation/par:transform] Перенос цитат не является локальным
действием, так как здесь требуется вместо цитат подставить обращения
к глобальным переменным. C заменой выражений проблем-то нет, но ведь эти
переменные ещё надо создать (вставив глобальные <code><span class="func">define</span></code> в подходящем месте),
а это мало похоже на локальные изменения! Правда, здесь можно выкрутиться,
обернув всю программу в макрос (скажем, <code><span class="func">with-quotations-extracted</span></code>), который
раскрывается в определения значений цитат, за которыми следует обработанная
программа.</p>

<p>Существуют и другие макросы, которым необходимо создавать глобальные переменные,
например, макрос <code><span class="func">define-class</span></code> в {\Meroonet}. Синтаксис Scheme не запрещает
его использование внутри <code><span class="func">let</span></code>-форм, но семантика данного макроса
подразумевает создание глобальной переменной, которая содержит объект,
описывающий определяемый класс. Такие задачи обычно нельзя решить, оставаясь
в рамках макросистемы, так что <code><span class="func">define-class</span></code> вынужден быть или специальной
формой, или же макросом, использующим внутренние (intrinsic) функции реализации
для достижения необходимого эффекта.</p>

<p>Однако, если EPS настолько хорош, то почему он так редко используется?
Во-первых, его сложнее реализовать, но главная причина не в этом. Вспомните, что большая
часть макросов проста по своей сути, а значит, более мощный и сложный механизм
их раскрытия по сути ничего не даст, кроме замедления работы.
В действительности, классический подход обладает существенным преимуществом: он
однопроходен. Однажды раскрытые выражения, не начинающиеся на ключевое слово,
больше никогда не будут просматриваться, так как гарантированно являются
вызовами функций. EPS же позволяет экспандерам просматривать обрабатываемое
выражение несколько раз, руководствуясь различными правилами раскрытия, что
приводит к замедлению работы и усложнению понимания выполняемых ими
трансформаций.</p>

<h2 id="macros/sect:accept">Приемлемость результатов раскрытия</h2>


<!--\indexR{бесконечный цикл}-->
<p>Одним из пунктов контракта экспандеров является требование, чтобы возвращаемый
ими результат был корректной программой, готовой для последующей предобработки.
В программе не должно быть нераскрытых макросов; иными словами, это должна быть
такая же программа, как если бы она была набрана вручную. На пути к этой светлой
цели нас подстерегают несколько ловушек. Во-первых, раскрытие макросов — это
некоторые вычисления, а вычисления иногда могут никогда не заканчиваться, что,
согласитесь, несколько мешает получению готовых программ. Загнать компилятор
в бесконечный цикл непросто, но если вам удалось, то понимайте это как плату
за истинно неограниченные выразительные возможности макросистемы.</p>

<p>Один из лёгких способов попасть в бесконечный цикл — попытаться наивно
определить макрос через самого себя. Как, например, в следующем определении
макроса <code><span class="func">while</span></code>:</p>

<pre>(define-abbreviation (while condition . body)
  `(if ,condition (begin (begin . body)
                         (while ,condition . ,body) )) )</pre>

<p>Помните, что в конце концов экспандер должен вернуть нормальную программу,
поэтому после первого раскрытия макроса <code><span class="func">while</span></code> он продолжит раскрывать
макросы в получившемся коде, а там его ждёт ещё один <code><span class="func">while</span></code>, а внутри него
— ещё один, и так далее.</p>

<p>В <span class="logo">Common Lisp</span> допустить аналогичную ошибку гораздо проще благодаря ключевому
слову <code><span class="func">\&whole</span></code>. С его помощью макрос может получить исходную форму, которая
вызвала его раскрытие, но её недальновидное использование приводит к печальным
последствиям.</p>

<pre>(defmacro while (&whole call)    |\dialect<span class="logo">Common Lisp</span>|
  (let ((condition (cadr call))
        (body      (cddr call)))
    `(if ,condition (begin (begin . ,body) ,call)) ) )</pre>


<!--\indexR{мемоизация}-->
<!--\indexR{макросы!раскрытие!мемоизация}-->
<!--\indexR{циклические структуры данных}-->
<p>Многие интерпретаторы выполняют раскрытие макросов на лету, сразу же после
считывания S-выражений. При этом часто с целью оптимизации все макровызовы
физически заменяются результатами раскрытия: это позволяет не дёргать
макроэкспандер при каждом вызове функции, содержащей макросы. В таком случае
предыдущий макрос <code><span class="func">while</span></code> сгенерировал бы циклическое S-выражение, которое,
в принципе, будет понятно интерпретаторам, но может вызвать затруднения
у компиляторов, так как обычно они рассчитаны на работу исключительно
с направленными ациклическими графами (деревьями, ветви которых могут
сращиваться) <span class="cite">[<a href="z1_bibliography.xhtml#que92a">que92a</a>]</span>. После преобразования макрос <code><span class="func">while</span></code> будет
выглядеть так:</p>

<pre>(defmacro while (&whole call)    |\dialect<span class="logo">Common Lisp</span>|
  (let ((condition (cadr call))
        (body      (cddr call)) )
    (setf (car call) 'if)
    (setf (cdr call) `(,condition (begin (begin . ,body) ,call)))
    call ) )</pre>

<p>Подобные проблемы с циклами возможны и в цитатах; они тоже могут вынуждать
некоторые компиляторы надолго задуматься. \seePage[assignment/sect:quotation]</p>


<!--\indexR{внешнее представление}-->
<!--\indexC{read}-->
<!--\indexR{цитаты!внешнее представление}-->
<!--\indexR{макросы!золотое правило}-->
<!--\indexR{золотое правило макросов}-->
<p>Ещё одним источником ошибок, часто даже более опасным, чем циклы, могут быть
макросы, содержащие значения, вычисляемые во время раскрытия. Порядочные
программисты строго соблюдают обет: никогда не писать макросы, раскрывающиеся
в код, который невозможно написать вручную. Такое соглашение подразумевает
наличие у программ некоторой письменной формы. В Scheme данная форма называется
<em class="term">внешним представлением</em>; любые цитаты (и вообще всё, что может прочитать
функция <code><span class="func">read</span></code>) обязаны записываться во внешнем представлении.</p>

<p>Давайте взглянем на особо поучительный пример цитирования значения, не имеющего
внешнего представления. Следующий макрос возвращает процитированное продолжение
собственного раскрытия:</p>


<!--\indexC{incredible}-->
<pre>(define-abbreviation (incredible x)
  (call/cc (lambda (k) `(quote (,k ,x)))) )</pre>


<!--\indexR{продолжения (continuations)}-->
<p>И что, по-вашему, эта тарабарщина означает? Давайте подумаем логически. Записать
результат раскрытия в файл нельзя, так как у продолжений нет внешнего
представления. Активировать это продолжение тоже вряд ли получится\textdots\
Что вообще должно происходить при активации продолжения, захваченного
<em>в другом</em> процессе? Ведь это то же самое, что во время работы приложения
<code><span class="func">a.out</span></code> начать выполнять нечто, что делалось после вызова компилятора
«<code><span class="func">cc main.c</span></code>», результатом работы которого стало данное приложение.
Конечно, в некотором смысле <code><span class="func">call/cc</span></code> можно считать машиной времени, но
не буквально же! Раз на эти вопросы нельзя дать однозначные ответы, то нам
остаётся лишь воспользоваться своим правом разработчика и объявить подобные
программы ошибочными.</p>

<p>Не только продолжения приводят к таким курьёзам. Напрямую нельзя также
записывать примитивы, замыкания, порты ввода-вывода. Всё это следует запретить;
даже если <code><span class="func">(',(lambda (y) car) x)</span></code>, или <code><span class="func">`(',car x)</span></code>, или <code><span class="func">(f
',(current-output-port))</span></code> не вызывают никаких проблем у интерпретаторов.</p>

<p>И напоследок, золотое правило макросов ещё раз: не генерировать программы,
которые нельзя написать вручную.</p>

<h2 id="macros/sect:define">Определение макросов</h2>


<!--\indexC{define-syntax}-->
<!--\indexC{let-syntax}-->
<!--\indexC{letrec-syntax}-->
<!--\indexC{defmacro}-->
<!--\indexC{macrolet}-->
<!--\indexC{define-abbreviation}-->
<!--\indexC{let-abbreviation}-->
<p>Существует множество форм, определяющих глобальные и локальные макросы (об их
области видимости мы поговорим позже, в разделе \ref{macros/sect:scope}).
В Scheme это <code><span class="func">define-syntax</span></code>, <code><span class="func">letrec-syntax</span></code> и <code><span class="func">let-syntax</span></code>;
в <span class="logo">Common Lisp</span> — <code><span class="func">defmacro</span></code> и <code><span class="func">macrolet</span></code>; в этой книге —
<code><span class="func">define-abbreviation</span></code> и <code><span class="func">let-abbreviation</span></code>.</p>

<p>Определить макрос — значит создать соответствующий ему экспандер и
зарегистрировать его в качестве обработчика данного макроса. Код экспандеров
записывается на специальном макроязыке, обычно диалекте Лиспа. Теперь давайте
проанализируем, как различные миры и подходы, рассмотренные ранее, влияют на
процесс определения макросов.</p>

<h3 id="macros/define/ssect:multiple">Множественные миры</h3>

<p>Напомним, здесь раскрытие макросов и исполнение результатов раскрытия происходят
в отдельных, непересекающихся мирах, не имеющих общей памяти.</p>

<h4 id="macros/define/multiple/sssect:endogeny">Эндогенный подход</h4>


<!--\indexR{подготовка программ!во множественных мирах}-->
<!--\indexR{множественные миры}-->
<!--\indexR{мир!множественный}-->
<!--\indexR{макросы!раскрытие!эндогенное}-->
<!--\indexR{макроэкспандер!эндогенный}-->
<!--\indexR{макроопределения!как синтаксические маркеры}-->
<p>Эндогенный подход подразумевает, что определение макроса (в нашем случае это
форма <code><span class="func">define-abbreviation</span></code>) на лету переводится в исполнимый код экспандера
с помощью явного вычислителя, реализующего макроязык. Таким образом, ключевое
слово <code><span class="func">define-abbreviation</span></code> — это синтаксический маркер для обработчика,
указывающий местоположение макроопределений. Следующая программа является
наивной иллюстрацией эндогенной стратегии раскрытия макросов:</p>


<!--\indexC{naive-endogenous-macroexpander}-->
<!--\indexC{install-macro"!}-->
<!--\indexE{macros@\protect<code><span class="func">*macros*</span></code>}-->
<pre>(define *macros* '())</p>

<p>(define (install-macro! name expander)
  (set! *macros* (cons (cons name expander) *macros*)) )</p>

<p>(define (naive-endogenous-macroexpander exps)
  (define (macro-definition? exp)
    (and (pair? exp)
         (eq? (car exp) 'define-abbreviation) ) )
  (if (pair? exps)
      (if (macro-definition? (car exps))
          (let* ((def       (car exps))
                 (name      (car (cadr def)))
                 (variables (cdr (cadr def)))
                 (body      (cddr def)) )
            (install-macro! name (macro-eval
                                  `(lambda ,variables . ,body) ))
            (naive-endogenous-macroexpander (cdr exps)) )
          (let ((exp (expand-expression (car exps) *macros*)))
            (cons exp (naive-endogenous-macroexpander (cdr exps))) ) )
      '() ) )</pre>

<p>Эта функция принимает список выражений (считанный из подготавливаемого файла) и
последовательно их обрабатывает, глядя в глобальную переменную <code><span class="func">*macros*</span></code>,
которая хранит текущие объявленные макросы. Собственно раскрытие выполняется
функцией <code><span class="func">expand-expression</span></code>. Если экспандер в процессе работы натыкается на
определение макроса, то оно тут же обрабатывается и помещается в <code><span class="func">*macros*</span></code>.
За создание тела нового экспандера отвечает вычислитель <code><span class="func">macro-eval</span></code>. Он
может отличаться от обычного <code><span class="func">eval</span></code>, ведь язык описания макросов
не обязательно совпадает с целевым языком экспандера. Макросы и обрабатываемые
ими программы принадлежат различным, абсолютно независимым мирам. Следующий
пример отлично иллюстрирует это утверждение.</p>

<p>\ForLayout{display}{\vskip-0.5\baselineskip}</p>


<!--\indexC{fact}-->
<p>\begin{code:lisp-framed}[title={\snippet{si/chap9b.scm}},label={src:chap9b.scm}]
(define (fact1 n)
  (if (= n 0) 1
      (* n (fact1 (- n 1))) ) )</p>

<p>(define-abbreviation (factorial n)
  (define (fact2 n)
    (if (= n 0) 1
        (* n (fact2 (- n 1))) ) )
  (if (and (integer? n) (> n 0))
      (fact2 n)
      `(fact1 ,n) ) )</p>

<p>(define (some-facts)
  (list (factorial 5) (factorial (+ 3 2))) )
\end{code:lisp-framed}</p>

<p>При эндогенном задании экспандеров нехорошо путать определения <code><span class="func">fact1</span></code> и
<code><span class="func">fact2</span></code>, так как <code><span class="func">fact1</span></code> для экспандера это всего лишь набор
S-выражений, а не функция; такой функции во время раскрытия макросов вообще
не существует. Поэтому <code><span class="func">factorial</span></code> определяет необходимый ему <code><span class="func">fact2</span></code>
самостоятельно. В итоге, после раскрытия мы получаем следующее:</p>

<p>\begin{code:lisp-framed}[title={\snippet{si/chap9b.escm}}]
(define (fact1 n)
  (if (= n 0) 1
      (* n (fact1 (- n 1))) ) )</p>

<p>(define (some-facts)
  (list 120 (fact1 (+ 3 2))) )
\end{code:lisp-framed}</p>

<p>Можно было бы сделать этот пример более запутанным, назвав <code><span class="func">fact1</span></code> и
<code><span class="func">fact2</span></code> просто <code><span class="func">fact</span></code>. Это немного затруднит восприятие кода
<code><span class="func">factorial</span></code> человеком, но не вызовет принципиальных проблем у экспандера, так
как различные упоминания переменной <code><span class="func">fact</span></code> чётко разделены: в одном месте
это имя будет означать локальную переменную макроса, существующую только
во время его раскрытия, а в другом — глобальную переменную <code><span class="func">fact</span></code>,
существующую во время исполнения программы.</p>


<!--\indexR{макросы!раскрытие!двухпроходное}-->
<p>Эндогенный подход, конечно, допускает некоторые вариации. Иногда раскрытие
выполняется в два прохода: сначала из программы извлекаются все
макроопределения, а на втором проходе уже выполняется раскрытие. Такой вариант
может работать неправильно, если макросам позволяется определять другие макросы,
потому что новые определения, получающиеся при раскрытии, могут быть
проигнорированы. Также здесь возникает возможность использовать макросы до их
определения в программе, что слегка сбивает с толку. При последовательной
обработке слева направо подобные затруднения отсутствуют в принципе.</p>

<p>Другой интересной (и весьма часто встречающейся) вариацией является реализация
<code><span class="func">define-abbreviation</span></code> как примитивного макроса.</p>

<p>
\subsubsection{Экзогенный подход}\label{macros/define/multiple/sssect:exogeny}</p>


<!--\indexR{подготовка программ!во множественных мирах}-->
<!--\indexR{множественные миры}-->
<!--\indexR{мир!множественный}-->
<!--\indexR{макросы!раскрытие!экзогенное}-->
<!--\indexR{макроэкспандер!экзогенный}-->
<!--\indexR{макроопределения!как предопределенные макросы}-->
<p>При экзогенном подходе определения макросов отделены от обрабатываемой
программы. Допустим, они могут быть отделены и друг от друга: то есть макросы
можно независимо друг от друга определять в разных модулях, а не обязательно все
в одном месте. Один из вариантов реализации такого поведения — специальный
макрос, который определяет макросы. Назовём его <code><span class="func">define-abbreviation</span></code>, вот
его метациклическое определение:</p>


<!--\indexC{define-abbreviation}-->
<!--\indexC{install-macro"!}-->
<pre>(define-abbreviation (define-abbreviation call . body)
  `(install-macro! ',(car call) (lambda ,(cdr call) . ,body)) )</pre>

<p>Задачей этого макроса является установка нового определения в макросистему.
Пусть для этой цели определена функция <code><span class="func">install-macro!</span></code>. Такой подход
несколько усложняет раскрытие макросов, так как определяются они в одном месте,
а используются в другом. Предположим, у нас есть следующий модуль:</p>

<p>\ForLayout{display}{\vskip-0.5\baselineskip}</p>


<!--\indexC{fact}-->
<p>\begin{code:lisp-framed}[title={\snippet{si/chap9c.scm}}]
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )</p>

<p>(define-abbreviation (factorial n)
  (if (and (integer? n) (> n 0))
      (fact n)
      `(fact ,n) ) )
\end{code:lisp-framed}</p>

<p>\noindent
После раскрытия макросов он выглядит так:</p>

<p>\begin{code:lisp-framed}[title={\snippet{si/chap9c.escm}}]
(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )</p>

<p>(install-macro! 'factorial
  (lambda (n) (if (and (integer? n) (> n 0))
                  (fact n)
                  `(fact ,n) )) )
\end{code:lisp-framed}</p>

<p>Теперь используем макрос <code><span class="func">factorial</span></code>, определяемый этим модулем, для
раскрытия макросов в другом модуле, где определяется функция <code><span class="func">some-facts</span></code>:</p>

<p>\begin{code:lisp-framed}[title={\snippet{si/chap9d.scm}}]
(define (some-facts)
  (list (factorial 5) (factorial (+ 2 3))) )
\end{code:lisp-framed}</p>

<p>\noindent
Мы получим следующий результат:</p>

<p>\begin{code:lisp-framed}[title={\snippet{si/chap9d.escm}}]
(define (some-facts)
  (list 120 (fact (+ 2 3))) )
\end{code:lisp-framed}</p>

<p>Первая ссылка на <code><span class="func">fact</span></code> в макросе <code><span class="func">factorial</span></code> затруднений не вызывает, это
очевидный вызов глобальной функции, определяемой в этом же модуле
<code><span class="func">si/chap9c.scm</span></code>. Второе упоминание имени <code><span class="func">fact</span></code> происходит уже в модуле
<code><span class="func">si/chap9d.escm</span></code>. Вот и первая проблема: переменная <code><span class="func">fact</span></code>-то свободна
в макросе <code><span class="func">factorial</span></code>: он на неё ссылается, но сам её ни с чем не связывает,
а ведь такой переменной может и вовсе не быть в модуле <code><span class="func">si/chap9d.escm</span></code>!</p>

<p>Простое решение заключается в подключении к <code><span class="func">si/chap9d.scm</span></code> модуля,
содержащего нужное определение. У нас пока есть только один подходящий модуль
— <code><span class="func">si/chap9c.scm</span></code>. Но если подключить его, то это приведёт к повторному
определению макроса <code><span class="func">factorial</span></code>, которому здесь не место. Более того, это
определение будет ещё и ошибочным, если функция <code><span class="func">install-macro!</span></code>
в пользовательском коде означает что-то другое или вовсе не существует.</p>


<!--\indexR{библиотека!макросов}-->
<p>Попробуем улучшить данное решение. Для этого необходимо разобраться
с зависимостями, возникающими между макросами и различными библиотеками;
особенно, <em>особенно</em> с тем, на каких этапах исполнения программы они
возникают. Макросы сложны отчасти потому, что требуют хорошего понимания
последовательности всех выполняемых действий. Вернёмся к примеру с <code><span class="func">fact1</span></code>,
<code><span class="func">fact2</span></code> и <code><span class="func">factorial</span></code>. Во время раскрытия макроса <code><span class="func">factorial</span></code>
экспандеру необходима функция <code><span class="func">fact2</span></code>. Результату же раскрытия для успешной
работы необходима функция <code><span class="func">fact1</span></code>. Будем говорить, что функция <code><span class="func">fact1</span></code>
принадлежит библиотеке <em class="term">времени исполнения</em> макроса <code><span class="func">factorial</span></code>, а
<code><span class="func">fact2</span></code> — библиотеке <em class="term">времени раскрытия</em> <code><span class="func">factorial</span></code>. Эти
библиотеки полностью независимы. Действительно, библиотека времени раскрытия
нужна только во время раскрытия, а библиотека времени исполнения — только
во время исполнения кода уже раскрытого макроса.</p>

<p>Итак, решение сводится к тому, что макросы и их библиотека времени раскрытия
определяются в одном модуле: <code><span class="func">si/libexp</span></code>, а все функции библиотеки времени
исполнения — в другом: <code><span class="func">si/librun</span></code>. \seeEx[macros/ex:study] На примере
факториала, раз:</p>

<p>\ForLayout{display}{\vskip-0.5\baselineskip}</p>

<p>\begin{code:lisp-framed}[title={\snippet{si/libexp.scm}}]
(define (fact2 n)
  (if (= n 0) 1
      (* n (fact2 (- n 1))) ) )</p>

<p>(define-abbreviation (factorial n)
  (if (and (integer? n) (> n 0))
      (fact2 n)
      `(fact1 ,n) ) )
\end{code:lisp-framed}</p>

<p>\noindent и два:</p>

<p>\begin{code:lisp-framed}[title={\snippet{si/librun.scm}}]
(define (fact1 n)
  (if (= n 0) 1
      (* n (fact1 (- n 1))) ) )
\end{code:lisp-framed}</p>

<p>Во время предобработки директивы анализируются, и компилятор делает заметку, что
для раскрытия макроса <code><span class="func">factorial</span></code> ему потребуется загрузить библиотеку
<code><span class="func">si/libexp</span></code>, а к готовому приложению должна быть подключена <code><span class="func">si/librun</span></code>.
Таким образом, ресурсы используются только тогда, когда они
действительно необходимы (дальнейшее развитие идеи см. в <span class="cite">[<a href="z1_bibliography.xhtml#dps94b">dps94b</a>]</span>). Итог
подведён на рисунке \ref{macros/define/multiple/exogeny/pic:lib-compile}:
сначала собираются необходимые библиотеки, затем программа компилируется и
связывается с макробиблиотекой времени исполнения, а библиотека времени
раскрытия выбрасывается за ненадобностью.</p>

<p>\begin{figure}[tb]
\centering
\input{figures/fig9.3}
\caption{Сборка приложения во множественных мирах.}%
\label{macros/define/multiple/exogeny/pic:lib-compile}
\end{figure}</p>

<h3 id="macros/define/ssect:unique">Единый мир</h3>


<!--\indexR{подготовка программ!в едином мире}-->
<!--\indexR{единый мир}-->
<!--\indexR{мир!единый}-->
<p>После предыдущего раздела вам может показаться, что во всём виновата
множественность миров и достаточно просто их объединить. Как бы не так!</p>

<p>В едином мире выражения считываются, раскрываются, подготавливаются и
исполняются в общей памяти. Следовательно, состояние макроэкспандера
переплетается с состоянием исполнителя кода. Если применяется эндогенный подход,
то макровычислитель (функцию <code><span class="func">macro-eval</span></code>) логично будет отождествить
с обычным вычислителем <code><span class="func">eval</span></code> (естественно, во всех его вариациях из восьмой
главы). \seePage[chapter:reflection] Так как мир един, то раскрываемые макросы
имеют неограниченный доступ ко всему его содержимому. Верно и обратное, так что
здесь нет особого различия между библиотеками времени исполнения и раскрытия.
Следующий код в едином мире ведёт себя именно так, как ожидается:</p>


<!--\indexC{fact}-->
<pre>(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )</p>

<p>(define-abbreviation (factorial n)
  (if (and (integer? n) (> n 0))
      (fact n)
      `(fact ,n) ) )</pre>


<!--\indexE{tree-shaker}-->
<p>Но есть и ложка дёгтя в бочке мёда: с таким подходом гораздо сложнее передавать
(и продавать) программы, так как трудно, а порой и вовсе невозможно выделить
в программе необходимые для её работы части. Следовательно, если мы хотим
передать программу кому-то другому, то вынуждены передавать её целиком
и полностью, чтобы ничего не забыть. Конечно, существуют специальные анализаторы
зависимостей, называемые <em class="term">tree-shakers</em>, которые могут помочь вытрясти из
программ всё ненужное. Но чаще всего, как видно из множества примеров, доступных
в Интернете, люди воздерживаются от включения экспортируемых макросов в готовые
приложения: код предоставляется либо полностью раскрытым, либо же использует
макросы только локально, внутри себя. В любом случае конечный пользователь
оказывается лишён всей их выразительной силы.</p>

<p>Если вы не доверяете алгоритмам определения зависимостей, то ничего не остаётся,
кроме как самостоятельно выбирать, что включать в программу, а что нет. Всего
имеется три типа ресурсов: необходимые исключительно для раскрытия макросов,
необходимые только при исполнении программ и (самое сложное) необходимые на
обеих этапах.</p>


<!--\indexC{compile-file}-->
<!--\indexR{единый мир!разновидности}-->
<!--\indexR{истинно единый мир}-->
<!--\indexR{мир!истинно единый}-->
<p>За подготовку программ к исполнению отвечает функция <code><span class="func">compile-file</span></code>. Единые
миры по отношению к ней разделяются на две группы, одну из которых можно назвать
<em class="term">истинно едиными мирами</em>. Предмет спора: макросы, доступные
<code><span class="func">compile-file</span></code> во время предобработки. Кроме того, даже в истинно едином мире
возможны разногласия, что даёт в итоге целых три вариации исходной идеи:</p>

<p>\begin{enumerate}
  \item В истинно едином мире макросы вездесущи, доступны всегда и отовсюду.
        Следовательно, компилируемый на лету модуль вполне может
        пользоваться макросами «родителя». Данная ситуация показана на
        рисунке \ref{macros/define/unique/pic:uniquely}, где макрос
        <code><span class="func">factorial</span></code>, определяемый интерактивно, используется при
        компиляции другого модуля. Вопрос: а что с макросами, которые
        определяются внутри компилируемого модуля?
  \begin{enumerate}
      \item С ними следует обращаться на общих началах: раз мир един, то
            они должны быть доступны внешнему коду. Создаваемые внутри
            макросы просто добавляются в глобальное общее пространство
            макросов и остаются там после компиляции подмодуля. Этот случай
            показан на рисунке \ref{macros/define/unique/pic:unique-endogeny}
            где <code><span class="func">(factorial 5)</span></code> возвращает <code><span class="func">120</span></code>.</p>

<p>      \item
<!--\indexR{макросы!глобальные}-->
            В другом случае глобальность понимается на уровне отдельных
            модулей: определяемые макросы видны только в пределах своего
            модуля. Глобальные макросы разделяются на <em>локально
            глобальные</em>, определяемые в этом же модуле, и
            <em>сверхглобальные</em>, определяемые вне его, но видимые
            благодаря иерархической компиляции модулей. Для программы на
            рисунке \ref{macros/define/unique/pic:unique-endogeny}
            этому случаю соответствует возвращаемая <code><span class="func">(factorial 5)</span></code>
            ошибка.
  \end{enumerate}
  \item Наконец, если мир не истинно един, то модуль может пользоваться
        исключено самостоятельно определяемыми макросами. В этом случае есть
        отдельное пространство макросов для интерактивной сессии и отдельные,
        персональные и изначально пустые пространства для компилируемых
        модулей. Однако, несмотря на то, что пространства макросов отделены
        друг от друга, память остаётся общей и всем макросам во время
        раскрытия доступны глобальные разделяемые ресурсы. Например, на
        рисунке \ref{macros/define/unique/pic:unique-endogeny} внутренний
        макрос <code><span class="func">factorial</span></code> вполне может использовать функцию <code><span class="func">fact</span></code>,
        определённую в интерактивной сессии.
\end{enumerate}</p>

<p>\begin{figure}\centering
\input{figures/fig9.4}
\caption{Истинно единый мир.}%
\label{macros/define/unique/pic:uniquely}
\end{figure}</p>

<p>\begin{figure}\centering
\input{figures/fig9.5}
\caption{Истинно единый мир с эндогенной компиляцией.}%
\label{macros/define/unique/pic:unique-endogeny}
\end{figure}</p>


<!--\indexR{интерактивная сессия (REPL)}-->
<!--\indexE{REPL}-->
<p>После внимательного изучения рисунков \ref{macros/define/unique/pic:uniquely}
и \ref{macros/define/unique/pic:unique-endogeny} можно прийти к выводу, что
в обоих случаях функция <code><span class="func">fact</span></code> определяется глобально в интерактивной сессии,
хотя похоже, что она нужна только для раскрытия макроса <code><span class="func">factorial</span></code>. Можно
было бы определить её локально, как это сделано в <code><span class="func">si/chap9b.scm</span></code>.
\seePage[src:chap9b.scm]</p>


<!--\indexR{макрораскрытие!и вычисления}-->
<!--\indexC{eval-in-abbreviation-world}-->
<p>Но что если <code><span class="func">fact</span></code> пригодилась бы не только этому макросу? Беда в том, что
макроэкспандер воспринимает только определения макросов. Если для раскрытия
потребуются глобальные переменные, вспомогательные функции или другие вещи, то
он просто не поймёт, о чём идёт речь. Если во множественных мирах при экзогенном
подходе с этим нет вообще никаких проблем, то в едином мире или при эндогенном
задании макросов придётся немного потрудиться. Вспомните, что сама суть этих
вариаций в том, что во время раскрытия макросов происходят некоторые вычисления.
Естественно, выполняемые вычисления вовсе не обязаны быть прямо связанными
с раскрытием макросов. В <span class="logo">Common Lisp</span> и некоторых реализациях Scheme существует
соответствующая форма, называемая <code><span class="func">eval-when</span></code>, способная просто вычислить
что-нибудь, не подставляя полученный результат в раскрываемый код. (Как обычно,
чтобы имена не пересекались, её местный аналог будет называться по-другому:
<code><span class="func">eval-in-abbreviation-world</span></code>.)</p>

<p>Форма <code><span class="func">eval-in-abbreviation-world</span></code> позволяет определять вспомогательные
функции, константы, проводить любые необходимые вычисления во время раскрытия
макросов и исключительно ради него. Фактически, эта форма явно отделяет
некоторые выражения от внешнего мира вычислений. Взгляните на
рисунок \ref{macros/define/unique/pic:endogeny}: функция <code><span class="func">fact</span></code>, определяемая
<code><span class="func">eval-in-abbreviation-world</span></code>, гарантированно может быть использована для
раскрытия <code><span class="func">factorial</span></code> внутри определения <code><span class="func">some-facts</span></code>. Возможность
использовать <code><span class="func">factorial</span></code> \hbox{и/или} <code><span class="func">fact</span></code> по возвращении
в интерактивную сессию зависит уже от «герметичности» мира макросов.</p>

<p>\begin{figure}\centering
\input{figures/fig9.6}
\caption{Явные эндогенные вычисления.}%
\label{macros/define/unique/pic:endogeny}
\end{figure}</p>

<p>Для реализации такого поведения достаточно научить макроэкспандер реагировать
всего лишь на одно ключевое слово <code><span class="func">eval-in-abbreviation-world</span></code>, вынуждающее
его отправлять <code><span class="func">cdr</span></code> этой формы соответствующему вычислителю — тому
самому, который в функции <code><span class="func">naive-endogenous-macroexpander</span></code> назывался
<code><span class="func">macro-eval</span></code>.</p>


<!--\indexC{expand-expression}-->
<pre>(define (expand-expression exp macroenv)
  (define (evaluation? exp)
    (and (pair? exp)
         (eq? (car exp) 'eval-in-abbreviation-world) ) )</p>

<p>  (define (macro-call? exp)
    (and (pair? exp) (find-expander (car exp) macroenv)) )</p>

<p>  (define (expand exp)
    (cond ((evaluation? exp) (macro-eval `(begin . ,(cdr exp))))
          ((macro-call? exp) (expand-macro-call exp macroenv))
          ((pair? exp)
           (let ((newcar (expand (car exp))))
             (cons newcar (expand (cdr exp))) ) )
          (else exp) ) )</p>

<p>  (expand exp) )</pre>

<p>Функция <code><span class="func">macro-eval</span></code> — это именно тот вычислитель, который реализует
внутренний макроязык. Это может быть и обычная функция <code><span class="func">eval</span></code>, но
использующая чистое глобальное окружение, отдельное от того, которым пользуется
интерактивная сессия. В таком случае и <code><span class="func">(factorial 5)</span></code>, и <code><span class="func">(fact 5)</span></code>
вернут ошибку.</p>

<p>Формы <code><span class="func">eval-in-abbreviation-world</span></code> понимаются как непосредственно исполнимые
директивы для макроэкспандера, включённые в программу. Они, естественно,
выполняются во время раскрытия макросов, поэтому вот так писать нельзя:</p>

<pre>(let ((x 33))
  (eval-in-abbreviation-world (display x)) )</pre>


<!--\indexC{compiler-let}-->
<!--\indexCS{eval-in-abbreviation-world}{локальные переменные}-->
<p>Если в процессе раскрытия макросов потребуется создавать локальные переменные,
— что для формы <code><span class="func">eval-in-abbreviation-world</span></code> невозможно, так как она
фактически является лишь вызовом <code><span class="func">eval</span></code> на глобальном уровне, — то следует
использовать форму <code><span class="func">compiler-let</span></code>, присутствующую в \CommonLisp I
<span class="cite">[<a href="z1_bibliography.xhtml#ste84">ste84</a>]</span> (но не в \CommonLisp II <span class="cite">[<a href="z1_bibliography.xhtml#ste90">ste90</a>]</span>). Необходимо лишь научить
<code><span class="func">expand-expression</span></code> распознавать её.</p>

<p>Во время раскрытия макросов ещё нет никакого окружения исполнения программы.
Верно и обратное: во время исполнения уже нет окружения раскрытия. Поэтому вот
так использовать макросы тоже нельзя:</p>

<pre>(define-abbreviation (foo ...) ...)
(apply foo ...)</pre>

<p>Форма <code><span class="func">eval-in-abbreviation-world</span></code> снова позволяет определить
<code><span class="func">define-abbreviation</span></code> как элементарный макрос:</p>


<!--\indexC{define-abbreviation}-->
<pre>(define-abbreviation (define-abbreviation call . body)
  `(eval-in-abbreviation-world
     (install-macro! ',(car call) (lambda ,(cdr call) . ,body))
     #t ) )</pre>

<p>Главной особенностью данного определения является возможность размещать
макроопределения где угодно, а не только на глобальном уровне. Следовательно,
такая программа вполне допустима:</p>

<pre>(begin (define-abbreviation (foo x) ...)
       (bar (foo 34)) )</pre>

<p>Хотя, конечно, чересчур сильная зависимость от порядка раскрытия макросов
считается плохим вкусом, равно как и извращения вроде</p>

<pre>(if (bar) (begin (define-abbreviation (foo x))
                 (hux) )
          (foo 35) )</pre>


<!--\indexR{макроопределения!глобальные}-->
<p>Большинство макросистем отличают макросы, объявляемые глобально, от других,
подобно тому, как глобальные формы <code><span class="func">define</span></code> отличаются от внутренних. Также
глобальные макроопределения гарантированно обрабатываются последовательно сверху
вниз. Это позволяет, например, сначала определить класс, а только потом его
наследников.</p>


<!--\indexR{уровни интерпретации}-->
<!--\indexR{интерпретация!уровневая}-->
<p>Стоит отметить, что в предыдущих примерах возможны определённые нестыковки,
касающиеся вычислителей, обрабатывающих выражения. Если эти вычислители
различны, то у них могут возникнуть проблемы с ошибочным использованием
структур данных друг друга, подобные тем, которые имеются у рефлексивных
интерпретаторов. \seePage[chapter:reflection] Форма <code><span class="func">install-macro!</span></code> из
определения <code><span class="func">define-abbreviation</span></code> обрабатывается <code><span class="func">macro-eval</span></code>, она
должна изменить текущий набора макросов, доступных <code><span class="func">find-expander</span></code>. Но ведь
функция <code><span class="func">find-expander</span></code> будет вызываться <code><span class="func">eval</span></code>, а не <code><span class="func">macro-eval</span></code>!
Ладно, оставим эти затруднения с совместимостью на потом.</p>

<div class="bigskip"/>

<p>\phantomlabel{macros/define/unique/par:apply-foo}
<!--\indexR{макросы!применения}-->
Одной из весьма полезных возможностей <code><span class="func">eval-in-abbreviation-world</span></code> является
создание глобальных переменных для макроэкспандера. Часто макросы применяются
для того, чтобы абстрагироваться от некоторых особенностей реализации. Например,
в старых версиях Scheme функция <code><span class="func">apply</span></code> была бинарной, а не $n$-арной, как
сейчас. Легко представить макрос, который бы раскрывался тем или иным образом,
чтобы скрыть данное различие. Помимо исправления уже существующих недостатков,
макросы можно использовать и для предотвращения новых проблем, заранее выполняя
раскрытие правильным образом. Так часто поступают в сложных системах вроде
{\Meroon} для обеспечения переносимости. Очевидно, в обоих случаях необходимо
иметь в распоряжении этот самый список особенностей реализации, куда можно
подглядывать во время раскрытия макросов на предмет интересующих деталей.
Например, как-то так:</p>


<!--\indexC{apply}-->
<pre>(define-abbreviation (apply-foo x y z)
  (if (memq 'binary-apply *features*)
      `(apply foo (cons x (cons y z)))
      `(apply foo x y z) ) )</pre>

<p>Переменная <code><span class="func">*features*</span></code> должна быть доступна экспандеру. Легче всего её
создать с помощью <code><span class="func">eval-in-abbreviation-world</span></code>, передав ей соответствующую
форму <code><span class="func">define</span></code>. Эта форма будет вычислена на глобальном уровне в мире
макросов, что приведёт к созданию необходимой переменной. Это может делаться,
например, в каком-нибудь автоматически загружаемом конфигурационном файле:</p>

<pre>(eval-in-abbreviation-world
  (define *features* '(31bit-fixnum binary-apply)) )</pre>

<h3 id="macros/define/ssect:simult">Совместные вычисления</h3>


<!--\indexR{интерактивная сессия (REPL)}-->
<!--\indexE{REPL}-->
<!--\indexR{макроэкспандер!варианты реализации}-->
<p>Ещё одной часто реализуемой вариацией единого мира является одновременное
выполнение предобработки и вычислений. Выражения считываются, раскрываются и
незамедлительно вычисляются. В коде это выглядит так:</p>


<!--\indexCS{macroexpand}{параллельный}-->
<pre>(define (simultaneous-eval-macroexpander exps)
  (define (macro-definition? exp)
    (and (pair? exp)
         (eq? (car exp) 'define-abbreviation) ) )</p>

<p>  (if (pair? exps)
      (if (macro-definition? (car exps))
          (let* ((def       (car exps))
                 (name      (car (cadr def)))
                 (variables (cdr (cadr def)))
                 (body      (cddr def)) )
            (install-macro!
             name (macro-eval `(lambda ,variables . ,body)) )
            (simultaneous-eval-macroexpander (cdr exp)) )
          (let ((e (expand-expression (car exps) *macros*)))
            (eval e)
            (cons e (simultaneous-eval-macroexpander (cdr exps))) ) )
      '() ) )</pre>

<p>Обратите внимание на вычислители: <code><span class="func">eval</span></code> отвечает за вычисление готовых
выражений целевого языка, а <code><span class="func">macro-eval</span></code> за вычисление выражений макроязыка.
Они разделены, так как выполняют различную работу на различных этапах.</p>

<h3 id="macros/define/ssect:redefinition">Переопределение макросов</h3>


<!--\indexR{макросы!переопределение}-->
<!--\indexR{переопределение!макросов}-->
<!--\indexR{гиперстатическое окружение}-->
<!--\indexR{глобальное окружение!гиперстатическое}-->
<!--\indexR{окружение!глобальное!гиперстатическое}-->
<!--\indexR{ленивые вычисления}-->
<p>Восклицательный знак в имени функции <code><span class="func">install-macro!</span></code> подразумевает
возможность переопределения макросов: если состояние макроэкспандера можно
модифицировать, добавляя новые макросы, то точно таким же путём можно изменять
определения уже существующих. Это может оказаться полезным, например, при
отладке с помощью интерпретатора: определяем функцию, тестирующую отлаживаемый
макрос, а затем вызываем её после каждого исправления. Но чтобы такой подход
сработал, интерпретатор должен честно раскрывать макросы в последний момент,
непосредственно перед вызовом функции. Однако чаще всего макросы раскрываются
лишь один раз в самом начале, строго разделяя процессы раскрытия и исполнения.
Очевидно, что однажды раскрытый макрос больше не зависит от своего определения.
Изменив определение, мы повлияем лишь на дальнейшие раскрытия этого макроса.
Таким образом, можно сказать, что определения макросов <em>гиперстатичны</em>.
\seePage[lisp1-2-omega/recusion/simple/par:hyperstatic]</p>

<h3 id="macros/define/ssect:comparison">Итоговое сравнение</h3>


<!--\indexR{макросы!проблемы}-->
<!--\indexR{мир!сравнение вариантов}-->
<!--\indexR{макросы!раскрытие}-->
<p>Одна из главных проблем с макросами состоит в том, что нельзя просто так взять
и изменить макросистему, предоставляемую реализацией. Вероятно, подобное
ограничение на свободу экспериментирования отчасти ответственно за современную
ситуацию с макросами в Лиспе и Scheme.</p>

<p>Системы с множественными мирами и экзогенными макроопределениями, кажется, более
точно выражают идею, но они довольно слабо распространены. Эндогенный подход
во множественных мирах есть лишь частный случай экзогенного, где вне
обрабатываемой программы определяются примитивы вроде <code><span class="func">define-abbreviation</span></code>
и т. д., с помощью которых реализуются пользовательские макросы. Наконец, единые
миры являются наиболее распространённым вариантом, хотя и вызывают определённые
затруднения с передачей готового программного обеспечения. Данное сравнение,
однако, слегка поверхностно, так как не учитывает двух важных аспектов:
компиляции макросов и определения макросов с помощью макросов. О них мы сейчас
и поговорим.</p>

<p>
\subsubsection{Компиляция макросов}%
\label{macros/define/comparison/sssect:compiling}</p>


<!--\indexR{компиляция!специализация}-->
<!--\indexR{макросы!компиляция}-->
<!--\indexR{компиляция!макросов}-->
<p>До сих пор мы неявно предполагали, что раскрытием макросов занимается
интерпретатор. Очевидно, это сказывается на производительности, особенно если
экспандер выполняет сложные вычисления (что редко, но бывает). Множественные
миры и экзогенное определение макросов \seePage[macros/expand/exo/par:compiler]
позволяют на лету сгенерировать специализированный компилятор, понимающий все
необходимые макросы, что должно благотворно сказаться на быстродействии. При
эндогенном подходе к описанию макросов одним из решений может быть создание
компилирующего аналога функции <code><span class="func">macro-eval</span></code>. В едином мире для этого
предназначена пара функций <code><span class="func">compile-file</span></code> и <code><span class="func">load</span></code>. Вся проблема в том,
как скомпилировать <em>определения</em> макросов.</p>


<!--\indexR{макроопределения!как синтаксические маркеры}-->
<!--\indexR{уровни интерпретации}-->
<!--\indexR{интерпретация!уровневая}-->
<p>Это отнюдь не тривиальная задача! Наши текущие экспандеры просматривают
раскрываемые выражения на предмет форм <code><span class="func">define-abbreviation</span></code> и определяют
соответствующие макросы на лету. Но теперь, при компиляции, они должны не только
запомнить определения где-то у себя внутри, но и оставить в программе нечто,
описывающее просмотренные определения. Если <code><span class="func">define-abbreviation</span></code> является на
самом деле макросом, раскрывающимся в форму <code><span class="func">install-macro!</span></code>, то исполняемая
программа сама всё сделает. Если же <code><span class="func">define-abbreviation</span></code> и компания — это
лишь синтаксические маркеры для экспандера, то всё придётся делать компилятору:
откомпилировать тело макроса в функцию-экспандер, которая будет динамически
вычислять, загружать и исполнять результаты раскрытия. Однако, при таком подходе
возникают некоторые неоднозначности: к примеру, как тогда понимать
<code><span class="func">(eval-in-abbreviation-world (load file))</span></code>? Очевидно, здесь имеется в виду,
что <em>компилятор</em> должен динамически загрузить файл. Но функция <code><span class="func">load</span></code>
— это же обёртка над <code><span class="func">eval</span></code>, что подразумевает динамические вычисления,
вычисления во время исполнения программы. Та же самая ситуация возникает и при
явном обращении к <code><span class="func">eval</span></code>: <code><span class="func">(eval-in-abbreviation-world (eval
'(define-abbreviation ...)))</span></code>. В обоих случаях вместо <code><span class="func">eval</span></code> должна
вызываться <code><span class="func">macro-eval</span></code>, чтобы эти выражения имели смысл, так как
<em>исполняемой программой</em> сейчас является сам компилятор. Таким образом,
в макромире действительно используется собственный язык с собственной <code><span class="func">eval</span></code>,
которая идентична <code><span class="func">macro-eval</span></code> целевого языка.</p>


<!--\indexR{макроопределения!как предопределенные макросы}-->
<!--\indexR{макросы!как полноценные объекты}-->
<!--\indexR{полноценные объекты!макросы}-->
<p>Всё это наталкивает нас на мысль, что для определения макросов необходимо
использовать другие макросы, а не просто синтаксические маркеры, на которые
реагирует экспандер-препроцессор. Если макросы требуется сохранять
в обработанных программах, то они вынуждены будут стать полноценными объектами
целевого языка. В таком случае анализ определений макросов и установка
обработанных определений в макроэкспандер тоже должны быть разделены, так как
они принадлежат различным мирам. Чуть позже мы рассмотрим этот вопрос подробнее.
\seePage[macros/sect:eval-and-expand]</p>

<p>
\subsubsection{Макросы, определяющие макросы}%
\label{macros/define/comparison/sssect:defining}</p>


<!--\indexR{макросы!применения}-->
<p>Время от времени бывает удобным определить макрос, который бы создавал другие
макросы. \seePage[macros/usage/par:inline] Это не бред, а вполне естественное
желание максимально полно использовать выразительные возможности,
предоставляемые макросами. Например, пусть мы разрабатываем объектную систему.
Логичным будет дать пользователю возможность создать класс <code><span class="func">Point</span></code> таким
образом, чтобы его аксессоры <code><span class="func">Point-x</span></code> и <code><span class="func">Point-y</span></code> были на самом деле
макросами, а не функциями. \seePage[objects/def-class/par:accessors] В таком
случае форма <code><span class="func">define-class</span></code> вынуждена будет сама создать эти новые макросы.</p>

<p>Рассмотрим для примера макрос <code><span class="func">define-alias</span></code>, делающий свой первый аргумент
тождественным второму. Вот два эквивалентных варианта его реализации:</p>


<!--\indexC{define-alias}-->
<pre>(define-abbreviation (define-alias newname oldname)
  `(define-abbreviation (,newname . parameters)
     `(,',oldname . ,parameters) ) )</p>

<p>(define-abbreviation (define-alias newname oldname)
  `(define-abbreviation (,newname . parameters)
     (cons ',oldname parameters) ) )</pre>


<!--\indexR{макроопределения!как синтаксические маркеры}-->
<!--\indexR{макроопределения!как предопределенные макросы}-->
<p>И снова, если <code><span class="func">define-abbreviation</span></code> это макрос, то при рекурсивном раскрытии
определения <code><span class="func">define-alias</span></code> макроэкспандер раскроет и вложенное определение.
А вот если бы <code><span class="func">define-abbreviation</span></code> была синтаксическим маркером, то не факт:
вдруг макроэкспандер выполняет работу за два прохода и на втором его уже
не интересуют всякие маркеры, он только раскрывает макросы, а на всё остальное
даже не смотрит. Таким образом, далее мы будем считать <code><span class="func">define-abbreviation</span></code>
именно предопределённым макросом; скорее даже примитивным, так как его нельзя
определить, не будь он изначально встроен в реализацию.</p>

<h2 id="macros/sect:scope">Область видимости макросов</h2>


<!--\indexR{область видимости!макроопределений}-->
<!--\indexE{Meroon@\protect\MeroonMeroonet!типы макросов}-->
<!--\indexR{макросы!области видимости}-->
<p>Если область видимости локальных макросов, определяемых формами наподобие
<code><span class="func">let-syntax</span></code> и <code><span class="func">letrec-syntax</span></code>, вполне очевидна, то вот определения
<code><span class="func">define-syntax</span></code> не настолько однозначны, потому что глобальные макросы можно
использовать по-разному. Рассмотрим возможные варианты подробнее на примере
{\Meroon} — переносимой объектной системы для Scheme, допускающей как
интерпретацию, так и компиляцию. Ядро {\Meroon} называется {\Meroonet}.
(См. одиннадцатую главу.) В этой системе используются три типа макросов:</p>

<p>\begin{enumerate}
  \item \textbf{Случайные макросы.} Такие макросы определяются, тут же
        используются, а дальше их можно выбросить. В принципе, для них
        прекрасно подходят формы <code><span class="func">let-syntax</span></code> или <code><span class="func">macrolet</span></code>, если,
        конечно, они поддерживаются реализацией. В качестве примера
        возьмём функцию <code><span class="func">make-fix-maker</span></code> из {\Meroonet}. Она создаёт
        «треугольник» замыканий вида <code><span class="func">(lambda (a b c ...) (vector
        cn a b c ...))</span></code>, но её определение записано вручную.
        \seePage[objects/accomp/maker/src:fix-maker]
        А можно было бы написать для этого специальный макрос:</p>

<pre>(define-abbreviation (generate-vector-of-fix-makers n)
  (let* ((numbers (iota 0 n))
         (variables (map (lambda (i) (gensym)) numbers)) )
    `(case size
       ,@(map (lambda (i)
                (let ((vars (list-tail variables (- n i))))
                  `((,i) (lambda ,vars (vector cn . ,vars))) ) )
              numbers )
       (else #f) ) ) )
\end{code:lisp}

        \noindent
        Здесь важно то, что подобные макросы «одноразовые». У них
        очень ограниченная область видимости: в любом случае не шире
        модуля, где они определены.</p>

<p>  \item \textbf{Локальные макросы.} Исходный код {\Meroon} разделён на
        25 небольших файлов. Естественно, внутри этих файлов используется
        некоторое количество макросов для собственных нужд, например,
        <code><span class="func">when</span></code>. Область видимости этих макросов должна быть ограничена
        исключительно файлами {\Meroon}. Макросы, локальные для объектной
        системы, не имеют права загрязнять внешний мир.</p>

<p>  \item \textbf{Экспортируемые макросы.} {\Meroon} экспортирует три своих
        макроса: <code><span class="func">define-class</span></code>, <code><span class="func">define-generic</span></code> и <code><span class="func">define-method</span></code>.
        Эти макросы существуют в первую очередь для пользователей {\Meroon},
        но и для самой системы они тоже могут быть полезны. Очевидно,
        макросы вроде <code><span class="func">when</span></code> запрещено использовать в макросах третьего
        типа, так как иначе <code><span class="func">when</span></code> выйдет за пределы своей
        системно-локальной области видимости. Целевой язык экспортируемых
        макросов — это язык пользователя, а не {\Meroon}.
\end{enumerate}</p>


<!--\indexR{библиотека!макросов}-->
<p>Существует не только три типа макросов, но и три способа их использования,
показанные на рисунке \ref{macros/scope/pic:usage}.</p>

<p>\begin{enumerate}
  \item \textbf{Для компиляции \Meroon.} Для этого необходимо раскрыть
        все макросы, присутствующие в исходном коде системы. Естественно,
        после этого не остаётся ни одного макровызова, что снимает все
        проблемы. Но от макросов третьего типа должно оставаться нечто,
        что позволяет их использовать снаружи, ведь они всё же
        экспортируются.</p>

<p>  \item \textbf{Для компиляции программ, использующих \Meroon.} В таком
        случае достаточно раскрыть лишь макросы {\Meroon} третьего типа,
        встречающиеся в пользовательском коде.</p>

<p>        Очевидно, что для этого в экспандер компилятора необходимо
        установить соответствующие определения. Иными словами, подключить
        библиотеку времени раскрытия макросов {\Meroon} третьего типа.
        Заметьте, что библиотеки для макросов второго и первого типов при
        этом не нужны.</p>

<p>  \item \textbf{Для создания интерпретатора с поддержкой \Meroon.}
        Получаемая интерактивная сессия должна быть способна на лету
        раскрывать макросы {\Meroon} третьего типа. Соответственно, эти
        макросы вместе со своей библиотекой времени раскрытия должны
        быть подключены к макроэкспандеру самого интерпретатора.
\end{enumerate}</p>

<p>% Жутко кривой хак, чтобы разрешить вылет текста на иллюстрации
% за поля, но чего только не сделаешь ради красивой вёрстки.
\begin{figure}\centering
\hbox{\hskip+1.0em\hbox{\hskip-2.0em\input{figures/fig9.7}}}
\caption{Варианты использования макросов.}
\label{macros/scope/pic:usage}
\end{figure}</p>


<!--\indexR{раскрутка (bootstrapping)}-->
<p>На рисунке \ref{macros/scope/pic:bootstrap} показан один из способов сборки
модулей {\Meroon}, известный как <em class="term">раскрутка</em> (bootstrapping). Библиотека
раскрытия макросов второго типа собирается исключительно как вспомогательная
при сборке остальной части объектной системы. Всё это напоминает так называемые
T-диаграммы <span class="cite">[<a href="z1_bibliography.xhtml#es70">es70</a>]</span>, отображающие связи между языками реализации,
реализуемыми языками и целевыми языками применительно к процессу компиляции.</p>

<p>\begin{figure}\centering
\input{figures/fig9.8}
\caption{Раскрутка \protect\Meroon.}
\label{macros/scope/pic:bootstrap}
\end{figure}</p>


<!--\indexR{множественные миры!как области видимости}-->
<!--\indexR{область видимости!пакеты}-->
<!--\indexR{пространства имён}-->
<!--\indexR{пакеты}-->
<p>После рассмотрения различных типов макросов и вариантов их использования можно
сделать вывод, что для подобных систем отлично подходит идея множественных
миров, так как в едином мире обычно отсутствуют ограничения на область
видимости. Одним из способов организации макросов являются <em class="term">пакеты</em> (как,
например, в <span class="logo">Common Lisp</span> или ILOG Talk). Внутренние макросы можно просто
собрать в пакет, получив таким образом для них отдельное пространство имён,
которое не будет пересекаться с пользовательскими. В едином же мире все три
типа макросов, которые мы так тщательно разделяли, оказываются сваленными в одну
кучу.</p>


<!--\indexC{define-meroonet-macro}-->
<p>{\Meroonet}, ядро объектной системы {\Meroon}, рассматривается подробнее
в одиннадцатой главе. Она определяет всего три макроса, но сама их при этом
не использует, избегая таким образом вышеупомянутых проблем. Данные макросы
относятся к третьему типу по нашей классификации и определяются с помощью
специального макроса <code><span class="func">define-meroonet-macro</span></code>. Сделано так потому, что
экспортируемые макросы связаны с пользовательской макросистемой, от которой
{\Meroonet} следует абстрагироваться. Нельзя ожидать, что ей будет доступна
функция <code><span class="func">install-macro!</span></code> или что-либо другое, поэтому она вводит интерфейс
в виде макроса <code><span class="func">define-meroonet-macro</span></code>, который должен быть реализован
с помощью примитивов конкретной макросистемы. Допустим, таким примитивом
является <code><span class="func">define-abbreviation</span></code>. Учитывая требование экспортируемости макросов
— возможности использовать их как в модуле, где они определяются, так и
в модулях, которые динамически загрузят модуль с определениями, —
<code><span class="func">define-meroonet-macro</span></code> можно реализовать следующим образом:</p>

<pre>(define-abbreviation (define-meroonet-macro call . body)f
  `(begin (define-abbreviation ,call . ,body)
          (eval '(define-abbreviation ,call . ,body)) ) )</pre>

<h2 id="macros/sect:eval-and-expand">Вычисления и макрораскрытие</h2>


<!--\indexR{интерактивная сессия (REPL)!макрораскрытие}-->
<!--\indexE{REPL!макрораскрытие}-->
<!--\indexR{макрораскрытие!в интерактивной сессии}-->
<p>В интерактивной сессии раскрытие макросов и вычисление выражений очень тесно
связаны друг с другом, за раскрытием всегда следует вычисление. В данном разделе
мы внимательнее присмотримся к этой неразлучной паре.</p>


<!--\indexR{язык!чистый (без макросов)}-->
<p>Макрораскрытие — это первый этап подготовки программы к исполнению. После
подготовки можно вычислять выражения, составляющие программу. Функция <code><span class="func">eval</span></code>
занимается исключительно вычислениями, она знает только чистый язык, лишённый
всяких макросов. Для динамического вычисления выражений, содержащих макросы, их
необходимо явно пропускать через экспандер перед передачей <code><span class="func">eval</span></code>.
Соответственно, вполне возможен вариант, когда в сессии одновременно существуют
два независимых макроэкспандера. Правда, такая практика обладает сомнительной
полезностью; обычно всё же в пределах одного языка есть только один вычислитель
и один макроэкспандер, так как иначе возникли бы определённые трудности
со стандартными макросами вроде <code><span class="func">cond</span></code>, <code><span class="func">let</span></code> или <code><span class="func">case</span></code>. Поэтому
обычно <code><span class="func">eval</span></code> на самом деле является чем-то вроде <code><span class="func">(lambda (e) (pure-eval
(macroexpand e *macros*)))</span></code>, где <code><span class="func">pure-eval</span></code> — это настоящий вычислитель
чистого языка, <code><span class="func">macroexpand</span></code> — явная функция-макро\-экспандер, а
<code><span class="func">*macros*</span></code> — текущий список макросов, известных интерпретатору.</p>


<!--\indexR{динамические вычисления!и макросы}-->
<p>Сказанное сейчас про <code><span class="func">eval</span></code> в равной мере касается и <code><span class="func">macro-eval</span></code>: у неё
тоже есть своя переменная <code><span class="func">*macros*</span></code>, которая хранит макросы, необходимые
во время подготовки. Вопросов эта пара из вычислителя и экспандера вызывает
немало. Например, вспомним \seePage[reflection/sect:eval-as-spec-form]
о существовании <code><span class="func">eval/ce</span></code>, которая позволяет проводить вычисления в текущем
окружении. Эта специальная форма захватывает всё видимое ей лексическое
окружение. По идее, <code><span class="func">eval/ce</span></code> должна уметь обращаться с выражениями,
содержащими макросы, но значит ли это, что она захватывает окружающие её
макроопределения? Другими словами, если написать</p>

<pre>(let-syntax ((foo ...))
  (eval/ce (read)) )</pre>

<p>\noindent
то раскроет ли <code><span class="func">eval/ce</span></code> макровызовы <code><span class="func">foo</span></code> в считанном выражении? Если да,
то она должна сохранять не только весь лексический контекст, но также и
макроконтекст — полное состояние макроэкспандера; только так <code><span class="func">eval/ce</span></code>
сможет корректно раскрыть <code><span class="func">foo</span></code>. Поскольку подобные приёмы серьёзно нарушает
принцип независимости процессов раскрытия и исполнения, они считаются плохим
стилем. Вообще говоря, <code><span class="func">eval</span></code> тоже по-хорошему должна быть чистой и
не вызывать всяческих раскрытий, когда её не просят, но это неудобно,
непрактично и т. д., и т. п.</p>

<p>После определения макроса его можно использовать при последующих раскрытиях.
Предположим, ранее мы определили весьма полезный макрос <code><span class="func">when</span></code>. Будет ли
работать следующее определение?</p>

<pre>(define-abbreviation (whenever condition . action)
  (when condition (display '(whenever is called)))
  `(when ,condition . ,action) )</pre>

<p>В этом макросе <code><span class="func">when</span></code> используется дважды. Второй раз приходится на результат
раскрытия, так что здесь проблем нет. Но вот в первый раз <code><span class="func">when</span></code> используется
во время раскрытия определения макроса, то есть когда вычислениями занимается
совершенно другой вычислитель, который может вообще не знать про <code><span class="func">when</span></code>: ведь
макросы-то сейчас раскрываются в обрабатываемой программе, а
не в макроопределениях! Макрос <code><span class="func">when</span></code>, доступный в том числе во время самого
процесса раскрытия, должен определяться вот так:</p>

<pre>(eval-in-abbreviation-world
  (define-abbreviation (when condition . body)
    `(if ,condition (begin . ,body)) ) )</pre>

<p>Похожая ситуация возникает и в выражении</p>

<pre>(define-abbreviation (foo)
  (define-abbreviation (bar)
    (when ...)
    (wrek) )
  (hux) )</pre>


<!--\indexR{бесконечная регрессия}-->
<!--\indexR{прагматика}-->
<p>\noindent
{\def\CPP{Си$+$$+$}%
Здесь внутреннее определение <code><span class="func">bar</span></code> вводится для расширения макроязыка, а
не пользовательского. Макрос <code><span class="func">bar</span></code> определяется, чтобы облегчить запись
определения другого макроса. Однако, даже если семантика данного выражения
сомнений не вызывает, то его прагматика\trnote{Прагматика — понятие лингвистики:
смысл выражения, определяемый его контекстом. Для языков программирования таким
контекстом является компьютер, исполняющий программы. То есть прагматика —
это принципы реализации языка для конкретных вычислительных машин, тогда как
семантика — это просто абстрактный смысл выражений языка.} слегка неясна,
так как здесь образуется своеобразный порочный круг. Ведь различными могут быть
не только целевой и макроязыки, но и язык для описания описаний макросов может
отличаться от макроязыка, и так далее. Другими словами, нельзя быть уверенным
в том, что форма <code><span class="func">when</span></code> в описании внутреннего макроса <code><span class="func">bar</span></code> будет понята
верно. Если взять действительно различные языки, проблема станет более явной.
Например, макросы в программах на {\CPP} раскрываются препроцессором {\CPP}.
Представьте, что эти макроопределения генерируются программой на Perl. Очевидно,
что она должна возвращать эти определения именно на {\CPP}, так как программа
на Perl для компилятора {\CPP} — это одна большая синтаксическая ошибка,
несмотря на то, что в ней и есть некий подразумеваемый смысл с точки
зрения Perl.}</p>


<!--\indexR{уровни интерпретации}-->
<p>И что же делать? Одним из вариантов является строгое следование семантике —
то есть поддержка всех используемых языков. К счастью, их редко когда требуется
больше двух. Но тогда возникают проблемы многоуровневой интерпретации,
рассмотренные ранее на примере рефлексивных интерпретаторов.
\seePage[reflection/sect:reflective-interpreter]</p>

<p>Ещё одна возможность заключается в объединении всех языков, используемых
макроэкспандером. То есть при раскрытии макросов все вычисления выполняются
в едином мире с одним-единственным языком описания макросов. Но тогда все наши
усилия по разделению языков провалятся в тартарары.</p>

<p>Третьим вариантом — именно его использует {\RnRS} — будет ограничение
языка описания макросов. Если его выразительные возможности сводятся лишь
к перестановкам и повторениям уже написанных конструкций целевого языка, то
такие макросы не смогут создавать другие макросы и исходная проблема
не возникает в принципе.</p>


<!--\indexR{продолжения (continuations)}-->
<p>Короче говоря, снова мы приходим к тому, что очень важно различать используемые
языки и стараться их не смешивать. Если используемая реализация Scheme
поддерживает многопоточность и распределённые вычисления, то отсюда вовсе
не следует, что её макроэкспандер тоже это умеет. Например, если в макромире
есть продолжения, то они не обязательно ведут себя так же, как и в Scheme.
Не надо, дорвавшись до них, тут же бежать показывать своё мастерство с помощью
чего-то подобного:</p>

<pre>(define-abbreviation (foo x)
  (call/cc (lambda (k)
             (set! the-k k)
             x )) )
(define-abbreviation (bar y)
  (the-k y) )</pre>

<h2 id="macros/sect:usage">Применения макросов</h2>


<!--\indexR{макросы!применения}-->
<p>В данном разделе рассматриваются типичные варианты использования макросов.
Предназначением макросов является, конечно же, преобразование программ, но
существует множество причин, по которым эти преобразования выполняются. Среди
них можно выделить следующие:</p>

<p>\begin{itemize}
  \item <em>Сокращение</em> объёма набираемого кода (особенно во время
        интерактивной работы или отладки). Если мы хотим писать <code><span class="func">(trace
        foo)</span></code>, чтобы получать в дальнейшем сообщения обо всех вызовах
        функции <code><span class="func">foo</span></code>, то здесь потребуется макрос, дабы значение
        <code><span class="func">foo</span></code> не вычислялось при подобном вызове.</p>

<p>  \item <em>Облагораживание</em> кода для сокрытия некрасивого синтаксиса.
        Например, использование <code><span class="func">bind-exit</span></code> вместо <code><span class="func">call/ep</span></code>, чтобы
        не писать каждый раз эту надоедливую <code><span class="func">lambda</span></code>.</p>

<p>  \item <em>Абстрагирование</em>, позволяющее скрывать детали реализации,
        — главная задача макросов. Не следует выставлять напоказ то,
        что может в скором времени измениться, или нечто личное, куда
        не должны совать свой нос посторонние. Примерами могут быть
        <code><span class="func">define-class</span></code> {\Meroonet} или <code><span class="func">syntax-rules</span></code> Scheme.
\end{itemize}</p>

<p>Отдельно стоит упомянуть ещё один важный подвид макросов, использующихся для
обеспечения переносимости. Вроде упомянутого ранее <code><span class="func">apply-foo</span></code>
\seePage[macros/define/unique/par:apply-foo], который был применён для скрытия
истинной арности <code><span class="func">apply</span></code>. Или, например, другая проблема: до \RnRS[4] пустой
список <code><span class="func">()</span></code> не обязательно имел булево значение <code><span class="func">\#t</span></code>. Ожидаемое поведение
можно обеспечить, используя везде специальный макрос, скажем, <code><span class="func">meroon-if</span></code>,
который определяется следующим образом:</p>

<pre>(define-abbreviation (meroon-if condition consequent . alternant)
  `(if (let ((tmp ,condition))
         (or tmp (null? tmp)) )
      ,consequent . ,alternant ) )</pre>

<p>Естественно, подобных уловок можно избежать, если изначально правильно писать
программы. Но, увы, не все программы хорошо написаны, а среди «плохих» вполне
могут оказаться и весьма полезные. Подобные макросы являются одним из способов
быстрого портирования необходимого программного обеспечения.</p>

<p>\phantomlabel{macros/usage/par:inline}
<!--\indexR{инлайнинг}-->
<!--\indexR{встраивание}-->
Ещё одним применением макросов является гарантирование некоторых оптимизаций
независимо от используемого компилятора. Одной из таких оптимизаций является
<em class="term">инлайнинг</em> — прямая подстановка кода функций вместо их вызова.
Некоторые реализации предоставляют специальные директивы для этого, но так как
подобный способ не является переносимым, а также не всегда позволяет
использовать подобные функции вне модуля, где они определены, нам остаётся
лишь реализовать всё самостоятельно. Для этого достаточно связать необходимую
функцию с одноимённым макросом:</p>

<pre>(define-abbreviation (define-inline call . body)
  (let ((name      (car call))
        (variables (cdr call)) )
    `(begin
       (define-abbreviation (,name . arguments)
         (cons (cons 'lambda (cons ',variables ',body))
               arguments ) )
       (define ,call (,name . ,variables)) ) ) )</pre>


<!--\indexR{функции!встраиваемые!рекурсия}-->
<p>Правда, этот макрос тоже не абсолютно переносим, так как в некоторых диалектах
запрещено одновременно иметь макрос и функцию с одинаковым именем. Другие
диалекты более снисходительны, но в них второе определение (функция) полностью
заменит первое (макрос), так что никакого инлайнинга не будет. Кроме того,
при таком подходе чрезвычайно сложно создать рекурсивную встраиваемую функцию,
не зациклив при этом макроэкспандер (хотя некоторые с этим не согласны,
см. <span class="cite">[<a href="z1_bibliography.xhtml#bak92b">bak92b</a>]</span>). Наконец, стоит избегать использования встраиваемых функций
как значений (например, не передавать их в <code><span class="func">apply</span></code>), потому как это позволит
компилятору вообще не создавать соответствующую полноценную функцию.</p>

<p>Во множественных мирах данный макрос работает прекрасно. Макроэкспандер
раскрывает все вызовы определённой таким образом функции, являющиеся на самом
деле макровызовами одноимённого макроса. Вместо них экспандер подставляет код
функции (в том числе в форме <code><span class="func">define</span></code>, которая определяет «настоящую»
функцию). В результате, после раскрытия макросов все прямые вызовы функции
оказываются заменены кодом, а остальные упоминания имени являются обычными
ссылками на обычную функцию — как раз это нам и надо.</p>

<h3 id="macros/usage/ssect:other">Иные качества</h3>


<!--\indexE{Scheme!качества макросов}-->
<p>Макросы Scheme стандарта {\RnRS} имеют четыре важных особенности:</p>

<p>\begin{enumerate}
  \item они гигиеничны (подробнее в разделе \ref{macros/sect:hygiene});
  \item они определяются с помощью <em class="term">паттернов</em>;
  \item они раскрываются простыми подстановками;
  \item они не имеют внутреннего состояния.
\end{enumerate}</p>


<!--\indexE{pattern matching}-->
<!--\indexR{сопоставление с образцом}-->
<p>Преимуществом определения синтаксиса макросов в виде паттернов является
возможность тонкого контроля над требуемой формой макровызовов. Более того,
не требуется писать ни одной строчки кода для обеспечения этого контроля.
Например, многие макросы последним аргументом принимают список, являющийся
неявным вызовом <code><span class="func">begin</span></code>. Им не требуется проверять, что этот список
является корректным (оканчивается на <code><span class="func">()</span></code>, а не точечную пару) — эта
проверка автоматически выполняется макроэкспандером, который расскажет обо всех
встреченных им синтаксических ошибках, включая и эту. Для реализации подобных
проверок существуют эффективные алгоритмы сопоставления с образцом (pattern
matching), например, рассмотренные в работах \cite{que90b,qg92,wc94}.</p>


<!--\indexR{квазицитирование}-->
<p>Подстановки также реализуются квазицитированием, но такой подход позволяют
выражать лишь операции над списками и векторами. В частности, здесь нет даже
четырёх арифметических действий и самих чисел вообще.
\seeEx[macros/ex:arg-sequence]</p>


<!--\indexR{макросы!внутреннее состояние}-->
<p>Отсутствие у макросов собственного состояния — более серьёзное неудобство.
Макросы в таком случае являются контекстно-независимыми, что с одной стороны,
конечно, удобно, но вызывает некоторые сложности с определением макросов вроде
<code><span class="func">define-class</span></code>, которому серьёзно облегчит жизнь поддерживаемая в адекватном
состоянии иерархия ранее определённых классов. Ведь для создания
классов-наследников необходимо иметь информацию об их родителях: к примеру,
количество и имена их полей.</p>

<p>Иногда действительно хочется иметь макросы, учитывающие контекст своего
раскрытия. Представьте себе макрос <code><span class="func">date</span></code>, раскрывающийся в текущую дату.
Он бы пригодился, например, в качестве простой системы управления версиями.</p>

<h3 id="macros/usage/ssect:code-walk">Обход кода</h3>


<!--\indexR{обход кода}-->
<!--\indexR{аксессоры!синтаксис}-->
<p>Большинство реально используемых макросов принимают выражение, делают немного
замен с перестановками в нем и возвращают результат. Этим весьма простым
макросам не требуется выполнять глубокий анализ своих аргументов. Но вот макрос,
к примеру, преобразующий арифметические выражения из инфиксной записи
в привычную для Лиспа префиксную, однозначно потребует более сложной логики.
Рассмотрим макрос <code><span class="func">with-slots</span></code> из CLOS на примере {\Meroonet}. К полям
объекта — для определённости, скажем, к полям объекта класса <code><span class="func">Point</span></code> —
доступ обеспечивают функции-аксессоры вроде <code><span class="func">Point-x</span></code>. Гораздо удобнее
было бы обращаться к полям просто по имени: <code><span class="func">x</span></code> или <code><span class="func">y</span></code>; по крайней мере,
в контексте объявления методов, где нужный объект самоочевиден. Тогда можно
будет объявлять методы как в Smalltalk <span class="cite">[<a href="z1_bibliography.xhtml#gr83">gr83</a>]</span>:</p>


<!--\indexC{define-handy-method}-->
<pre>(define-handy-method (double (o Point))
  (set! x (* 2 x))
  (set! y (* 2 y))
  o )</pre>

<p>\noindent
вместо такого ужаса:</p>

<pre>(define-method (double (o Point))
  (set-Point-x! o (* 2 (Point-x o)))
  (set-Point-y! o (* 2 (Point-y o)))
  o )</pre>

<p>Макрос <code><span class="func">define-handy-method</span></code>, соответственно, должен пройтись по своему телу
и заменить все ссылки и присваивания переменным, чьи имена совпадают с именами
полей класса, на корректные обращения к данным полям. Он мог бы воспользоваться
более быстрыми вариантами аксессоров, которые не выполняют всяческих проверок
типов, так как правильный тип аргумента уже гарантирован дискриминантом метода.
Подобный макрос не только улучшает читабельность, но и немного помогает
компилятору с оптимизациями.</p>


<!--\indexR{смысл программ!по отношению к синтаксису}-->
<!--\indexR{программы!смысл}-->
<!--\indexR{значения!как программы}-->
<p>Однако перед тем, как раскатывать губу, сначала стоит вспомнить, что тело
метода, передаваемое в <code><span class="func">define-handy-method</span></code>, — это не программа, а просто
S-выражение, в котором могут быть и другие макросы. Очевидно, что сначала надо
раскрыть их, а для этого потребуется доступ к макроэкспандеру. Более того, как
вы помните, раскрытие макросов может вызвать создание других макросов,
существуют локальные макросы и так далее, так что это должен быть именно текущий
макроэкспандер со всем своим состоянием. Дабы не уходить в дебри реализации,
предположим, что во время раскрытия макроса мы всегда имеем доступ к его
экспандеру посредством переменной <code><span class="func">macroexpand</span></code>.</p>

<p>После раскрытия макросов тело <code><span class="func">define-handy-method</span></code> уже является нормальной
программой, которую можно анализировать. Это несложно. В конце концов, всю эту
книгу мы только тем и занимались, что анализировали программы. Сейчас нас
интересуют специальные формы и вызовы функций, где могут встретиться необходимые
переменные. Цитаты можно не трогать, там переменных нет. Смотреть надо на
локальные связывающие формы, способные ввести новые переменные, которые
скроют наши удобные ссылки на поля объекта; очевидно, такие переменные тоже
не надо трогать. Реализовать собственно обход программ на Лиспе несложно,
см. \cite{cur89,wat93}; значительно сложнее будет определить, на какие формы
языка — вернее, его реализации — следует реагировать, а на какие нет.</p>


<!--\indexR{специальные формы}-->
<!--\indexR{форма!специальная}-->
<p>Ядром языка являются специальные формы, но в их толковании многие реализации
часто допускают определённые вольности, как то:</p>

<p>\begin{itemize}
  \item стандартные возможности, реализованные в виде специальных форм
        (чаще всего <code><span class="func">let</span></code> и <code><span class="func">letrec</span></code>);</p>

<p>  \item введение нестандартных специальных форм (<code><span class="func">define-class</span></code>,
        например);</p>

<p>  \item реализация некоторых специальных форм как макросов (вроде
        известной вам <code><span class="func">begin</span></code>).
\end{itemize}</p>


<!--\indexR{рефлексия!и макросы}-->
<p>Не имея рефлексивной информации о языке, сложно ответить на возникающие
в процессе обхода вопросы: «Во что именно превратились все формы <code><span class="func">begin</span></code>?
Как найти в исходном коде условные выражения, если <code><span class="func">if</span></code> — это на самом
деле хитрый макрос, раскрывающийся в специальную форму <code><span class="func">typecase</span></code>? Что делать
с незнакомыми специальными формами вроде <code><span class="func">define-class</span></code>, чей синтаксис
объявления полей идентичен синтаксису вызова функций? Откуда экспандер узнает,
что <code><span class="func">bind-exit</span></code> является связывающей формой, которая создаёт локальные
привязки, способные скрывать одноимённые переменные?»</p>

<p>Хорошо было бы заморозить набор специальных форм и явно запретить реализациям
изменять его в большую или меньшую сторону. В таком случае можно быть уверенным,
что после окончания раскрытия макросов программа имеет чётко определённую
структуру, где не осталось всяких специальных встроенных макросов или чего-то
подобного. К сожалению, в Scheme нет стандартного способа получить необходимую
рефлексивную информацию о языке и его реализации, так что написать идеально
переносимую версию <code><span class="func">define-handy-method</span></code> не получится.</p>

<h2 id="macros/sect:hygiene">Непредвиденные захваты</h2>


<!--\indexR{макросы!гигиеничные}-->
<!--\indexR{макрогигиена}-->
<!--\indexR{гигиеничные макросы}-->
<!--\indexR{свободные переменные!в макросах}-->
<p>Идея <em class="term">гигиены</em> применительно к макросам была тщательно рассмотрена
в работах \cite{kffd86,br88,cr91a}. Проблема, решаемая ею, состоит в том, что
макросы после раскрытия могут содержать переменные, которые в некотором
смысле «свободны», то есть ни с чем не связаны, а значит, являются источником
трудноуловимых ошибок, возникающих из-за сокрытия как переменных окружающего
кода свободными переменными макросов, так и наоборот. Следующий пример
демонстрирует оба случая:</p>


<!--\indexC{acons}-->
<pre>(define-abbreviation (acons key value alist)
  `(let ((f cons)) (f (f ,key ,value) ,alist)) )</p>

<p>(let ((cons list)
      (f #f) )
  (acons 'false f '()) )</pre>

<p>Переменная <code><span class="func">cons</span></code>, оказавшись в раскрытом макросе <code><span class="func">acons</span></code>, будет
ссылаться не на ту <code><span class="func">cons</span></code>, к которой все привыкли, а на локальную переменную
<code><span class="func">cons</span></code>, введённую формой <code><span class="func">let</span></code>, внутри которой расположен макровызов
<code><span class="func">acons</span></code>. И наоборот, сам макрос <code><span class="func">acons</span></code> вводит переменную <code><span class="func">f</span></code>, которая
помешает аргументу <code><span class="func">value</span></code> получить ожидаемое значение <code><span class="func">\#f</span></code>. Ужас!</p>

<p>Гигиеничные макросы в принципе лишены подобных проблем. Давайте подумаем, как им
это удаётся.</p>

<p>Вот уже тридцать лет от второй проблемы в Лиспе избавляются с помощью простого
переименования переменных. Раз переменная <code><span class="func">f</span></code> внутри макроса может пересечься
с какой-то внешней лексической переменной, то сделаем так, чтобы этого никогда
не произошло: возьмём <code><span class="func">gensym</span></code> и получим для внутренней переменной
неповторимое и гарантированно уникальное в текущем лексическом окружении имя.
Поражаясь простоте решения, невозмутимо пишем:</p>

<pre>(define-abbreviation (acons key value alist)
  (let ((f (gensym)))
    `(let ((,f cons)) (,f (,f ,key ,value) ,alist)) ) )</pre>

<p>С первой проблемой, касающейся ссылки на <code><span class="func">cons</span></code> в макросе, разобраться будет
сложнее. В данном случае хочется иметь какой-то механизм, с помощью которого
можно было бы сказать, что <code><span class="func">cons</span></code> — это ссылка на глобальную переменную
<code><span class="func">cons</span></code>, а не на что-то другое. В конце концов, именно эта переменная
<code><span class="func">cons</span></code> была видна с места определения макроса <code><span class="func">acons</span></code>. Из этого наблюдения
следует главное правило макрогигиены: в раскрытом макросе свободные переменные
сохраняют смысл, который они имели при определении этого макроса.</p>

<p>На случай с <code><span class="func">cons</span></code> во многих реализациях Лиспа и Scheme есть механизм доступа
к глобальным переменным в любом контексте; обычно это нечто вроде <code><span class="func">(global
cons)</span></code> или <code><span class="func">lisp:cons</span></code>. Но иногда необходимо связать локальную переменную
с переменной в раскрытом макросе, как в следующем примере:</p>

<pre>(let ((results '())
      (compose cons) )
  (let-syntax ((push (syntax-rules ()
                      ((push e) (set! results (compose e results))) )))
    |$\pi$|
    results ) )</pre>

<p>Мы хотим, чтобы во всём теле $\pi$ этого выражения можно было использовать
макрос <code><span class="func">push</span></code>, который присоединяет свой аргумент к переменной <code><span class="func">results</span></code>
с помощью функции <code><span class="func">compose</span></code>. Для этого необходимо обеспечить гигиеничность
данного макроса — сделать так, чтобы ни одно определение внутри $\pi$ не смогло
изменить смысл <code><span class="func">push</span></code>. По существу, у нас есть два варианта:</p>

<p>\begin{enumerate}
  \item переименовать все мешающие переменные внутри $\pi$ так, чтобы
        всегда были видны правильные <code><span class="func">results</span></code> и <code><span class="func">compose</span></code>;</p>

<p>  \item аккуратно переименовать сами переменные <code><span class="func">results</span></code> и <code><span class="func">compose</span></code>,
        чтобы они не пересекались ни с чем из $\pi$; то есть, изменить
        <code><span class="func">let</span></code>-форму, определение <code><span class="func">push</span></code> и тело <code><span class="func">let-syntax</span></code>.
\end{enumerate}</p>


<!--\indexR{привязки (bindings)!захват}-->
<!--\indexR{символы!захват смысла}-->
<!--\indexR{захват смысла символов}-->
<p>Несмотря на то, что мы постоянно говорим о переменных и привязках, для макросов
таких вещей не существует. Они не захватывают привязки, подобно замыканиям, так
как никаких привязок вообще ещё нет — ведь во время раскрытия макросов всё
это просто S-выражения! Более того, {\RnRS} не вводит никаких зарезервированных
идентификаторов, поэтому ничто не запрещает создавать макросы-тёзки специальных
форм. Следовательно, внутренние макросы $\pi$ вполне могут «переопределить»
примитив <code><span class="func">set!</span></code>, очевидно свободный в макросе <code><span class="func">push</span></code>. Даже это не должно
изменить поведения <code><span class="func">push</span></code>. Гигиеничные макросы захватывают сам <em>смысл</em>
символов, а не значения переменных.</p>


<!--\indexR{макрогигиена!исключения}-->
<!--\indexC{loop}-->
<p>Гигиена — это замечательная и привлекательная возможность, но её нельзя
принять с распростёртыми объятиями всюду, так как существуют чрезвычайно
полезные, но не полностью гигиеничные макросы. Наиболее известный из них —
это макрос <code><span class="func">loop</span></code>. Из него обычно можно выйти с помощью функции <code><span class="func">exit</span></code>.
Однако, если он будет реализован вот так:</p>


<!--\indexC{loop}-->
<pre>(define-syntax loop
  (syntax-rules ()
    ((loop e1 e2 ...)
     (call/cc (lambda (exit)
                (let loop () e1 e2 ... (loop)) )) ) ) )</pre>

<p>\noindent
то из него нельзя будет выйти таким образом, потому что любое упоминание
<code><span class="func">exit</span></code> внутри форм <code><span class="func">e1</span></code>, <code><span class="func">e2</span></code>\textdots\ из-за гигиенических
переименований будет ссылаться не на тот <code><span class="func">exit</span></code>, который объявлен внутри
макроса, а на тот, который виден с места макровызова. Здесь необходимо как-то
сказать экспандеру, чтобы он не трогал переменную <code><span class="func">exit</span></code>, но в стандарте
{\RnRS} такая возможность не предусмотрена. Строгая гигиена является хорошим
решением по умолчанию: в определении <code><span class="func">loop</span></code> кажется логичным, что форма
<code><span class="func">(loop)</span></code> ссылается именно на определяемую там же локальную переменную;
однако иногда от правил требуется отступать.</p>


<!--\indexC{with-aliases}-->
<p>В Интернете можно найти множество вполне неплохих реализаций гигиеничных
макросистем, каждая из них обладает своими особенностями, достойными изучения.
Приводимое здесь решение проблемы гигиены не ограничивает вычисления,
допускаемые во время раскрытия макросов, но является довольно низкоуровневым по
сравнению с другими известными реализациями, например, описанными
в \cite{kcr98,dhb93}. Идея заключается в явном перечислении символов, чей смысл
во время раскрытия должен остаться тем же, каким он был во время объявления
макроса, а не определяться из контекста. Рассмотрим на примере. Форма
<code><span class="func">with-aliases</span></code> принимает список пар «имя переменной — символ»; <em>на
время раскрытия</em> макросов эта форма связывает переменные с тем, что означают
соответствующие символы в текущем окружении. Внутри макросов можно пользоваться
данными переменными, чтобы получить доступ к необходимым объектам. Остальные
аргументы формы <code><span class="func">with-aliases</span></code> составляют её тело, лексический блок,
содержащий созданные переменные. Итого, предыдущий пример переписывается
следующим образом:</p>

<pre>(let ((results '())
      (compose cons) )
  (with-aliases ((s set!) (r results) (c compose))
    (let-abbreviation (((push e)
                        `(,s ,r (,c ,e ,r)) ))
      |$\pi$|
      results ) ) )</pre>

<p>\noindent
А пример с <code><span class="func">loop</span></code> теперь выглядит вот так:</p>

<pre>(with-aliases ((cc call/cc) (lam lambda) (ll let))
  (define-abbreviation (loop . body)
    (let ((loop (gensym)))
      `(,cc (,lam (exit)
               (,ll ,loop () ,@body (,loop)) )) ) ) )</pre>

<p>Все символы, чей смысл мы хотим сохранить неизменным при раскрытии макросов,
перечисляются в <code><span class="func">with-aliases</span></code>. Она захватывает их, а во время раскрытия
макросов мы можем воспользоваться новыми именами, чтобы вставить на их место
именно то, что означали эти имена при входе в форму <code><span class="func">with-aliases</span></code>, а не то,
что они означают в текущем окружении, где раскрывается макрос.</p>

<p>Квазицитирование при такой реализации не особо удобно ввиду того, что большая
часть выражения не фиксирована. Также этот механизм довольно низкоуровневый —
он не делает макросы автоматически гигиеничными, лишь предоставляет инструмент
для самостоятельного соблюдения гигиены. Следующий раздел посвящён подробному
разбору этой и других частей нашей макросистемы.</p>

<h2 id="macros/sect:macrosystem">Макросистема</h2>


<!--\indexC{define-abbreviation}-->
<!--\indexC{let-abbreviation}-->
<!--\indexC{eval-in-abbreviation-world}-->
<!--\indexC{with-aliases}-->
<p>В этом разделе мы рассмотрим реализацию макросистемы, которая предоставляет
следующие возможности:</p>

<p>\begin{itemize}
  \item <code><span class="func">define-abbreviation</span></code> для определения глобальных макросов;</p>

<p>  \item <code><span class="func">let-abbreviation</span></code> для определения локальных макросов;</p>

<p>  \item <code><span class="func">eval-in-abbreviation-world</span></code> для вычислений в макромире;</p>

<p>  \item <code><span class="func">with-aliases</span></code> для захвата смысла символов.
\end{itemize}</p>

<p>Чтобы ещё раз подчеркнуть различие между подготовкой и исполнением программ,
результат раскрытия макросов будет на лету преобразовываться в дерево объектов.
Получаемое промежуточное объектное представление программ можно использовать
по-разному: можно отдать его на непосредственное исполнение быстрому
интерпретатору, как в шестой главе \seePage[chapter:fast], а можно взять
компилятор из десятой главы \seePage[chapter:cc] и преобразовать дерево объектов
в код на Си. В любом случае макросы раскрываются лишь один раз, после чего
структура программы застывает в виде объектов.</p>

<h3 id="macros/macrosystem/ssect:object">Объектификация</h3>


<!--\indexR{объектификация}-->
<!--\indexR{реификация}-->
<!--\indexR{преобразование!объектификация}-->
<!--\indexR{промежуточное представление}-->
<p>Отчасти объектификация схожа с реификацией — оба процесса приводят к некоему
«осязаемому» результату. Под объектификацией понимается преобразование
программ в соответствующие им объекты. Также сюда входит проверка и нормализация
синтаксиса обрабатываемых выражений, дабы нас в дальнейшем не тревожили глупые
ошибки. Эта трансформация программ схожа с той, что выполняется для быстрого
интерпретатора (и намерения у них тоже схожи), но в этот раз она выполняется
исключительно ради получения промежуточного представления как такового. Поэтому
вместо замыканий без аргументов, которые удобно вызывать, но очень сложно
анализировать, мы возьмём нечто более прозрачное — объекты, чьи поля будут
содержать всю необходимую для вычислений информацию. Кроме того, объектами
гораздо проще манипулировать, используя обобщённые функции.</p>

<p>Итак, иерархия используемых классов:</p>


<!--\indexC{Program}-->
<!--\indexC{Reference}-->
<!--\indexC{Local-Reference}%-->
<!--\indexC{Global-Reference}-->
<!--\indexC{Predefined-Reference}%-->
<!--\indexC{Global-Assignment}-->
<!--\indexC{Local-Assignment}-->
<!--\indexC{Function}%-->
<!--\indexC{Alternative}-->
<!--\indexC{Sequence}-->
<!--\indexC{Constant}-->
<!--\indexC{Application}%-->
<!--\indexC{Regular-Application}-->
<!--\indexC{Predefined-Application}-->
<!--\indexC{Fix-Let}%-->
<!--\indexC{Arguments}-->
<!--\indexC{No-Argument}-->
<!--\indexC{Variable}-->
<!--\indexC{Global-Variable}%-->
<!--\indexC{Predefined-Variable}-->
<!--\indexC{Local-Variable}-->
<pre>(define-class Program                Object ())
(define-class Reference              Program (variable))
(define-class Local-Reference        Reference ())
(define-class Global-Reference       Reference ())
(define-class Predefined-Reference   Reference ())
(define-class Global-Assignment      Program (variable form))
(define-class Local-Assignment       Program (reference form))
(define-class Function               Program (variables body))
(define-class Alternative Program (condition consequent alternant))
(define-class Sequence               Program (first last))
(define-class Constant               Program (value))
(define-class Application            Program ())
(define-class Regular-Application    Application (function arguments))
(define-class Predefined-Application Application (variable arguments))
(define-class Fix-Let                Program (variables arguments body))
(define-class Arguments              Program (first others))
(define-class No-Argument            Program ())
(define-class Variable               Object (name))
(define-class Global-Variable        Variable ())
(define-class Predefined-Variable    Variable (description))
(define-class Local-Variable         Variable (mutable? dotted?))</pre>

<p>В этом перечне легко заметить влияние предыдущих глав на наши представления
о внутреннем устройстве языка. Например, вызовы примитивов, приводимых форм
\seePage[fast/fast/ssect:reducible] и обычных функций выделены в отдельные
категории. Класс <code><span class="func">Program</span></code> представляет исключительно вычислимые понятия:
обращения к переменным, присваивания, вызовы функций. Сами переменные —
привязки значений к именам — являются объектами класса <code><span class="func">Variable</span></code>, это
не программы. Также стоит обратить внимание на деталь, отличающую эту реализацию
от рассмотренных ранее. Большинство определённых классов содержат столько полей,
сколько синтаксических элементов имеют соответствующие формы языка. Однако класс
локальных переменных содержит два дополнительных булевых поля: первое
показывает, обнаружены ли в программе присваивания этой переменной, а второе
истинно, если данная переменная — это точечный аргумент. Как вы помните,
точечные переменные требуют особого внимания при обработке вызовов функций.</p>


<!--\indexC{read}-->
<p>Часто предобработчик считывает исходные выражения просто с помощью <code><span class="func">read</span></code>
(или эквивалентной функции, возвращающей сырые S-выражения). Однако более
удобным подходом было бы использование функции, формирующей четвёрку из
собственно выражения, файла, откуда оно было считано, а также соответствующих
строки и столбца. Тогда мы сможем выводить прекрасно детализированные сообщения
об ошибках. Более того, в символы можно добавить дополнительное поле со ссылкой
на экспандер одноимённого макроса, что ускорит поиск макросов. На этапе
предобработки допустимо расширять поля объектов как угодно, если это поможет
улучшить её скорость \hbox{и/или} качество.</p>


<!--\indexR{ключевые слова}-->
<p>Итак, считанные S-выражения анализируются и преобразуются в объект класса
<code><span class="func">Program</span></code>, при этом в нём раскрываются все встреченные макросы. Главная
функция <code><span class="func">objectify</span></code> принимает два аргумента: S-выражение и его лексическое
окружение. Если выражение является формой, то <code><span class="func">objectify</span></code> смотрит на её
функциональный терм и выполняет соответствующую ему обработку. Обработчики
макросов не разбросаны где попало по коду, а располагаются в поле <code><span class="func">handler</span></code>
объектов класса <code><span class="func">Magic-Keyword</span></code> (терминология <span class="cite">[<a href="z1_bibliography.xhtml#ss75">ss75</a>]</span>), туда же для
удобства отправлены и специальные формы.</p>


<!--\indexC{Magic-Keyword}-->
<!--\indexC{objectify}-->
<p>\begin{code:lisp}[label=macros/macrosystem/object/src:objectify]
(define-class Magic-Keyword Object (name handler))</p>

<p>(define (objectify e r)
  (if (atom? e)
      (cond ((Magic-Keyword? e) e)
            ((Program? e)       e)
            ((symbol? e)        (objectify-symbol e r))
            (else               (objectify-quotation e r)) )
      (let ((m (objectify (car e) r)))
        (if (Magic-Keyword? m)
            ((Magic-Keyword-handler m) e r)
            (objectify-application m (cdr e) r) ) ) ) )</pre>

<p>Теперь остаётся лишь разобрать всевозможные специализированные подфункции,
выполняющие преобразования. Большинство из них просто заполняют поля объектов
результатами рекурсивной объектификации элементов соответствующих S-выражений.
И правда, сложно придумать какой-то другой способ для
<code><span class="func">objectify-alternative</span></code> и <code><span class="func">objectify-sequence</span></code>. Помимо этого функция
<code><span class="func">objectify-sequence</span></code> нормализует последовательности форм, превращая их
в набор одинаковых по структуре бинарных последовательностей, подобных
<code><span class="func">cons</span></code>-парам.</p>


<!--\indexC{objectify-quotation}-->
<!--\indexC{objectify-alternative}-->
<!--\indexC{objectify-sequence}-->
<pre>(define (objectify-quotation value r)
  (make-Constant value) )</p>

<p>(define (objectify-alternative ec et ef r)
  (make-Alternative (objectify ec r)
                    (objectify et r)
                    (objectify ef r) ) )</p>

<p>(define (objectify-sequence e* r)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (let ((a (objectify (car e*) r)))
            (make-Sequence a (objectify-sequence (cdr e*) r)) )
          (objectify (car e*) r) )
      (make-Constant 42) ) )</pre>

<p>Обработка вызовов функций немного сложнее, так как необходимо проанализировать
выражение и категоризовать его как приводимую форму, вызов примитива или вызов
обычной функции. Анализ выполняется на основе первого терма формы. Единственная
возможная тут неясность была упомянута ранее
\seePage[fast/fast/ssect:integrating]: доступна ли нам информация об арности
предопределённых функций и как её использовать для более эффективной компиляции.
Класс <code><span class="func">Functional-Description</span></code> подробно рассматривается чуть позже
(в разделе \ref{cc/gen/ssect:predef-env}) вместе с механизмом наполнения
начального окружения.</p>


<!--\indexC{objectify-application}-->
<!--\indexC{process-closed-application}-->
<pre>(define (objectify-application ff e* r)
  (let ((ee* (convert2arguments (map (lambda (e)
                                       (objectify e r) ) e*))))
    (cond ((Function? ff)
           (process-closed-application ff ee*) )
          ((Predefined-Reference? ff)
           (let* ((fvf  (Predefined-Reference-variable ff))
                  (desc (Predefined-Variable-description fvf)) )
             (if (Functional-Description? desc)
                 (if ((Functional-Description-comparator desc)
                      (length e*) (Functional-Description-arity desc) )
                     (make-Predefined-Application fvf ee*)
                     (objectify-error
                      "Incorrect predefined arity" ff e* ) )
                 (make-Regular-Application ff ee*) ) ) )
          (else (make-Regular-Application ff ee*)) ) ) )</p>

<p>(define (process-closed-application f e*)
  (let ((v* (Function-variables f))
        (b  (Function-body f)) )
    (if (and (pair? v*) (Local-Variable-dotted? (car (last-pair v*))))
        (process-nary-closed-application f e*)
        (if (= (number-of e*) (length v*))
            (make-Fix-Let v* e* b)
            (objectify-error "Incorrect regular arity" f e*) ) ) ) )</pre>

<p>Список аргументов вызова функции тоже преобразуется в объект (экземпляр класса
<code><span class="func">Arguments</span></code>); заканчивается этот список на специальный объект класса
<code><span class="func">No-Argument</span></code>. Количество аргументов можно определить с помощью обобщённой
функции <code><span class="func">number-of</span></code>.</p>


<!--\indexC{convert2arguments}-->
<!--\indexC{number-of}-->
<pre>(define (convert2arguments e*)
  (if (pair? e*)
      (make-Arguments (car e*) (convert2arguments (cdr e*)))
      (make-No-Argument) ) )</p>

<p>(define-generic (number-of (o)))</p>

<p>(define-method (number-of (o Arguments))
  (+ 1 (number-of (Arguments-others o))) )</p>

<p>(define-method (number-of (o No-Argument)) 0)</pre>

<p>Как обычно, редкий и громоздкий случай $n$-арных приводимых форм обрабатывается
отдельно. Дополнительные аргументы собираются в список, а соответствующая
точечная переменная заменяется обычной.
\seePage[fast/fast/ssect:reducible]</p>


<!--\indexC{process-nary-closed-application}-->
<pre>(define (process-nary-closed-application f e*)
  (let* ((v* (Function-variables f))
         (b  (Function-body f))
         (o (make-Fix-Let
             v*
             (let gather ((e* e*) (v* v*))
               (if (Local-Variable-dotted? (car v*))
                   (make-Arguments
                    (let pack ((e* e*))
                      (if (Arguments? e*)
                          (make-Predefined-Application
                           (find-variable? 'cons g.predef)
                           (make-Arguments
                            (Arguments-first e*)
                            (make-Arguments
                             (pack (Arguments-others e*))
                             (make-No-Argument) ) ) )
                          (make-Constant '()) ) )
                    (make-No-Argument) )
                   (if (Arguments? e*)
                       (make-Arguments (Arguments-first e*)
                                       (gather (Arguments-others e*)
                                               (cdr v*) ) )
                       (objectify-error
                        "Incorrect dotted arity" f e* ) ) ) )
             b )) )
    (set-Local-Variable-dotted?! (car (last-pair v*)) #f)
    o ) )</pre>

<p>Абстракции анализируются и объектифицируются функцией <code><span class="func">objectify-function</span></code>.
Она использует <code><span class="func">objectify-variables-list</span></code> для обработки списка аргументов,
которыми расширяется окружение создаваемого замыкания.</p>


<!--\indexC{objectify-function}-->
<!--\indexC{objectify-variables-list}-->
<pre>(define (objectify-function names body r)
  (let* ((vars (objectify-variables-list names))
         (b    (objectify-sequence body (r-extend* r vars))) )
    (make-Function vars b) ) )</p>

<p>(define (objectify-variables-list names)
  (if (pair? names)
      (cons (make-Local-Variable (car names) #f #f)
            (objectify-variables-list (cdr names)) )
      (if (symbol? names)
          (list (make-Local-Variable names #f #t))
          '() ) ) )</pre>

<p>Наконец, <code><span class="func">objectify-symbol</span></code> отвечает за обработку переменных. Сначала она
пытается найти их в текущем едином статическом лексическом окружении —
<code><span class="func">r</span></code>. Если переменная там не обнаружена, то она добавляется в глобальное
окружение функцией <code><span class="func">objectify-free-global-reference</span></code>. Верно, здесь мы решили
создавать новые переменные автоматически при их первом упоминании.</p>


<!--\indexC{objectify-symbol}-->
<!--\indexC{objectify-free-global-reference}-->
<pre>(define (objectify-symbol variable r)
  (let ((v (find-variable? variable r)))
    (cond ((Magic-Keyword? v)       v)
          ((Local-Variable? v)      (make-Local-Reference v))
          ((Global-Variable? v)     (make-Global-Reference v))
          ((Predefined-Variable? v) (make-Predefined-Reference v))
          (else (objectify-free-global-reference variable r)) ) ) )</p>

<p>(define (objectify-free-global-reference name r)
  (let ((v (make-Global-Variable name)))
    (insert-global! v r)
    (make-Global-Reference v) ) )</pre>

<p>Окружение <code><span class="func">r</span></code> является, в принципе, списком локальных переменных, за которым
следует список всех глобальных переменных, а в конце располагается список
предопределённых переменных. Так как это статическое окружение, то в нём
отсутствуют значения переменных — они определяются динамически, во время
исполнения программы. Различные окружения представляются списками объектов
класса <code><span class="func">Environment</span></code>. Их можно расширять как локальными, так и глобальными
переменными. Новые глобальные переменные физически добавляются в общую
глобальную часть, до которой можно добраться с помощью функции
<code><span class="func">find-global-environment</span></code>.</p>


<!--\indexC{Environment}-->
<!--\indexC{Full-Environment}-->
<!--\indexC{r-extend*}-->
<!--\indexC{find-variable"?}-->
<!--\indexC{insert-global"!}-->
<!--\indexC{mark-global-preparation-environment}-->
<!--\indexC{find-global-environment}-->
<pre>(define-class Environment      Object (next))
(define-class Full-Environment Environment (variable))</p>

<p>(define (r-extend* r vars)
  (if (pair? vars) (r-extend (r-extend* r (cdr vars)) (car vars))
                   r ) )</p>

<p>(define (r-extend r var)
  (make-Full-Environment r var) )</p>

<p>(define (find-variable? name r)
  (if (Full-Environment? r)
      (let ((var (Full-Environment-variable r)))
        (if (eq? name (cond ((Variable? var)
                             (Variable-name var))
                            ((Magic-Keyword? var)
                             (Magic-Keyword-name var) ) ) )
            var
            (find-variable? name (Full-Environment-next r)) ) )
      (if (Environment? r)
          (find-variable? name (Environment-next r))
          #f ) ) )</p>

<p>(define (insert-global! variable r)
  (let ((r (find-global-environment r)))
    (set-Environment-next!
     r (make-Full-Environment (Environment-next r) variable) ) ) )</p>

<p>(define (mark-global-preparation-environment g)
  (make-Environment g) )</p>

<p>(define (find-global-environment r)
  (if (Full-Environment? r)
      (find-global-environment (Full-Environment-next r))
      r ) )</pre>


<!--\indexC{mutable"?}-->
<p>Обработка присваиваний позволяет собрать информацию об изменяемости локальных
переменных: именно здесь у них устанавливается флаг <code><span class="func">mutable?</span></code>. Эта
информация впоследствии будет использована для проведения оптимизаций в десятой
главе. \seePage[chapter:cc]</p>


<!--\indexC{objectify-assignment}-->
<pre>(define (objectify-assignment variable e r)
  (let ((ov (objectify variable r))
        (of (objectify e r)) )
    (cond ((Local-Reference? ov)
           (set-Local-Variable-mutable?!
            (Local-Reference-variable ov) #t )
           (make-Local-Assignment ov of) )
          ((Global-Reference? ov)
           (make-Global-Assignment (Global-Reference-variable ov) of) )
          (else
           (objectify-error "Illegal assignment" variable) ) ) ) )</pre>

<p>Для программ, представленных деревьями подобных объектов, очень легко написать
интерпретатор, проверяющий правильность выполнения преобразования. Результат
будет сильно напоминать объектный интерпретатор из третьей главы и быстрый
интерпретатором из шестой.</p>


<!--\indexC{g.predef}-->
<!--\indexC{sg.predef}-->
<p>Рассмотрим общую структуру этого интерпретатора, чтобы вы не терялись
в последующих фрагментах кода. Вычисления выполняет функция <code><span class="func">evaluate</span></code>. Она
принимает два аргумента: экземпляр <code><span class="func">Program</span></code> и экземпляр <code><span class="func">Environment</span></code>
(теперь уже A-список пар из имён переменных и значений). Вначале окружение
содержит только предопределённые переменные. Его статическая часть представлена
переменной <code><span class="func">g.predef</span></code>, а динамическая — <code><span class="func">sg.predef</span></code>. Динамическая часть
связывает экземпляры <code><span class="func">RunTime-Primitive</span></code> с предопределёнными функциями.
Расширяется динамическое окружение с помощью функции <code><span class="func">sr-extend</span></code>.</p>

<h3 id="macros/macrosystem/ssect:special">Специальные формы</h3>


<!--\indexR{специальные формы}-->
<!--\indexR{форма!специальная}-->
<!--\indexR{ключевые слова}-->
<p>В данный момент объектификатор не распознаёт специальные формы, так что для
каждой из них надо определить персональную процедуру преобразования
в соответствующий объект класса <code><span class="func">Program</span></code>. Они определяются как ключевые
слова со специальными обработчиками. Эти обработчики будут просто вызывать
функции, рассмотренные в предыдущем разделе.</p>


<!--\indexC{special-if}-->
<!--\indexC{special-begin}-->
<!--\indexC{special-quote}-->
<!--\indexC{special-set"!}-->
<!--\indexC{special-lambda}-->
<pre>(define special-if
  (make-Magic-Keyword 'if
    (lambda (e r)
      (objectify-alternative (cadr e) (caddr e) (cadddr e) r) ) ) )</p>

<p>(define special-begin
  (make-Magic-Keyword 'begin
    (lambda (e r)
      (objectify-sequence (cdr e) r) ) ) )</p>

<p>(define special-quote
  (make-Magic-Keyword 'quote
    (lambda (e r)
      (objectify-quotation (cadr e) r) ) ) )</p>

<p>(define special-set!
  (make-Magic-Keyword 'set!
    (lambda (e r)
      (objectify-assignment (cadr e) (caddr e) r) ) ) )</p>

<p>(define special-lambda
  (make-Magic-Keyword 'lambda
    (lambda (e r)
      (objectify-function (cadr e) (cddr e) r) ) ) )</pre>


<!--\indexC*{special-form-keywords}{*special-form-keywords*}-->
<p>Естественно, точно таким же образом можно определить столько дополнительных
специальных форм, сколько необходимо. Чтобы ничего потом не напутать, запишем
их все в список <code><span class="func">*special-form-keywords*</span></code>:</p>

<pre>(define *special-form-keywords*
  (list special-quote
        special-if
        special-begin
        special-set!
        special-lambda
        ;; <code><span class="func">cond</span></code>, <code><span class="func">letrec</span></code> и т. д.
        special-let
        ) )</pre>

<h3 id="macros/macrosystem/ssect:eval-level">Уровни интерпретации</h3>


<!--\indexR{уровни интерпретации}-->
<!--\indexR{интерпретация!уровневая}-->
<p>Как вы знаете, эндогенное раскрытие макросов подразумевает наличие внутри
специального вычислителя. Но не забывайте, что эндогенный подход не требует
единства мира: результат объектификации не обязательно исполняется в том же
окружении, где он создавался. Компилятор в Си из десятой главы
\seePage[chapter:cc] служит этому хорошим примером. Нам бы не хотелось
запутаться во всех этих вычислителях, так что давайте введём понятие
<em class="term">уровня интерпретации</em> (или вычислений) и примем наиболее строгий постулат:
язык, макроязык, макроязык макроязыка и так далее — все они отделены друг от
друга, соответствующие вычисления производятся в различных глобальных
окружениях. Данные вычислители представляются объектами класса <code><span class="func">Evaluator</span></code>,
описывающего их важнейшие свойства:</p>


<!--\indexC{Evaluator}-->
<pre>(define-class Evaluator Object
  ( mother
    Preparation-Environment
    RunTime-Environment
    eval
    expand
    ) )</pre>

<p>Взаимодействие вычислителей весьма запутанно.
Рисунок \ref{macros/macrosystem/eval-level/pic:tower} иллюстрирует цепочку
вызовов, возникающую в процессе раскрытия макросов. Экспандер одного уровня
использует вычислитель следующего, который в свою очередь тоже предварительно
раскрывает макросы в получаемом выражении, используя вычислитель следующего
уровня, и так далее. Цепочка прерывается, как только получаемое выражение
оказывается лишённым макросов; в таком случае следующий уровень не нужен. Обычно
бывает достаточно всего двух-трёх уровней. Каждый уровень интерпретации имеет
своё окружение времени подготовки (для <code><span class="func">expand</span></code>) и окружение времени
исполнения (для <code><span class="func">eval</span></code>), кроме разве что самого нижнего уровня, где в цепочке
может участвовать один лишь экспандер.</p>

<p>\begin{figure}\centering
\input{figures/fig9.9}
\ForLayout{display}{\vskip-\medskipamount}
\caption{Цепочка вычислителей.}%
\label{macros/macrosystem/eval-level/pic:tower}
\ForLayout{display}{\vskip-\medskipamount}
\end{figure}</p>


<!--\indexC{enrich-with-new-global-variables"!}-->
<p>Функция <code><span class="func">create-evaluator</span></code> используется для создания новых уровней
интерпретации. Она строит новый уровень над тем, который получает через
аргумент. Также она определяет пару функций <code><span class="func">eval</span></code> и <code><span class="func">expand</span></code>, а также
соответствующие им окружения подготовки и исполнения. Перед началом вычислений
<code><span class="func">eval</span></code> раскрывает в полученном выражении макросы, затем выполняет собственно
вычисления с помощью функции <code><span class="func">evaluate</span></code>. Этому чистому вычислителю кроме
выражения необходимо лишь окружение времени исполнения, хранимое в поле
<code><span class="func">RunTime-Environment</span></code> текущего экземпляра <code><span class="func">Evaluator</span></code>. При необходимости
вычислитель может физически изменять данное окружение. Функция <code><span class="func">expand</span></code>
объектифицирует получаемое выражение с помощью <code><span class="func">objectify</span></code>
в окружении времени подготовки, хранимом в соответствующем поле
<code><span class="func">Preparation-Environment</span></code>. Для простоты все глобальные переменные,
создаваемые во время вложенных вычислений, помещаются в персональное
глобальное окружение текущего вычислителя с помощью функции
<code><span class="func">enrich-with-new-global-variables!</span></code>. Функция <code><span class="func">eval</span></code> рефлексивным
образом устанавливается в своё собственное окружение времени исполнения как
предопределённый примитив. Таким образом, различные уровни пользуются
различными функциями <code><span class="func">eval</span></code>. Далее, перед началом работы окружение
времени подготовки расширяется специальными формами, хранимыми в переменной
<code><span class="func">*special-form-keywords*</span></code>. Эта переменная должна быть видима на всех уровнях.
Кроме того, окружение времени подготовки расширяется предопределёнными
макросами, возвращаемыми вызовом <code><span class="func">(make-macro-environment level)</span></code>, который
мы рассмотрим чуть позже.</p>

<p>\ForLayout{display}{\vskip-\smallskipamount}</p>


<!--\indexC{create-evaluator}-->
<pre>(define (create-evaluator old-level)
  (let ((level 'wait)
        (g     g.predef)
        (sg    sg.predef))
    (define (expand e)
      (let ((prg (objectify
                  e (Evaluator-Preparation-Environment level) )))
        (enrich-with-new-global-variables! level)
        prg ) )
    (define (eval e)
      (let ((prg (expand e)))
        (evaluate prg (Evaluator-RunTime-Environment level)) ) )</p>

<p>  ;; Создаём вычислитель
    (set! level (make-Evaluator old-level 'wait 'wait eval expand))</p>

<p>  ;; Наполняем глобальное окружение
    (set! g (r-extend* g *special-form-keywords*))
    (set! g (r-extend* g (make-macro-environment level)))
    (let ((eval-var (make-Predefined-Variable
                     'eval (make-Functional-Description = 1 "") ))
          (eval-fn (make-RunTime-Primitive eval = 1)) )
      (set! g (r-extend g eval-var))
      (set! sg (sr-extend sg eval-var eval-fn)) )</p>

<p>  ;; Устанавливаем окружения в вычислитель
    (set-Evaluator-Preparation-Environment!
     level (mark-global-preparation-environment g) )
    (set-Evaluator-RunTime-Environment!
     level (mark-global-runtime-environment sg) )

    level ) )</pre>

<p>Если программе потребуется явный экспандер или вычислитель, то достаточно
создать новый уровень интерпретации с помощью <code><span class="func">create-evaluator</span></code> и достать
оттуда необходимую функцию <code><span class="func">expand</span></code> или <code><span class="func">eval</span></code>. Ос\-то\-рожно: вопреки
ожиданиям, <code><span class="func">expand</span></code> возвращает экземпляры <code><span class="func">Program</span></code>, а не выражения
Scheme. Если нужны именно такие выражения, то несложно написать соответствующую
функцию-преобразователь. \seeEx[macros/ex:decompile]</p>

<h3 id="macros/macrosystem/ssect:macros">Макросы</h3>


<!--\indexR{бесконечная регрессия}-->
<!--\indexR{ленивые вычисления}-->
<!--\indexR{обещания}-->
<p>По нашей задумке, в начальном окружении времени подготовки должны изначально
присутствовать предопределённые макросы, создаваемые функцией
<code><span class="func">make-macro-environment</span></code>. Вот эта четвёрка: <code><span class="func">eval-in-abbreviation-world</span></code>,
<code><span class="func">define-abbreviation</span></code>, <code><span class="func">let-abbreviation</span></code> и <code><span class="func">with-aliases</span></code>. Все они
предполагают существование следующего уровня интерпретации, который должен быть
построен той же функцией <code><span class="func">make-macro-environment</span></code>. Однако, если попытаться
создать этот уровень сразу же, то мы погрязнем в бесконечном цикле, так как на
новом уровне тоже должна быть своя четвёрка предопределённых макросов. Эта
проблема известна в философии как <em>бесконечная регрессия</em>. Новый уровень
интерпретации необходим только в том случае, если какой-то из данных макросов
действительно используется на текущем уровне. \seeEx[macros/ex:unique] Поэтому
мы просто пообещаем создать этот уровень, когда он кому-то понадобится. Если
это так, то новый уровень останется и продолжит накапливать в себе определения,
иначе же он просто никогда не будет создан.</p>

<p>\ForLayout{display}{\clearpage}</p>


<!--\indexC{make-macro-environment}-->
<pre>(define (make-macro-environment current-level)
  (let ((metalevel (delay (create-evaluator current-level))))
    (list (make-Magic-Keyword 'eval-in-abbreviation-world
           (special-eval-in-abbreviation-world metalevel) )
          (make-Magic-Keyword 'define-abbreviation
           (special-define-abbreviation metalevel) )
          (make-Magic-Keyword 'let-abbreviation
           (special-let-abbreviation metalevel) )
          (make-Magic-Keyword 'with-aliases
           (special-with-aliases metalevel) ) ) ) )</pre>

<p>Макрос <code><span class="func">eval-in-abbreviation-world</span></code> является наиболее простым, так как его
работа сводится лишь к вычислению выражения с помощью вычислителя следующего
уровня. Вот здесь как раз и придётся потребовать создать для нас данный уровень.
Возвращаемым значением <code><span class="func">eval-in-abbreviation-world</span></code> должен быть объект,
получаемый вызовом объектификатора в текущем окружении. Это правило общее для
всех обитателей мира макросов.</p>


<!--\indexC{special-eval-in-abbreviation-world}-->
<pre>(define (special-eval-in-abbreviation-world level)
  (lambda (e r)
    (let ((body (cdr e)))
      (objectify ((Evaluator-eval (force level))
                  `(,special-begin . ,body) ) r) ) ) )</pre>


<!--\indexR{замыкания (closures)}-->
<p>Макрос <code><span class="func">define-abbreviation</span></code> создаёт и переопределяет глобальные макросы. Он
конструирует соответствующий экспандер и вычисляет полученную абстракцию на
следующем уровне, затем на текущем уровне в глобальном окружении предобработки
создаётся новое ключевое слово, чьим обработчиком назначается полученный ранее
экспандер. Функция <code><span class="func">invoke</span></code> в данном случае более удобна для вычислений,
нежели <code><span class="func">evaluate</span></code>. Когда создаваемый макрос вызовет экспандер с помощью
<code><span class="func">invoke</span></code>, он будет проводить вычисления в том окружении времени исполнения,
где был создан, то есть в окружении следующего уровня, которое замкнуто
в экспандере. Возвращает же макрос <code><span class="func">define-abbreviation</span></code> просто <code><span class="func">\#t</span></code>.
Можно было бы возвращать символ с именем созданного макроса, но мы сэкономим
немного памяти на этом.</p>


<!--\indexC{special-define-abbreviation}-->
<pre>(define (special-define-abbreviation level)
  (lambda (e r)
    (let* ((call      (cadr e))
           (body      (cddr e))
           (name      (car call))
           (variables (cdr call)) )
      (let ((expander ((Evaluator-eval (force level))
                       `(,special-lambda ,variables . ,body) )))
        (define (handler e r)
          (objectify (invoke expander (cdr e)) r) )
        (insert-global! (make-Magic-Keyword name handler) r)
        (objectify #t r) ) ) ) )</pre>

<p>Локальные макросы создаются похожим образом. Разница только в том, что
новые ключевые слова помещаются в начало текущего окружения — туда, где
расположены локальные определения.</p>


<!--\indexC{special-let-abbreviation}-->
<pre>(define (special-let-abbreviation level)
  (lambda (e r)
    (let ((level  (force level))
          (macros (cadr e))
          (body   (cddr e)) )
      (define (make-macro def)
        (let* ((call      (car def))
               (body      (cdr def))
               (name      (car call))
               (variables (cdr call)) )
          (let ((expander ((Evaluator-eval level)
                           `(,special-lambda ,variables . ,body) )))
            (define (handler e r)
              (objectify (invoke expander (cdr e)) r) )
            (make-Magic-Keyword name handler) ) ) )
      (objectify `(,special-begin . ,body)
                 (r-extend* r (map make-macro macros)) ) ) ) )</pre>

<p>Самым сложным из всей четвёрки является макрос <code><span class="func">with-aliases</span></code>, так как его
работа затрагивает сразу несколько уровней. Он должен захватить смысл символов
на текущем уровне, передать его на следующий, там связать эти значения с новыми
переменными, причём сделать всё это исключительно на время выполнения раскрытия
своего тела. Именно хореография областей видимости, уровней интерпретации
и времени жизни делает этот макрос столь сложным.</p>


<!--\indexC{special-with-aliases}-->
<pre>(define (special-with-aliases level)
  (lambda (e current-r)
    (let* ((level   (force level))
           (old-r   (Evaluator-Preparation-Environment level))
           (old-sr  (Evaluator-RunTime-Environment level))
           (aliases (cadr e))
           (body    (cddr e)) )
      (let bind ((aliases aliases)
                 (r  old-r)
                 (sr old-sr) )
        (if (pair? aliases)
            (let* ((variable (car (car aliases)))
                   (keyword  (cadr (car aliases)))
                   (var      (make-Local-Variable variable #f #f)) )
              (bind (cdr aliases)
                    (r-extend r var)
                    (sr-extend sr var
                               (objectify keyword current-r) ) ) )
            (let ((result 'wait))
              (set-Evaluator-Preparation-Environment! level r)
              (set-Evaluator-RunTime-Environment! level sr)
              (set! result (objectify `(,special-begin . ,body)
                                      current-r ))
              (set-Evaluator-Preparation-Environment! level old-r)
              (set-Evaluator-RunTime-Environment! level old-sr)
              result ) ) ) ) ) )</pre>


<!--\indexR{динамическое связывание}-->
<!--\indexR{связывание!динамическое}-->
<p>Для временной модификации окружения следующего уровня интерпретации прекрасно
подошёл бы механизм динамического связывания, гарантирующий восстановление
старого окружения после завершения раскрытия формы <code><span class="func">with-aliases</span></code>.</p>

<p>Переменные, создаваемые <code><span class="func">with-aliases</span></code>, связываются со значениями, которые
ранее вернула функция <code><span class="func">objectify</span></code>, то есть с объектами класса <code><span class="func">Program</span></code>
или <code><span class="func">Magic-Keyword</span></code>. Так как подобные объекты вполне могут быть возвращены
обратно из <code><span class="func">with-aliases</span></code> в результате раскрытия макросов, то <code><span class="func">objectify</span></code>
должна уметь с ними обращаться. Именно поэтому она вначале проверяет,
не является ли полученное выражение уже объектифицированной программой или
ключевым словом. \seePage[macros/macrosystem/object/src:objectify]</p>

<h3 id="macros/macrosystem/ssect:limits">Ограничения</h3>


<!--\indexR{гигиеничные макросы}-->
<!--\indexR{макрогигиена}-->
<!--\indexR{макросы!гигиеничные}-->
<p>Механизм гигиеничного переименования позволяет жонглировать переменными и
привязками, даёт возможность захватывать значение символа в одном месте, а
использовать его в совершенно другом — там, откуда до данной переменной
нельзя добраться иным способом; и даже там, где она вовсе не существует.
Например:</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>

<pre>(let ((count 0))
  (with-aliases ((c count))
    (define-abbreviation (tick) c) )
  (tick) )
(let ((count 1) (c 2))
  (tick) )</pre>


<!--\indexR{захват смысла символов}-->
<p>Глобальный макрос <code><span class="func">tick</span></code> ссылается на локальную переменную <code><span class="func">count</span></code>,
которая не видна из второй формы <code><span class="func">let</span></code>. Действительно, необдуманный захват
смысла символов может вызывать ошибки нового типа: обращения к несуществующим
переменным. Несмотря на то, что в локальном окружении есть переменная с именем
<code><span class="func">count</span></code>, это <em>не та</em> <code><span class="func">count</span></code>, которую ищет <code><span class="func">tick</span></code>! Причина ошибки
видна яснее в следующем «деобъектифицированном» представлении исходного
фрагмента:</p>

<pre>((LAMBDA (COUNT501)
   (BEGIN #T ;; <code><span class="func">(tick)</span></code> $\leadsto$ <code><span class="func">COUNT501</span></code>
          COUNT501 ) ) 0)
((LAMBDA (COUNT502 C503) COUNT501) 1 2)</pre>

<p>\ForLayout{display}{\endgroup}</p>

<p>Расположение формы <code><span class="func">with-aliases</span></code> необходимо тщательно выбирать, так как это
нечто вроде <code><span class="func">let</span></code>, только для следующего уровня интерпретации. Если написать</p>

<pre>(define-abbreviation (loop . body)
  (with-aliases ((cc call/cc) (lam lambda) (ll let))
    (let ((loop (gensym)))
      `(,cc (,lam (exit) (,ll ,loop () ,@body (,loop)))) ) ) )</pre>

<p>\noindent
то форма <code><span class="func">with-aliases</span></code> захватит смысл символов на уровне макроопределений,
так что использовать их можно только на этом или более высоком уровне. Здесь
<code><span class="func">with-aliases</span></code> содержится внутри <code><span class="func">define-abbreviation</span></code>, поэтому в момент
раскрытия макроса <code><span class="func">loop</span></code> смысл <code><span class="func">call/cc</span></code> захватывается в мире макросов,
привязывается к переменной <code><span class="func">cc</span></code> и\textdots\ мы получаем ошибку <code><span class="func">"cc:
unknown value"</span></code>, так <code><span class="func">call/cc</span></code> из мира макросов недоступна раскрытому коду,
находящемуся в мире программ.</p>


<!--\indexR{полноценные объекты!окружения}-->
<!--\indexC{import}-->
<!--\indexC{export}-->
<p>Если не брать в расчёт специальные формы и другие ключевые слова вроде <code><span class="func">else</span></code>
и <code><span class="func">=></span></code>, то смысл локальных и глобальных переменных вполне успешно
захватывался с помощью полноценных окружений и форм <code><span class="func">import</span></code>\slash<code><span class="func">export</span></code>.
\seePage[reflection/reify-env/ssect:import] Однако механизм, показанный в данной
главе, несомненно является более мощным, так как, во-первых, он позволяет
захватывать специальные формы в том числе, а во-вторых, он выполняет это
статически, а не динамически.</p>

<p>Также рассмотренная макросистема позволяет создание предопределённых макросов,
чьё написание невозможно для конечного пользователя; например, можно определить
макрос, создающий глобальные переменные прямым вызовом функции
<code><span class="func">insert-global!</span></code>.</p>

<p>Несмотря на это, она имеет и недостатки. Если пользователь захочет посмотреть,
во что именно раскрываются макросы, то он столкнётся как минимум с двумя
затруднениями. Во-первых, ему недоступна функция <code><span class="func">expand</span></code>. Очевидно, это
можно исправить, сделав так, чтобы переменная <code><span class="func">expand</span></code> текущего уровня
интерпретации ссылалась на функцию <code><span class="func">expand</span></code> следующего. Вторая проблема
заключается в том, что результатом раскрытия является объект класса
<code><span class="func">Program</span></code>, чья структура неизвестна пользователю. Но и это тоже поправимо:
\seeEx[macros/ex:decompile].</p>

<p>Одной из задач данной макросистемы было продемонстрировать тесную связь между
макросами и компиляцией — оба понятия имеют поразительно много общего. Если
из приведённой реализации убрать код, ответственный за собственно вычисления и
объектификацию, то о макросах в нём будет напоминать только небольшая часть
функций <code><span class="func">objectify</span></code> и <code><span class="func">objectify-symbol</span></code>, а также четыре обработчика
предопределённых макросов. Суммарно это чуть меньше сотни строк кода — очень
мало.</p>

<p>Серьёзная макросистема, конечно же, должна включать в себя гораздо больше
полезных вещей:</p>

<p>\begin{enumerate}
  \item встроенные синтаксические возможности вроде <code><span class="func">or</span></code>, <code><span class="func">letrec</span></code>,
        вложенных <code><span class="func">define</span></code> и т. д.;</p>

<p>  \item квазицитирование, органично объединённое с объектификацией
        и раскрытием макросов;</p>

<p>  \item пользовательские макросимволы, позволяющие удобное написание
        программ в стиле <code><span class="func">define-handy-method</span></code>.
        \seePage[macros/usage/ssect:code-walk]
\end{enumerate}</p>

<p>Тем не менее, одной из изначальных целей — ознакомиться с идеей захвата
смысла символов — мы всё же достигли.</p>

<h2 id="macros/sect:conclusions">Заключение</h2>

<p>Все проблемы, связанные с макросами, можно обобщить двумя словами: необходимость
и несовместимость. Макросы регулярно используются на практике в том или ином
виде, но при этом существует огромное число несовместимых друг с другом
реализаций макросистем, предоставляющих различные возможности. В этой главе
мы попробовали охватить максимально широкий ассортимент решений. Немногие
руководства по реализациям Лиспа и Scheme точно описывают используемую модель
макросов, однако в их защиту можно сказать, что данная глава, вероятно, является
одной из первых попыток описать и классифицировать безмерное множество вариантов
поведения макросистем.</p>

<h2 id="macros/sect:exercises">Упражнения</h2>

<p>\begin{exercise}\label{macros/ex:repeat}
Определите макрос <code><span class="func">repeat</span></code>, который был описан в начале этой главы. Сделайте
его гигиеничным.
\end{exercise}</p>

<p>\begin{exercise}\label{macros/ex:arg-sequence}
С помощью <code><span class="func">define-syntax</span></code> определите макрос, принимающий последовательность
выражений и печатающий их по порядку рядом с их номерами. Например, макровызов
<code><span class="func">(enumerate $\pi_0$ $\pi_1$ ... $\pi_n$)</span></code> должен раскрыться в нечто, что при
выполнении напечатает <code><span class="func">0</span></code>, затем значение $\pi_0$, потом <code><span class="func">1</span></code>, а за ней
значение $\pi_1$, и так далее.
\end{exercise}</p>

<p>\begin{exercise}\label{macros/ex:unique}
Перенесите макросистему из данной главы в истинно единый мир.
\end{exercise}</p>

<p>\begin{exercise}\label{macros/ex:decompile}
Напишите функцию, преобразующую объекты <code><span class="func">Program</span></code> обратно в эквивалентные
S-выражения.
\end{exercise}</p>

<p>\begin{exercise}\label{macros/ex:study}
Изучите реализацию {\Meroonet} \seePage[chapter:objects] и определите, что
оттуда относится к библиотеке времени раскрытия, что к библиотеке времени
исполнения, а что к обеим.
\end{exercise}</p>

<p>
\section*{Рекомендуемая литература}\label{macros/sect:recommended-reading}</p>

<p>Весьма интересные мысли в защиту макросов приведены в книге <span class="cite">[<a href="z1_bibliography.xhtml#gra93">gra93</a>]</span>. Есть
также и работы больше теоретического характера, вроде <span class="cite">[<a href="z1_bibliography.xhtml#qp90">qp90</a>]</span>. О проблемах
гигиеничного макрораскрытия можно почитать в \cite{kffd86,dfh88,cr91a,qp91b}.
Наконец, стоит обратить внимание на многообещающую модель раскрытия,
рассмотренную в работе <span class="cite">[<a href="z1_bibliography.xhtml#dm95">dm95</a>]</span>.</p>

<p></body>
</html>
