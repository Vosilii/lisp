<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru"></p>

<p><body>
\chapter{\texorpdfstring{Lisp, 1, 2, \dots, $\omega$}{Lisp, 1, 2, ..., ω}}%
\label{chapter:lisp1-2-omega}</p>

<p>\initial{0.0ex}{0.0ex}{Ф}{\kern0.45ex ункции занимают} центральное место
в Лиспе, поэтому очевидно, что эффективность их вызовов очень важна.
Неудивительно, что за прошедшее время соответствующие механизмы были изучены
вдоль и поперёк, а исследования по диагонали всё ещё продолжаются. В этой главе
речь пойдёт о различных вариантах понимания функций и их вызовов. Мы поговорим
о том, что называется Lisp<sub>1</sub> и Lisp<sub>2</sub>, а также их различиях, вызываемых
концепцией отдельных пространств имён. Заканчивается глава рассмотрением
рекурсии и способов её реализации с учётом изученных вопросов.</p>

<div class="bigskip"/>

<p>Среди всевозможных объектов, используемых интерпретатором, функции требуют
особого подхода. Этот базовый тип объектов имеет личный конструктор:
<code><span class="func">lambda</span></code>, и поддерживает как минимум одну операцию: применение функции
к аргументам. Вряд ли можно его описать ещё проще, не сделав совсем бесполезным.
Кстати, именно то, что у функций немного характерных черт, делает их прекрасным
строительным блоком, инкапсулирующим поведение; функция может делать только то,
для чего она запрограммирована. К примеру, с помощью функций можно представлять
объекты, имеющие поля и методы <span class="cite">[<a href="z1_bibliography.xhtml#ar88">ar88</a>]</span>. В Scheme функциями представляется
вообще всё, что только можно представить в виде функции.</p>

<p>\phantomlabel{lisp1-2-omega/par:apval}
<!--\indexC{APVAL}-->
<!--\indexC{EXPR}-->
<!--\indexC{MACRO}-->
Попытки сделать вызовы функции более эффективными привели к множеству (часто
несовместимых) вариаций языка. Изначально <span class="logo">Lisp 1.5</span> <span class="cite">[<a href="z1_bibliography.xhtml#mae+62">mae+62</a>]</span> не имел
понятия объекта-функции. Реализация была такова, что переменная, функция и
макрос могли одновременно носить одно и то же имя, так как хранились в различных
ячейках (<code><span class="func">APVAL</span></code>, <code><span class="func">EXPR</span></code> и <code><span class="func">MACRO</span></code>\footnote{<code><span class="func">APVAL</span></code>,
<em class="term">A Permanent VALue</em>, для глобальных переменных; <code><span class="func">EXPR</span></code>,
<em class="term">EXPRession</em>, для глобальных функций; <code><span class="func">MACRO</span></code> для макросов.}) списка
свойств соответствующего символа.</p>


<!--\indexCS{lambda}{как ключевое слово}-->
<p>Maclisp выделял именованные функции в отдельную категорию, а его потомок
<span class="logo">Common Lisp</span> (CLtL2) <span class="cite">[<a href="z1_bibliography.xhtml#ste90">ste90</a>]</span> только недавно получил поддержку функций как
объектов первого класса. В <span class="logo">Common Lisp</span> <code><span class="func">lambda</span></code> — это ключевое слово
со значением: «Внимание! Дальше идёт определение анонимной функции».
<code><span class="func">lambda</span></code>-формы не имеют возвращаемого значения и могут находиться лишь
в определённых местах: как первый элемент формы вызова или как первый аргумент
специальной формы <code><span class="func">function</span></code>.</p>


<!--\indexR{объекты!первого класса}-->
<!--\indexR{объекты!полноценные}-->
<!--\indexR{первый класс (объектов)}-->
<!--\indexR{первый класс (объектов)|see{полноценные объекты}}-->
<!--\indexR{полноценные объекты}-->
<p>В отличие от них, Scheme с самой первой версии 1975 года имел функциональные
объекты и единое пространство имён, распространяя понятие <em class="term">первого класса</em>
практически на всё. Объекты первого класса (полноценные объекты) могут
приниматься или возвращаться функциями, находиться в списке, массиве, переменной
и т. д. Такой подход широко распространён в классе языков вроде ML, он же будет
использоваться и здесь.</p>

<h2 id="lisp1-2-omega/sect:lisp1">\texorpdfstring{\protectLisp<sub>1</sub>}{Lisp₁}</h2>


<!--\indexE{Lisp1@\protectLisp<sub>1</sub>}-->
<!--\indexR{Лисп!Lisp1@\protectLisp<sub>1</sub>}-->
<p>В предыдущей главе мы применяли именно такой подход: функции были объектами
(их создавала <code><span class="func">make-function</span></code>); в процессе вычислений мы не различали
функции и аргументы, при вычислении формы аппликации не было никакой разницы
между вычислением элемента на месте <em class="term">функции</em> и вычислением элементов,
находящихся на месте <em class="term">параметров</em>. Давайте ещё раз посмотрим на
интерпретатор из предыдущей главы:</p>

<pre>(define (evaluate e env)
  (if (atom? e) ...
      (case (car e)
        ...
        ((lambda) (make-function (cadr e) (cddr e) env))
        (else (invoke (evaluate (car e) env)
                      (evlis (cdr e) env) )) ) ) )</pre>

<p>Самое важное в нём:</p>

<p>\begin{enumerate}
  \item <code><span class="func">lambda</span></code> создаёт полноценные объекты — замыкания, —
        которые сохраняют окружение своего определения.</p>

<p>  \item При применении функции всё вычисляется одинаковым образом:
        с помощью <code><span class="func">evaluate</span></code>; <code><span class="func">evlis</span></code> лишь вызывает
        <code><span class="func">evaluate</span></code> для всех элементов списка.
\end{enumerate}</p>

<p>Благодаря этим двум качествам Scheme является представителем семейства Lisp<sub>1</sub>.</p>

<h2 id="lisp1-2-omega/sect:lisp2">\texorpdfstring{\protectLisp<sub>2</sub>}{Lisp₂}</h2>


<!--\indexE{Lisp2@\protectLisp<sub>2</sub>}-->
<!--\indexR{Лисп!Lisp2@\protectLisp<sub>2</sub>}-->
<p>В большинстве программ на Лиспе при вызовах функций первым элементом формы
является имя глобальной функции. Это справедливо и для программ из предыдущей
главы. Мы могли бы сделать данное ограничение частью языка. Это бы не сильно
изменило внешний вид кода, но облегчило бы вычисление форм: для первого элемента
уже не нужна вся мощь <code><span class="func">evaluate</span></code>, достаточно мини-вычислителя, который бы
умел только искать нужную функцию по имени. Для реализации этой идеи изменим
соответствующую часть <code><span class="func">evaluate</span></code>:</p>

<pre>...
(else (invoke (lookup (car e) env)
              (evlis (cdr e) env) )) ...</pre>


<!--\indexC{fenv}-->
<!--\indexR{окружение!функциональное}-->
<p>Теперь у нас два разных вычислителя, по одному на каждый случай, где мы можем
встретить переменную: на месте функции или на месте аргумента. Мы можем
по-разному обрабатывать один и тот же идентификатор в зависимости от его
положения. Если функции требуют особого подхода, то логичным будет также
выделить для них особое пространство имён. Очевидно, что легче искать имена
функций в окружении, где нет имён переменных, которые только мешают.
Интерпретатор легко адаптировать для этого случая. Нам понадобится окружение
для функций <code><span class="func">fenv</span></code> и специализированный вычислитель
<code><span class="func">evaluate-application</span></code>, который знает, как обращаться с элементами данного
окружения. Так как теперь у нас два окружения и два вычислителя, то мы назовём
это Lisp<sub>2</sub> <span class="cite">[<a href="z1_bibliography.xhtml#sg93">sg93</a>]</span>.</p>


<!--\indexC{f.evaluate}-->
<pre>(define (f.evaluate e env fenv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (f.evaluate (cadr e) env fenv)
                      (f.evaluate (caddr e) env fenv)
                      (f.evaluate (cadddr e) env fenv) ))
        ((begin)  (f.eprogn (cdr e) env fenv))
        ((set!)   (update! (cadr e)
                           env
                           (f.evaluate (caddr e) env fenv) ))
        ((lambda) (f.make-function (cadr e) (cddr e) env fenv))
        (else     (evaluate-application (car e)
                                        (f.evlis (cdr e) env fenv)
                                        env
                                        fenv )) ) ) )</pre>

<p>За вычисление форм отвечает <code><span class="func">evaluate-application</span></code>, которая принимает
«сырое» имя функции, вычисленные значения аргументов и два текущих окружения.
Как видно из определения <code><span class="func">lambda</span></code>, при создании функции замыкаются оба
окружения: <code><span class="func">env</span></code> и <code><span class="func">fenv</span></code>. В остальном новая версия отличается только тем,
что за <code><span class="func">env</span></code> следует (как тень) <code><span class="func">fenv</span></code>. Естественно, ещё необходимо
доработать функции <code><span class="func">evlis</span></code> и <code><span class="func">eprogn</span></code>, чтобы они использовали <code><span class="func">fenv</span></code>:</p>


<!--\indexC{f.evlis}-->
<!--\indexC{f.eprogn}-->
<pre>(define (f.evlis exps env fenv)
  (if (pair? exps)
      (cons (f.evaluate (car exps) env fenv)
            (f.evlis (cdr exps) env fenv) )
      '() ) )</p>

<p>(define (f.eprogn exps env fenv)
  (if (pair? exps)
    (if (pair? (cdr exps))
        (begin (f.evaluate (car exps) env fenv)
               (f.eprogn (cdr exps) env fenv) )
        (f.evaluate (car exps) env fenv) )
    empty-begin ) )</pre>

<p>При вызове функции её аргументы расширяют окружение переменных, для этого
необходимо доработать только способ создания функции; механизм вызова
(<code><span class="func">invoke</span></code>) изменений не требует.</p>


<!--\indexC{f.make-function}-->
<pre>(define (f.make-function variables body env fenv)
  (lambda (values)
    (f.eprogn body (extend env variables values) fenv) ) )</pre>

<p>Задача <code><span class="func">evaluate-application</span></code> в том, чтобы проанализировать функциональный
элемент формы и обеспечить правильный вызов. Если мы последуем путём
<span class="logo">Common Lisp</span>, то на месте функционального элемента может стоять или символ,
или <code><span class="func">lambda</span></code>-форма.</p>


<!--\indexC{evaluate-application}-->
<p>\begin{code:lisp}[label=lisp1-2-omega/lisp2/src:erroneous-eval-application]
(define (evaluate-application fn args env fenv)
  (cond ((symbol? fn)
         (invoke (lookup fn fenv) args) )
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn)
                   (extend env (cadr fn) args)
                   fenv ) )
        (else (wrong "Incorrect functional term" fn)) ) )</pre>

<p>И что же мы в итоге получили, а что потеряли? Первое очевидное преимущество
состоит в том, что для поиска функции по имени необходим только простой вызов
<code><span class="func">lookup</span></code>, а не <code><span class="func">f.evaluate</span></code> с последующим долгим синтаксическим разбором.
Далее, так как мы избавились ото всех ссылок на переменные в <code><span class="func">fenv</span></code>, это
окружение стало компактнее, а значит и поиск в нём ускорился. Второе
преимущество состоит в ускорении вычисления форм, где на месте функции находится
<code><span class="func">lambda</span></code>-форма. Например:</p>

<pre>(let ((state-tax 1.186))
  ((lambda (x) (* state-tax x)) (read)) )</pre>

<p>В этом случае для <code><span class="func">(lambda (x) (* state-tax x))</span></code> не будет создаваться
замыкание, её тело будет вычислено сразу в правильном окружении.</p>

<p>Проблема в том, что эти два преимущества по сути ничего не дают, так как тех же
результатов можно добиться и в Lisp<sub>1</sub> с помощью небольшого предварительного
анализа. Есть только один действительно приятный момент: Lisp<sub>2</sub> чуть-чуть
быстрее, так как мы можем быть уверены в том, что любое имя из <code><span class="func">fenv</span></code> связано
с функцией и ни с чем иным, а значит, проверку на то, что это действительно
функция, надо выполнять лишь один раз: при помещении функции в окружение. И так
как каждое имя должно быть связано с функцией, то все неиспользуемые имена можно
просто связать с <code><span class="func">wrong</span></code>.</p>

<p>Ввиду того, что каждое имя из <code><span class="func">fenv</span></code> связано с функцией, мы можем вообще
избавиться от вызова <code><span class="func">invoke</span></code>, а заодно и от вызова <code><span class="func">procedure?</span></code> внутри.
Это возможно, потому что мы реализуем интерпретатор на Scheme (в <span class="logo">Common Lisp</span>
формы вроде <code><span class="func">((lookup fn fenv) args)</span></code> запрещены). Для этого следует немного
изменить начало <code><span class="func">evaluate-application</span></code>:</p>

<pre>(define (evaluate-application fn args env fenv)
  (cond ((symbol? fn) ((lookup fn fenv) args))
        ... ) )</pre>

<p>В Лиспе функции вызываются так часто, что любой выигрыш времени при вызовах —
это уже хорошо и может сильно повлиять на производительность. Но этот конкретный
выигрыш не так уж и велик: он появляется только для динамически определяемых
функций, тогда как в большинстве случаев вызываемая функция известна статически.</p>

<p>Теперь поговорим о том, что же мы потеряли. А потеряли мы возможность
<em>вычислить</em> применяемую функцию. Рассмотрим выражение \ic{(if \ii{условие}
(+ 3 4) (* 3 4))}. В Scheme можно легко вынести аргументы <code><span class="func">3</span></code> и <code><span class="func">4</span></code> за
скобки: \ic{((if \ii{условие} + *) 3 4)}. Это просто, понятно и логично.
Фактически, это тождество. Но в Lisp<sub>2</sub> данная программа вызовет ошибку, так как
<code><span class="func">if</span></code>-форма, стоящая на месте функции, — это ни символ,
ни <code><span class="func">lambda</span></code>-форма.</p>

<h3 id="lisp1-2-omega/lisp2/ssect:eval-func-term">Вычисляем функции</h3>

<p>Возможности текущего окружения функций ещё далеки от возможностей окружения
переменных (окружения параметров). В частности, как вы видели, мы не можем
вычислить применяемую функцию. Традиционный трюк, существующий ещё со времён
Maclisp, заключается в том, что если <code><span class="func">evaluate-application</span></code> натыкается на
что-то непонятное, то она передаёт его функции <code><span class="func">f.evaluate</span></code>:</p>


<!--\indexC{evaluate-application}-->
<pre>(define (evaluate-application2 fn args env fenv)
  (cond ((symbol? fn)
         ((lookup fn fenv) args) )
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn)
                   (extend env (cadr fn) args)
                   fenv ) )
        [(else (evaluate-application2
               (f.evaluate fn env fenv) args env fenv))] ) )</pre>

<p>Теперь наша проблема решается следующим образом:</p>

<pre>(if |\ii{условие}| (+ 3 4) (* 3 4)) |\eq| ((if |\ii{условие}| '+ '*) 3 4)</pre>

<p>Не особо элегантно, так необходимо писать лишние кавычки, но по крайней мере это
работает. Работает, но, пожалуй, чересчур прилежно; иногда настолько, что
попадает в бесконечный цикл.</p>

<pre>('''''''''''''1789 |\ii{аргументы}|)</pre>

<p>Выражение \ic{'{}'{}'{}'{}'{}'{}'{}'{}'{}'{}'{}'{}'1789} сначала будет
вычислено тринадцать раз подряд, пока <code><span class="func">evaluate-application2</span></code> не доберётся до
числа 1789, а затем она попадёт в бесконечный цикл, так как 1789 — это
не функция и не символ, а значит, его надо передать в <code><span class="func">f.evaluate</span></code>,
чтобы\textdots\ получить опять число 1789! Короче говоря, надо тщательнее
следить за тем, что передаётся <code><span class="func">f.evaluate</span></code>. Проблема остаётся даже тогда,
когда мы перепишем интерпретатор следующим образом:</p>

<pre>(define (evaluate-application3 fn args env fenv)
  (cond
    ((symbol? fn)
     (let ((fun (lookup fn fenv)))
       (if fun (fun args)
           (evaluate-application3 (lookup fn env) args env fenv) ) ) )
    ... ) )</pre>

<p>В этом случае, если символ отсутствует в функциональном окружении, то поиск
повторяется уже в окружении переменных. Ой! Даже если предположить, что
не существует функции <code><span class="func">foo</span></code>, мы спокойно можем зациклиться при вычислении
значения переменной. Например:</p>

<pre>(let ((foo 'foo))
  (foo |\ii{аргументы}|) )</pre>

<p>Нет, можно, конечно, встроить в <code><span class="func">evaluate-application</span></code> защиту от этого,
проверяя, совпадает ли значение переменной с её именем. Но ведь можно написать
и так:</p>

<pre>(let ((flip 'flop)
      (flop 'flip) )
  (flip) )</pre>

<p>Единственный вариант, который пока не удалось одурачить — это самый первый на
странице \pageref{lisp1-2-omega/lisp2/src:erroneous-eval-application}, поэтому
необходимо найти другой метод вычисления функционального элемента формы.</p>

<h3 id="lisp1-2-omega/lisp2/ssect:duality">Двойственность миров</h3>

<p>Обобщая данные затруднения, можно сказать, что есть некоторые вычисления,
принадлежащие миру параметров, которые мы хотим перенести в мир функций,
и наоборот. Точнее говоря, мы хотим иметь возможность возвращать функцию как
результат вычислений и передавать её как аргумент вычислений.</p>


<!--\indexC{funcall}-->
<p>Если абсолютно необходимо, чтобы на месте функции стояло имя функции, но в то же
время мы хотим иметь возможность вычислять необходимую функцию, то будет
достаточно предопределённой функции, которая знает, как применять функции
к аргументам. Назовём её <code><span class="func">funcall</span></code> (от <em class="term">function call</em>). Она применяет
свой первый аргумент (который обязан быть функцией) к остальным. С её помощью
наша проблема решается следующим образом:</p>

<pre>(if |\ii{условие}| (+ 3 4) (* 3 4)) |\eq| (funcall (if |\ii{условие}| + *) 3 4)</pre>

<p>Все аргументы (первый в том числе) вычисляются обычной <code><span class="func">f.evaluate</span></code>.
Функция <code><span class="func">funcall</span></code> только берёт всё готовое и выполняет вызов. Мы легко можем
определить <code><span class="func">funcall</span></code> как</p>


<!--\indexC{funcall}-->
<pre>(define (funcall . args)
  (if (> (length args) 1)
      (invoke (car args) (cdr args))
      (wrong "Incorrect arity" 'funcall) ) )</pre>

<p>В Lisp<sub>2</sub> <code><span class="func">funcall</span></code> используется для динамического вычисления функций. Во всех
остальных случаях функция известна и не требуется проверять, действительно ли
это функция.</p>

<p>Обратите внимание на вызов <code><span class="func">invoke</span></code> в <code><span class="func">funcall</span></code>. Эта функция проверяет,
действительно ли её аргумент является функцией, в отличие от
<code><span class="func">evaluate-application</span></code>, где эта проверка не выполняется. Функций <code><span class="func">funcall</span></code>
больше похожа на <code><span class="func">apply</span></code>: обе принимают первым аргументом функцию, а за ним
— необходимые аргументы. Разница между ними лишь в том, что <code><span class="func">funcall</span></code>
статически знает количество передаваемых аргументов.</p>


<!--\indexE{+@<code><span class="func">+</span></code> (в \protect\CommonLisp)}-->
<!--\indexE{*@<code><span class="func">*</span></code> (в \protect\CommonLisp)}-->
<!--\indexE{REPL!определение}-->
<!--\indexR{интерактивная сессия (REPL)}-->
<p>К сожалению, есть ещё одна небольшая проблема. Когда мы пишем \ic{(if
\ii{условие} + *)}, мы ожидаем получить функцию сложения или умножения. Но то,
что мы сейчас получаем, — это значение переменной <code><span class="func">+</span></code> или <code><span class="func">*</span></code>!
В <span class="logo">Common Lisp</span> значения этих переменных и близко не связаны с арифметикой: они
хранят последнее считанное и последнее возвращённое REPL\trnote*{REPL —
«<em class="term">read--eval--print loop</em>», интерактивная сессия. В интерпретаторе из
предыдущей главы ей соответствует функция <code><span class="func">toplevel</span></code>.} значение!</p>


<!--\indexC{function}-->
<p>Мы ввели <code><span class="func">funcall</span></code> для того, чтобы получить возможность проводить вычисления
с функциями как со значениями. Конечно же, в интерпретаторе присутствует и
обратный процесс: ведь <code><span class="func">evaluate-application</span></code> получает именно такие значения
и вызывает их как функции; но эти преобразования происходят неявно.
В присутствии <code><span class="func">funcall</span></code> нам необходимо иметь возможность явно превратить имя
функциональной переменной <code><span class="func">+</span></code> в соответствующую функцию из окружения функций.
Для этого мы введём ещё одно приспособление: <code><span class="func">function</span></code>. Эта специальная
форма принимает имя функции и возвращает соответствующее функциональное
значение. Теперь мы можем свободно перемещаться меж двух миров:</p>

<pre>(if |\ii{условие}| (+ 3 4) (* 3 4)) |\equals|
       |\equals| (funcall (if |\ii{условие}| (function +) (function *)) 3 4)</pre>

<p>Для определения <code><span class="func">function</span></code> достаточно добавить соответствующую обработку
в <code><span class="func">f.evaluate</span></code>. Эта форма <code><span class="func">function</span></code> не имеет ничего общего с одноимённой
\seePage[basics/repr-func/dyn-and-lex-bind/src:closure-eval] формой
\ic{(function (lambda \ii{переменные} \ii{тело}))}, создающей замыкания. Здесь
мы определяем \ic{(function \ii{имя-функции})}, преобразующую имена функций
в их значения.</p>

<pre>...
((function)
 (cond ((symbol? (cadr e))
        (lookup (cadr e) fenv) )
       (else (wrong "Incorrect function" (cadr e))) ) ) ...</pre>


<!--\indexCS{lambda}{как метка}-->
<p>Мы легко можем расширить это определение, чтобы оно принимало и
<code><span class="func">lambda</span></code>-формы, как это сделано в <span class="logo">Common Lisp</span> или у нас на
странице \pageref{basics/repr-func/dyn-and-lex-bind/src:closure-eval}. Но в этом
нет особого смысла, так как наша <code><span class="func">lambda</span></code> сразу возвращает нужное значение.
В <span class="logo">Common Lisp</span> такое расширение необходимо, потому что там <code><span class="func">lambda</span></code> лишь
помечает код функции и «специальной форме» <code><span class="func">lambda</span></code> позволено или
находиться на месте функции, или быть первым аргументом специальной формы
<code><span class="func">function</span></code>.</p>

<p>Функция <code><span class="func">funcall</span></code> позволяет поместить результат вычислений из мира параметров
в переменную из мира функций. И наоборот, <code><span class="func">function</span></code> позволяет поместить
значение из мира функций в переменную из мира параметров. В них усматриваются
очевидные параллели: «применение функций — <code><span class="func">funcall</span></code>» и «разыменование
переменных — <code><span class="func">function</span></code>». Одновременное существование двух миров и
возможность общения между ними требуют подобных мостов.</p>


<!--\indexR{инлайнинг!функций}-->
<!--\indexR{функции!встраиваемые}-->
<!--\indexR{встраивание!функций}-->
<p>Заметьте, что сейчас мы не имеем возможности изменять функциональное окружение;
у нас нет соответствующего присваивания. Это позволяет компиляторам без опаски
и в полную силу задействовать механизм <em class="term">инлайн-функций</em>. Одной из
привлекательных сторон использования нескольких пространств имён является
возможность наделить каждое из них особыми свойствами.</p>

<p>
\subsection{\texorpdfstring{Используем \protectLisp<sub>2</sub>}{Используем Lisp₂}}%
\label{lisp1-2-omega/lisp2/ssect:using}</p>

<p>Чтобы полностью определить наш Lisp<sub>2</sub>, остаётся указать начальное функциональное
окружение и запустить в цикле сам интерпретатор, <code><span class="func">f.evaluate</span></code>. Определение
глобального функционального окружения мало чем отличается от окружения
переменных: надо всего лишь расширять другое начальное окружение.</p>


<!--\indexC{fenv.global}-->
<!--\indexC{definitial-function}-->
<!--\indexC{defprimitive}-->
<pre>(define fenv.global '())</p>

<p>(define-syntax definitial-function
  (syntax-rules ()
    ((definitial-function name)
     (begin (set! fenv.global (cons (cons 'name 'void) fenv.global))
            'name) )
    ((definitial-function name value)
     (begin (set! fenv.global (cons (cons 'name value) fenv.global))
            'name) ) ) )</p>

<p>(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value arity)
     (definitial-function name
       (lambda (values)
         (if (= arity (length values))
             (apply value values)
             (wrong "Incorrect arity"
              (list 'name 'values) ) ) ) ) ) ) )</p>

<p>(defprimitive car car 1)
(defprimitive cons cons 2)</pre>

<p>\noindent
И наконец:</p>

<pre>(define (|\fbox{\ii{бесспорно Lisp<sub>2</sub>}}|)
  (define (toplevel)
    (display (f.evaluate (read) env.global fenv.global))
    (toplevel) )
  (toplevel) )</pre>

<p>
\subsection{Расширяем функциональное окружение}%
\label{lisp1-2-omega/lisp2/ssect:enriching}</p>


<!--\indexR{окружение!как тип данных}-->
<p>Все окружения — это объекты некоторого абстрактного типа данных. Что мы
ожидаем от этого типа данных? Мы ожидаем, что он будет хранить связи между
именами и сущностями, что мы можем по имени отыскать нужную сущность, и что мы
можем добавлять новые связи. Ещё мы хотим иметь возможность определять локальные
функции, а для этого необходим механизм локального расширения функционального
окружения. В общем, хочется <code><span class="func">let</span></code>, но только для функций. Сейчас
функциональное окружение неизменяемо, так что было бы здорово иметь такую
возможность. Создадим новую специальную форму <code><span class="func">flet</span></code> (<em class="term">functional let</em>)
со следующим синтаксисом:</p>


<!--\indexC{flet}-->
<pre>(flet ((|\ii{имя\sub1}| |\ii{аргументы\sub1}| |\ii{тело\sub1}|)
        ...
       (|\ii{имя\sub{n}}| |\ii{аргументы\sub{n}}| |\ii{тело\sub{n}}|) )
  |\ii{выражения}|... )</pre>

<p>Так как <code><span class="func">flet</span></code> умеет создавать только локальные функции, нет необходимости
писать <code><span class="func">lambda</span></code>, это и так подразумевается. Специальная форма <code><span class="func">flet</span></code>
вычисляет формы \ic{(lambda \ii{аргументы\sub{i}} \ii{тело\sub{i}})} и связывает
получаемые значения с именами \ii{имя\sub{i}} в функциональном окружении. После
этого \ii{выражения} вычисляются в расширенном окружении, где можно ставить
\ii{имя\sub{i}} на место функции или передавать его в <code><span class="func">function</span></code>, если
понадобится соответствующее \nohyp{замыкание}.</p>

<p>Добавить <code><span class="func">flet</span></code> в <code><span class="func">f.evaluate</span></code> просто:</p>

<pre>...
((flet)
 (f.eprogn
  (cddr e)
  env
  (extend fenv
          (map car (cadr e))
          (map (lambda (def)
                 (f.make-function (cadr def) (cddr def) env fenv) )
               (cadr e) ) ) ) ) ...</pre>

<p>Форма <code><span class="func">flet</span></code> серьёзно расширяет наши возможности: например, она позволяет
<code><span class="func">lambda</span></code> замыкать в себе не только <code><span class="func">env</span></code>, но и <code><span class="func">fenv</span></code>. Рассмотрим
пример:</p>

<pre>(flet ((square (x) (* x x))
  (lambda (x) (square (square x))) )</pre>

<p>Значением этого выражения является анонимная функция, возводящая число
в четвёртую степень. Это замыкание сохраняет в себе и использует локальную
функцию <code><span class="func">square</span></code>.</p>

<h2 id="lisp1-2-omega/sect:extensions">Другие возможности</h2>

<p>Как только мы заставили вычислитель относиться по-особенному к функциям, на ум
сразу же приходят другие варианты использования этой возможности. Например, мы
могли бы трактовать числа как функции-аксессоры для списков:</p>

<pre>(2 '(foo bar hux wok))  |\is| hux
(-2 '(foo bar hux wok)) |\is| (hux wok)</pre>

<p>Число $n$ считается синонимом для \ic{cad\sup{$n$}r}, если оно неотрицательно,
или \ic{cd\sup{$-n$}r}, если оно меньше ноля. Базовым аксессорам <code><span class="func">car</span></code> и
<code><span class="func">cdr</span></code> соответствуют числа <code><span class="func">0</span></code> и <code><span class="func">-1</span></code>. После этого элементарно
реализуются чисто алгебраические преобразования $\text{<code><span class="func">(-1 (-2 $\pi$))</span></code>}
\eq \text{<code><span class="func">(-3 $\pi$)</span></code>}$ или $\text{<code><span class="func">(2 (-3 $\pi$))</span></code>} \eq
\text{<code><span class="func">(5 $\pi$)</span></code>}$.</p>

<p>Также можно придать смысл спискам функций на месте функции:</p>

<pre>((list + - *) 5 3) |\is| (8 2 15)</pre>

<p>Применение списка функций возвращает список из результатов применения каждого
элемента-функции к соответствующим аргументам. Фактически, предыдущий пример
— это краткая запись для</p>

<pre>(map (lambda (f) (f 5 3))
     (list + - *) )</pre>

<p>Наконец, мы могли бы разрешить функции быть вторым элементом аппликации,
эмулируя привычную инфиксную запись: выражение <code><span class="func">(1 + 2)</span></code> вернёт <code><span class="func">3</span></code>.
К примеру, такое поведение реализовано в DWIM из \cite{tei74,tei76}.</p>

<p>Но, во-первых, подобные инновации опасны, так как они уменьшают количество явно
ошибочных форм, а значит, затрудняют поиск ошибок, которые иначе бы легко
находились. Во-вторых, они не дают какой-либо существенной экономии и в конце
концов редко используются. В-третьих, они ещё сильнее разделяют функции и
функциональные объекты, которые можно применять как функции. Списки или числа
становятся вызываемыми, но вовсе не обязуются быть функциями. В итоге становятся
возможными безобразия вроде</p>

<pre>(apply (list 2 (list 0 (+ 1 2)))
       '(foo bar hux wok) )
   |\is| (hux (foo wok))</pre>

<p>Поэтому не рекомендуется реализовывать данные инновации как часть базового
языка. \seeEx[lisp1-2-omega/ex:innovations]</p>

<p>
\section{\texorpdfstring{Сравнение \protectLisp<sub>1</sub> и \protectLisp<sub>2</sub>}%
{Сравнение Lisp₁ и Lisp₂}}%
\label{lisp1-2-omega/sect:comparison}</p>

<p>Подходя к окончанию наших исследований Lisp<sub>1</sub> и Lisp<sub>2</sub>, что мы можем сказать
в итоге об этих двух подходах?</p>


<!--\indexR{пространства имён}-->
<!--\indexE{Lispn@\protect\Lisp{\protect\ii{n}}}-->
<!--\indexR{Лисп!Lispn@\protect\Lisp{\protect\ii{n}}}-->
<p>Scheme является Lisp<sub>1</sub>, на нём приятно программировать и ему легко обучать, так
как процесс вычислений прост и последователен. Lisp<sub>2</sub> же более сложен, потому
что существование двух миров требует использования особых форм для перехода
между ними. <span class="logo">Common Lisp</span> является не совсем Lisp<sub>2</sub>, так как имеет множество
других пространств имён: для меток лексических переходов, для меток форм
<code><span class="func">tagbody</span></code> и т. д. Поэтому иногда его называют \Lisp{\ii{n}}, так как одно и
то же имя может вести себя различными способами в зависимости от синтаксической
роли. Языки со строгим синтаксисом (или, как говорят, с деспотичным синтаксисом)
часто имеют множество пространств имён или множество окружений (для переменных,
для функций, для типов и т. д.). Каждое из этих окружений имеет свои
особенности. Например, если функциональное окружение неизменяемо (то есть
функциям нельзя присваивать новые значения), то становится очень легко
оптимизировать вызовы локальных функций.</p>

<p>В программах на Lisp<sub>2</sub> функции чётко отделены от остальных вычислений. Это очень
выгодное разграничение, так что, по мнению <span class="cite">[<a href="z1_bibliography.xhtml#sen89">sen89</a>]</span>, его следует применять
всем хорошим компиляторам Scheme. Внутри них программы переводятся на
Lisp<sub>2</sub>-язык, который удаётся лучше компилировать. Компилятор чётко определяет
каждое место, куда необходимо вставить <code><span class="func">funcall</span></code>, — те места, где функции
вычисляются динамически. Пользователи Lisp<sub>2</sub> вынуждены делать часть работы
компилятора вручную, так что в итоге они лучше понимают стоимость использования
своих конструкций.</p>


<!--\indexE{Lisp2@\protectLisp<sub>2</sub>}-->
<!--\indexR{Лисп!Lisp2@\protectLisp<sub>2</sub>}-->
<p>На предыдущих страницах мы разобрали довольно много вариаций, так что сейчас
будет полезным собрать всё воедино и дать ещё одно определение — простейшее
из возможных — очередного Lisp<sub>2</sub>-языка, похожего на <span class="logo">Common Lisp</span>. В этот раз
мы ограничимся только введением функции <code><span class="func">f.lookup</span></code>, которая ищет функцию по
имени в функциональном окружении, а если не находит, то вызывает <code><span class="func">wrong</span></code>. Это
позволит гарантировать конечное время выполнения <code><span class="func">f.lookup</span></code>. Конечно,
следствием такого похода будет появление своеобразных ошибок замедленного
действия, так как само по себе обращение к неопределённой функции не считается
ошибочным. Проблемы возникают лишь при попытке вызова, которая может произойти
гораздо позже, а то и вовсе никогда.</p>


<!--\indexC{f.evaluate}-->
<!--\indexC{f.evaluate-application}-->
<!--\indexC{f.lookup}-->
<pre>(define (f.evaluate e env fenv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (f.evaluate (cadr e) env fenv)
                      (f.evaluate (caddr e) env fenv)
                      (f.evaluate (cadddr e) env fenv) ))
        ((begin)  (f.eprogn (cdr e) env fenv))
        ((set!)   (update! (cadr e)
                           env
                           (f.evaluate (caddr e) env fenv) ))
        ((lambda) (f.make-function (cadr e) (cddr e) env fenv))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv) )
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (f.make-function
                 (cadr (cadr e)) (cddr (cadr e)) env fenv ) )
               (else (wrong "Incorrect function" (cadr e))) ) )
        ((flet)
         (f.progn (cddr e)
                  env
                  (extend fenv (map car (cadr e))
                          (map (lambda (def)
                                 (f.make-function (cadr def)
                                                  (cddr def)
                                                  env fenv ) )
                               (cadr e) ) ) ) )
        ((labels)
         (let ((new-fenv (extend fenv
                                 (map car (cadr e))
                                 (map (lambda (def) 'void)
                                      (cadr e) ) )))
           (for-each (lambda (def)
                       (update! (car def)
                                new-fenv
                                (f.make-function (cadr def) (cddr def)
                                                 env new-fenv ) ) )
                     (cadr e) )
           (f.eprogn (cddr e) env new-fenv) ) )
        (else (f.evaluate-application (car e)
                                      (f.evlis (cdr e) env fenv)
                                      env
                                      fenv )) ) ) )</p>

<p>(define (f.evaluate-application fn args env fenv)
  (cond ((symbol? fn)
         ((f.lookup fn fenv) args) )
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn)
                   (extend env (cadr fn) args)
                   fenv ) )
        (else (wrong "Incorrect functional term" fn)) ) )</p>

<p>(define (f.lookup id fenv)
  (if (pair? fenv)
      (if (eq? (caar fenv) id)
          (cdar fenv)
          (f.lookup id (cdr fenv)) )
      (lambda (values)
        (wrong "No such functional binding" id) ) ) )</pre>

<p>Ещё одно важное, по мнению <span class="cite">[<a href="z1_bibliography.xhtml#gp88">gp88</a>]</span>, практическое различие между Lisp<sub>1</sub> и
Lisp<sub>2</sub> состоит в читабельности. Хотя, конечно, опытные программисты вряд ли
будут писать что-то вроде:</p>

<pre>(defun foo (list)
  (list list) )</pre>


<!--\indexR{самоприменение!в \protectLisp<sub>1</sub> и \protectLisp<sub>2</sub>}-->
<p>\noindent
С точки зрения Lisp<sub>1</sub>, <code><span class="func">(list list)</span></code> — это вполне допустимое
самоприменение,\footnote*{Существуют и другие самоприменения, которые имеют
смысл, хотя их и не особо много. Например, <code><span class="func">(number? number?)</span></code>.} но в Lisp<sub>2</sub>
это выражение имеет совершенно различный смысл. В <span class="logo">Common Lisp</span> эти два имени
принадлежат различным окружениям и не конфликтуют. Тем не менее, лучше избегать
подобного стиля именования и не называть локальные переменные именами известных
глобальных функций; это поможет избежать проблем с макросами и сделает программы
менее зависимыми от используемого диалекта.</p>


<!--\indexR{макросы!в \protectLisp<sub>1</sub> и \protectLisp<sub>2</sub>}-->
<p>Следующее отличие между Lisp<sub>1</sub> и Lisp<sub>2</sub> заключается в собственно макросах.
В <span class="logo">Common Lisp</span> довольно непросто написать макрос, раскрывающийся
в <code><span class="func">lambda</span></code>-форму, который был бы полезен, например, при реализации объектной
системы. Дело в том, что <span class="logo">Common Lisp</span> ограничивает места, где может появляться
<code><span class="func">lambda</span></code>. Она может стоять только на месте функции, так что конструкция
<code><span class="func">(... (lambda ...) ...)</span></code> вызовет ошибку в <span class="logo">Common Lisp</span>. Единственное
исключение — <code><span class="func">lambda</span></code> может быть первым аргументом <code><span class="func">function</span></code>. Но сама
<code><span class="func">function</span></code> может быть только параметром функции, так что <code><span class="func">((function
(lambda ...)) ...)</span></code> — это снова ошибка. Если макрос не знает, где именно он
раскроется: как аргумент или как функция, то его нельзя использовать без
некоторого усложнения программ. Для той же системы объектов, например, придётся
раскрывать макрос в <code><span class="func">(function (lambda ...))</span></code>, а потом вручную оборачивать
его в <code><span class="func">funcall</span></code> там, где он вызывается как функция.</p>


<!--\indexR{конфликт имён}-->
<!--\indexR{область видимости!конфликт имён}-->
<p>Наконец, стоит упомянуть радикальное решение, используемое многими языками.
Можно запретить использование одного и того же имени даже в различных
окружениях. Предыдущий пример с <code><span class="func">list</span></code> вызвал бы ошибку, так как
имя <code><span class="func">list</span></code> уже используется в функциональном окружении. Практически все
реализации Лиспа и Scheme запрещают переменной иметь то же имя, что и функция
или макрос. Такое правило действительно облегчает жизнь.</p>

<h2 id="lisp1-2-omega/sect:namespaces">Пространства имён</h2>


<!--\indexR{пространства имён}-->
<p><em class="term">Окружения</em> устанавливают соответствия между именами и объектами. На данный
момент нам известны два типа окружений: обычное окружение <code><span class="func">env</span></code> и
функциональное <code><span class="func">fenv</span></code>. Причина, по которой они разделены, состоит в желании
ускорить вызовы функций и отделить функции от переменных. Но это разделение
потребовало от нас ввода двух различных вычислителей, а также механизма переноса
сущностей одного окружения в другое, — и это усложнило язык. При обсуждении
динамических переменных мы упомянули, что современные диалекты Лиспа (вроде
ILOG Talk, <span class="logo">EuLisp</span>, <span class="logo">ISLisp</span>) помещают динамические переменные в отдельное
пространство имён. Сейчас мы подробнее рассмотрим это решение. Занимаясь этим,
мы проиллюстрируем саму идею <em class="term">пространств имён</em>.</p>

<div class="bigskip"/>


<!--\indexR{привязки (bindings)}-->
<!--\indexR{привязки (bindings)|seealso{связывание}}-->
<!--\indexR{привязки (bindings)!захват}-->
<!--\indexR{объекты!второго класса}-->
<p>Окружения можно понимать как абстрактный тип данных. Они содержат
<em class="term">привязки</em> (bindings) объектов к их именам. Объекты могут быть как
значениями (полноценными объектами первого класса, которые можно передавать,
копировать, присваивать и т. д.), так и сущностями (объектами второго класса,
которыми можно оперировать лишь посредством их имён и, обычно, только
с помощью ограниченного числа специальных форм или иных синтаксических
конструкций). В данный момент нам известен только один тип подобных сущностей
— сами привязки. Они существуют лишь потому, что они — это нечто,
захватываемое замыканиями. Мы рассмотрим их свойства подробнее, когда будем
изучать побочные эффекты.</p>

<p>Есть множество способов использования окружений. Нас может интересовать,
присутствует ли какое-то имя в окружении; мы можем искать объект по его имени;
мы можем искать саму привязку, чтобы изменить её. Мы также можем изменять
окружение, добавляя в него новые привязки, будь это текущее, локальное или
глобальное окружение. Конечно же, не все возможности необходимы для каждого
из окружений. В действительности, многие окружения полезны именно благодаря
накладываемым ими ограничениям. Следующая таблица показывает особенности
окружения переменных Scheme:</p>

<p>\begin{envtable}
Ссылка      & \ii{x}                             \\
Значение    & \ii{x}                             \\
Изменение   & \ic{(set! \ii{x} ...)}             \\
Расширение  & \ic{(lambda (... \ii{x} ...) ...)} \\
Определение & \ic{(define \ii{x} ...)}           \\
\end{envtable}</p>

<p>Мы будем использовать такие таблицы и понятия из них довольно часто при
обсуждении свойств окружений, так что остановимся на них подробнее. Первая
строка показывает синтаксис, используемый для получения ссылки на переменную,
обращения к ней. Вторая строка показывает синтаксис, используемый для получения
значения переменной. В данном случае они совпадают, но так бывает отнюдь
не всегда. Третья строка показывает, как связать переменную с другим значением.
Четвёртая строка показывает, как расширить окружение локальных переменных новой
привязкой: с помощью <code><span class="func">lambda</span></code>-формы или, конечно же, макросов вроде <code><span class="func">let</span></code>
или <code><span class="func">let*</span></code>, раскрывающихся в <code><span class="func">lambda</span></code>-формы. Наконец, последняя строка
показывает, как определить глобальную переменную. Не волнуйтесь, если эти
различия сейчас для вас кажутся чересчур тонкими и излишними, мы и в дальнейшем
будем использовать подобные таблицы для пояснения вариантов использования
переменных, а там различия будут более заметными.</p>

<p>Например, пространство имён функций Lisp<sub>2</sub>, рассмотренного в начале главы,
описывается следующей таблицей:</p>

<p>\begin{envtable}
Ссылка      & \ic{(\ii{f} ...)}                      \\
Значение    & \ic{(function \ii{f})}                 \\
Изменение   & запрещено                              \\
Расширение  & \ic{(flet (... (\ii{f} ...) ...) ...)} \\
Определение & не рассматривалось ранее (<code><span class="func">defun</span></code>)  \\
\end{envtable}</p>

<p>
\subsection{Динамические переменные}%
\label{lisp1-2-omega/namespaces/ssect:dyn-vars}</p>


<!--\indexR{динамические переменные}-->
<!--\indexR{переменные!динамические}-->
<!--\indexR{динамическое окружение}-->
<!--\indexR{окружение!динамическое}-->
<p><em class="term">Динамические переменные</em> принципиально отличаются от лексических, поэтому
имеет смысл отличать их также и на уровне окружений. Следующая таблица
показывает желаемые свойства нашего нового окружения, окружения динамических
переменных:</p>

<p>\begin{envtable}
Ссылка      & не может быть получена                        \\
Значение    & \ic{(dynamic \ii{d})}                         \\
Изменение   & \ic{(dynamic-set! \ii{d} ...)}                \\
Расширение  & \ic{(dynamic-let (... (\ii{d} ...) ...) ...)} \\
Определение & здесь не рассматривается                      \\
\end{envtable}</p>

<p>Окружение учитывает новые особенности: можно создавать локальные динамические
переменные\footnote{Название «локальные переменные» не совсем удачно, так как
поведение динамических переменных кардинально отличается от поведения обычных
(лексических) переменных.} с помощью формы <code><span class="func">dynamic-let</span></code>, подобной <code><span class="func">let</span></code>
и <code><span class="func">flet</span></code>; значение динамической переменной получается с помощью <code><span class="func">dynamic</span></code>,
а изменяется — с помощью <code><span class="func">dynamic-set!</span></code>.</p>


<!--\indexE{Lisp3@\protect\Lisp3}-->
<!--\indexR{Лисп!Lisp3@\protect\Lisp3}-->
<p>Пока что это три специальные формы, но далее будут рассмотрены другие варианты
реализации. А сейчас мы всего лишь добавим в наш интерпретатор <code><span class="func">f.evaluate</span></code>
поддержку динамического окружения: <code><span class="func">denv</span></code>. Это окружение будет содержать
только динамические переменные. Новый интерпретатор, назовём его \Lisp3, будет
использовать функции с префиксом <code><span class="func">df.</span></code>, чтобы не путать их с остальными. Вот
его код. (Форма <code><span class="func">flet</span></code> не показана для краткости.)</p>


<!--\indexC{df.evaluate}-->
<!--\indexC{df.evaluate-application}-->
<!--\indexC{df.make-function}-->
<!--\indexC{df.eprogn}-->
<pre>(define (df.evaluate e env fenv denv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (df.evaluate (cadr e) env fenv denv)
                      (df.evaluate (caddr e) env fenv denv)
                      (df.evaluate (cadddr e) env fenv denv) ))
        ((begin)  (df.eprogn (cdr e) env fenv denv))
        ((set!)   (update! (cadr e)
                           env
                           (df.evaluate (caddr e) env fenv denv) ))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv) )
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (df.make-function
                 (cadr (cadr e)) (cddr (cadr e)) env fenv ) )
               (else (wrong "Incorrect function" (cadr e))) ) )
        ((dynamic) (lookup (cadr e) denv))
        ((dynamic-set!)
         (update! (cadr e)
                  denv
                  (df.evaluate (caddr e) env fenv denv) ) )
        ((dynamic-let)
         (df.eprogn (cddr e)
                    env
                    fenv
                    (extend denv
                            (map car (cadr e))
                            (map (lambda (e)
                                   (df.evaluate e env fenv denv) )
                                 (map cadr (cadr e)) ) ) ) )
        (else (df.evaluate-application (car e)
                                       (df.evlis (cdr e) env fenv denv)
                                       env
                                       fenv
                                       denv )) ) ) )</p>

<p>(define (df.evaluate-application fn args env fenv denv)
  (cond ((symbol? fn) ((f.lookup fn fenv) args denv))
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (df.eprogn (cddr fn)
                    (extend env (cadr fn) args)
                    fenv
                    denv ) )
        (else (wrong "Incorrect functional term" fn)) ) )</p>

<p>(define (df.make-function variables body env fenv)
  (lambda (values denv)
    (df.eprogn body (extend env variables values) fenv denv) ) )</p>

<p>(define (df.eprogn e* env fenv denv)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (begin (df.evaluate (car e*) env fenv denv)
                 (df.eprogn (cdr e*) env fenv denv) )
          (df.evaluate (car e*) env fenv denv) )
      empty-begin ) )</pre>

<p>Для поддержки нового окружения, <code><span class="func">denv</span></code>, потребовалось изменить прототипы
<code><span class="func">df.evaluate</span></code> и <code><span class="func">df.eprogn</span></code>, чтобы не терять это окружение при
вычислениях. Далее, <code><span class="func">df.evaluate</span></code> определяет три новые специальные формы
для операций над <code><span class="func">denv</span></code>, динамическим окружением. Есть и менее заметные
изменения: <code><span class="func">df.evaluate-application</span></code> передаёт в функции <em>текущее</em>
динамическое окружение. Мы уже встречались с таким поведением
\seePage[basics/representing-functions/fixing/src:inject-current-env], когда
были вынуждены передавать текущее лексическое окружение в вызываемую функцию.</p>


<!--\indexR{динамическое окружение!варианты}-->
<!--\indexR{окружение!динамическое!варианты}-->
<p>При применении функции используются одновременно несколько окружений. Есть
окружение с переменными и функциями, захваченными при определении функции. Есть
также окружение с динамическими переменными, существующими в момент вызова. Это
окружение не может быть захвачено и сохранено в замыкании, каждый раз значение
динамической переменной ищется заново в текущем динамическом окружении. Оно
может там отсутствовать, что, конечно же, приводит к ошибке. Возможны и другие
варианты реализации: например, сделать единое глобальное окружение динамических
переменных, как в <span class="logo">ISLisp</span>; или выдать каждому модулю собственное динамическое
окружение, как в <span class="logo">EuLisp</span>; или даже иметь глобальное окружение лексических
переменных, как в <span class="logo">Common Lisp</span>.
\seePage[lisp1-2-omega/namespaces/ssect:dyn-vars-cl]</p>

<p>Одно из преимуществ отдельного окружения: становится чётко видно, какие
переменные динамические, а какие нет. При всяком обращении к динамическому
окружению необходимо использовать специальную форму с префиксом <code><span class="func">dynamic</span></code>.
Явные обращения к динамическим переменным невозможно не заметить. Это очень
важно, так как в \Lisp3 поведение функции определяется не только значениями
локальных переменных, но и текущим состоянием динамического окружения. </p>


<!--\indexR{привязки (bindings)!динамические}-->
<!--\indexR{обработка ошибок!динамические переменные}-->
<p>Среди традиционных вариантов использования динамических окружений наиболее
полезным является обработка ошибок. При возникновении ошибки или исключительной
ситуации создаётся некий объект, описывающий, что произошло, и к этому объекту
применяется соответствующая функция, которая обработает исключительную ситуацию
(и, возможно, попытается восстановить работоспособность программы). Этот
обработчик мог бы быть общей глобальной функцией, но это потребовало бы кучи
ненужных присваиваний для использования правильного обработчика в правильное
время. «Герметичность» лексических окружений плохо сочетается со сквозным
указанием различных функций-обработчиков. Хотя мы всегда можем ограничить время
жизни локальных переменных, заключив вычисления в <code><span class="func">let</span></code> или <code><span class="func">dynamic-let</span></code>,
но у <code><span class="func">dynamic-let</span></code> есть несколько серьёзных преимуществ:</p>

<p>\begin{enumerate}
  \item создаваемые привязки не могут быть захвачены;

  \item эти привязки доступны только во время вычислений,
        вложенных в форму;

  \item привязки автоматически уничтожаются после завершения
        вычислений.
\end{enumerate}</p>

<p>\noindent
Поэтому <code><span class="func">dynamic-let</span></code> идеально подходит для временной установки
функций-обработчиков ошибок.</p>

<p>Вот ещё один пример разумного использования динамических переменных. Функции
вывода в <span class="logo">Common Lisp</span> настраиваются динамическими переменными вроде
<code><span class="func">*print-base*</span></code>, <code><span class="func">*print-circle*</span></code> и т. д. В них хранится информация
об основании счисления для вывода чисел, о том, могут ли выводимые данные
содержать циклические списки, и тому подобное. Конечно, можно передавать всю
эту информацию через аргументы, но только представьте, что вместо \ic{(print
\ii{выражение})} приходилось бы писать \ic{(print \ii{выражение}
\ii{escape-символы?} \ii{основание} \ii{циклы?} \ii{pretty-print?} \ii{регистр?}
\ii{уровень-вложенности}\ForLayout{display}{\\} \ii{векторы?}
\ii{использовать-gensym?})}. Каждый раз. Динамические переменные позволяют один
раз установить значения по умолчанию для таких параметров и больше никогда их
не указывать, если не требуется особого поведения.</p>


<!--\indexR{циклические структуры данных}-->
<p>Scheme использует похожий механизм для указания портов ввода-вывода. Можно
написать \ic{(display \ii{выражение})} или\footnote{Это две различные функции
<code><span class="func">display</span></code>, принимающие один и два аргумента соответственно. В Scheme нет
поддержки опциональных аргументов и значений по умолчанию на уровне языка.
Лисп же поддерживает эту идею, поэтому не нуждается в динамических переменных
для реализации подобного поведения.} \ic{(display \ii{выражение} \ii{порт})}.
Первая форма, с одним аргументом, выводит \ii{выражение} в текущий порт вывода.
Вторая же использует явно указанный порт. Функция <code><span class="func">with-output-to-file</span></code>
позволяет указать порт вывода, который будет текущим на время вычисления
выражения. Узнать текущий порт можно с помощью <code><span class="func">current-output-port</span></code>. Вот так
определяется функция,\footnote*{См. также реализацию функции <code><span class="func">list-length</span></code> из
<span class="logo">Common Lisp</span>.} которая выводит циклические списки в текущий порт:</p>


<!--\indexC{display-cyclic-spine}-->
<pre>(define (display-cyclic-spine list)
  (define (scan l1 l2 flip)
    (cond ((atom? l1)  (unless (null? l1)
                          (display " . ") (display l1) )
                       (display ")") )
          ((eq? l1 l2) (display "...)"))
          (else        (display (car l1))
                       (when (pair? (cdr l1)) (display " "))
                       (scan (cdr l1)
                             (if (and flip (pair? l2))
                                 (cdr l2)
                                 l2 )
                             (not flip) ) ) ) )
  (display "(")
  (scan list (cons 42 list) #f) )

(display-cyclic-spine        ; напечатает <code><span class="func">(1 2 3 4 1 ...)</span></code>
  (let ((l (list 1 2 3 4)))
    (set-cdr! (cdddr l) l)
    l ) )</pre>

<p>Можно даже составить таблицу характеристик для портов вывода Scheme:</p>

<p>\begin{envtable}
Ссылка      & автоматически, если не упоминается явно                  \\
Значение    & <code><span class="func">(current-output-port)</span></code>                               \\
Изменение   & запрещено                                                \\
Расширение  & \ic{(with-output-to-file \ii{имя-файла} \ii{замыкание})} \\
Определение & неприменимо                                              \\
\end{envtable}</p>


<!--\indexC*{standard-output}{*standard-output*}-->
<!--\indexR{соглашения именования!динамических переменных}-->
<p>В <span class="logo">Common Lisp</span> данный механизм явно использует динамические переменные.
По умолчанию функции вывода вроде <code><span class="func">print</span></code> или <code><span class="func">write</span></code> используют порт,
хранящийся в переменной <code><span class="func">*standard-output*</span></code>.\footnote*{По соглашению, имена
динамических переменных окружаются звёздочками, чтобы выделить их.} Мы можем
проэмулировать\footnote{Разумеется, это не <span class="logo">Common Lisp</span>. Это наш \Lisp3,
определённый чуть выше.} <code><span class="func">with-output-to-file</span></code> следующим образом:</p>


<!--\indexC{with-output-to-file}-->
<pre>(define (with-output-to-file filename thunk)
  (dynamic-let ((*standard-output* (open-input-file filename)))
    (thunk) ) )</pre>

<p>
\subsection{Динамические переменные в <span class="logo">Common Lisp</span>}%
\label{lisp1-2-omega/namespaces/ssect:dyn-vars-cl}</p>


<!--\indexR{динамические переменные!синтаксис}-->
<!--\indexR{синтаксис!динамических переменных}-->
<p>Хотя <span class="logo">Common Lisp</span> разделяет динамические и лексические переменные с точки
зрения вычислений, но синтаксис их использования отличается слабо. В нём нет
формы <code><span class="func">dynamic-let</span></code>, но её можно легко сымитировать:</p>

<p>{\def\E{\hbox to 0pt{\kern0.15em$\equals$}}
\begin{code:lisp}
(dynamic-let ((x |$\alpha$|)) |\E|   (let ((x |$\alpha$|))
  |$\beta$| )                     (declare (special x))
                          |$\beta$| )
\end{code:lisp}}</p>

<p>Отличие состоит в том, что для получения значения динамической переменной <code><span class="func">x</span></code>
внутри $\beta$ нет надобности использовать форму <code><span class="func">dynamic</span></code>, достаточно писать
просто <code><span class="func">x</span></code>. Причина такого поведения в том, что выражение <code><span class="func">(declare
(special x))</span></code> означает сразу две вещи: привязка, устанавливаемая <code><span class="func">let</span></code>
для <code><span class="func">x</span></code> должна быть динамической, а каждая ссылка на <code><span class="func">x</span></code> внутри
тела <code><span class="func">let</span></code> должно пониматься как <code><span class="func">(dynamic x)</span></code>.</p>

<p>Это не совсем удобно, так как внутри $\beta$ нельзя обращаться к лексической
переменной <code><span class="func">x</span></code>, нам будет видна только её динамическая тёзка. Можно было бы
пойти другим путём, указывая конкретные места, где необходимо использовать
динамическую переменную <code><span class="func">x</span></code> с помощью конструкции <code><span class="func">(locally (declare
(special x)) x)</span></code>. Это в точности идентично нашей форме <code><span class="func">dynamic</span></code>.</p>

<p>Стратегия <span class="logo">Common Lisp</span> состоит в указании типа привязки с помощью конструкций
языка. Мы можем реализовать этот механизм, сделав следующие изменения
в интерпретаторе:</p>


<!--\indexC{df.evaluate}-->
<!--\indexC{special-extend}-->
<!--\indexC{cl.lookup}-->
<pre>(define (df.evaluate e env fenv denv)
  (if (atom? e)
      (cond ((symbol? e) (cl.lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (df.evaluate (cadr e) env fenv denv)
                      (df.evaluate (caddr e) env fenv denv)
                      (df.evaluate (cadddr e) env fenv denv) ))
        ((begin)  (df.eprogn (cdr e) env fenv denv))
        ((set!)   (update! (cadr e)
                           env
                           (df.evaluate (caddr e) env fenv denv) ))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv) )
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (df.make-function
                 (cadr (cadr e)) (cddr (cadr e)) env fenv ) )
               (else (wrong "Incorrect function" (cadr e))) ) )
        ((dynamic) (lookup (cadr e) denv))
        ((dynamic-set!)
         (update! (cadr e)
                  denv
                  (df.evaluate (caddr e) env fenv denv) ) )
        ((dynamic-let)
         (df.eprogn (cddr e)
                    [(special-extend env
                                    (map car (cadr e)) )]
                    fenv
                    (extend denv
                            (map car (cadr e))
                            (map (lambda (e)
                                   (df.evaluate e env fenv denv) )
                                 (map cadr (cadr e)) ) ) ) )
        (else (df.evaluate-application (car e)
                                       (df.evlis (cdr e) env fenv denv)
                                       env
                                       fenv
                                       denv )) ) ) )</p>

<p>(define (special-extend env variables)
  (append variables env) )</p>

<p>(define (cl.lookup var env denv)
  (let look ((env env))
    (if (pair? env)
        (if (pair? (car env))
            (if (eq? (caar env) var)
                (cdar env)
                (look (cdr env)) )
            (if (eq? (car env) var)
                ;; ищем в текущем динамическом окружении
                (let lookup-in-denv ((denv denv))
                  (if (pair? denv)
                      (if (eq? (caar denv) var)
                          (cdar denv)
                          (lookup-in-denv (cdr denv)) )
                      ;; если не находим, ищем в глобальном лексическом
                      (lookup var env.global) ) )
                (look (cdr env)) ) )
        (wrong "No such binding" var) ) ) )</pre>

<p>Теперь разберём, как это работает. Когда <code><span class="func">dynamic-let</span></code> создаёт динамическую
переменная, она не только связывает её со значением в динамическом окружении, но
и помечает её как динамическую в лексическом окружении, записывая туда её имя.
Для поддержки этих меток изменяется механизм поиска значения по ссылке
(<code><span class="func">cl.lookup</span></code>): он должен проанализировать ссылку, чтобы определить тип
привязки (лексическая или динамическая), после чего отыскать значение
в правильном окружении. Также, если переменная не найдена в текущем динамическом
окружении, то следующим просматривается глобальное лексическое окружение,
которое в <span class="logo">Common Lisp</span> одновременно является глобальным динамическим.</p>

<p>Приведём пример работы такого \Lisp3, имитирующего <span class="logo">Common Lisp</span>:</p>

<pre>(dynamic-let ((x 2))
  (+ x                        ; динамический <code><span class="func">x</span></code>
     (let ((x (+              ; лексический
                 x x )))      ; динамические
       (+ x                   ; лексический
          (dynamic x) ) ) ) ) ; динамический
|\is| 8</pre>

<p>
\subsection{Динамические переменные без специальных форм}%
\label{lisp1-2-omega/namespaces/ssect:dyn-vars-no-special}</p>

<p>Сейчас для работы с динамическими переменными используются целых три специальные
формы. Так как Scheme исповедует минимализм по отношению к количеству
специальных форм, стоит подумать о других вариантах. Не будем рассматривать их
все, а остановимся на следующем, так как он использует всего две функции. Первая
функция динамически связывает два значения; вторая функция может по первому
значению найти второе. На роль идентификаторов динамических переменных прекрасно
подходят символы. Кроме них нам потребуется некий изменяемый тип данных вроде
точечных пар, если мы хотим изменять установленные связи. Так наше решение будет
удовлетворять аскетичным традициям Scheme.</p>

<p>Во время изучения данного подхода мы будем использовать интерпретатор с двумя
окружениями: <code><span class="func">env</span></code> и <code><span class="func">denv</span></code>. Это тот же предыдущий интерпретатор, только
из него убрано несколько вещей: ненужные специальные формы, поддержка
функциональных окружений и ссылки на переменные как в <span class="logo">Common Lisp</span>. Остались
только мы и динамические окружения. Такой интерпретатор несколько менее полезен,
так как динамическое окружение уже нельзя расширять непосредственно, но, тем
не менее, это окружение всё ещё передаётся в каждую функцию — и этого
достаточно! Чтобы отличать эту вариацию от предыдущих, её функциям выдан
префикс <code><span class="func">dd</span></code>.</p>


<!--\indexC{dd.evaluate}-->
<!--\indexC{dd.make-function}-->
<!--\indexC{dd.evlis}-->
<!--\indexC{dd.eprogn}-->
<pre>(define (dd.evaluate e env denv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e)(string? e)(char? e)
                 (boolean? e)(vector? e) )
             e )
            (else (wrong "Cannot evaluate" e)) )
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (dd.evaluate (cadr e) env denv)
                      (dd.evaluate (caddr e) env denv)
                      (dd.evaluate (cadddr e) env denv) ))
        ((begin)  (dd.eprogn (cdr e) env denv))
        ((set!)   (update! (cadr e) env
                           (dd.evaluate (caddr e) env denv) ))
        ((lambda) (dd.make-function (cadr e) (cddr e) env))
        (else (invoke (dd.evaluate (car e) env denv)
                      (dd.evlis (cdr e) env denv)
                      denv )) ) ) )</p>

<p>(define (dd.make-function variables body env)
  (lambda (values denv)
    (dd.eprogn body (extend env variables values) denv) ) )</p>

<p>(define (dd.evlis e* env denv)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (cons (dd.evaluate (car e*) env denv)
                (dd.evlis (cdr e*) env denv) )
          (list (dd.evaluate (car e*) env denv)) )
      '() ) )</p>

<p>(define (dd.eprogn e* env denv)
  (if (pair? e*)
      (if (pair? (cdr e*))
          (begin (dd.evaluate (car e*) env denv)
                 (dd.eprogn (cdr e*) env denv) )
          (dd.evaluate (car e*) env denv) )
      empty-begin ) )</pre>

<p>Как мы и обещали, теперь определим две функции. Первую назовём
<code><span class="func">bind-with-dynamic-extent</span></code>; это длинное название, так что сократим его до
<code><span class="func">bind/de</span></code>. Первым её аргументом является ключ <code><span class="func">tag</span></code>; вторым —
значение <code><span class="func">value</span></code>, связываемое с ключом; третьим — замыкание <code><span class="func">thunk</span></code>,
функция без аргументов, которая будет вызвана в расширенном динамическом
окружении.</p>


<!--\indexC{bind/de}-->
<pre>(definitial bind/de
  (lambda (values denv)
    (if (= 3 (length values))
        (let ((tag   (car values))
              (value (cadr values))
              (thunk (caddr values)) )
          (invoke thunk '()
                  (extend denv (list tag) (list value)) ) )
        (wrong "Incorrect arity" 'bind/de) ) ) )</pre>

<p>Следующая функция будет использовать динамическое окружение. Так как нам надо
что-то делать в случае, если динамической переменной с запрошенным именем нет,
то функция <code><span class="func">assoc/de</span></code> первым аргументом принимает ключ, а вторым —
функцию. Она вызовет полученную функцию и передаст ей ключ, если не найдёт его
в динамическом окружении.</p>


<!--\indexC{assoc/de}-->
<pre>(definitial assoc/de
  (lambda (values current.denv)
    (if (= 2 (length values))
        (let ((tag     (car values))
              (default (cadr values)) )
          (let look ((denv current.denv))
            (if (pair? denv)
                (if (eqv? tag (caar denv))
                    (cdar denv)
                    (look (cdr denv)) )
                (invoke default (list tag) current.denv) ) ) )
        (wrong "Incorrect arity" 'assoc/de) ) ) )</pre>

<p>Можно реализовать несколько вариантов её поведения в зависимости от
используемого механизма сравнения (<code><span class="func">eqv?</span></code> или <code><span class="func">equal?</span></code>).
\seeEx[lisp1-2-omega/ex:assoc-with-comparator]</p>

<p>\ForLayout{display}{\clearpage}</p>

<p>Перепишем предыдущий пример:</p>

<pre>(bind/de 'x 2
  (lambda () (+ (assoc/de 'x error)
                (let ((x (+ (assoc/de 'x error)
                            (assoc/de 'x error) )))
                  (+ x (assoc/de 'x error)) ) )) )
|\is| 8</pre>

<p>Таким образом, мы опровергли необходимость использования специальных форм для
реализации механизма динамических переменных. Заодно мы получили возможность
связывать что угодно с чем угодно. Конечно, это преимущество — ничто по
сравнению с тем, что есть гораздо более эффективные реализации динамических
переменных (даже без учёта многопоточности). Хотя бы то же ближнее связывание,
которое лишь требует, чтобы ключ был символом.\footnote*{Многие реализации Лиспа
не считают ключевые слова вроде <code><span class="func">nil</span></code> или <code><span class="func">if</span></code> символами (а значит, и
легальными именами переменных).} С другой стороны, в данном варианте не потеряна
ссылочная прозрачность. Но всё равно доступ к динамическим переменным требует
недешёвых вызовов функций. Наше решение ещё довольно далеко от органичного
сочетания динамических и лексических переменных в <span class="logo">Common Lisp</span>.</p>

<p>Среди всех неудобств стоит отметить ещё то, что использование <code><span class="func">bind/de</span></code>
требует использования <code><span class="func">assoc/de</span></code> и написания функции-обработчика. Хотя,
естественно, с помощью макросов это можно спрятать. Другое неудобство возникает
уже для компилятора: ведь ему надо будет генерировать код для создания и
использования динамических переменных. К счастью, они помечены вызовами
соответствующих функций, так что дальнейшее отдаётся на откуп компилятору:
генерировать код в лоб (это легче) или вставить свою, более эффективную
реализацию.</p>

<p>
\subsection{В заключение о пространствах имён}%
\label{lisp1-2-omega/namespaces/ssect:conclusions}</p>

<p>После отступления к динамическим переменным, вернёмся к идее пространств имён
в общем: специализированные окружения для специализированных объектов. Мы уже
видели \Lisp3 в деле, а также разобрали механизм динамических переменных
в <span class="logo">Common Lisp</span>.</p>


<!--\indexE{Lispn@\protect\Lisp{\protect\ii{n}}}-->
<!--\indexR{Лисп!Lispn@\protect\Lisp{\protect\ii{n}}}-->
<p>Тем не менее, наша последняя реализация — та, что с двумя функциями вместо
трёх специальных форм, — поднимает каверзный вопрос. Если это \Lisp{$n$}, то
чему равно $n$? Базируется она на Scheme, но всё же явно имеет два окружения:
<code><span class="func">env</span></code> и <code><span class="func">denv</span></code>. В то же время, вычислитель у неё лишь один, что является
отличительной чертой Scheme и класса Lisp<sub>1</sub>. Однако, нам пришлось довольно
сильно модифицировать интерпретатор (просто сравните <code><span class="func">evaluate</span></code> и
<code><span class="func">dd.evaluate</span></code>), чтобы реализовать функции <code><span class="func">bind/de</span></code> и <code><span class="func">assoc/de</span></code>. Мы
столкнулись с примитивными функциями, которые нельзя выразить тем же языком,
если только они уже не определены; более того, само существование этих функций
глубоко влияет на процесс вычислений. В следующей главе будет такая же ситуация
с <code><span class="func">call/cc</span></code>.</p>


<!--\indexR{списки свойств}-->
<!--\indexR{символы!списки свойств}-->
<p>Короче говоря, похоже, что у нас получился Lisp<sub>1</sub>, если смотреть на количество
вычислителей, и Lisp<sub>2</sub> — если смотреть на пространства имён. Обобщением этих
парадоксов является мнение, что наличие списка свойств у символов является
чертой \Lisp{$n$}, где $n$ может быть произвольным.
\seeEx[lisp1-2-omega/ex:write-put/get-prop]
Так как наши пространства имён объективно существуют, а значения соответствующих
переменных вычисляются особым образом (пусть и с помощью примитивных функций, а
не специальных форм), то будем считать нашу реализацию представителем
класса Lisp<sub>2</sub>.</p>

<div class="bigskip"/>


<!--\indexC{csetq}-->
<!--\indexR{константы}-->
<p>Остаётся ещё один урок, который можно извлечь из рассмотрения лексических и
динамических переменных. <span class="logo">Common Lisp</span> старается унифицировать доступ
к переменным из различных пространств имён, предоставляя одинаковый синтаксис.
Поэтому необходимо знать правила, по которым он определяет, из какого
пространства имён взять переменную. К сожалению, они не всегда однозначны;
например, <span class="logo">Common Lisp</span> не различает глобальное динамическое и глобальное
лексическое окружения. Далее, в <span class="logo">Lisp 1.5</span> существовала концепция констант,
определяемых специальной формой <code><span class="func">csetq</span></code> (<code><span class="func">setq</span></code> для констант).</p>

<p>\begin{envtable}
Ссылка      & \ii{x}                         \\
Значение    & \ii{x}                         \\
Изменение   & \ic{(csetq \ii{x} \ii{форма})} \\
Расширение  & запрещено                      \\
Определение & \ic{(csetq \ii{x} \ii{форма})} \\
\end{envtable}</p>

<p>Введение констант тоже делает синтаксис неоднозначным. Когда мы пишем <code><span class="func">foo</span></code>
— это может быть как константа, так и переменная. Правило разрешения
противоречий в <span class="logo">Lisp 1.5</span> было таково: если существует константа с именем
<code><span class="func">foo</span></code>, то вернуть её значение; иначе искать одноимённую переменную
в лексическом пространстве имён. Но: «константы» можно изменять (представьте
себе!) с помощью той же формы <code><span class="func">csetq</span></code>, что используется для их создания.
Таким образом, константы <span class="logo">Lisp 1.5</span> соответствуют глобальным переменным Scheme,
только с обратным приоритетом: в Scheme сначала ищется локальная лексическая
переменная, а глобальная переменная является лишь значением по умолчанию на
случай, если локальная переменная не будет найдена.</p>

<p>Проблема имеет довольно общий характер. Если для доступа к нескольким
пространствам имён используется одинаковый синтаксис, то необходимы чётко
прописанные правила разрешения неоднозначностей.</p>

<h2 id="lisp1-2-omega/sect:recursion">Рекурсия</h2>


<!--\indexR{рекурсия}-->
<!--\indexR{рекурсия|seealso{рекурсия}}-->
<!--\indexR{рекурсия|\protect-->
<!--\indexR{рекурсия}}-->
<p>Рекурсия естественна для Лиспа, но мы пока так ничего и не сказали о том, как же
она реализуется. Далее мы проанализируем различные типы рекурсии и вызываемые
ими проблемы.</p>

<h3 id="lisp1-2-omega/recusion/ssect:simple">Простая рекурсия</h3>


<!--\indexR{рекурсия!простая}-->
<p>Наверное, наиболее известной простой рекурсивной функцией является факториал,
определяемый следующим образом:</p>


<!--\indexC{fact}-->
<pre>(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )</pre>

<p>Язык, который был определён в предыдущей главе, не знает, что такое <code><span class="func">define</span></code>,
так что давайте представим, что это макрос, который раскрывается в следующий
код:</p>

<pre>(set! fact (lambda (n)
             (if (= n 1) 1
                 (* n (fact (- n 1))) ) ))</pre>


<!--\indexR{привязки (bindings)!неинициализированные}-->
<p>Здесь мы видим присваивание, изменение значения переменной <code><span class="func">fact</span></code>. Это
изменение бессмысленно, если переменная <code><span class="func">fact</span></code> не существует. Глобальное
окружение можно считать местом, где уже существуют все возможные переменные.
В этой <em>виртуальной реальности</em> интерпретатор (а точнее, его часть,
ответственная за чтение программ) должен создать привязку для переменной, когда
впервые видит её имя, после чего невозмутимо продолжить работу, будто бы эта
переменная уже сто лет как здесь. Каждая переменная уже существует до своего
первого использования, а значит, её определение — это лишь изменение значения
существующей переменной. Но при таком подходе возникает проблема с получением
значения переменной, которой ещё ничего не было присвоено. Интерпретатор должен
отловить эту ошибку, когда переменная вроде как есть, но значения у неё ещё нет.
Как видите, идея привязок не так уж и проста, мы рассмотрим её подробнее
в четвёртой главе. \seePage[chapter:assignment]</p>


<!--\indexC{define}-->
<p>Можно избавиться от проблем с привязками, которые существуют, но еще
не инициализированы, если принять другую позицию. Пусть изменять можно только
существующие переменные; иными словами, переменной нет, если она не была
определена явно. Для этого используется специальная форма <code><span class="func">define</span></code>,
создающая переменные. Без неё у нас не получится ни обратиться к переменной,
ни установить её значение. Однако, посмотрим теперь на это с другой стороны:</p>

<p>\begin{code:lisp}[label=lisp1-2-omega/recusion/simple/code:redefine]
(define (display-pi)
  (display pi) )
(define pi 2.7182818285)    ; ой, не та константа
(define (print-pi)
  (display pi) )
(define pi 3.1415926536)</pre>

<p>Допустимо ли такое определение <code><span class="func">display-pi</span></code>? Её тело ссылается на <code><span class="func">pi</span></code>,
которая ещё не определена. Четвёртый <code><span class="func">define</span></code> исправляет ошибку во втором; но
даже если <code><span class="func">define</span></code> создаёт новую привязку, можно ли создать ещё одну
с таким же именем?</p>

<p>Эти вопросы не имеют однозначного ответа. Есть как минимум два варианта: считать
глобальные определения лексическими (как это делает ML) или считать их
динамическими (как это принято в Лиспе).</p>


<!--\indexR{окружение!глобальное!гиперстатическое}-->
<!--\indexR{глобальное окружение!гиперстатическое}-->
<!--\indexR{гиперстатическое окружение}-->
<p>\phantomlabel{lisp1-2-omega/recusion/simple/par:hyperstatic}
В глобальном окружении, которое <em>полностью лексично</em> — будем называть
его <em class="term">гиперстатическим</em>, — мы не можем использовать переменную (ссылаться
на неё, получать или изменять её значение), если она не существует. В нём
определение функции <code><span class="func">display-pi</span></code> будет ошибочным, так как оно ссылается на
переменную <code><span class="func">pi</span></code>, которая не существует на момент определения. Любой вызов
функции <code><span class="func">display-pi</span></code> привёл бы к ошибке «Неизвестная переменная: <code><span class="func">pi</span></code>»
(если бы это не случилось ещё при её определении). Но с функцией <code><span class="func">print-pi</span></code>
всё в порядке, она будет выводить значение, существовавшее на момент её
определения (в данном случае это <code><span class="func">2.7182818285</span></code>), и ничто не сможет изменить
выводимое значение. Здесь переопределение <code><span class="func">pi</span></code> вполне допустимо и создаст
новую переменную <code><span class="func">pi</span></code>, которая будет использоваться в последующих выражениях
в пределах своей области видимости. Предыдущий пример можно представить примерно
таким образом:</p>

<pre>(let ((display-pi (lambda () (display pi))))
  (let ((pi 2.7182818285))
    (let ((print-pi (lambda () (display pi))))
      (let ((pi 3.1415926536))
        ... ) ) ) )</pre>

<p>В Лиспе, как было сказано, принят динамический подход. Предполагается, что может
существовать максимум одна глобальная переменная с уникальным именем, и эта
переменная видна везде, в том числе в своём собственном определении. Лисп
поддерживает опережающие ссылки без какого-либо специального синтаксиса. (Под
таким синтаксисом понимаются явные объявления вроде ключевого слова <code><span class="func">forward</span></code>
Паскаля или прототипов ISO C <span class="cite">[<a href="z1_bibliography.xhtml#iso90">iso90</a>]</span>.)</p>

<p>Выбор отнюдь не так прост. Возвращаясь к факториалу; в окружении, где будет
вычисляться <code><span class="func">lambda</span></code>-форма, необходимо ответить на вопрос: «Чему здесь равно
значение <code><span class="func">fact</span></code>?» Если вычисление происходит в глобальном окружении, где нет
привязки для <code><span class="func">fact</span></code>, то эта функция в принципе не может быть рекурсивной.
Причина: функция ссылается на некую переменную <code><span class="func">fact</span></code>, значение которой
следует искать в окружении, захваченном замыканием (в том, которое состоит из
свободных переменных и параметров функции). Так как в момент создания замыкания
переменная <code><span class="func">fact</span></code> не существовала, то и в окружении её нет. Следовательно,
для рекурсии её необходимо каким-то образом туда добавить. Проще всего это
сделать, выбрав динамический подход к глобальному окружению, который снимает
вопрос существования переменных в принципе. При гиперстатическом же подходе надо
убедиться в том, что <code><span class="func">define</span></code> создаёт привязку для <code><span class="func">fact</span></code> перед тем, как
вычислять замыкание, которое станет значением <code><span class="func">fact</span></code>. Резюмируя: простая
рекурсия требует глобального окружения.</p>

<h3 id="lisp1-2-omega/recusion/ssect:mutual">Взаимная рекурсия</h3>


<!--\indexR{рекурсия!взаимная}-->
<p>Теперь предположим, что мы хотим определить две взаимно рекурсивные функции.
Возьмём для примера <code><span class="func">odd?</span></code> и <code><span class="func">even?</span></code>, реализующие (весьма медленную)
проверку натуральных чисел на чётность. Они определяются следующим образом:</p>


<!--\indexC{even?}-->
<!--\indexC{odd?}-->
<!--\indexE{even?@\protect<code><span class="func">even?</span></code>|seealso{\protect<code><span class="func">odd?</span></code>}}-->
<!--\indexE{odd?@\protect<code><span class="func">odd?</span></code>|seealso{\protect<code><span class="func">even?</span></code>}}-->
<pre>(define (even? n)
  (if (= n 0) #t (odd? (- n 1))) )
(define (odd? n)
  (if (= n 0) #f (even? (- n 1))) )</pre>

<p>Можно менять их местами, но в любом случае первое определение не будет знать
о втором; в данном случае <code><span class="func">even?</span></code> не знает в момент определения про
<code><span class="func">odd?</span></code>. И опять, кажется, решением будет глобальное окружение с заранее
созданными переменными: оба замыкания захватывают глобальное окружение,
в котором есть все возможные переменные, среди них, в частности, и необходимые
<code><span class="func">odd?</span></code> и <code><span class="func">even?</span></code>. Конечно, мы пока оставим в стороне вопрос, как именно
реализуется захват только необходимых привязок.</p>

<p>Довольно непросто перенести это поведение в мир с гиперстатическим глобальным
окружением, так как здесь уж точно первое определение никогда не сможет узнать
о втором. Одно из решений состоит в том, чтобы определять эти две функции
одновременно, тогда не будет никаких первых и вторых, и обе функции смогут
ссылаться друг на друга без проблем. (Мы вернёмся к этому вопросу чуть позже,
после изучения локальной рекурсии.) Например, когда-то в <span class="logo">Lisp 1.5</span> имелась
форма <code><span class="func">define</span></code> с подобной возможностью:</p>


<!--\indexCS{define}{параллельные объявления}-->
<pre>(define ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1))))) ))</pre>

<p>Таким образом, с помощью глобального окружения и некоторых ухищрений можно
выразить и взаимную рекурсию.</p>

<p>Но что случится, если нам понадобятся локальные рекурсивные функции?</p>

<p>
\subsection{\texorpdfstring{Локальная рекурсия в Lisp<sub>2</sub>}%
{Локальная рекурсия в Lisp₂}}%
\label{lisp1-2-omega/recusion/ssect:local-lisp2}</p>


<!--\indexR{рекурсия!локальная}-->
<p>Некоторые проблемы, с которыми мы столкнулись при попытках определить <code><span class="func">fact</span></code>
в глобальном окружении, возвращаются при попытках определить <code><span class="func">fact</span></code> локально.
Нам надо сделать что-то, чтобы вызов <code><span class="func">fact</span></code> из тела <code><span class="func">fact</span></code> был
рекурсивным. Чтобы <code><span class="func">fact</span></code> из функционального окружения была связана
с функцией вычисления факториала даже внутри самой функции вычисления
факториала. И вот здесь как раз проявляется отличие между локальным и
глобальным окружениями: вспомните, что происходит, если искомая локальная
переменная не существует. Рассмотрим следующую программу на Lisp<sub>2</sub>:</p>


<!--\indexC{fact}-->
<pre>(flet ((fact (n) (if (= n 0) 1
                     (* n (fact (- n 1))) )))
  (fact 6) )</pre>

<p>Форма <code><span class="func">flet</span></code> связывает функцию вычисления факториала с именем <code><span class="func">fact</span></code>
в своём внутреннем функциональном окружении. Замыкание захватывает
функциональное и параметрическое окружения, локальные для формы <code><span class="func">flet</span></code>. Таким
образом, <code><span class="func">fact</span></code> внутри <code><span class="func">fact</span></code> ссылается не на функцию <code><span class="func">fact</span></code>, локальную
для тела <code><span class="func">flet</span></code>, а на какую-то другую функцию <code><span class="func">fact</span></code> из окружения всей
формы <code><span class="func">flet</span></code>. Эта функция не обязана вычислять факториал (а то и вовсе
не существует), так что рекурсию мы не получаем.</p>


<!--\indexC{label}-->
<!--\indexR{специальные формы!label@\protect<code><span class="func">label</span></code>}-->
<p>Эта проблема была очевидна ещё во времена <span class="logo">Lisp 1.5</span>. Для её решения была введена
специальная форма <code><span class="func">label</span></code>, позволявшая определять локальные рекурсивные
функции. Пример с факториалом тогда записывается так:</p>

<pre>(label fact (lambda (n) (if (= n 0) 1
                            (* n (fact (- n 1))) )))</pre>

<p>Эта форма возвращает анонимную функцию, вычисляющую факториал. Более того, это
именно та функция, которая связана с <code><span class="func">fact</span></code> в своём же теле.</p>


<!--\indexC{labels}-->
<!--\indexR{специальные формы!labels@\protect<code><span class="func">labels</span></code>}-->
<p>К сожалению, нельзя сказать, что <span class="logo">Lisp 1.5</span> был Lisp<sub>2</sub>, а <code><span class="func">label</span></code>, какой бы
удобной она не была, не может легко справиться со взаимной рекурсией. Поэтому
гораздо позже, судя по <span class="cite">[<a href="z1_bibliography.xhtml#hs75">hs75</a>]</span>, был изобретён её $n$-арный аналог:
<code><span class="func">labels</span></code>. Эта форма имеет тот же синтаксис, что и <code><span class="func">flet</span></code>, но гарантирует,
что замыкания будут создаваться в окружении, где можно ссылаться на локальные
функции. С её помощью можно определить и <code><span class="func">fact</span></code>, и взаимно рекурсивные
<code><span class="func">odd?</span></code> и <code><span class="func">even?</span></code>:</p>

<pre>(labels ((fact (n) (if (= n 0) 1
                       (* n (fact (- n 1))) ) ))
  (fact 6) ) |\is| 720</p>

<p>(funcall (labels ((even? (n) (if (= n 0) #t (odd? (- n 1))))
                  (odd? (n) (if (= n 0) #f (even? (- n 1)))) )
           (function even?) )
         4 ) |\is| #t</pre>

<p>Так что в Lisp<sub>2</sub> мы имеем две формы для расширения локального функционального
окружения: <code><span class="func">flet</span></code> и <code><span class="func">labels</span></code>.</p>

<p>
\subsection{\texorpdfstring{Локальная рекурсия в Lisp<sub>1</sub>}%
{Локальная рекурсия в Lisp₁}}%
\label{lisp1-2-omega/recusion/ssect:local-lisp1}</p>


<!--\indexR{рекурсия!локальная}-->
<p>Проблема определения локальных рекурсивных функций существует и в Lisp<sub>1</sub>;
решается она похожим способом. Форма <code><span class="func">letrec</span></code> (рекурсивная <code><span class="func">let</span></code>) очень
похожа по смыслу на <code><span class="func">labels</span></code>.</p>

<p>В Scheme <code><span class="func">let</span></code> имеет следующий синтаксис:</p>

<pre>(let ((|\ii{переменная\sub{1}}| |\ii{выражение\sub{1}}|)
      (|\ii{переменная\sub{2}}| |\ii{выражение\sub{2}}|)
       ...
      (|\ii{переменная\sub{n}}| |\ii{выражение\sub{n}}|) )
  |\ii{выражения}|... )</pre>


<!--\indexC{let}-->
<p>\noindent
И она эквивалентна такому выражению:</p>

<pre>((lambda (|\ii{переменная\sub{1}}| |\ii{переменная\sub{2}}| ... |\ii{переменная\sub{n}}|) |\ii{выражения}|...)
 |\ii{выражение\sub{1}}| |\ii{выражение\sub{2}}| ... |\ii{выражение\sub{n}}| )</pre>

<p>Поясним, что здесь происходит. Сперва вычисляются все аргументы аппликации:
\ii{выражение\sub{1}}, \ii{выражение\sub{2}}, \dots, \ii{выражение\sub{n}};
затем переменные \ii{перемен\-ная\sub{1}}, \ii{перемен\-ная\sub{2}}, \dots,
\ii{перемен\-ная\sub{n}} связываются с только что полученными значениями;
наконец, \ii{выражения}, составляющие тело <code><span class="func">let</span></code>, вычисляются в расширенном
окружении внутри неявной формы <code><span class="func">begin</span></code>, а её значение становится значением
всей формы <code><span class="func">let</span></code>.</p>

<p>Как видим, в принципе нет необходимости делать <code><span class="func">let</span></code> специальной формой, так
как её полностью заменяет <code><span class="func">lambda</span></code>; следовательно, <code><span class="func">let</span></code> может быть всего
лишь макросом. (Именно так и поступили в Scheme: <code><span class="func">let</span></code> — это встроенный
макрос.) Тем не менее, <code><span class="func">let</span></code> хороша с точки зрения стиля кодирования, потому
что позволяет не разделять имя переменной и её начальное значение большим куском
кода. Теперь самое время заметить, что начальные значения локальных переменных
формы <code><span class="func">let</span></code> вычисляются в текущем окружении; в расширенном вычисляется только
её тело.</p>


<!--\indexC{letrec}-->
<p>По тем же причинам, с которыми мы столкнулись в Lisp<sub>2</sub>, это значительно
усложняет написание взаимно рекурсивных функций. Поэтому вводится форма
<code><span class="func">letrec</span></code>, аналог <code><span class="func">labels</span></code>.</p>

<p>Синтаксис <code><span class="func">letrec</span></code> такой же, как и у <code><span class="func">let</span></code>. Например:</p>

<pre>(letrec ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd? (lambda (n) (if (= n 0) #f (even? (- n 1))))) )
  (even? 4) )</pre>


<!--\indexCS{letrec}{как макрос}-->
<p>Отличается <code><span class="func">letrec</span></code> от <code><span class="func">let</span></code> тем, что выражения-инициализаторы
вычисляются в том же окружении, что и тело <code><span class="func">letrec</span></code>. Операции, которые
выполняет <code><span class="func">letrec</span></code>, те же, что и у <code><span class="func">let</span></code>, но их порядок несколько иной.
Сначала локальное окружение расширяется переменными <code><span class="func">letrec</span></code>. Затем в этом
расширенном окружении вычисляются начальные значения переменных. Наконец,
в том же расширенном окружении вычисляется тело <code><span class="func">letrec</span></code>. По этому описанию
довольно легко понять, как реализовать такое поведение. Действительно,
достаточно написать следующее:</p>


<!--\indexC{even"?}-->
<!--\indexC{odd"?}-->
<!--\indexC*{void}{'void}-->
<pre>(let ((even? 'void) (odd? 'void))
  (set! even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
  (set! odd? (lambda (n) (if (= n 0) #t (even? (- n 1)))))
  (even? 4) )</pre>

<p>Сначала создаются привязки для <code><span class="func">even?</span></code> и <code><span class="func">odd?</span></code>. (Их начальные значения
не важны, просто <code><span class="func">let</span></code> и <code><span class="func">lambda</span></code> требуют какое-то значение.) Затем эти
переменные инициализируются значениями, вычисленными в окружении, где известны
переменные <code><span class="func">even?</span></code> и <code><span class="func">odd?</span></code>. Мы говорим «известны», потому что хотя для
этих переменных и созданы привязки, их значения не имеют смысла, так как они
ещё не были правильно инициализированы. Про <code><span class="func">even?</span></code> и <code><span class="func">odd?</span></code> известно
достаточно, чтобы ссылаться на них, но пока ещё недостаточно, чтобы они
участвовали в вычислениях.</p>


<!--\indexR{порядок вычислений!неопределённый}-->
<p>Однако, такое преобразование не совсем корректно из-за порядка вычислений:
действительно, <code><span class="func">let</span></code> раскрывается в применение функции, следовательно,
<code><span class="func">letrec</span></code>, по идее, должна вести себя так же, а это значит, что начальные
значения переменных должны вычисляться как аргументы функции — то есть
в неопределённом порядке. К сожалению, подобный вариант всегда вычисляет их
слева направо. \seeEx[lisp1-2-omega/ex:orderless-letrec]</p>

<p>
\subsubsection{\texorpdfstring{Уравнения и \protect<code><span class="func">letrec</span></code>}%
{Уравнения и letrec}}</p>


<!--\indexCS{letrec}{и уравнения}-->
<p>С формой <code><span class="func">letrec</span></code> есть ещё одна серьёзная проблема: её синтаксис не является
строгим. При текущей трактовке <code><span class="func">letrec</span></code> допускает в качестве инициализаторов
всё что угодно, не только функции; тогда как <code><span class="func">labels</span></code> в <span class="logo">Common Lisp</span>
разрешает определять исключительно функции. То есть в Scheme теоретически можно
будет написать следующее:</p>

<pre>(letrec ((x (/ (+ x 1) 2))) x)</pre>

<p>Заметьте, что переменная <code><span class="func">x</span></code> фактически определяется через саму себя. Это,
похоже, обыкновенное уравнение
%
\[  x = \frac{x + 1}{2}  \]
%
Логично будет сделать значением <code><span class="func">x</span></code> корень этого уравнения. То есть такое
выражение должно вернуть <code><span class="func">1</span></code>.</p>

<p>Но что делать, если у уравнения нет корней или если их несколько?</p>

<pre>(letrec ((x (+ x 1))) x)            ; $x = x + 1$
(letrec ((x (+ (power x 37) 1))) x) ; $x = x^{37} + 1$</pre>

<p>Однако, существуют множества, вроде известного вам множества S-выражений, где
достаточно легко убедиться в том, что уравнение имеет единственное решение
<span class="cite">[<a href="z1_bibliography.xhtml#ms80">ms80</a>]</span>. Например, следующим образом можно без побочных эффектов определить
бесконечный список — как корень данного «списочного» уравнения:</p>

<pre>(letrec ((foo (cons 'bar foo))) foo)</pre>


<!--\indexR{ленивые вычисления}-->
<p>Значением этого выражения может быть или лениво вычисляемый бесконечный
список <code><span class="func">(bar bar bar ...)</span></code>, как это сделано в \cite{fw76,pj87}, так и
закольцованная структура данных (менее дорогая с вычислительной точки зрения):</p>

<pre>(let ((foo (cons 'bar 'wait)))
  (set-cdr! foo foo)
  foo )</pre>

<p>Эффективно это одно и то же, но на самом деле нет. В общем, из-за всех этих
неоднозначностей стоит ввести правило, запрещающее использовать переменную,
определяемую <code><span class="func">letrec</span></code>, для определения значения этой же переменной. В двух
предыдущих примерах необходимо было знать значение <code><span class="func">x</span></code> для того чтобы
инициализировать <code><span class="func">x</span></code>. Теперь они, очевидно, являются ошибочными. Однако мы
помним, что порядок инициализации в Scheme должен быть неопределённым, а значит,
некоторые конструкции, допускаемые данным правилом, могут быть ошибочными
в одних реализациях, но работать в других. Рассмотрим следующий пример:</p>

<pre>(letrec ((x (+ y 1))
         (y 2) )
  x )</pre>

<p>Если <code><span class="func">y</span></code> инициализируется до <code><span class="func">x</span></code>, то всё в порядке. В противном случае
возникает ошибка, потому что мы хотим увеличить значение переменной <code><span class="func">y</span></code>,
которая уже существует, но ещё не имеет значения. Некоторые компиляторы Scheme
и ML анализируют выражения-инициализаторы и проводят топологическую сортировку
для определения подходящего порядка инициализации. Естественно, такое решение
тоже не всегда срабатывает; в частности, при взаимной зависимости\footnote{Ведь
<code><span class="func">(42 42)</span></code> вполне подходит как корень данного уравнения, но почему
именно <code><span class="func">42</span></code>?} вроде такой:</p>

<pre>(letrec ((x y) (y x)) (list x y))</pre>

<p>Рассмотренные примеры напоминают о нашей дискуссии вокруг глобального окружения
и семантики <code><span class="func">define</span></code>. Там возникла похожая проблема: что делать
с неинициализированными привязками и как узнать о том, что они вообще
существуют.</p>

<p>
\subsection{Объявление неинициализированных привязок}%
\label{lisp1-2-omega/recusion/ssect:uninitialized}</p>


<!--\indexR{привязки (bindings)!неинициализированные}-->
<p>Официально семантика Scheme считает <code><span class="func">letrec</span></code> производной формой; то есть
удобным, но отнюдь не обязательным сокращением. Соответственно, любую
<code><span class="func">letrec</span></code>-форму можно переписать с помощью примитивных форм Scheme. Чуть
раньше мы попробовали это сделать, временно связывая переменные <code><span class="func">letrec</span></code>
со значением <code><span class="func">void</span></code>. К сожалению, это тоже инициализация, так что обращения
к неинициализированным переменным подобным образом отловить нельзя. Наша
ситуация усугубляется тем, что ни одна из четырёх специальных форм Scheme
не позволяет создавать «родные» неинициализированные привязки.</p>


<!--\indexC*{UFO}{\#<UFO>}-->
<p>В первом приближении можно было бы решить проблему, используя некий объект
<code><span class="func">\#<UFO></span></code> \seePage[basics/s:env/ufo] вместо <code><span class="func">void</span></code>. С ним ничего нельзя
сделать: ни прибавить к нему число, ни взять его <code><span class="func">car</span></code>; однако, это всё же
полноценный объект, так что его можно передать как аргумент в <code><span class="func">cons</span></code>, а
значит, следующая программа не будет ошибочной и вернёт <code><span class="func">\#<UFO></span></code>:</p>

<pre>(letrec ((foo (cons 'foo foo))) (cdr foo))</pre>

<p>Причина такого поведения в том, что неинициализированность — это свойство
самой привязки, а не её значения. Следовательно, мы не сможем решить проблему,
используя объекты первого класса.</p>

<p>\ForLayout{display}{\medskip}</p>


<!--\indexC*{uninitialized}{\#<uninitialized>}-->
<p>И всё же, многие реализации дают неинициализированным переменным специальное
значение. Давайте назовём его <code><span class="func">\#<uninitialized></span></code> и предположим, что это
полноценный объект. Любая переменная с таким значением считается
неинициализированной. Следовательно, используя вместо <code><span class="func">void</span></code> значение
<code><span class="func">\#<uninitialized></span></code>, мы получаем желаемую возможность обнаружить ошибку.
Однако, эта возможность чересчур явная: ничто не запрещает передавать
<code><span class="func">\#<uninitialized></span></code> в функцию как аргумент, а значит, больше нельзя
предполагать, что все аргументы функции имеют значения. Мы будем вынуждены
каждый раз проверять, действительно ли это так:</p>

<pre>(define (fact n)
  (if (eq? n '#<uninitialized>)
      (wrong "Uninitialized n")
      (if (= n 0) 1
          (* n (fact (- n 1))) ) ) )</pre>

<p>Делать так со всеми переменными — это слишком большая плата за <code><span class="func">letrec</span></code>.
Так что <code><span class="func">\#<uninitialized></span></code> нельзя делать полноценным объектом, это должно
быть особое внутреннее значение интерпретатора, которое нельзя использовать
в программах. Для того, чтобы им можно было пользоваться безопасно, необходим
специальный синтаксис.</p>

<p>\ForLayout{display}{\medskip}</p>

<p>Третий вариант решения состоит во введении специальной формы, создающей
неинициализированные привязки. Например, перенесём синтаксис <code><span class="func">let</span></code> из
<span class="logo">Common Lisp</span>, выполняющей данное действие, в Scheme:</p>

<pre>(let (|\ii{переменная}| ...)
  ... )</pre>

<p>Если имя переменной указано само по себе, без начального значения, то привязка
к этому имени не будет инициализирована. Если нам понадобится её значение, то мы
будем вынуждены проверять, была ли инициализирована данная переменная или нет.
Теперь можно будет написать нормальную реализацию <code><span class="func">letrec</span></code>. В следующем коде
переменные \ii{temp\sub{i}} являются «гигиеничными»: им выдаются специальные
имена, гарантированно не конфликтующие с именами переменных <code><span class="func">letrec</span></code> или
свободными переменными её тела.</p>

<p>\ForLayout{display}{\clearpage}</p>

<p>{\def\N#1{\ii{имя\sub{#1}}}
\def\T#1{\ii{temp\sub{#1}}}
\def\E#1{\ii{выражение\sub{#1}}}
\def\Q{\hbox to 0pt{\kern0.3em$\equals$}}
\begin{code:lisp}
(letrec ((|\N 1| |\E 1|)       (let (|\N 1| ... |\N n|)
         ...                        (let ((|\T 1| |\E 1|)
         (|\N n| |\E n|) )  |\Q|           ...
  |\ii{тело}| )                                  (|\T n| |\E n|) )
                                      (set! |\N 1| |\T 1|)
                                      ...
                                      (set! |\N n| |\T n|)
                                      |\ii{тело}| ) )
\end{code:lisp}}</p>


<!--\indexCS{let}{специальная форма}-->
<p>Итого, проблема решена с приемлемой эффективностью: лишь неинициализированные
переменные вызывают накладные расходы, потому что за особенности надо платить.
Но теперь форма <code><span class="func">let</span></code> не является просто синтаксическим сахаром, теперь это
полноценная специальная форма, которую должен обрабатывать лично интерпретатор.
Добавляем соответствующий код в <code><span class="func">evaluate</span></code>:</p>

<pre>...
((let)
 (eprogn (cddr e)
         (extend env
                 (map (lambda (binding)
                        (if (symbol? binding) binding
                            (car binding) ) )
                      (cadr e) )
                 (map (lambda (binding)
                        (if (symbol? binding) the-uninitialized-marker
                            (evaluate (cadr binding) env) ) )
                      (cadr e) ) ) ) ) ...</pre>

<p>Переменная <code><span class="func">the-uninitialized-marker</span></code> принадлежит языку определения. Зададим
её, например, так:</p>


<!--\indexC{the-uninitialized-marker}-->
<pre>(define the-uninitialized-marker (cons 'not 'initialized))</pre>

<p>Конечно, теперь необходимо встроить поддержку этого внутреннего значения
в функцию <code><span class="func">lookup</span></code>. Функция <code><span class="func">update!</span></code> в изменениях не нуждается по
очевидным причинам. Обращения к <code><span class="func">wrong</span></code> отвечают за два различных типа
ошибок: несуществующую привязку и неинициализированную привязку.</p>


<!--\indexC{lookup}-->
<pre>(define (lookup id env)
  (if (pair? env)
      (if (eq? (caar env) id)
          (let ((value (cdar env)))
            (if (eq? value the-uninitialized-marker)
                (wrong "Uninitialized binding" id)
                value ) )
          (lookup id (cdr env)) )
      (wrong "No such binding" id) ) )</pre>

<p>После блужданий по пустыне семантики и синтаксиса, у нас наконец-то получилась
форма <code><span class="func">letrec</span></code>, позволяющая определять локальные взаимно рекурсивные функции.</p>

<p>
\subsection{Рекурсия без присваивания}%
\label{lisp1-2-omega/recusion/ssect:no-assignment}</p>


<!--\indexR{язык!чисто функциональный}-->
<!--\indexR{рекурсия!без присваивания}-->
<p>Форма <code><span class="func">letrec</span></code>, которую мы рассматривали, использует присваивания для
обеспечения правильного вычисления начальных значений. Языки, называемые
<em>чисто функциональными</em>, не имеют в своём распоряжении операторов
присваивания; в них принципиально нет побочных эффектов, а чем, как
не побочным эффектом вычислений, является изменение значения переменной?</p>

<p>В качестве парадигмы программирования запрет на присваивание имеет свои
преимущества: он гарантирует сохранение ссылочной прозрачности и этим
развязывает руки множеству оптимизаций, позволяя перемещать и распараллеливать
части программ, использовать ленивые вычисления и т. д. Однако, если нет
возможности использовать присваивания, то некоторые алгоритмы становятся
не такими простыми, а также несколько усложняется перенос программ на реальные
компьютеры, так как побочные эффекты являются неотъемлемой частью их работы.</p>


<!--\indexC{letrec}-->
<p>Первое, что приходит в голову, это сделать <code><span class="func">letrec</span></code> ещё одной специальной
формой, как это и сделано в ML и подобных ему языках. Модифицируем <code><span class="func">evaluate</span></code>
для обработки этого случая:</p>

<pre>...
((letrec)
 (let ((new-env (extend env
                        (map car (cadr e))
                        (map (lambda (binding) the-uninitialized-marker)
                             (cadr e) ) )))
      (map (lambda (binding)         ; <code><span class="func">map</span></code> во имя беспорядка!
             (update! (car binding)
                      new-env
                      (evaluate (cadr binding) new-env) ) )
           (cadr e) )
      (eprogn (cddr e) new-env) ) ) ...</pre>

<p>В этом случае побочные эффекты всё равно присутствуют, но на уровне
интерпретатора, внутри <code><span class="func">update!</span></code>; с точки зрения определяемого языка побочных
эффектов нет. Стоит заметить, что мы намеренно не указываем порядок вычислений,
используя <code><span class="func">map</span></code>, которая, в отличие от <code><span class="func">for-each</span></code>, вольна обрабатывать
список в любом удобном порядке.\footnote*{Правда, расплачиваясь за это
необходимостью собирать бесполезный список, который тут же удаляется после
создания.}</p>

<p>
\subsubsection{\texorpdfstring%
{\protect<code><span class="func">letrec</span></code> и полностью лексическое глобальное окружение}%
{letrec и полностью лексическое глобальное окружение}}</p>

<p>В гиперстатическом глобальном окружении переменную можно использовать только
после того, как она была определена. С такими ограничениями мы не можем легко
определять ни взаимно, ни даже просто рекурсивные функции. Форма <code><span class="func">letrec</span></code>
решает эту проблему, а заодно служит индикатором рекурсивных определений.</p>

<pre>(letrec ((fact (lambda (n)
                 (if (= n 0) 1 (* n (fact (- n 1)))) )))
  (letrec ((odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
           (even? (lambda (n) (if (= n 0) #t (odd? (- n 1))))) )
    ... ) )</pre>

<p>\noindent
В данном случае <code><span class="func">letrec</span></code> создаёт опережающие ссылки на <code><span class="func">fact</span></code>, <code><span class="func">odd?</span></code>
и <code><span class="func">even?</span></code>, так что определения будут работать и в гиперстатическом окружении.</p>

<p>
\subsubsection{Парадоксальный комбинатор}</p>


<!--\indexR{комбинаторы!неподвижной точки}-->
<!--\indexR{комбинаторы!Y@\protect\comb{Y}}-->
<!--\indexE{Y@\protect\comb{Y}, комбинатор}-->
<!--\indexR{теорема о неподвижной точке}-->
<!--\indexR{неподвижная точка}-->
<!--\indexR{лямбда-исчисление@λ-исчисление!комбинаторы}-->
<p>Если вы имели дело с λ-исчислением, то вы наверняка помните, что
такое <em>комбинаторы неподвижной точки</em> и как записывается самый известный
из них — <em>парадоксальный</em> или Y-комбинатор. Функция $f$ имеет
неподвижную точку, если в её области определения существует элемент $x$ такой,
что $f(x) = x$. Комбинатор \comb{Y} принимает любую функцию
λ-исчисления и возвращает её неподвижную точку. Эта идея выражена
в одной из наиболее прекрасных и содержательных теорем λ-исчисления:</p>

<p>\begin{theorem}{Теорема о неподвижной точке}
$\exists \comb{Y}\colon \forall F\colon \comb{Y} F = F(\comb{Y} F)$
\end{theorem}</p>

<p>В терминах Лиспа, \comb{Y} — это значение выражения</p>

<pre>(let ((W (lambda (w)
           (lambda (f)
             (f ((w w) f)) ) )))
  (W W) )</pre>

<p>Доказать это весьма просто. Если предположить, что \comb{Y} равен $(W W)$,
то какой должна быть $W$\!, чтобы $(W W)F$ равнялось $F ((W W) F)$?
Очевидно, что функция $W$\! должна быть ничем иным, как $\lambda W. \lambda F.
F ((W W) F)$. Приведённое выражение лишь записывает эту идею на Лиспе.</p>


<!--\indexR{комбинаторы!Z@\protect\comb{Z}}-->
<!--\indexE{Z@\protect\comb{Z}, комбинатор}-->
<!--\indexR{эта-конверсия@$\eta$-конверсия}-->
<p>Правда, здесь возникает небольшое затруднений из-за принятой в Scheme передачи
аргументов по значению. Терм <code><span class="func">((w w) f)</span></code> не следует вычислять слишком рано,
поэтому мы вынуждены добавить излишнюю (в λ-исчислении)
$\eta$-конверсию, чтобы избежать проблем. В итоге мы приходим к так называемому
Z-комбинатору, где <code><span class="func">(lambda (x) (... x))</span></code> означает $\eta$-конверсию:</p>

<p>\ForLayout{display}{\clearpage}</p>


<!--\indexC{fix}-->
<pre>(define fix
  (let ((d (lambda (w)
             (lambda (f)
               (f (lambda (x) (((w w) f) x))) ) )))
  (d d) ) )</pre>

<p>Самое сложное в этом определении — понять, как оно работает. Сейчас мы этим
и займёмся. Определим функцию <code><span class="func">meta-fact</span></code>:</p>


<!--\indexC{meta-fact}-->
<p>\begin{code:lisp}[label=lisp1-2-omega/recursion/y-combinator/code:meta-fact]
(define (meta-fact f)
  (lambda (n)
    (if (= n 0) 1
        (* n (f (- n 1))) ) ) )</pre>

<p>Эта функция подозрительно похожа на факториал. Проверив, мы убеждаемся, что
<code><span class="func">(meta-fact fact)</span></code> вычисляет факториал с таким же успехом, что и <code><span class="func">fact</span></code>,
разве что несколько медленнее. Теперь предположим, что мы знаем неподвижную
точку $f$ функции <code><span class="func">meta-fact</span></code>: $f = \text{<code><span class="func">(meta-fact $f$)</span></code>}$. Эта
неподвижная точка по определению является решением следующего функционального
уравнения относительно $f$:</p>

<pre>|\ii{f}| = (lambda (n)
      (if (= n 0) 1
          (* n (|\ii{f}| (- n 1))) ) )</pre>

<p>Итак, что же такое $f$? Не что иное, как всем известный факториал!</p>

<p>Вообще-то говоря, нет ни единого основания полагать, что уравнение выше имеет
решение и что оно единственно. (Конечно, эти термины надо бы определить строго
математически, но это выходит за рамки данной книги.) Действительно, есть как
минимум ещё одно решение:</p>


<!--\indexC{fact}-->
<pre>(define (another-fact n)
  (cond ((< n 1) (- n))
        ((= n 1) 1)
        (else (* n (another-fact (- n 1)))) ) )</pre>


<!--\indexR{неподвижная точка!наименьшая}-->
<p>Проверьте, пожалуйста, что <code><span class="func">another-fact</span></code> также является неподвижной точкой
<code><span class="func">meta-fact</span></code>. Анализируя возможные неподвижные точки, можно прийти к выводу,
что есть такая область определения, на которой их значения совпадают: все они
вычисляют факториал натуральных чисел. Их поведение различно только тогда, когда
исходный вариант <code><span class="func">fact</span></code> попадает в бесконечный цикл. Для отрицательных целых
чисел <code><span class="func">another-fact</span></code> возвращает одно значение, хотя вполне могла бы вернуть
какое-нибудь другое, потому что исходное функциональное уравнение не указывает,%
\footnote*{Более подробное объяснение см. в <span class="cite">[<a href="z1_bibliography.xhtml#man74">man74</a>]</span>.} что делать в таком
случае. Если упорядочить функции по некоторой мере их определённости, то должна
существовать наименьшая неподвижная точка — наименее определённое решение
функционального уравнения.</p>

<p>Математический смысл глобальных рекурсивных определений вроде <code><span class="func">fact</span></code> состоит
в том, что они определяют функции, являющиеся наименьшими неподвижными точками
соответствующих функциональных уравнений. Когда мы пишем:</p>

<pre>(define (fact n)
  (if (= n 0) 1
      (* n (fact (- n 1))) ) )</pre>

<p>\noindent
то фактически записываем уравнение относительно переменной <code><span class="func">fact</span></code>. Форма
<code><span class="func">define</span></code> решает это уравнение и связывает полученное решение
с переменной <code><span class="func">fact</span></code>. Такая трактовка уводит нас далеко от обсуждения
инициализации глобальных переменных
\seePage[lisp1-2-omega/recusion/ssect:simple]
и превращает <code><span class="func">define</span></code> в магический решатель уравнений. В действительности,
<code><span class="func">define</span></code> реализована именно так, как предложено ранее. Просто рекурсия
в глобальном окружении вместе с нормальным порядком вычислений действительно
способны находить наименьшие неподвижные точки.</p>

<p>А теперь вернёмся к <code><span class="func">fix</span></code>, нашему Z-комбинатору, и проследим, как же
вычисляется <code><span class="func">((fix meta-fact) 3)</span></code>. Помните, что здесь функции не имеют
побочных эффектов, а значит, результаты вычислений можно свободно подставлять
друг в друга, чем мы и будем пользоваться.</p>


<!--\indexC{fix}-->
<pre>((fix meta-fact) 3)
|\Equals|   (((d d)|\begin{where}
                    \- d {\eq} \begin{complex}
                              \-(lambda (w)
                              \-  (lambda (f)
                              \-   (f (lambda (x)
                              \-        (((w w) f) x) )) ) )
                              \end{complex}
                    \end{where}|
     meta-fact )
    3 )</p>

<p>|\Equals|   (((lambda (f)               ; <em class="term">шаг I</em>
       (f (lambda (x)
            (((w w) f) x) )) )|\begin{where}
                               \- w {\eq} \begin{complex}
                                         \-(lambda (w)
                                         \-  (lambda (f)
                                         \-   (f (lambda (x)
                                         \-        (((w w) f) x) )) ) )
                                         \end{complex}
                              \end{where}|
     meta-fact )
    3 )</p>

<p>|\Equals|   ((meta-fact (lambda (x)
                 (((w w) f) x) ))|\begin{where}
                                  \- w {\eq} \begin{complex}
                                            \-(lambda (w)
                                            \-  (lambda (f)
                                            \-    (f (lambda (x)
                                            \-         (((w w) f) x) )) ) )
                                            \end{complex}
                                  \end{where}|
    3 )
|\Equals|   ((lambda (n)
      (if (= n 0) 1
          (* n (f (- n 1))) ) )|\begin{where}
                                \- f {\eq} \begin{complex}
                                          \-(lambda (x)
                                          \-  (((w w) meta-fact) x) )\begin{where}
                                                         \- w {\eq} \begin{complex*}{6.2cm}
                                                                   \-(lambda (w)
                                                                   \-  (lambda (f)
                                                                   \-    (f (lambda (x)
                                                                   \-         (((w w) f) x) )) ) )
                                                                   \end{complex*}
                                                         \end{where}
                                                  \end{complex}
                                \end{where}|
    3 )
|\Equals|   (* 3 (f 2))|\begin{where}
                        \- f {\eq} \begin{complex}
                                  \-(lambda (x)
                                  \-  (((w w) meta-fact) x) )\begin{where}
                                                             \- w {\eq} \begin{complex*}{4.8cm}
                                                                       \-(lambda (w)
                                                                       \-  (lambda (f)
                                                                       \-    (f (lambda (x)
                                                                       \-         (((w w) f) x) )) )  )
                                                                       \end{complex*}
                                                                      \end{where}
                                  \end{complex}
                        \end{where}|
|\Equals|   (* 3 (((w w) meta-fact) 2))|\begin{where}
                                        \- w {\eq} \begin{complex}
                                                  \-(lambda (w)
                                                  \-  (lambda (f)
                                                  \-    (f (lambda (x)
                                                  \-         (((w w) f) x) )) ) )
                                                  \end{complex}
                                        \end{where}|
|\Equals|   (* 3 (((lambda (f)           ; <em class="term">шаг II</em>
            (f (lambda (x)
                 (((w w) f) x) )) )|\begin{where}
                                    \- w {\eq} \begin{complex}
                                              \-(lambda (w)
                                              \-  (lambda (f)
                                              \-    (f (lambda (x)
                                              \-         (((w w) f) x) )) ) )
                                              \end{complex}
                                    \end{where}|
          meta-fact )
         2 ) )</pre>

<p>Остановимся на минутку, чтобы заметить, что на шаге II мы получили то же самое
выражение, что и на шаге I. Естественно, оно появится и в третий раз:</p>

<pre>(* 3 (* 2 (((lambda (f)
              (f (lambda (x)
                   (((w w) f) x) )) )|\begin{where}
                                      \- w {\eq} \begin{complex}
                                                \-(lambda (w)
                                                \-  (lambda (f)
                                                \-    (f (lambda (x)
                                                \-         (((w w) f) x) )) ) )
                                                \end{complex}
                                      \end{where}|
            meta-fact )
           1 )))
|\Equals|   (* 3 (* 2 ((meta-fact (lambda (x)
                           (((w w) meta-fact) x) ))|\begin{where}
                                                    \- w {\eq} \begin{complex*}{4.5cm}
                                                              \-(lambda (w)
                                                              \-  (lambda (f)
                                                              \-    (f (lambda (x)
                                                              \-         (((w w) f) x) )) ) )
                                                              \end{complex*}
                                                    \end{where}|
              1 )))
|\Equals|   (* 3 (* 2 ((lambda (n)
                (if (= n 0) 1
                    (* n (f (- n 1))) ) )|\begin{where}
                                          \- f {\is} ...
                                          \end{where}|
              1 )))
|\Equals|   (* 3 (* 2 (if (= n 0) 1 (* n (f (- n 1))))))|\begin{where}
                                                         \- n {\is} 1
                                                         \- f {\is} ...
                                                         \end{where}|
|\Equals|   (* 3 (* 2 1))</p>

<p>|\is| 6</pre>

<p>Обратите внимание, что в процессе вычислений мы действительно используем
функцию, вычисляющую факториал. Это значение выражения:</p>

<pre>(lambda (x)
  (((w w) f) x) )|\begin{where}
                  \- f {\eq} meta-fact
                  \- w {\is} \begin{complex}
                            \-(lambda (w)
                            \-  (lambda (f)
                            \-    (f (lambda (x)
                            \-         (((w w) f) x) )) ) )
                            \end{complex}
                  \end{where}|</pre>


<!--\indexR{самоприменение!и рекурсия}-->
<p>Идея состоит в том, что благодаря самоприменению мы помним, как создать заново
данную функцию, и делаем это каждый раз, когда для вычислений требуется
рекурсивный вызов.</p>


<!--\indexCS{define}{как решатель уравнений}-->
<p>Таким образом можно получить простую рекурсию без использования побочных
эффектов, только с помощью <code><span class="func">fix</span></code>, комбинатора неподвижной точки. Благодаря
\comb{Y} (или <code><span class="func">fix</span></code>), <code><span class="func">define</span></code> можно определить как решатель рекурсивных
уравнений; она принимает уравнение и связывает решение с переданным именем.
В итоге, если мы передадим <code><span class="func">define</span></code> уравнение для факториала, то с <code><span class="func">fact</span></code>
будет связано следующее значение:</p>

<pre>(fix (lambda (fact)
       (lambda (n)
         (if (= n 0) 1
             (* n (fact (- n 1))) ) ) ))</pre>

<p>Аналогично можно решать системы уравнений, а значит, и задавать взаимно
рекурсивные функции, собирая их уравнения воедино:</p>


<!--\indexC{odd"?}-->
<!--\indexC{even"?}-->
<pre>(define odd-and-even
  (fix (lambda (f)
         (lambda (which)
           (case which
             ((odd) (lambda (n) (if (= n 0) #f
                                    ((f 'even) (- n 1)) )))
             ((even) (lambda (n) (if (= n 0) #t
                                     ((f 'odd) (- n 1)) ))) ) ) )) )
(define odd? (odd-and-even 'odd))
(define even? (odd-and-even 'even))</pre>

<p>У этого метода есть один большой недостаток: неэффективность, даже по сравнению
с наивной реализацией <code><span class="func">letrec</span></code>. (И всё же, см. \cite{roz92,ser93}.) Тем
не менее, он используется, особенно в качестве книжного примера. Функциональные
языки, по мнению <span class="cite">[<a href="z1_bibliography.xhtml#pj87">pj87</a>]</span>, тоже особо не жалуют данный метод, так как,
во-первых, он неэффективен, а во-вторых, <code><span class="func">fix</span></code> плохо сочетается с системами
вывода типов. Действительно, <code><span class="func">fix</span></code> принимает функционал,%
\footnote*{Терминология Маккарти из <span class="cite">[<a href="z1_bibliography.xhtml#mae+62">mae+62</a>]</span>: функционал — это функция,
принимающая другие функции как аргументы.} принимающий функцию типа $\alpha \to
\beta$, и возвращает неподвижную точку этого функционала. То есть типом <code><span class="func">fix</span></code>
является
%
\[ \big((\alpha \to \beta) \to (\alpha \to \beta)\big) \to (\alpha \to \beta) \]</p>


<!--\indexR{самоприменение!типизация}-->
<p>Но в определении <code><span class="func">fix</span></code> есть самоприменение: <code><span class="func">(d d)</span></code>. Обозначив его тип
$\gamma$, имеем:
%
\[ \gamma = \gamma \to (\alpha \to \beta) \]</p>

<p>Потребуется или нетривиальная система типов, чтобы в ней можно было выразить
подобный рекурсивный тип, или же мы будем вынуждены реализовать <code><span class="func">fix</span></code>
в интерпретаторе как примитивную функцию, так как её нельзя выразить средствами
самого языка.</p>

<h2 id="lisp1-2-omega/sect:conclusions">Заключение</h2>

<p>В этой главе мы прошлись по наиболее заметным из вопросов, на которые сообщество
Лиспа за последние несколько десятков лет так и не смогло дать однозначного
ответа. Рассмотрев причины данных разногласий, мы поняли, что они вовсе не такие
серьёзные по своей сути. Большая часть из них связана с неоднозначностью
толкования смысла формы <code><span class="func">lambda</span></code> и различными способами применения функций.
Хотя идея функции достаточно хорошо проработана в математике, но
в функциональных (!) языках вроде Лиспа это отнюдь не так. Различные мнения по
таким вопросам — это часть истории Лиспа. Подобно изучению истории родного
народа, их знание облегчает понимание причин тех или иных решений в дизайне
языка, а также улучшает стиль программирования в общем.</p>

<p>Также данная глава демонстрирует существенную важность понятия связывания.
В Lisp<sub>1</sub> переменная (имя) ассоциируется с уникальной привязкой (возможно
глобальной), которая в свою очередь ассоциируется с каким-либо значением. Так
как привязка уникальна, то мы говорим о значении переменной, а не о значении
привязки этой переменной. Если рассматривать привязки как абстрактный тип
данных, то можно сказать, что объекты этого типа создаются связывающими формами,
их значение определяется вычислением, изменяются они присваиванием, и могут быть
захвачены при создании замыкания, если тело замыкания ссылается на переменную,
которая ассоциирована с данной привязкой.</p>

<p>Привязки не являются полноценными объектами. Они не существуют в отрыве от
переменных и могут быть изменены только косвенно. Собственно, привязки полезны
именно потому, что они крепко-накрепко связаны со своими переменными.</p>


<!--\indexR{форма!связывающая}-->
<!--\indexR{связывающие формы}-->
<!--\indexR{область видимости!лексическая}-->
<p>Бок о бок со связывающими формами следует идея областей видимости. Область
видимости переменной — это пространство в тексте программы, где можно
обращаться к данной переменной. Область видимости переменных, создаваемых
формой <code><span class="func">lambda</span></code>, ограничена телом данной формы. Поэтому она называется
текстуальной или лексической.</p>

<p>Присваивание вносит множество неоднозначностей в идею связывания, мы изучим этот
вопрос подробнее в следующих главах.</p>


<h2 id="lisp1-2-omega/sect:exercises">Упражнения</h2>

<h5 class="exercise" id="lisp1-2-omega/ex:funcall">Упражнение <span class="seq">0.0</span></h5>
<p>Следующее выражение записано на <span class="logo">Common Lisp</span>. Как бы вы его перевели на Scheme?</p>

<pre>(funcall (function funcall) (function funcall) (function cons) 1 2)
\end{code:lisp}</p>


<h5 class="exercise" id="lisp1-2-omega/ex:lexical">Упражнение <span class="seq">0.0</span></h5>
<p>Что вернёт данная программа на псевдо-<span class="logo">Common Lisp</span> из этой главы?
О чём она вам напоминает?</p>

<pre>(defun test (p)
  (function bar) )</p>

<p>(let ((f (test #f)))
  (defun bar (x) (cdr x))
  (funcall f '(1 . 2)) )
\end{code:lisp}</p>


<h5 class="exercise" id="lisp1-2-omega/ex:innovations">Упражнение <span class="seq">0.0</span></h5>
<p>Реализуйте в вашем интерпретаторе первые две инновации из
раздела \ref{lisp1-2-omega/sect:extensions}
\seePage[lisp1-2-omega/sect:extensions]. Речь идёт о трактовке чисел и
списков как функций.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:assoc-with-comparator">Упражнение <span class="seq">0.0</span></h5>
<p>Можно научить функцию <code><span class="func">assoc/de</span></code> явно принимать компаратор (вроде <code><span class="func">eq?</span></code>,
<code><span class="func">equal?</span></code> и т. п.) через аргумент, а не задавать его внутри. Сделайте это.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:dynamic">Упражнение <span class="seq">0.0</span></h5>
<p>Используя <code><span class="func">bind/de</span></code> и <code><span class="func">assoc/de</span></code>, напишите макросы, эмулирующие
специальные формы <code><span class="func">dynamic-let</span></code>, <code><span class="func">dynamic</span></code> и <code><span class="func">dynamic-set!</span></code>.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:write-put/get-prop">Упражнение <span class="seq">0.0</span></h5>
<!--\indexC{putprop}-->
<!--\indexC{getprop}-->
<p>Напишите функции <code><span class="func">getprop</span></code> и <code><span class="func">putprop</span></code>, которые реализуют списки свойств.
Любой символ имеет личный список свойств в виде пар «ключ — значение»;
добавление в этот список осуществляет функция <code><span class="func">putprop</span></code>, поиск значения по
ключу осуществляет функция <code><span class="func">getprop</span></code>. Также, естественно, должно выполняться
утверждение</p>

<pre>(begin (putprop 'symbol 'key 'value)
       (getprop 'symbol 'key) )      |\is| value
\end{code:lisp}</p>


<h5 class="exercise" id="lisp1-2-omega/ex:label">Упражнение <span class="seq">0.0</span></h5>
<p>Определите специальную форму <code><span class="func">label</span></code> на Lisp<sub>1</sub>.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:labels">Упражнение <span class="seq">0.0</span></h5>
<p>Определите специальную форму <code><span class="func">labels</span></code> на Lisp<sub>2</sub>.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:orderless-letrec">Упражнение <span class="seq">0.0</span></h5>
<!--\indexC{letrec}-->
<p>Придумайте, как реализовать <code><span class="func">letrec</span></code> с помощью <code><span class="func">let</span></code> и <code><span class="func">set!</span></code> так,
чтобы порядок вычисления значений-инициализаторов был неопределённым.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:fixn">Упражнение <span class="seq">0.0</span></h5>
<!--\indexR{комбинаторы!неподвижной точки!универсальный}-->
<p>У нашего комбинатора неподвижной точки на Scheme обнаружился недостаток: он
поддерживает только унарные функции. Реализуйте <code><span class="func">fix2</span></code>, работающий
с бинарными функциями. Затем <code><span class="func">fixN</span></code>, поддерживающий функции любой арности.</p>


<h5 class="exercise" id="lisp1-2-omega/ex:nfixn">Упражнение <span class="seq">0.0</span></h5>
<p>Далее напишите функцию <code><span class="func">NfixN</span></code>, возвращающую неподвижные точки для списка
функционалов произвольной арности. Её можно использовать, например, следующим
образом:</p>

<pre>(let ((odd-and-even
       (NfixN (list (lambda (odd? even?)    ; <code><span class="func">odd?</span></code>
                      (lambda (n)
                        (if (= n 0) #f (even? (- n 1))) ) )
                    (lambda (odd? even?)    ; <code><span class="func">even?</span></code>
                      (lambda (n)
                        (if (= n 0) #t (odd? (- n 1))) ) ) )) ))
  (set! odd? (car odd-and-even))
  (set! even? (cadr odd-and-even)) )
\end{code:lisp}</p>


<h5 class="exercise" id="lisp1-2-omega/ex:klop">Упражнение <span class="seq">0.0</span></h5>
<p>Рассмотрим функцию <code><span class="func">klop</span></code>. Является ли она комбинатором неподвижной точки?
Попробуйте доказать или опровергнуть, что <code><span class="func">(klop $f$)</span></code> тоже возвращает
неподвижную точку $f$ подобно <code><span class="func">fix</span></code>.</p>


<!--\indexC{klop}-->
<pre>(define klop
  (let ((r (lambda (s c h e m)
             (lambda (f)
               (f (lambda (n)
                    (((m e c h e s) f) n) )) ) )))
    (r r r r r r) ) )
\end{code:lisp}</p>


<h5 class="exercise" id="lisp1-2-omega/ex:hyper-fact">Упражнение <span class="seq">0.0</span></h5>
<!--\indexC{fact}-->
<p>Если функция <code><span class="func">hyper-fact</span></code> определена так:</p>

<pre>(define (hyper-fact f)
  (lambda (n)
    (if (= n 0) 1
        (* n ((f f) (- n 1))) ) ) )</pre>

<p>\noindent
то что вернёт <code><span class="func">((hyper-fact hyper-fact) 5)</span></code>?</p>

<p>\section*{Рекомендуемая литература}%
\label{lisp1-2-omega/sect:recommended-reading}</p>

<p>Кроме упомянутой ранее работы по λ-исчислению <span class="cite">[<a href="z1_bibliography.xhtml#ss78a">ss78a</a>]</span> также имеет
смысл почитать про анализ функций в <span class="cite">[<a href="z1_bibliography.xhtml#mos70">mos70</a>]</span> и сравнительный анализ Lisp<sub>1</sub>
и Lisp<sub>2</sub> в <span class="cite">[<a href="z1_bibliography.xhtml#gp88">gp88</a>]</span>.</p>

<p>В <span class="cite">[<a href="z1_bibliography.xhtml#gor88">gor88</a>]</span> есть интересное введение в λ-исчисление.</p>

<p>Комбинатор \comb{Y} разбирается подробнее в <span class="cite">[<a href="z1_bibliography.xhtml#gab88">gab88</a>]</span>.</p>

<p></body>
</html>
