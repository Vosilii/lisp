<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru"></p>

<p><body>
\begingroup\ChapterFiveSpecials
\chapter{Денотационная семантика}\label{chapter:denotational}</p>

<p>\initial{1.0ex}{0.65ex}{Э}{\kern0.25ex та глава} начинается кратким обзором
λ-исчисления, после чего переходит к денотационной семантике во всей её
красе. Мы рассмотрим ещё одно определение Лиспа — в этот раз денотационное,
— значительно отличающееся от предыдущих интерпретаторов: смысл программ
теперь будет выражаться математическими объектами — термами
λ-исчисления.</p>

<div class="bigskip"/>


<!--\indexR{смысл программ}-->
<!--\indexR{программы!смысл}-->
<!--\indexR{язык!и смысл программ}-->
<p>Чем именно является программа? <em class="term">Программа</em> — это описание вычислений,
которые приводят к определённому результату: значению \hbox{и/или} эффекту.</p>

<p>Очень часто программу путают с её исполнимым воплощением для той или иной
машины; аналогично, определением программы часто считают файл с её исходным
кодом; но всё это совершенно различные понятия.</p>

<p>Программы записываются на некотором <em class="term">языке</em>; определение этого языка
придаёт корректным программам <em class="term">смысл</em>. Смысл программы — это не только и
не столько результаты вычислений, так как они зависят от введённых данных, от
событий во внешнем мире, от действий других программ. Смысл программы — это
нечто большее, это суть проводимых вычислений.</p>

<p>Если мы хотим как-то изучать смысл программ и обрабатывать их, то они обязаны
иметь математическое представление. Возьмём любое преобразование, например,
перевод программы в «коробочный стиль» из предыдущей главы.
\seePage[assignment/assignment/boxes/p:boxing] Как мы можем быть уверены, что
после подобной операции смысл программы останется неизменным? Только с помощью
тысячелетнего опыта математики — науки об отношениях, структуре и
преобразованиях. А для этого необходимо связать смысл программ с математическими
объектами. Такой подход кажется вполне разумным и полезным: например, если бы
функция <code><span class="func">fact</span></code> выражалась буквально через факториал, то стало бы гораздо
проще убедиться в том, что она вычисляет именно факториал, или что другие
функции, вроде <code><span class="func">meta-fact</span></code>
\seePage[lisp1-2-omega/recursion/y-combinator/code:meta-fact], действительно ей
эквивалентны.</p>

<p>Для определения смысла программы необходим её математический эквивалент, а для
его построения нам надо в точности знать свойства языка, на котором написана
программа. В общем, проблема сводится к отысканию способа построения
математических эквивалентов всех конструкций языка. То есть к формализации его
<em class="term">семантики</em>. Семантика языка программирования даёт нам его полное
понимание: мы можем реализовать язык на чём угодно, мы можем доказывать
правильность программ и их преобразований, мы можем сравнивать языки между собой
и многое другое. Применений семантики великое множество, но не только она одна
даёт такие возможности.</p>


<!--\indexR{эталонная реализация}-->
<p>Одним из древнейших способов определения языков является предоставление
<em class="term">эталонной реализации</em>. Когда необходима некая информация о языке,
например, последствия выполнения какой-либо программы, то эту программу можно
передать эталонной реализации и получить ответ: каким должно быть возвращаемое
значение или побочные эффекты. Но, как и с любым чёрным ящиком, очень непросто
построить полную теорию его работы, пользуясь лишь подобными наблюдениями. Если
мы решим открыть ящик, то внутри окажется ещё одна программа на каком-то языке,
что возвращает нас к исходному вопросу о смысле программ.</p>


<!--\indexR{виртуальная машина}-->
<p>Следующий подход основывается на идее <em class="term">виртуальной машины</em>. Это не решает
проблему одним махом, но разделяет её на две проблемы поменьше. Сначала нам
необходимо описать конструкции языка с помощью ограниченного числа операций
вычислительной машины определённой архитектуры. После этого остаётся только
понять, как работает данная машина. Сама виртуальная машина является формальной
абстракцией, так что может быть реализована на любой реальной вычислительной
машине.</p>

<p>Многие языки определяются именно таким образом: PL/I (на VDM), PSL <span class="cite">[<a href="z1_bibliography.xhtml#gbm82">gbm82</a>]</span>,
Le_Lisp (на LLM3 <span class="cite">[<a href="z1_bibliography.xhtml#cha80">cha80</a>]</span>), Gambit поверх PVM <span class="cite">[<a href="z1_bibliography.xhtml#fm90">fm90</a>]</span>.</p>


<!--\indexR{семантика!операционная}-->
<p>Главная проблема — это разработать хорошую виртуальную машину. Это не так
легко, как кажется: она должна одновременно подходить для языка, быть простой
в использовании и тривиальной в реализации. На выбор есть множество вариантов:
стековые машины, регистровые, основанные на деревьях, графах — в общем, всё,
что душе угодно. (Здесь мы сначала выбираем язык ассемблера, а затем подгоняем
под него архитектуру машины.) В этом случае сравнение программ сводится
к сравнению соответствующих им машинных кодов или же хода их исполнения машиной.
Так как в итоге всё упирается в работу вычислительной машины, виртуальной или
реальной, то подобный способ определения языка называется <em class="term">операционной
семантикой</em>.</p>


<!--\indexR{денотация!определение}-->
<p>Но у данного способа есть врождённый недостаток: ему необходима специальная
вычислительная машина; иными словами, формальная теория вычислений. Если
в качестве такой теории взять какую-нибудь простую, всем понятную концепцию, то
можно избавиться от поддержки зоопарка всевозможных машин. Программа — это,
прежде всего, функция, преобразующая входные данные в выходные. В этом случае
не требуется сложная машина: математика веками оттачивала такой способ
«исполнения программ», называя его «применением функций». Таким образом,
идея состоит в том, чтобы преобразовать программу в функцию (из определённого
множества функций). Подобная функция называется <em class="term">денотацией</em> программы.
Теперь остаётся только определить вышеупомянутое множество.</p>


<!--\indexR{лямбда-исчисление@λ-исчисление}-->
<!--\indexR{лямбда-терм@$\lambda$-терм}-->
<!--\indexR{терм!лямбда-исчисления@λ-исчисления}-->
<!--\indexR{семантика!денотационная}-->
<p>Для наших целей прекрасно подойдёт λ-исчисление. Его аксиомы настолько
просты, что их толкование не вызывает никаких разногласий. Таким образом,
семантику языка программирования можно понимать как способ перевода программ
в соответствующие денотации. Этот процесс, между прочим, тоже можно представить
как функцию. Денотация программы — это выражение λ-исчисления
($\lambda$-терм), представляющее смысл программы. Вооружившись теорией
λ-исчисления, мы теперь в состоянии сказать, эквивалентны ли две
программы, предсказать результат вычислений и т. д. Конечно, есть множество
тонкостей: используемый вариант λ-исчисления, способ определения
семантической функции, преобразующей программы в денотации, и многое другое, но
общая идея — это именно то, что называется <em class="term">денотационной семантикой</em>.</p>


<!--\indexR{семантика!аксиоматическая}-->
<p>Стоит упомянуть ещё один способ понимания программ, особо полезный для
доказательства их корректности. Речь идёт об <em class="term">аксиоматической семантике</em>
Ричарда Флойда и Тони Хоара. Идея состоит в том, что для всех конструкций языка
составляются логические утверждения вида $\{P\}\text{\ii{форма}}\{Q\}$. Данная
формула означает, что если утверждение $P$ истинно перед исполнением \ii{формы},
то в результате её исполнения станет истинным $Q$. В итоге конструкции языка
сводятся к набору подобных утверждений-аксиом, из которых выводятся
утверждения-теоремы о поведении программ. Такой подход несомненно удобен для
доказательства корректности программ, но, к сожалению, ничего не говорит о том,
как реализовывать вычислитель для языка. Ни даже о том, возможно ли построить
такой вычислитель в принципе.</p>


<!--\indexR{семантика!естественная}-->
<!--\indexR{семантика!алгебраическая}-->
<p>Конечно же, многообразие семантик не исчерпывается перечисленными вариантами.
Например, существует <em class="term">естественная семантика</em> <span class="cite">[<a href="z1_bibliography.xhtml#kah87">kah87</a>]</span>, подобная
денотационной, но с большим упором на логический вывод свойств программы из
аксиом. Или <em class="term">алгебраическая семантика</em> <span class="cite">[<a href="z1_bibliography.xhtml#ff89">ff89</a>]</span>, рассматривающая правила
эквивалентных преобразований программ.</p>

<p>
\section{\texorpdfstring{Краткий обзор λ-исчисления}%
{Краткий обзор λ-исчисления}}\label{denotational/sect:lambda-review}</p>


<!--\indexR{интерпретатор!в денотационной семантике}-->
<p>Суть денотационной семантики лежит в определении (специфичной для языка)
функции, называемой <em class="term">интерпретатором</em> (\english{valuation function}),
которая переводит корректную программу на языке в соответствующую денотацию —
элемент множества денотаций. В качестве подобного множества мы решили взять
λ-исчисление, так как оно имеет простую структуру и довольно близко
к Scheme, который иногда так и называют «интерпретатором $\lambda$-термов»
\cite{ss75,wan84}.</p>


<!--\indexR{абстракция}-->
<!--\indexR{аппликация}-->
<p>Сейчас мы быстро пробежимся по основам λ-исчисления.\footnote*{Хорошим
введением в λ-исчисление могут служить книги \cite{sto77, gor88}.
Первой книгой библии λ-исчисления считается <span class="cite">[<a href="z1_bibliography.xhtml#bar84">bar84</a>]</span>.} Его
синтаксис очень простой: выражения (термы) ограничиваются переменными,
абстракциями и аппликациями. Множество всех доступных переменных будем
обозначать \Vset{Переменные}. Множество всех термов λ-исчисления будем
обозначать $\Lambda$; его можно индуктивно определить следующим образом:</p>

<p>\[ \begin{array}{rll}
  \text{\ii{переменные}:} & \forall x \in \Vset{Переменные}\colon
                            & x \in \Lambda                                   \\
  \text{\ii{абстракции}:} & \forall x \in \Vset{Переменные}, M \in \Lambda\colon
                            & \lambda x . M \in \Lambda                       \\
  \text{\ii{аппликации}:} & \forall M, N \in \Lambda\colon
                          & (M\ N) \in \Lambda
\end{array} \]</p>


<!--\indexR{Лисп!и лямбда-исчисление@и λ-исчисление}-->
<!--\indexR{лямбда-исчисление@λ-исчисление!синтаксис}-->
<!--\indexR{синтаксис!лямбда-исчисления@λ-исчисления}-->
<p>Синтаксис не особо важен и термы λ-исчисления одинаково удобно
записываются в виде S-выражений.\footnote*{Фактически, именно это Джон Маккарти
и сделал в 1960 году.} Таким образом, множество термов λ-исчисления
синтаксически совпадает с подмножеством программ на Scheme, использующих только
одну специальную форму — <code><span class="func">lambda</span></code>:
%
\[
x \qquad\qquad \text{<code><span class="func">(lambda ($x$) $M$)</span></code>} \qquad\qquad \text{<code><span class="func">($M$ $N$)</span></code>}
\]</p>


<!--\indexR{абстракция!редукция}-->
<!--\indexR{бета-редукция@$\beta$-редукция}-->
<!--\indexR{функции!в лямбда-исчислении@в λ-исчислении}-->
<!--\indexR{функции!модель подстановки}-->
<!--\indexR{модель подстановки}-->
<p>С помощью λ-исчисления мы можем определять функции. Есть даже правило
их применения — <em class="term">$\beta$-редукция</em>: в результате применения
функции $\lambda x . M$ к терму $N$ получается новый терм, являющийся телом
функции $M$\!, в котором вместо переменной $x$ используется $N$\!, что коротко
записывается: $M[x \to N]$. Это обычная модель подстановки, испокон веков
используемая математикой как само собой разумеющееся. Именно так проводятся
вычисления в программах на Scheme, принадлежащих вышеупомянутому подмножеству
(без побочных эффектов, с одной специальной формой).
%
\[ \text{$\beta$-редукция:} \quad (\lambda x . M\ N) \to*{\beta} M[x \to N] \]</p>


<!--\indexR{лексическое связывание!в лямбда-исчислении@в λ-исчислении}-->
<p>Подстановка $M[x \to N]$ должна быть достаточно сообразительной, чтобы нечаянно
не затронуть лишние переменные. Имеются в виду свободные переменные, которые
могут появиться при подстановке, если $M$ является абстракцией. Свободные
переменные терма $N$ не получают значений одноимённых переменных терма $M$ при
подстановке $N$ в $M$; подстановка значений вместо переменных может быть только
явной. Говоря более понятным языком, в λ-исчислении принято лексическое
связывание. Подобная подстановка определяется следующим образом (скобки отделяют
выражения, где происходят изменения):
%
\begin{align*}
  &  x[x \to N] = N \\
  &  y[x \to N] = y \quad \text{если $x \ne y$}                               \\
  &  (\lambda x . M)[x \to N] = \lambda x . M                                 \\
  &  (\lambda y . M)[x \to N] = \lambda z . \big(M[y \to z][x \to N]\big)
         \quad \text{где $x \ne y$ и $z$ не свободна в $M$ и $N$}             \\
  &  (M_1\ M_2)[x \to N] = (M_1[x \to N]\ M_2[x \to N])
\end{align*}</p>


<!--\indexR{редексы}-->
<!--\indexR{приводимые!выражения}-->
<!--\indexR{форма!нормальная}-->
<!--\indexR{нормальная форма}-->
<!--\indexR{теорема Чёрча"""-"- Россера}-->
<!--\indexR{Чёрча"""-"- Россера, теорема}-->
<p><em class="term">Редексом</em> (от \english{reducible expression}) или приводимым выражением
называется аппликация, где первый терм (терм на месте функции) является
абстракцией. $\beta$-редукция позволяет избавиться от редексов. Если терм
не содержит редексов (является неприводимым), то говорят, что он находится
в <em class="term">нормальной форме.</em> Термы λ-исчисления не обязательно имеют
нормальную форму, но если она существует, то, в соответствии с теоремой
Чёрча"-- Россера, она единственна.</p>


<!--\indexR{стратегия вычислений}-->
<!--\indexR{вычисления!стратегия вычислений}-->
<!--\indexE{Scheme!порядок вычислений}-->
<!--\indexR{нормальный порядок вычислений}-->
<!--\indexR{аппликативный порядок вычислений}-->
<!--\indexR{энергичный порядок вычислений}-->
<!--\indexR{порядок вычислений!нормальный}-->
<!--\indexR{порядок вычислений!аппликативный}-->
<!--\indexR{порядок вычислений!энергичный}-->
<!--\indexR{вызов!по значению}-->
<!--\indexR{вызов!по имени}-->
<p>Если терм имеет нормальную форму, то она обязательно достижима за конечное
число $\beta$-редукций. <em class="term">Стратегией вычислений</em> называется правило выбора
редекса (если их несколько), который будет редуцирован следующим. К сожалению,
есть как хорошие правила, так и плохие. Пример хорошего правила: редуцировать
самый левый редекс. Оно не обязательно ведёт по кратчайшему пути, но
гарантированно достигает нормальной формы (если она вообще существует). Данное
правило называется <em class="term">нормальным</em> порядком вычислений, он же <em class="term">вызов по
имени</em>. Примером плохого правила — именно его использует Scheme — является
<em class="term">аппликативный</em> порядок вычислений, также известный как <em class="term">вызов по
значению</em> или <em class="term">энергичный</em> порядок (\english{eager evaluation}). В этом
случае функция применяется лишь после вычисления её аргументов. Рассмотрим
несколько примеров. Вот терм, который не имеет нормальной формы:
%
\[
  (\omega\ \omega) \quad \text{где}\ \omega = \lambda x . (x\ x)
      \quad \text{так как}\ (\omega\ \omega) \to*{\beta} (\omega\ \omega)
                                             \to*{\beta} (\omega\ \omega)
                                             \to*{\beta} \dots
\]</p>

<p>В Scheme подобная программа приводит к бесконечному циклу и, очевидно, точно
не к нормальной форме.</p>

<p>А вот пример терма, который имеет нормальную форму, но правило вычислений,
принятое в Scheme, не позволяет её достичь.
%
\[
  \big((\lambda x . \lambda y . y\ (\omega\ \omega))\ z\big)
      \to*{\beta} (\lambda y . y\ z) \to*{\beta} z
\]
%
Scheme сразу же пойдёт вычислять аргумент $(\omega\ \omega)$ и попадёт
в бесконечный цикл, так и не дойдя до нормальной формы.</p>

<p>Из-за этого правила Scheme также может успешно вычислять термы без нормальной
формы: правило требует избавляться от редексов в аргументах сразу же, но
запрещает избавляться от них в теле функций. Так что можно спокойно передавать
что-то вроде $\lambda x . (\omega\ \omega)$ как аргумент, не получая никаких
бесконечных циклов.</p>


<!--\indexR{порядок вычислений!ленивый}-->
<!--\indexR{ленивые вычисления}-->
<!--\indexR{вызов!по необходимости}-->
<p>Так почему же Scheme использует такое плохое правило? Во-первых, компьютеры
гораздо эффективнее обрабатывают вызовы по значению, чем «хорошие» вызовы по
имени, даже если их улучшить до <em class="term">вызовов по необходимости</em> (также известных
как <em class="term">ленивый</em> порядок вычислений). Во-вторых, если плохое правило приводит
к нормальной форме, то это будет та же форма, которую мы бы получили при
использовании хорошего правила. Поэтому ради эффективности Scheme использует
плохой аппликативный порядок.</p>


<!--\indexR{лямбда-исчисление@λ-исчисление!синтаксис}-->
<!--\indexR{синтаксис!лямбда-исчисления@λ-исчисления}-->
<p>В λ-исчислении принят удобный синтаксический сахар для записи функций
нескольких переменных: считать $\lambda xy . M$ сокращением для $\lambda x .
\lambda y . M$, а $(M\ N_1\ N_2)$ — сокращением для $((M\ N_1)\ N_2)$.
Предыдущий пример становится гораздо понятнее, если его переписать в виде
$(\lambda x y . y\ (\omega\ \omega)\ z)$. Теперь бессмысленность вычисления
значения локальной переменной $x$ должна быть очевидна: ведь это значение никак
не используется в результате.</p>


<!--\indexR{лямбда-исчисление@λ-исчисление!прикладное}-->
<p>Естественно, мы легко могли бы говорить про λ-исчисление ещё пару глав,
но за этим отправляйтесь к соответствующим книгам: \cite{bar84,gor88,dil88}.
Среди всего прочего можно ввести вспомогательные термы, например, целые числа.
В результате такого расширения получается <em>прикладное</em>
λ-исчисление. Мы могли бы также добавить функции от этих термов:
например, $2 + 2 \to 4$; они называются $\delta$-правилами. Однако, подобные
расширения не являются в строгом смысле необходимыми, так как числа, булевы
значения, сложение, вычитание, логическое \textsc{или} — всё это можно
представить и с помощью обычных $\lambda$-термов. Даже списочные структуры
вместе с <code><span class="func">car</span></code>, <code><span class="func">cons</span></code> и <code><span class="func">cdr</span></code> возможно представить подобным образом
<span class="cite">[<a href="z1_bibliography.xhtml#gor88">gor88</a>]</span>. \seeEx[assignment/ex:lambda-cons]</p>


<!--\indexR{эквивалентность!лямбда-термов@$\lambda$-термов}-->
<!--\indexR{машина Тьюринга}-->
<!--\indexR{Тьюринга, машина}-->
<p>В заключение стоит сказать, что λ-исчисление — это хорошо
проработанная теория вычислений, одновременно простая и мощная.
$\beta$-редукция равна по выразительной силе машине Тьюринга, но при этом
не такая запутанная. Также важно, что λ-исчисление обладает при той же
простоте более гибким понятием эквивалентных программ: два терма эквивалентны,
если эквивалентны их нормальные формы. По всем перечисленным причинам именно
λ-исчисление было выбрано множеством денотаций для наших целей.</p>

<h2 id="denotational/sect:semantics">Семантика Scheme</h2>


<!--\indexC{evaluate}-->
<p>По результатам демократических обсуждений, представителем денотаций было избрано
λ-исчисление. Предыдущий интерпретатор написан на Scheme без побочных
эффектов. Его сердце — это функция-вычислитель <code><span class="func">evaluate</span></code>, имеющая вот
такой тип:
%
\[
  \text{<code><span class="func">evaluate</span></code>:} \quad
      \Vset{Программа}   \times \Vset{Окружение} \times
      \Vset{Продолжение} \times \Vset{Память}    \to \Vset{Значение}
\]</p>

<p>Первый аргумент (программу) можно легко каррировать, переходя к следующему типу:
%
\[ \Vset{Программа} \to
  (\Vset{Окружение} \times \Vset{Продолжение}
                    \times \Vset{Память}      \to \Vset{Значение})
\]</p>


<!--\indexR{контекст вычислений}-->
<!--\indexR{вычисления!контекст}-->
<!--\indexR{Денотация@\protect\Vset{Денотация}}-->
<p>Каждая программа превращается в функцию, которая по окружению, продолжению и
памяти (вместе они называются <em class="term">контекстом вычислений</em>) может сказать нам
возвращаемое значение. Это похоже на понятие смысла программы, так что
остановимся на таком определении:
%
\begin{align*}
& \ii{интерпретация}\colon \quad \Vset{Программа} \to \Vset{Денотация} \\
& \Vset{Денотация}\colon \quad \Vset{Окружение} \times \Vset{Продолжение}
                               \times \Vset{Память} \to \Vset{Значение}
\end{align*}</p>


<!--\indexR{соглашения именования!в денотациях}-->
<p>Люди, серьёзно занимающиеся денотационной семантикой, не особо любят скобочки
и имеют своеобразные предпочтения в наименовании сущностей. Прежде всего,
они (повсюду) используют греческие буквы и сокращают всё, что только можно.
В итоге, для непосвящённых их записи выглядят загадочным набором иероглифов.
Причиной таких привычек служит то, что подобная запись позволяет уместить
семантику языка на одной-единственной странице, где она как на ладони. Это
преимущество\footnote{Очень полезное преимущество, если учесть, что средний
размер научной публикации — это около десяти страниц.} недостижимо, если
использовать пространные названия и лишние символы. Греческие же буквы выбраны
для того, чтобы не путать денотации с выражениями определяемого языка. Так как
чаще всего денотационная семантика используется для определения языков
программирования, алфавит которых ограничен ASCII, то греческие буквы являются
хорошим выбором: они компактные и выделяющиеся. Наконец, для уменьшения
количества ошибок денотации являются типизированными, их тип выводится из имён
переменных.</p>


<!--\indexR{а льфа@$\a$ (адреса)}     -->
<!--\indexE{a lpha@$\a$ (адреса)}-->
<!--\indexR{э псилон@$\e$ (значения)} -->
<!--\indexE{e psilon@$\e$ (значения)}-->
<!--\indexR{р о@$\r$ (окружение)}     -->
<!--\indexE{r ho@$\r$ (окружение)}-->
<!--\indexR{с игма@$\s$ (память)}     -->
<!--\indexE{s igma@$\s$ (память)}-->
<!--\indexR{н ю@$\n$ (переменные)}    -->
<!--\indexE{n u@$\n$ (переменные)}-->
<!--\indexR{п и@$\p$ (программы)}     -->
<!--\indexE{p i@$\p$ (программы)}-->
<!--\indexR{к аппа@$\k$ (продолжения)}-->
<!--\indexE{k appa@$\k$ (продолжения)}-->
<!--\indexR{ф и@$\f$ (функции)}       -->
<!--\indexE{p hi@$\f$ (функции)}-->
<p>Мы тоже будем следовать этим соглашениям. По давней традиции функции
обозначаются буквой $\f$. Остальные сущности обычно именуют по первой букве их
английского названия: $\k$ для продолжений, $\a$ для адресов, $\n$ для
идентификаторов (name), $\p$ для программ, $\s$ для памяти (store или state).
Попробуйте самостоятельно догадаться, почему окружения обозначаются буквой $\r$.
%
\begin{center} \begin{tabular}{ll|ll}
  $\p$ & \Vset{Программы}    &  $\r$ & \Vset{Окружения}  \\
  $\n$ & \Vset{Переменные}   &  $\a$ & \Vset{Адреса}     \\
  $\s$ & \Vset{Память}       &  $\e$ & \Vset{Значения}   \\
  $\k$ & \Vset{Продолжения}  &  $\f$ & \Vset{Функции}
\end{tabular} \end{center}</p>


<!--\indexR{домены}-->
<!--\indexR{Программы@\protect\Vset{Программы}}-->
<!--\indexR{Окружения@\protect\Vset{Окружения}}-->
<!--\indexR{Переменные@\protect\Vset{Переменные}}-->
<!--\indexR{Адреса@\protect\Vset{Адреса}}-->
<!--\indexR{Память@\protect\Vset{Память}}-->
<!--\indexR{Значения@\protect\Vset{Значения}}-->
<!--\indexR{Продолжения@\protect\Vset{Продолжения}}-->
<!--\indexR{Функции@\protect\Vset{Функции}}-->
<p>Каждое слово, набранное жирным шрифтом, соответствует <em class="term">домену</em> объектов.
Здесь присутствуют все классы объектов, которые мы рассматривали в предыдущих
главах.
%
\begin{align*}
  \Vset{Окружение} & = \Vset{Переменная} \to \Vset{Адрес}                     \\
     \Vset{Память} & = \Vset{Адрес} \to \Vset{Значение}                       \\
   \Vset{Значения} & = \Vset{Функции} + \Vset{Числа} + \Vset{Пары} + \cdots   \\
\Vset{Продолжение} & = \Vset{Значение}\times \Vset{Память} \to \Vset{Значение}\\
    \Vset{Функция} & = \Vset{Значения}^* \times \Vset{Продолжение}
                                         \times \Vset{Память} \to\Vset{Значение}
\end{align*}</p>


<!--\indexR{приведение типов}-->
<!--\indexR{инъекция, $\protect\Inj{Домен}(x)$}-->
<!--\indexR{проекция, $x\protect\Prj{Домен}$}-->
<!--\indexE{-inj@$\protect\Inj{Домен}(x)$ (инъекция)}-->
<!--\indexE{-proj@$x\protect\Prj{Домен}$ (проекция)}-->
<p>Как обычно, звёздочка означает список. Например, домен $\Vset{Значения}^*$ —
это домен последовательностей \Vset{Значений}. Символ $\times$ означает
декартово произведение. Символ $+$ означает дизъюнктивную сумму; то есть
\Vset{Значение} — это или \Vset{Функция}, или \Vset{Число}, или \Vset{Пара},
и т. д. Это важное свойство дизъюнктивной суммы: каждый элемент
домена \Vset{Значений} принадлежит одному и только одному из доменов,
составляющих дизъюнктивную сумму. Так как мы считаем сущности типизированными,
то необходимо чётко обозначать переходы между доменами. Инъекция
$\Inj{Значение}(\e)$ переносит терм $\e$ в домен \Vset{Значений}, а проекция
$\e\Prj{Числа}$ отображает значение $\e$ на домен \Vset{Чисел} (конечно же,
если $\e$ ему действительно принадлежит).</p>


<!--\indexR{лямбда-исчисление@λ-исчисление!математическая модель}-->
<p>Домены определяются рекурсивно — это важно с математической точки зрения;
именно по этой и некоторым другим причинам они называются доменами, а не просто
множествами. Не особо углубляясь в детали, скажем, что λ-исчисление
было разработано Алонзо Чёрчем в 1930-х годах, но ему не хватало строгой
математической модели — она была построена Даной Скоттом около 1970 года.
λ-исчисление ещё тогда доказало свою полезность, но с математической
моделью оно стало идеальным. Со временем были разработаны и другие модели:
$D_\infty$, $\mathcal{P}\omega$. \cite{sco76,sto77}</p>


<!--\indexR{лямбда-исчисление@λ-исчисление!экстенсиональность}-->
<!--\indexR{эта-редукция@$\eta$-редукция}-->
<!--\indexR{экстенсиональность}-->
<p><em class="term">Экстенcиональность</em> это свойство функций $\forall x\colon \big(f(x) =
g(x)\big) \Rightarrow (f = g)$. Оно связано с $\eta$-редукцией — одним
из вспомогательных правил λ-исчисления:
%
\[
  \text{$\eta$-редукция:}
      \quad \lambda x . (M\ x) \to*{\eta} M
      \quad \text{где $x$ не свободна в $M$}
\]
%
Удивительно, но есть как экстенсиональные модели вроде $D_\infty$, так и нет;
например, $\mathcal{P}\omega$ не экстенсиональна. Интересно, а наш мир
экстенсионален?</p>

<p>Дана Скотт показал, что любая формальная система, рекурсивно определяемая
через домены с помощью $\to$, $\times$, $+$ и ${}^*$, является алгоритмически
разрешимой: то есть истинность любого корректного утверждения в ней можно
доказать или опровергнуть за конечное число шагов.</p>


<!--\indexR{лямбда-исчисление@λ-исчисление!композициональность}-->
<!--\indexR{композициональность!лямбда-исчисления@λ-исчисления}-->
<p>Ещё один важный принцип денотационной семантики — это
<em class="term">композициональность</em>: смысл фрагмента программы зависит только от смысла
составляющих его частей. Он очень важен для индуктивного метода доказательства и
не только: это удобно для реализации, когда программы не зависят от контекста.</p>


<!--\indexE{"["]@$[\![$\quad$]\!]$ (семантические скобки)}-->
<!--\indexE{E-@$\protect\Eval$, интерпретатор}-->
<!--\indexR{интерпретатор!E@$\protect\Eval$}-->
<p>Функцию-интерпретатор обычно обозначают $\Eval$. Чтобы отличать программы от их
семантики, фрагменты программ будут заключаться в семантические скобки:
$[\![$ и $]\!]$. Теперь мы наконец-то перейдём к разбору форм одна за другой.</p>

<h3 id="denotational/semantics/ssect:var-ref">Обращения к переменным</h3>

<p>Простейшая из денотаций — получение значения переменной:</p>

<p>\begin{denotation}
$\Eval\sem{\n} = \lambda\r\k\s.(\k\ (\s\ (\r\ \n))\ \s)$
\end{denotation}</p>

<p>Денотация ссылки на переменную (с именем $\n$) это $\lambda$-терм, который по
окружению $\r$, продолжению $\k$ и памяти $\s$ определяет сначала адрес
расположения переменной с помощью окружения: $(\r\ \n)$, потом передаёт адрес
памяти для получения значения: $(\s\ (\r\ \n))$, затем, наконец, передаёт
значение продолжению вместе с исходной памятью (так как чтение её не меняет).</p>

<p>Здесь мы воспользовались упомянутым ранее сокращением для функций нескольких
аргументов. Конечно, можно было бы писать более строго:</p>

<p>\begin{denotation}
$\Eval\sem{\n} = \lambda\r.\lambda\k.\lambda\s.(\k\ (\s\ (\r\ \n))\ \s)$
\end{denotation}</p>

<p>Нам нет смысла выставлять напоказ свою педантичность, поэтому мы не будем
использовать подобную запутанную запись. В действительности, мы её ещё сильнее
упростим, приняв синтаксис, похожий на <code><span class="func">define</span></code>:</p>

<p>\begin{denotation}
$\Eval\sem{\n}\r\k\s = (\k\ (\s\ (\r\ \n))\ \s)$
\end{denotation}</p>


<!--\indexR{р о0@$\r_0$ (начальное окружение)}-->
<!--\indexE{r ho0@$\r_0$ (начальное окружение)}-->
<p>Конечно, обязательно надо учитывать возможность ошибки: переменной может
не оказаться в окружении. С этим будет разбираться начальное окружение $\r_0$:</p>

<p>\begin{denotation}
$(\r_0\ \n) = \ii{wrong}\ \dc{"No such variable"}$
\end{denotation}</p>


<!--\indexE{.bot@$\bot$}-->
<!--\indexR{строгие функции}-->
<!--\indexR{функции!строгие}-->
<!--\indexE{wrong@\protect\ii{wrong}}-->
<p>Если переменная не будет обнаружена в окружении, то вызывается \ii{wrong},
которая в свою очередь вернёт особое значение, обычно обозначаемое $\bot$. Это
значение является в некотором смысле абсорбентом, то есть $\forall f\colon
f(\bot) = \bot$. Следовательно, если возникает ошибка, то всё вычисление
возвращает $\bot$, что явно сигнализирует о проблеме. На самом деле, это
не $\bot$ само по себе имеет такое свойство, а функции так с ним обращаются
(в этом случае они называются <em class="term">строгими</em>). Функция $f$ строга тогда и
только тогда, когда $f(\bot) = \bot$. Если условиться использовать только
строгие функции, то это избавит нас в определённой мере от обработки ошибок и
позволит сконцентрироваться на более важных вещах.</p>

<h3 id="denotational/semantics/ssect:sequence">Последовательность</h3>


<!--\indexR{интерпретатор!Eplus@$\protect\Eval^+$}-->
<!--\indexE{E-plus@$\protect\Eval^+$, интерпретатор}-->
<p>Денотация последовательных вычислений как обычно вызывает вспомогательную
функцию, которой в предыдущих интерпретаторах соответствует функция <code><span class="func">eprogn</span></code>.
Мы будем обозначать её $\Eval^+$. С плюсом, потому что в форме <code><span class="func">begin</span></code> должен
присутствовать хотя бы один элемент. Аналогично будем обозначать
последовательность непустых форм: $\p^+$. Интерпретатор $\Eval^+$ превращает
$\p^+$ в денотацию, которая вычисляет все элементы слева направо и возвращает
значение последнего из них. Его работа сводится к двум случаям: когда $\p^+$
состоит из одной и более чем одной формы. В Scheme смысл <code><span class="func">(begin)</span></code>
не определён, поэтому и здесь такого случая нет в определении.</p>

<p>\begin{denotation}
$\Eval\sem*{(begin $\p^+$)}\r\k\s = (\Eval^+\sem{\p^+}\ \r\ \k\ \s)$          \|
$\Eval^+\sem{\p}\r\k\s = (\Eval\sem{\p}\ \r\ \k\ \s)$                         \|
$\Eval^+\sem{\p\ \p^+}\r\k\s = \big(\Eval\sem{\p}\ \r\ \lambda\e\s_1.
    (\Eval^+\sem{\p^+}\ \r\ \k\ \s_1)\ \s\big)$
\end{denotation}</p>


<!--\indexR{эта-упрощение@$\eta$-упрощение}-->
<p>Если последовательность состоит из одного элемента, то она эквивалентна данному
элементу. Можно было бы записать это буквально:</p>

<p>\begin{denotation}
$\Eval^+\sem{\p} = \Eval\sem{\p}$
\end{denotation}</p>

<p>В λ-исчислении это называется $\eta$-упрощением. Мы будем избегать
подобных фокусов, так как они затрудняют понимание программ, а также скрывают
естественную арность функций; как говорят <span class="cite">[<a href="z1_bibliography.xhtml#wl93">wl93</a>]</span>, часто так пишут только
чтобы выглядеть умнее.</p>

<p>Если последовательность состоит из более чем одного элемента, то вычисляется
значение первого из них и управление передаётся продолжению, которое должно
вычислить все остальные. Тут — в одной строке! — ещё раз можно увидеть,
что продолжение игнорирует вычисленное ранее значение, но не состояние памяти
после его вычисления. В конечном итоге именно продолжения позволяют упорядочить
вычисления.</p>

<h3 id="denotational/semantics/ssect:conditional">Ветвление</h3>


<!--\indexE{T@\protect\comb{T}, комбинатор}-->
<!--\indexE{F@\protect\comb{F}, комбинатор}-->
<!--\indexR{комбинаторы}-->
<!--\indexR{комбинаторы!T@\protect\comb{T}}-->
<!--\indexR{комбинаторы!F@\protect\comb{F}}-->
<!--\indexR{логические значения!в лямбда-исчислении@в λ-исчислении}-->
<!--\indexR{представление!логических значений!в лямбда-исчислении@в λ-исчислении}-->
<p>Денотация условного оператора довольно стандартна и не представляет трудностей,
если знать, как представить булевы значения с помощью абстракций
λ-исчисления. На самом деле это не так сложно: мы определим их как
комбинаторы (то есть функции без свободных переменных).
%
\[ \comb{T} = \lambda xy. x
      \quad \text{и} \quad
   \comb{F} = \lambda xy. y \]</p>


<!--\indexE{If@$\mathbf{If}$ (логическая операция)}-->
<p>Эти функции принимают два аргумента и выбирают один из них в качестве
результата. Это напоминает логическую операцию $\mathbf{If}$, определяемую
уравнениями
%
\[ \mathbf{If}(\fn{истина}, p, q) = p
              \quad \text{и} \quad
   \mathbf{If}(\fn{ложь}, p, q) = q \]</p>

<p>Внимание: это не имеет ничего общего с <code><span class="func">if</span></code> в Scheme. В этом определении
ничего не говорится о порядке вычислений, только о том, что $\mathbf{If}$ это
булева функция; её можно определить с помощью той же таблицы истинности, но
более коротко она описывается вот так:
%
\[ \mathbf{If}(c, p, q) = (\neg c \lor p) \land (c \lor q) \]</p>


<!--\indexR{комбинаторы!IF@\protect\comb{IF}}-->
<!--\indexE{IF@\protect\comb{IF}, комбинатор}-->
<p>Благодаря выбранному представлению булевых значений, мы можем легко перенести
$\mathbf{If}$ в λ-исчисление, написав следующий комбинатор:
%
\[ \comb{IF}\ c\ p\ q = (c\ p\ q) \]</p>

<p>Как и в логике, здесь ничего не сказано о порядке вычислений, только
об отношениях между тремя значениями. Если понимать $\mathbf{If}$ как функцию,
то она возвращает второй аргумент, если первый является истиной, и третий
в противном случае. Вслед за <span class="cite">[<a href="z1_bibliography.xhtml#fw84">fw84</a>]</span>, мы будем называть такую
функцию <code><span class="func">ef</span></code>. На Scheme она бы записывалась так:
%
<!--\indexC{ef}-->
<!--\indexE{if@\protect<code><span class="func">if</span></code>|seealso{\protect<code><span class="func">ef</span></code>}}-->
\begin{code:lisp}
(define (ef v v1 v2)
  (v v1 v2) )</pre>

<p>Чтобы сделать запись более понятной, подобный выбор будем записывать
как в <span class="cite">[<a href="z1_bibliography.xhtml#sch86">sch86</a>]</span>:</p>

<p>\begin{denotation}
$\e_0 \is \e_1 \switch \e_2$
\end{denotation}</p>

<p>\noindent
В {\RnRS} применяется немного другая нотация:</p>

<p>\begin{denotation}
$\e_1 \is \e_2, \e_3$
\end{denotation}</p>

<p>Держа всё это в уме, определим денотацию условного оператора:</p>

<p>\begin{denotation}
$\Eval\sem*{(if $\p$ $\p_1$ $\p_2$)}\r\k\s =$                                 \|
$(\Eval\sem{\p}\ \r\ \lambda\e\s_1. (\fn{boolify}\ \e) \to
  (\Eval\sem{\p_1}\ \r\ \k\ \s_1) \switch (\Eval\sem{\p_2}\ \r\ \k\ \s_1)\ \s)$
\end{denotation}</p>


<!--\indexE{boolify@\protect\ii{boolify}}-->
<!--\indexR{порядок вычислений!в лямбда-исчислении@в λ-исчислении}-->
<p>Функция \fn{boolify} приводит значение к булевому типу, так как в Scheme любое
значение, кроме <code><span class="func">\#f</span></code>, считается истиной. Условный оператор начинает работу
с вычисления условия с продолжением, которое выбирает нужную ветку
в соответствии со значением условия. Внимание: условный оператор
в λ-исчислении только выглядит похожим на \ii{if}--\ii{then}--\ii{else}
из Scheme, они отличаются очень важной деталью: порядком вычислений.
В λ-исчислении он абсолютно произвольный, ничто не мешает параллельно
вычислять все три выражения и выбирать одну из двух веток только в конце всех
вычислений.</p>


<!--\indexE{Scheme!и лямбда-исчисление@и λ-исчисление}-->
<p>Это очень важное замечание, так как мы не можем считать λ-исчисление
(и, следовательно, определяемый нами язык) полностью эквивалентным Scheme.
В λ-исчислении вообще нет понятия порядка вычислений, просто условная
форма может принять одно из двух значений; какое именно — зависит от первого
аргумента.</p>


<!--\indexR{порядок вычислений}-->
<p>Тем не менее, отсутствие порядка не мешает правильности вычислений, так как
переменные обеих веток изолированы, а функции λ-исчисления не имеют
побочных эффектов. Например, следующее выражение вполне успешно вычисляется,
хотя кажется, что если вычислять его параллельно или в «неправильном» порядке,
то нас ожидает провал:</p>

<pre>(if (= 0 q) 1 (/ p q))</pre>

<p>Это выражение сначала проверяет, равна ли <code><span class="func">q</span></code> нулю, и, если это так, то
возвращает единицу, иначе — выполняет деление <code><span class="func">p</span></code> на <code><span class="func">q</span></code> и возвращает
его результат. Денотация данного вычисления выражает выбор между $1$ и $p/q$
в зависимости от того, равна ли $q$ нулю.</p>

<p>Из-за «плохого» порядка вычислений, принятого в Scheme, денотацию этой формы
иногда сложно понимать, так как от неё ожидается вычисление условия перед телом,
а не вычисление всего сразу вместе с возможными вариантами подобно квантовым
компьютерам. Поэтому мы перепишем денотацию следующим образом:</p>

<p>\begin{denotation}
$\Eval\sem*{(if $\p$ $\p_1$ $\p_2$)}\r\k\s =
  (\Eval\sem{\p}\ \r\ \lambda\e\s_1. ((\fn{boolify}\ \e) \to
    \Eval\sem{\p_1} \switch \Eval\sem{\p_2}\ \r\ \k\ \s_1)\ \s)$
\end{denotation}</p>

<p>Здесь вводится некоторый порядок вычислений. Теперь значение условия служит
только для выбора нужной ветки — собственно вычисление значения выполняется
отдельно и один раз.</p>

<p>Попробуем проверить, эквивалентны ли данные определения. Для этого достаточно
будет доказать эквивалентность их денотаций, иными словами, показать, что
%
\[
  (\fn{boolify}\ \e) \to (\Eval\sem{\p_1}\ \r\ \k\ \s)
      \switch (\Eval\sem{\p_2}\ \r\ \k\ \s)
  \equiv
  ((\fn{boolify}\ \e) \to \Eval\sem{\p_1} \switch
      \Eval\sem{\p_2}\ \r\ \k\ \s\big)
\]</p>

<p>Это тождество очевидно ложно в Scheme из-за аппликативного порядка вычислений.
Для доказательства достаточно положить $\p_2$ равной бесконечному циклу. Но
денотации — это выражения λ-исчисления, и сравнивать их следует по
законам λ-исчисления. В этом случае мы видим простейший дистрибутивный
закон.</p>

<p>\ForLayout{display}{\begingroup\setlength{\denotepadding}{\smallskipamount}}</p>


<!--\indexE{if-then-else-endif@$\protect\IF\ldots\protect\THEN\ldots%-->
<p>\protect\ELSE\ldots\protect\ENDIF$}
Надеюсь, иероглифов было достаточно. Далее будет использоваться более
читабельная запись условных выражений:</p>

<p>\begin{denotation}
$\Eval\sem*{(if $\p$ $\p_1$ $\p_2$)}\r\k\s =
  (\Eval\sem{\p}\ \r\ \lambda\e\s_1. ($\.$\IF    (\fn{boolify}\ \e)$  \\
                                         $\THEN  \Eval\sem{\p_1}   $  \\
                                         $\ELSE  \Eval\sem{\p_2}   $  \\
                                         $\ENDIF \r\ \k\ \s_1)\ \s)$
\end{denotation}</p>

<h3 id="denotational/semantics/ssect:assign">Присваивание</h3>

<p>Денотация присваивания проста. Версия, приведённая здесь, возвращает только что
присвоенное значение.</p>

<p>\begin{denotation}
$\Eval\sem*{(set! $\n$ $\p$)}\r\k\s =
    (\Eval\sem{\p}\ \r\ \lambda\e\s_1. (\k\ \e\ \s_1[(\r\ \n) \to \e])\ \s)$  \|
$f[y \to z] = \lambda x .${}$\IF y = x \THEN z \ELSE (f\ x) \ENDIF$
\end{denotation}</p>


<!--\indexE{->@$\s[\a \protect\to \e]$ (расширение окружения)}-->
<p>Память расширяется, чтобы учесть новое значение $\e$ по адресу переменной $\n$.
Мы обозначаем это расширение $\s[\a \to \e]$. Подобная нотация используется и
в других работах: $[\a \to \e]\s$ в <span class="cite">[<a href="z1_bibliography.xhtml#sch86">sch86</a>]</span>, $[\e/\a]\s$ в <span class="cite">[<a href="z1_bibliography.xhtml#sto77">sto77</a>]</span>
или $\s[\e/\a]$ в \cite{gor88,kcr98}.</p>


<!--\indexE{-e<>@$\protect\seq{\e^*_1, \ldots, \e^*_n}$ (последовательность)}-->
<!--\indexE{-eS@$\e^*_1 \protect\append \e^*_2$ (конкатенация)}-->
<!--\indexE{-ea@$\e^*\protect\car n$ (денотационный <code><span class="func">car</span></code>)}-->
<!--\indexE{-ed@$\e^*\protect\cdr n$ (денотационный <code><span class="func">cdr</span></code>)}-->
<!--\indexE{-el@$\#\e^*$ (длина последовательности)}-->
<p>Давайте расширим λ-исчисление несколькими вспомогательными функциями.
Последовательности будем записывать в угловых скобках: $\langle$ и $\rangle$.
Конкатенацию последовательностей будем обозначать знаком $\append$. Извлечение
$i$-го элемента последовательности будем обозначать $\seq{\e_1, \e_2, \dots,
\e_n}\car i$ (получая $\e_i$). Отбрасывание первых $i$ элементов
последовательности — $\seq{\e_1, \e_2, \dots, \e_n}\cdr i$ (получая
$\seq{\e_{i+1}, \dots, \e_n}$). Длина последовательности $\e^*$
записывается $\#\e^*$. Все эти определения можно было бы привести
непосредственно в виде $\lambda$-термов, но это стало бы чересчур серьёзным
отступлением от темы, поэтому, ничуть не умаляя достоверности повествования, мы
сходу будем использовать $\car 1$, $\cdr 1$, $\#$ и $\append$ как денотационные
эквиваленты <code><span class="func">car</span></code>, <code><span class="func">cdr</span></code>, <code><span class="func">length</span></code> и <code><span class="func">append</span></code>.</p>


<!--\indexE{->*@$\s[\a^* \protect\to*{*} \e^*]$ (расширение окружения списком)}-->
<p>Теперь можно коротко записать расширение памяти списком переменных.
Предполагается, что $y^*$ и $z^*$ имеют равную длину.</p>

<p>\begin{denotation}
$f[y^* \to*{*} z^*] = \;
  \IF \#y^* > 0
  \THEN f[y^*\cdr1 \to*{*} z^*\cdr1][y^*\car1 \to z^*\car1]
  \ELSE f
  \ENDIF $
\end{denotation}</p>

<p>\subsection{Абстракция}\label{denotational/semantics/ssect:abstraction}</p>

<p>Для начала рассмотрим лишь случай функций фиксированной арности.</p>

<p>\begin{denotation}
$\Eval\sem*{(lambda ($\n^*$) $\p^+$)}\r\k\s =$                \|
$\quad(\k\ \Inj{Значение}(\lambda
    \e^*\k_1\s_1.$\.$\IF   \#\e^* = \#\n^*$                   \\
                    $\THEN {}$\*$\ii{allocate}\ \s_1\ \#\n^*$ \\
                                  $\lambda \s_2\a^*.
                                  (\Eval^+\sem{\p^+}\ \r[\n^* \to*{*}
                                  \a^*]\ \k_1\ \s_2[\a^* \to*{*} \e^*])$ \/
                    $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$\\
                    $\ENDIF)\ \s)$
\end{denotation}</p>

<p>Инъекция $\Inj{Значение}(\ldots)$ принимает $\lambda$-терм, представляющий
функцию, и превращает его в значение. При применении функции производится
обратное преобразование.</p>


<!--\indexE{allocate@\protect\ii{allocate}}-->
<p>Вызванная функция проверят фактическую арность, затем выделяет место в памяти
под свои аргументы и связывает переменные со значениями, после чего
последовательно вычисляет формы, составляющие её тело. Выделением памяти
занимается функция \ii{allocate}; она принимает память, необходимое количество
адресов и продолжение, которому она передаст список выделенных адресов и новое
состояние памяти. \ii{allocate} — это чистая функция: эквивалентные аргументы
дают эквивалентные результаты её применения. Её определение довольно рутинно,
так что здесь мы его опустим, чтобы не перегружать выкладки. (Интересующиеся
могут переписать определение \ii{allocate} из предыдущей главы.
\seePage[assignment/implementation/ssect:memory])</p>

<p>Функция \ii{allocate} имеет следующий полиморфный тип ($\alpha$ соответствует
любому типу данных):
%
\[
  \Vset{Память} \times \Vset{НатуральноеЧисло} \times
    (\Vset{Память} \times \Vset{Адреса}^* \to \alpha) \to \alpha
\]</p>

<h3 id="denotational/semantics/ssect:application">Аппликация</h3>


<!--\indexR{интерпретатор!Eseq@$\protect\Eval^*$}-->
<!--\indexE{E-seq@$\protect\Eval^*$, интерпретатор}-->
<p>Функции создаются для того, чтобы их применяли, поэтому на очереди аппликация.
Как обычно, нам потребуется вспомогательный интерпретатор: $\Eval^*$,
аналог <code><span class="func">evlis</span></code>.</p>

<p>\begin{denotation}
$\Eval\sem*{($\p$ $\p^*$)}\r\k\s =
    (\Eval\sem{\p}\ \r\ \lambda \f\s_1.
        (\Eval^*\sem{\p^*}\ \r\ \lambda \e^*\s_2.
            (\f\Prj{Функции}\ \e^*\ \k\ \s_2)\ \s_1)\ \s)$  \|
$\Eval^*\sem{\,}\r\k\s = (\k\ \seq{}\ \s)$                  \|
$\Eval^*\sem{\p\ \p^*}\r\k\s =
    (\Eval\sem{\p}\ \r\ \lambda \e\s_1.
        (\Eval^*\sem{\p^*}\ \r\ \lambda \e^*\s_2.
            (\k\ \seq{\e} \append \e^*\ \s_2)\ \s_1)\ \s)$
\end{denotation}</p>

<p>Продолжения, которые принимает $\Eval^*$\!, работают со списками значений, а
не с отдельными значениями. Это отличает $\Eval^*$ от $\Eval^+$. Данные
продолжения $\k$ имеют тип
%
\[ \Vset{Значения}^* \times \Vset{Память} \to \Vset{Значение} \]</p>

<p>
\subsection{\texorpdfstring{\protect<code><span class="func">call/cc</span></code>}{call/cc}}%
\label{denotational/semantics/ssect:call/cc}</p>

<p>Разумеется, наше знакомство с денотационной семантикой было бы неполным без
определения существенной для Scheme функции — <code><span class="func">call/cc</span></code>. Глобальная
функция <code><span class="func">call/cc</span></code> определяется следующим образом:</p>


<!--\indexC{call/cc}-->
<p>\begin{denotation}
$(\s_0\ (\r_0\ \sem*{call/cc})) = $                  \|
$\quad\Inj{Значение}(\lambda\e^*\k\s.$\.
                $\IF   \#\e^* = 1$                   \\
                $\THEN ($\.$\e^*\car1\Prj{Функции}$  \\
                        $\langle\Inj{Значение}(\lambda\e^*_1\k_1\s_1.$\.
                                               $\IF   \#\e^*_1 = 1
                                                \THEN (\k\ \e^*_1\car1\ \s_1)$\\
                                    $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$\\
                                    $\ENDIF)\rangle\ \k\ \s)$\-\-\\
                $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$  \\
                $\ENDIF)$
\end{denotation}</p>

<p>Обратите внимание на переходы между доменами \Vset{Значений} и \Vset{Функций}.
Сама денотация не сложнее любого другого из способов определения <code><span class="func">call/cc</span></code>,
которые были рассмотрены ранее в третьей главе.
\seePage[escape/implementation/ssect:call/cc]</p>

<p>\ForLayout{display}{\endgroup}% \setlength{\denotepadding}{\smallskipamount}</p>

<p>
\subsection{Предварительные выводы}%
\label{denotational/sematics/ssect:conclusions}</p>

<p>Нам удалось шаг за шагом определить функцию, которая ставит в соответствие
каждой программе $\lambda$-терм. Не подлежит сомнению тот факт, что она
существует, ведь мы руководствовались принципом композициональности при её
определении. Возможны только некоторые проблемы с синтаксически рекурсивными
программами <span class="cite">[<a href="z1_bibliography.xhtml#que92a">que92a</a>]</span>, так что для точного доказательства корректности
потребуется немного больше математики.</p>

<p>Теперь вы можете своими глазами убедиться в том, что семантика ядра Scheme
умещается на одном листе бумаги:
см. таблицу \ref{denotational/sematics/fig:naked-scheme}.</p>

<p>\begin{table}[!p]
<!--\indexE{Scheme!семантика}-->
\begin{semantic}\begin{denotation}
$\Eval\sem{\n}\r\k\s = (\k\ (\s\ (\r\ \n))\ \s)$                       \
$\Eval\sem*{(if $\p$ $\p_1$ $\p_2$)}\r\k\s =
    (\Eval\sem{\p}\ \r\ \lambda\e\s_1. ($\.$\IF    (\fn{boolify}\ \e)$ \\
                                           $\THEN  \Eval\sem{\p_1}   $ \\
                                           $\ELSE  \Eval\sem{\p_2}   $ \\
                                           $\ENDIF \r\ \k\ \s_1)\ \s)$ \-\|
$\Eval\sem*{(set! $\n$ $\p$)}\r\k\s =
    (\Eval\sem{\p}\ \r\ \lambda\e\s_1.
        (\k\ \e\ \s_1[(\r\ \n) \to \e])\ \s)$                          \
$\Eval\sem*{(lambda ($\n^*$) $\p^+$)}\r\k\s =$                         \|
$\quad(\k\ \Inj{Значение}(\lambda\e^*\k_1\s_1.$\.
    $\IF   \#\e^* = \#\n^*$                            \\
    $\THEN {}$\*$\ii{allocate}\ \s_1\ \#\n^*$          \\
             $\lambda \s_2\a^*.
                (\Eval^+\sem{\p^+}\ \r[\n^* \to*{*}
                \a^*]\ \k_1\ \s_2[\a^* \to*{*} \e^*])$ \/
    $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$         \\
    $\ENDIF)\ \s)$                                     \-\|
$\Eval\sem*{($\p$ $\p^*$)}\r\k\s =$                         \|
$\quad(\Eval\sem{\p}\ \r\ \lambda \f\s_1.
    (\Eval^*\sem{\p^*}\ \r\ \lambda \e^*\s_2.
        (\f\Prj{Функции}\ \e^*\ \k\ \s_2)\ \s_1)\ \s)$      \
$\Eval^*\sem{\p\ \p^*}\r\k\s =$                             \|
$\quad(\Eval\sem{\p}\ \r\ \lambda \e\s_1.
    (\Eval^*\sem{\p^*}\ \r\ \lambda \e^*\s_2.
        (\k\ \seq{\e} \append \e^*\ \s_2)\ \s_1)\ \s)$      \
$\Eval^*\sem{\,}\r\k\s = (\k\ \seq{}\ \s)$                             \
$\Eval\sem*{(begin $\p^+$)}\r\k\s = (\Eval^+\sem{\p^+}\ \r\ \k\ \s)$   \
$\Eval^+\sem{\p\ \p^+}\r\k\s = \big(\Eval\sem{\p}\ \r\ \lambda\e\s_1.
    (\Eval^+\sem{\p^+}\ \r\ \k\ \s_1)\ \s\big)$                        \
$\Eval^+\sem{\p}\r\k\s = (\Eval\sem{\p}\ \r\ \k\ \s)$                  \
$(\s_0\ (\r_0\ \sem*{call/cc})) = $                                    \|
$\quad\Inj{Значение}($\*$\lambda \e^*\k\s. $                           \\
                $\IF   \#\e^* = 1$                                     \\
                $\THEN ($\.$\e^*\car1\Prj{Функции}$                    \\
                        $\langle\Inj{Значение}($\*$\lambda\e^*_1\k_1\s_1.$    \\
                                               $\IF   \#\e^*_1 = 1$           \\
                                               $\THEN (\k\ \e^*_1\car1\ \s_1)$\\
                                    $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$\\
                                    $\ENDIF)\rangle\ \k\ \s)$\-\-     \\
                $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$            \\
                $\ENDIF)$
\end{denotation}\end{semantic}%
\caption{Сущность Scheme.}\label{denotational/sematics/fig:naked-scheme}%
\end{table}</p>

<p>Конечно, специальная форма <code><span class="func">quote</span></code> остаётся нереализованной (как вы помните,
с цитированием не всё так просто \seePage[assignment/sect:quotation]), функции
с переменной арностью отложены на потом. Естественно, здесь не хватает <code><span class="func">eq?</span></code>
для сравнения функций, а также множества других примитивов. Правда, у нас есть
<code><span class="func">call/cc</span></code> в костюме Евы. На самом деле важно то, что другие функции вроде
<code><span class="func">car</span></code>, <code><span class="func">cons</span></code>, <code><span class="func">set-cdr!</span></code> могут быть реализованы с помощью данного
базиса без каких-либо добавок в ядро. Специальных форм и некоторых примитивных
функций вроде <code><span class="func">call/cc</span></code> достаточно для понимания принципа.</p>

<p>Как бы то ни было, я настаиваю на том, что выражение сути Scheme с подобной
точностью и лаконичностью стоит затраченных усилий. Таким образом, наше
путешествие, начавшееся в первой главе с определения подмножества Scheme
с помощью всего Scheme, подходит к концу. Сейчас мы определили весь Scheme
с помощью одного лишь λ-исчисления.</p>

<p>
\section{\texorpdfstring{Семантика λ-исчисления}%
{Семантика λ-исчисления}}\label{denotational/sect:lambda}</p>

<p>Определение сущности языка с помощью нескольких формул является одной из
притягательных черт Scheme. Именно поэтому функциональные языки являются
лингвистическими лабораториями для испытания новых конструкций и изучения их
фундаментальных, обобщённых свойств. Попробуем и мы провести подобное
исследование. Для этого мы примемся за довольно простой по своей сути язык —
само λ-исчисление. Здесь нет никакой тавтологии или шутки, будет
полезным рассмотреть семантику языка, который отличается от Scheme, но всё же
является родственным.</p>

<p>Начнём с синтаксиса. Он, как уже было сказано, не важен, так что будем
использовать Scheme-подобный синтаксис:
%
\[
  x                              \qquad\qquad
  \text{<code><span class="func">(lambda ($x$) $M$)</span></code>} \qquad\qquad
  \text{<code><span class="func">($M$ $N$)</span></code>}
\]</p>

<p>Теперь определим домены. В λ-исчислении нет присваиваний и продолжений,
что серьёзно облегчает нам работу. Более того, мы ограничимся чистым
λ-исчислением — то есть никаких чисел и всего такого, только голые
абстракции. Итак, домены:
%
\[ \def\Venv#1{\hbox to 0pt{\Vset{#1}}\phantom{\Vset{Окружения}}}
\begin{array}{ll}
  \p & \Vset{Программы}                                                       \\
  \n & \Vset{Переменные}                                                      \\
  \r & \Vset{Окружения} = \Vset{Переменная} \to \Vset{Значение}               \\
  \e & \Venv{Значения}  = \Vset{Функции}                                      \\
  \f & \Venv{Функции}   = \Vset{Значение} \to \Vset{Значение}
\end{array} \]</p>


<!--\indexR{интерпретатор!L@$\protect\Lain$}-->
<!--\indexE{L@$\protect\Lain$, интерпретатор}-->
<p>Функцию-интерпретатор мы назовём $\Lain$. Она будет сопоставлять каждому
$\lambda$-терму его денотацию — другой $\lambda$-терм. Таким образом,
интерпретатор имеет простой тип
%
\[
  \Lain\colon \quad \Vset{Программа} \to (\Vset{Окружение} \to \Vset{Значение})
\]</p>

<p>Осталось только определить одну за другой денотации синтаксических форм. Всё их
огромное разнообразие собрано в таблице \ref{denotational/lambda/fig:self}.</p>

<p>\begin{table}[!h]
<!--\indexR{лямбда-исчисление@λ-исчисление!семантика}-->
\begin{semantic}\begin{denotation}
$\Lain\sem{\n}\r = (\r\ \n)$                    \
$\Lain\sem*{(lambda ($\n$) $\p$)}\r =
    \lambda \e. (\Lain\sem{\p}\ \r[\n \to \e])$ \
$\Lain\sem*{($\p$ $\p'$)}\r =
    \big((\Lain\sem{\p}\ \r)\ (\Lain\sem{\p'}\ \r)\big)$
\end{denotation}\end{semantic}%
\caption{Семантика λ-исчисления.}\label{denotational/lambda/fig:self}%
\end{table}</p>

<p>Данная семантика очень точна, вплоть до неопределённости порядка вычислений.
Аппликация переводится в аппликацию, так что никакого порядка
не устанавливается.</p>

<p>Интерпретатор $\Lain$ определяется рекурсивно. Мы можем так делать благодаря
композициональности: рано или поздно все вычисления сведутся к ссылкам
на переменные.</p>

<p>λ-исчисление представляет особенный случай, так как мы и безо всяких
денотаций имеем довольно чёткое представление о его семантике. Можно доказать
<span class="cite">[<a href="z1_bibliography.xhtml#sto77">sto77</a>]</span>, что подобное самоопределение сохраняет все необходимые свойства
λ-исчисления вроде $\beta$-редукции.</p>

<p>Денотирование λ-исчислением хорошо работает для языков без побочных
эффектов и продолжений. Но если данные явления в языке всё же присутствуют, то
эффективнее будет использовать другой метод, в котором можно явно задавать
порядок вычислений. Также для работы присваивания необходимо разделить окружение
и память, введя механизм ссылок, как в ML, коробки из четвёртой главы, или нечто
подобное. \seePage[assignment/assignment/ssect:boxes]</p>

<h2 id="denotational/sect:varargs">Функции с переменной арностью</h2>


<!--\indexR{переменная арность}-->
<!--\indexR{арность!переменная}-->
<p>В этом разделе мы покажем, как привнести в Scheme функции с точечным аргументом.
Особенность этих функций в том, что они собирают «лишние» аргументы в список,
который передаётся через последний аргумент. Следовательно, при каждом вызове
подобной функции необходимо создавать в памяти список, что влияет на
производительность. От некоторых проблем нас может избавить функция <code><span class="func">apply</span></code>,
которая сразу принимает список аргументов и применяет к нему функцию, но ведь
эти списки тоже кто-то должен создать. В общем, переменная арность неразлучно
связана со списками, так что нам потребуются соответствующие функции: <code><span class="func">car</span></code>,
<code><span class="func">cons</span></code> и т. д.</p>


<!--\indexR{Пары@\protect\Vset{Пары}}-->
<p>Точечные пары принадлежат домену \Vset{Пар}. Естественно, этот домен также
входит в дизъюнктивную сумму \Vset{Значений}. Точечные пары представляются
так же, как и в предыдущей главе: двумя адресами.
%
\begin{align*}
  \Vset{Значения} & = \Vset{Функции} + \Vset{Числа} + \Vset{Пары} + \cdots    \\
      \Vset{Пара} & = \Vset{Адрес} \times \Vset{Адрес}
\end{align*}</p>

<p>Денотации <code><span class="func">cons</span></code>, <code><span class="func">car</span></code> и <code><span class="func">set-cdr!</span></code> (надо же показать хотя бы один
побочный эффект) не таят сюрпризов; мы используем в точности тот же подход, что
и в предыдущей главе. Единственное, о чём стоит договориться, это
ассоциативность операций. Выражение $\e^*\car1\Prj{Пары}\car2$ читается слева
направо: первый аргумент $\e^*\car1$, пока ещё значение, проецируется на домен
пар $\Prj{Пары}$ (если это значение на самом деле не было парой, то мы
получаем $\bot$), после чего извлекается <code><span class="func">cdr</span></code> этой пары, её второй
компонент $\car2$.</p>


<!--\indexC{cons}-->
<!--\indexC{car}-->
<!--\indexC{set-cdr"!}-->
<p>\begin{denotation}
$(\s_0\ (\r_0\ \sem*{cons})) = $                            \|
$\quad\Inj{Значение}(\lambda \e^*\k\s.$\.
  $\IF \#\e^* = 2$                                          \\
  $\THEN {}$\*$\ii{allocate}\ \s\ 2$                        \\
                $\lambda \s_1\a^*.
                    (\k\ \Inj{Значение}(\seq{\a^*\car1,
                    a^*\car2})\ \s_1[\a^* \to*{*} \e^*])$   \/
  $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$              \-\|
$(\s_0\ (\r_0\ \sem*{car})) = $                     \|
$\quad\Inj{Значение}(\lambda \e^*\k\s.$\.
  $\IF \#\e^* = 1$                                  \\
  $\THEN (\k\ (\s\ \e^*\car1\Prj{Пары}\car1)\ \s)$  \\
  $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$        \\
  $\ENDIF)$                                       \-\|
$(\s_0\ (\r_0\ \sem*{set-cdr!})) = $                \|
$\quad\Inj{Значение}(\lambda \e^*\k\s.$\.
  $\IF \#\e^* = 2$                                  \\
  $\THEN (\k\ \e^*\car1\ \s[\e^*\car1\Prj{Пары}\car2 \to \e^*\car2])$ \\
  $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$        \\
  $\ENDIF)$
\end{denotation}</p>

<p>После определения структуры списков написание <code><span class="func">apply</span></code> не составляет проблем.
Мы собираем в последовательность все элементы формы аппликации, кроме первого
(функции) и последнего. Если предпоследний элемент является списком, то его
необходимо пришить к концу формируемой последовательности. После всех этих
манипуляций выполняется собственно вызов функции.</p>

<p>\ForLayout{display}{\begingroup\setlength{\denotepadding}{\smallskipamount}}</p>


<!--\indexC{apply}-->
<!--\indexE{collect@\protect\ii{collect}}-->
<!--\indexE{flat@\protect\ii{flat}}-->
<!--\indexE{where-and@$\protect\WHERE \ldots \protect\AND \ldots$}-->
<p>\begin{denotation}
$(\s_0\ (\r_0\ \sem*{apply})) = $ \|
$\quad\Inj{Значение}(\lambda \e^*\k\s.$\.
  $\IF   \#\e^* \geq 2$           \\
  $\THEN {}$\.$(\e^*\car1\Prj{Функции}\ (\fn{collect}\ \e^*\ \cdr1)\ \k\ \s)$ \\
           $\WHERE \ii{collect} = \lambda \e^*_1.$\.
              $\IF   \e^*_1\cdr1 = \seq{}$                                \\
              $\THEN (\ii{flat}\ \e^*_1\car1)$                            \\
              $\ELSE \seq{\e^*_1\car1}\append(\fn{collect}\ \e^*_1\cdr1)$ \\
              $\ENDIF$                                                    \/
           $\AND \ii{flat} = \lambda\e.$\.
              $\IF   \e \in \Vset{Пары}$                       \\
              $\THEN \seq{(\s\ \e\Prj{Пары}\car1)}\append
                        (\ii{flat}\ (\s\ \e\Prj{Пары}\car2))$  \\
              $\ELSE \seq{}$                                   \\
              $\ENDIF$                                     \-\-\\
  $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$  \\
  $\ENDIF)$
\end{denotation}</p>

<p>Здесь $\WHERE \ldots \AND \ldots$ определяет взаимно рекурсивные функции.</p>


<!--\indexR{интерпретатор!B@$\protect\Bind$}-->
<!--\indexE{B@$\protect\Bind$, интерпретатор}-->
<!--\indexR{т ау@$\tau$ (контекст вычислений)}-->
<!--\indexE{t au@$\tau$ (контекст вычислений)}-->
<!--\indexR{м ю@$\mu$ (денотация функции)}-->
<!--\indexE{m u@$\mu$ (денотация функции)}-->
<p>Теперь перейдём к собственно обработке точечных аргументов. Для этого нам
потребуется изменить форму <code><span class="func">lambda</span></code>, а также ввести ещё один интерпретатор.
Его задачей будет правильным образом связывать переменные и значения. Мы назовём
его $\Bind$, от <em class="term">binding</em>. Его тип связан с типом $\Eval$ для функций; для
краткости обозначим буквой $\mu$ денотацию функции, для которой $\Bind$
подготавливает аргументы, а для контекста вычислений используем букву $\tau$:
%
\begin{align*}
&  \tau \equals \Vset{Значения}^* \times \Vset{Окружение}
     \times \Vset{Продолжение} \times \Vset{Память}                           \\
&  \:\:\llap{$\Eval$}\colon \quad \Vset{Программа}\to(\tau\to\Vset{Значение}) \\
&  \:\:\llap{$\Bind$}\colon \quad \Vset{СписокАргументов} \to
      \big(\underbrace{(\tau \to \Vset{Значение})}_{\displaystyle\mu}
          \times \tau \to \Vset{Значение}\big)
\end{align*}</p>

<p>
$\Bind$, связывающий интерпретатор, начинает работу после проверки арности. Если
с ней всё в порядке, то он заносит один за другим фактические значения
аргументов в память и расширяет лексическое окружение функции соответствующими
переменными. Наконец, управление передаётся телу функции. Определение функций
фиксированной арности с помощью $\Bind$ выглядит так:</p>


<!--\indexC{lambda}-->
<!--\indexE{let-in@$\protect\LET \ldots \IN$}-->
<p>\begin{denotation}
$\Eval\sem*{(lambda ($\n^*$) $\p^+$)}\r\k\s = $ \|
$\quad(\k\ \Vset{Значение}(\lambda \e^*\k_1\s_1.$\.
  $\IF   \#\e^* = \#\n^*$                       \\
  $\THEN \big((\Bind\sem{\n^*}\ \lambda\e^*_1\r_1\k_2\s_2.
            (\Eval^+\sem{\p^+}\ \r_1\ \k_2\ \s_2))\ \e^*\ \r\ \k_1\ \s_1\big)$\\
  $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$    \\
  $\ENDIF)\ \s)$                              \-\|
$\Bind\sem{\n\ \n^*}\mu = (\Bind\sem{\n}\ (\Bind\sem{\n^*}\ \mu))$  \|
$\Bind\sem{\,}\mu = \mu$                                            \|
$\Bind\sem{\n}\mu =
  \lambda \e^*\r\k\s.
      \ii{allocate}\ \s\ 1\ \lambda \s_1\a^*.$\.
                                $\LET \a = \a^*\car1$  \\
                                $\IN  (\mu\ \e^*\cdr1\ \r[\n \to
                                         \a]\ \k\ \s_1[\a \to \e^*\car1])$
\end{denotation}</p>

<p>Конструкция $\LET \ldots \IN$ вводит локальные нерекурсивные определения.</p>

<p>\ForLayout{display}{\endgroup} % \setlength{\denotepadding}</p>

<p>Для обработки случая функций переменной арности потребуется определить
дополнительный синтаксис формы <code><span class="func">lambda</span></code>, принимающей список с точкой, а также
новый вариант $\Bind$. Эта форма принимает последовательность «лишних»
значений, превращает её в список (настоящий, из точечных пар), который связывает
с именем последнего аргумента. Если учесть, что функции с переменной арностью и
<code><span class="func">apply</span></code> могут использоваться совместно с побочными эффектами, то подобные
списки необходимо создавать заново при каждом вызове. В конце концов,
в стандарте есть требование, чтобы функции вели таким образом. Поэтому следующее
выражение должно возвращать ложь:</p>

<pre>(let ((arguments (list 1 2 3)))
  (apply (lambda args (eq? args arguments)) arguments) )</pre>

<p>Если мы не хотим этого делать, то вначале потребуется доказать, что совместное
использование одного и того же физического списка не изменит смысла программы.</p>

<p>Наконец, переходим к денотациям:</p>


<!--\indexE{listify@\protect\ii{listify}}-->
<p>\begin{denotation}
$\Eval\sem*{(lambda ($\n^*$ \!. $\n$) $\p^+$)}\r\k\s = $                   \|
$\quad(\k\ \Inj{Значение}(\lambda \e^*\k_1\s_1.$\.
  $\IF   \#\e^* \geq \#\n^*$                                               \\
  $\THEN \big($\.$(\Bind\sem{\n^*}\ %
                    (\Bind\sem*{. $\n$}\ {}$\*$\lambda \e^*_1\r_1\k_2\s_2.$\\
                                $(\Eval^+\sem{\p^+}\ \r_1\ \k_2\ \s_2)))$  \/
              $\e^*\ \r\ \k_1\ \s_1\big)$                                  \/
  $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$                               \\
  $\ENDIF)\ \s)$                                                         \-\|
\*$\Bind\sem*{. $\n$}\mu = {}$\.
  $\lambda \e^*\r\k\s. \big(\fn{listify}\ \e^*\ \s\ $\*$\lambda \e\s_1.$   \\
           \*$\ii{allocate}\ \s_1\ 1$                                      \\
                $\lambda \s_2\a^*.$\.
             $\LET \a = \a^*\car1$                                         \\
             $\IN  (\mu\ \seq{}\ \r[\n\to\a]\ \k\ \s_2[\a\to\e])\big)$\-\-\-\-\\
  $\WHERE \ii{listify} = {}$\*%
      $\lambda \e^*_1\s_1\k_1.$              \\
        $\IF   \#\e^*_1 > 0$                 \\
        $\THEN {}$\*$\ii{allocate}\ \s_1\ 2$ \\
            $\lambda \s_2\a^*.$\.
              $\LET \k_2 = {}$\*$\lambda \e\s_3 .$                 \\
                             $(\k_1\ \Inj{Значение}
                                  (\a^*)\ \s_3[\a^*\car2 \to \e])$ \/
              $\IN (\fn{listify}\
                    \e^*_1\cdr1\ \s_2[\a^*\car1 \to \e^*_1\car1]\ \k_2)$\-\-\\
        $\ELSE (\k_1\ \Inj{Значение}(\seq{})\ \s_1)$                        \\
        $\ENDIF$
\end{denotation}</p>


<!--\indexR{переменная арность!сложность}-->
<p>Как видите, введение нетривиальных возможностей вроде функций переменной арности
требует существенных усилий. Нам пришлось, фактически, написать ещё один
интерпретатор. Если сравнить получившуюся версию с элегантной реализацией ядра
Scheme, то станет очевидным, что добавление всего одной интересной, но всё же
несущественной детали почти удвоило размер кода, не говоря уже о читабельности
и понятности.</p>

<h2 id="denotational/sect:eval-order">Порядок вычисления аргументов</h2>


<!--\indexR{порядок вычислений!в Scheme и Си}-->
<p>Время от времени в Интернете вспыхивают яростные религиозные войны по поводу
толкования стандартов Scheme. Данная книга строго следует стандарту: порядок
вычисления термов аппликации не определён. К сожалению, из-за этого правила
сложно не только писать корректные программы, зависящие от конкретного порядка,
но и отлаживать некорректные. Многие программы, даже некоторые из написанных
видными экспертами, неявно зависят от порядка вычислений; особенно программы,
использующие продолжения. Лично я предпочитаю порядок слева направо, так как
он соответствует направлению чтения во многих языках, а также привносит хоть
какую-то систематичность в поиск ошибок.</p>

<p>Особый интерес среди доводов противоборствующей стороны представляют
следующие два. Первый из них состоит в том, что многие языки не указывают
порядок вычислений. Даже императивный Си не указывает порядок вычисления
аргументов функций. Если выражение <code><span class="func">(foo (f x) (g x y))</span></code> транслируется
в следующий код на Си: <code><span class="func">foo(f(x), g(x, y))</span></code>, то нам действительно
не следует полагаться на какой-либо порядок.</p>

<p>Второй довод больше философский. В языке без предопределённого порядка
вычислений его всё же можно явно установить самостоятельно с помощью <code><span class="func">begin</span></code>.
Следовательно, порядок всё же есть, просто «не определён» следует читать как
«не определён нами». Поэтому для истинной неопределённости реализация языка
должна использовать какой-нибудь генератор случайных чисел, который будет
определять «неопределённый» порядок непосредственно перед вычислениями.
\seeEx[denotational/ex:truly-random]</p>

<p>В Си порядок в действительности не определяется для того, чтобы разрешить
компилятору выбирать любой необходимый ему порядок, например, чтобы эффективнее
распределять регистры.</p>

<p>Явный порядок вычислений упрощает отладку, делая одной неопределённостью меньше.
Если порядок будет случайным, то два прогона одной и той же программы на одних и
тех же данных могут дать разные результаты. Рассмотрим пример\footnote{Данная
функция была придумана и реализована совместно с Матиасом Феллайзеном
(Matthias Felleisen).}:</p>


<!--\indexC{dynamically-changing-evaluation-order}-->
<!--\indexC{amb}-->
<pre>(define (dynamically-changing-evaluation-order?)
  (define (amb)
    (call/cc (lambda (k) ((k #t) (k #f)))) )
  (if (eq? (amb) (amb))
    (dynamically-changing-evaluation-order?)
    #t ) )</pre>

<p>Функция <code><span class="func">amb</span></code> возвращает истину или ложь в зависимости от того, какой терм
вычисляется первым. Если порядок вычислений не фиксирован, то функция
<code><span class="func">dynamically-changing-evaluation-order?</span></code> рано или поздно остановится и
вернёт <code><span class="func">\#t</span></code>; иначе она попадает в бесконечный цикл. В {\RnRS} нет ничего,
что требовало бы от этой функции того или иного поведения. Оно зависит
исключительно от реализации.</p>


<!--\indexR{порядок вычислений!неопределённый}-->
<p>Необходимо чётко отделять реализацию языка от его стандарта. Интерпретатор или
компилятор по очевидным причинам вынуждены использовать хоть какой-нибудь
порядок. Не особо важно, слева направо, или справа налево, как MacScheme, или
хоть в зависимости от текущей фазы Луны. Но ни одна из известных мне реализаций
не изменяет всерьёз порядок вычисления аргументов во время выполнения программы.
Обычно порядок устанавливается при компиляции, после чего к этому вопросу больше
не возвращаются. Поэтому неопределённость порядка всё же следует понимать как
привилегию выбирать любой, а не обязанность поддерживать случайный.</p>


<!--\indexR{результат@\protect\Vset{Результат}}-->
<p>Проблема в том, как показать в денотациях неопределённость порядка, но в то же
время разрешить реализациям определять свой порядок, используя одни и те же
денотации. Идея решения данной проблемы состоит в небольшом изменении структуры
денотаций. Сейчас они считаются $\lambda$-термами, которые принимают окружение,
продолжение и память, а потом возвращают некоторый результат. Данный результат
принадлежит домену \Vset{Значений}, но ведь на самом деле он неразрывно связан
с состоянием памяти: мы говорили, что побочные эффекты — это тоже результат
работы программы. Поэтому нам стоит сделать результатом вычислений именно пару
(\ii{значение}, \ii{память}). Мы не будем заниматься философствованиями на тему
того, чем именно является результат вычислений, а просто сделаем областью
значений денотаций домен \Vset{Результатов}.</p>


<!--\indexR{порядок вычислений!неопределённый!денотация}-->
<!--\indexR{интерпретатор!N@$\protect\Noir\mskip-\thinmuskip$}-->
<!--\indexE{N@$\protect\Noir\mskip-\thinmuskip$, интерпретатор}-->
<!--\indexE{P@$\mathcal{P}(Q)$ (множество)}-->
<p>Так как вычисления могут проходить по-разному, то и денотации будут возвращать
не один результат, а множество всех возможных результатов в зависимости от
порядка вычислений. Реализация же будет выбирать из этого множества какой-нибудь
один, руководствуясь собственными соображениями. Следовательно, $\Eval$ теперь
соответствует обобщённому результату, а конкретная реализация представляется
функцией $\Noir$\!. Если обозначить множество всех подмножеств $Q$ как
$\mathcal{P}(Q)$, то эти функции имеют следующие типы:
%
\begin{align*}
  \Eval\colon& \quad \Vset{Программа} \to \Vset{Значения}^*
      \times \Vset{Окружение} \times {}                             \\
  & \hskip10em {} \times \Vset{Продолжение} \times \Vset{Память}
      \to \mathcal{P}(\Vset{Результаты})                            \\
\Noir\!\colon& \quad \Vset{Программа} \to \Vset{Значения}^*
      \times \Vset{Окружение} \times {}                             \\
  & \hskip10em {} \times \Vset{Продолжение} \times \Vset{Память}
      \to \Vset{Результат}
\end{align*}</p>


<!--\indexE{oneof@\protect\ii{oneof}}-->
<p>$\Noir$ определяется просто: она использует \ii{oneof}\!, чтобы выбрать один из
возможных результатов. Определение функции \ii{oneof}, естественно, возлагается
на реализацию.</p>

<p>\begin{denotation}
$\Noir\sem{\p}\r\k\s = (\fn{oneof}\ (\Eval\sem{\p}\ \r\ \k\ \s))$
\end{denotation}</p>

<p>Теперь необходимо переопределить аппликацию функций так, чтобы получать все
возможные результаты. Если порядок случаен, то это фактически значит, что
аппликация выполняется так: сначала выбирается случайный терм, обозначим
его $\p'_0$, он вычисляется в $\e'_0$, потом из оставшихся выбирается следующий
терм $\p'_1$, который вычисляется в $\e'_1$, и так далее. Затем значения
$\e'_0, \e'_1, \dots, \e'_n$ переупорядочиваются так, как они шли в исходной
форме: $\e_0, \e_1, \dots, \e_n$, и, наконец, первое значение-функция
применяется к последовательности из всех остальных. При таком подходе порядок
вычислений действительно случаен для каждого отдельного вызова, а не выбирается
и фиксируется для каждой функции. Рассмотрим пример. Следующая функция не только
выводит неопределённое число, но и продолжение, которое она возвращает, тоже
выводит неопределённое число.</p>


<!--\indexC{one-two-three}-->
<pre>(define (one-two-three)
  (call/cc (lambda (k)
             ((begin (display 1) (call/cc k))
              (begin (display 2) (call/cc k))
              (begin (display 3) (call/cc k)) ) )) )</pre>


<!--\indexE{forall@\protect\ii{forall}}-->
<!--\indexE{cut@\protect\ii{cut}}-->
<!--\indexR{стиль передачи продолжений (CPS)}-->
<!--\indexE{CPS}-->
<p>Денотация аппликации с неопределённым порядком вычисления аргументов будет
выполнять именно то, что мы сказали ранее. Она рассмотрит все возможные
перестановки аргументов с помощью функции \ii{forall}, которая применяет свой
первый аргумент (тернарную функцию) ко всем возможным срезам своего второго
аргумента (списка). Срезы предоставляются функцией \ii{cut}, которая разрезает
список на две части: одна из них содержит первые $i$ элементов, другая — все
оставшиеся; затем \ii{cut} применяет свой третий аргумент (продолжение) к этим
двум частям. Определения слегка запутанные, но это хороший пример стиля передачи
продолжений. (Данная программа была разработана в сотрудничестве с Софи Англад и
Жан-Жаком Лакрампом <span class="cite">[<a href="z1_bibliography.xhtml#alq95">alq95</a>]</span>.)</p>


<!--\indexE{possible-paths@\protect\ii{possible-paths}}-->
<!--\indexE{loop@\protect\ii{loop}}-->
<!--\indexE{accumulate@\protect\ii{accumulate}}-->
<p>\begin{denotation}
$\Eval\sem*{($\p_0$ $\p_1$ ... $\p_n$)}\r\k\s = \big($\.
  $(\ii{possible-paths}\ \seq{\Eval\sem{\p_0},
      \Eval\sem{\p_1}, \dots, \Eval\sem{\p_n}})$                    \\
  $\r\ \lambda\e^*\s_1.
         (\e^*\car1\Prj{Функции}\ \e^*\cdr1\ \k\ \s_1)\ \s\big)$  \-\
$(\ii{possible-paths}\ \mu^+) = $                                   \\
$\quad\lambda \r\k\s.$\.
  $\IF   \#\mu^+\cdr1 > 0$        \\
  $\THEN (\ii{forall}\ $\*%
    $\lambda \mu^+_1\mu\mu^+_2.$  \\
    $(\mu\ \r\ $\*%
      $\lambda \e\s_1.$           \\
      $($\.$(\ii{possible-paths}\ \mu^+_1\append\mu^+_2)$ \\
           $\r\ \lambda \e^*\s_2.$\.
              $\LET \k_1 = {}$\*$\lambda \e^*_1\e^*_2.$      \\
                        $(\k\ \e^*_1 \append \seq{\e} \append \e^*_2\ \s_2)$\-\\
              $\IN  (\fn{cut}\ \#\mu^+_1\ \e^*\ \k_1)$    \/
           $\s_1)\ \s)\ \mu^+)$                     \-\-\-\\
  $\ELSE (\mu^+\car1\ \r\ \lambda \e\s_1.(\k\ \seq{\e}\ \s_1)\ \s)$\\
  $\ENDIF$  \-\
\*$(\ii{forall}\ \f\ \ell) = (\fn{loop}\ \seq{}\ \ell\car1\ \ell\cdr1)$       \\
  $\WHERE \ii{loop} =
    \lambda \ell_1\e\ell_2.
      (\f\ \ell_1\ \e\ \ell_2) \cup {}$\.
          $\IF   \#\ell_2 > 0$                        \\
          $\THEN (\fn{loop}\ \ell_1 \append
                 \seq{\e}\ \ell_2\car1\ \ell_2\cdr1)$ \\
          $\ELSE \emptyset$                           \\
          $\ENDIF$                                \-\-\
\*$(\fn{cut}\ \iota\ \e^*\ \k) = (\fn{accumulate}\ \iota\ \seq{}\ \e^*)$      \\
  $\WHERE \ii{accumulate} = \lambda \iota\ell\ell_1.$\.
    $\IF   \iota > 0$                                       \\
    $\THEN (\fn{accumulate}\ (\iota - 1)\ \seq{\ell_1\car1}
            \append\ell\ \ell_1\cdr1)$                      \\
    $\ELSE (\k\ (\fn{reverse}\ \ell)\ \ell_1)$              \\
    $\ENDIF$
\end{denotation}</p>


<!--\indexE{Scheme!параллельные вычисления}-->
<p>Во всех приведённых случаях порядок вычисления аргументов является
неопределённым, но сами вычисления остаются последовательными — это
требование стандарта: результат должен быть эквивалентен вычислению аргументов
в какой-нибудь последовательности. То есть следующая программа может вернуть
<code><span class="func">(3 5)</span></code> или <code><span class="func">(4 3)</span></code>, но никак не <code><span class="func">(3 3)</span></code>:</p>

<pre>(let ((x 1) (y 2))
  (list (begin (set! x (+ x y)) x)
        (begin (set! y (+ x y)) y) ) )</pre>

<p>Денотация следующей программы, полученная с помощью новой $\Eval$, будет
возвращать два возможных результата: <code><span class="func">1</span></code> и <code><span class="func">2</span></code>. Конкретная реализация
сможет выбрать один из них с помощью $\Noir$ и \ii{oneof}\!.</p>

<pre>(call/cc (lambda (k) ((k 1) (k 2)))) |{\is} $\{<code><span class="func">1</span></code>,\ <code><span class="func">2</span></code>\}$|</pre>

<h2 id="denotational/sect:dynamic">Динамическое связывание</h2>


<!--\indexR{динамическое связывание}-->
<!--\indexR{связывание!динамическое}-->
<!--\indexR{окружение!динамическое}-->
<p>Идея динамического связывания не только важна сама по себе, но и действительно
полезна. В конце концов, довольно долгое время разнообразные диалекты Лиспа были
именно динамическими. Поэтому мы просто не можем обойти стороной эту идею и
не показать её денотацию. Для этого нам потребуется поправить ядро Scheme, а
также добавить несколько специальных форм для работы с новым типом привязок.
Конечно, есть далеко не один вариант реализации динамического окружения; взять
хотя бы возможность использовать или специальные формы, или же
специализированные функции.
\seePage[lisp1-2-omega/namespaces/ssect:dyn-vars-no-special] Традиционно
в Scheme принят второй подход, чтобы как можно меньше вмешиваться в ядро языка.
К сожалению, не все функции можно отделить от ядра, даже если они вызываются,
используются и ведут себя именно как функции. Например, <code><span class="func">call/cc</span></code>: ей
необходим доступ к продолжениям. Аналогично, всем функциям для работы
с динамическими переменными потребуется доступ к окружению динамических
переменных. Доработанное ядро Scheme приведено
в таблице \ref{denotational/dynamic/fig:dynamic-scheme}.</p>

<p>\begin{table}[!p]
<!--\indexE{Scheme!семантика!динамическое окружение}-->
\begin{semantic}\begin{denotation}
$\Eval\sem{\n}\r\d\k\s = (\k\ (\s\ (\r\ \n))\ \s)$                     \
$\Eval\sem*{(if $\p$ $\p_1$ $\p_2$)}\r\d\k\s =
    (\Eval\sem{\p}\ \r\ \d\ \lambda\e\s_1. ($\.$\IF    (\fn{boolify}\ \e)$    \\
                                            $\THEN  \Eval\sem{\p_1}   $       \\
                                            $\ELSE  \Eval\sem{\p_2}   $       \\
                                            $\ENDIF \r\ \d\ \k\ \s_1)\ \s)$ \-\|
$\Eval\sem*{(set! $\n$ $\p$)}\r\d\k\s =
    (\Eval\sem{\p}\ \r\ \d\ \lambda\e\s_1.
        (\k\ \e\ \s_1[(\r\ \n) \to \e])\ \s)$                          \
$\Eval\sem*{(lambda ($\n^*$) $\p^+$)}\r\d\k\s =$                       \|
$\quad(\k\ \Inj{Значение}(\lambda\e^*\d_1\k_1\s_1.$\.
    $\IF   \#\e^* = \#\n^*$                            \\
    $\THEN {}$\*$\ii{allocate}\ \s_1\ \#\n^*$          \\
              \*$\lambda \s_2\a^*.$                    \\
                $(\Eval^+\sem{\p^+}\ \r[\n^* \to*{*}
                \a^*]\ \d_1\ \k_1\ \s_2[\a^* \to*{*} \e^*])$ \-\/
    $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$         \\
    $\ENDIF)\ \s)$                                     \-\|
$\Eval\sem*{($\p$ $\p^*$)}\r\d\k\s =$                         \|
$\quad(\Eval\sem{\p}\ \r\ \d\ \lambda \f\s_1.
    (\Eval^*\sem{\p^*}\ \r\ \d\ \lambda \e^*\s_2.
        (\f\Prj{Функции}\ \e^*\ \d\ \k\ \s_2)\ \s_1)\ \s)$    \
$\Eval^*\sem{\p\ \p^*}\r\d\k\s =$                             \|
$\quad(\Eval\sem{\p}\ \r\ \d\ \lambda \e\s_1.
        (\Eval^*\sem{\p^*}\ \r\ \d\ \lambda \e^*\s_2.
            (\k\ \seq{\e} \append \e^*\ \s_2)\ \s_1)\ \s)$    \
$\Eval^*\sem{\,}\r\d\k\s = (\k\ \seq{}\ \s)$                  \
$\Eval\sem*{(begin $\p^+$)}\r\d\k\s = (\Eval^+\sem{\p^+}\ \r\ \d\ \k\ \s)$\
$\Eval^+\sem{\p\ \p^+}\r\d\k\s = \big(\Eval\sem{\p}\ \r\ \d\ \lambda\e\s_1.
    (\Eval^+\sem{\p^+}\ \r\ \d\ \k\ \s_1)\ \s\big)$           \
$\Eval^+\sem{\p}\r\d\k\s = (\Eval\sem{\p}\ \r\ \d\ \k\ \s)$   \
$(\s_0\ (\r_0\ \sem*{call/cc})) = $                           \|
$\quad\Inj{Значение}($\*$\lambda \e^*\d\k\s.$                 \\
                $\IF   \#\e^* = 1$                            \\
                $\THEN ($\.$\e^*\car1\Prj{Функции}$           \\
                        $\langle\Inj{Значение}($\*$\lambda\e^*_1\d_1\k_1\s_1.$\\
                                               $\IF   \#\e^*_1 = 1$           \\
                                               $\THEN (\k\ \e^*_1\car1\ \s_1)$\\
                                    $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$\\
                                    $\ENDIF)\rangle\ \d\ \k\ \s)$  \-\-\\
                $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$             \\
                $\ENDIF)$
\end{denotation}\end{semantic}%
\caption{Scheme с динамическим окружением.}%
\label{denotational/dynamic/fig:dynamic-scheme}%
\end{table}</p>


<!--\indexR{д ельта@$\d$ (динамическое окружение)}-->
<!--\indexE{d elta@$\d$ (динамическое окружение)}-->
<!--\indexR{память!однопоточность}-->
<p>Динамическое окружение, обозначаемое $\d$, отличается от лексического $\r$. Оно
передаётся только туда, где его можно использовать. Отличается оно и от
памяти $\s$, которая является <em class="term">однопоточной</em>: каждое вычисление принимает
память, достаёт значения нужных переменных или изменяет их, после чего передаёт
новое состояние памяти дальше. Поток передачи памяти только один, в каждый
момент времени существует только одно актуальное состояние памяти. Динамическое
окружение хоть и передаётся от функции к функции похожим образом, но поток может
разделяться, например, при вычислении термов аппликации.</p>


<!--\indexR{ДинамическоеОкружение@\protect\Vset{ДинамическоеОкружение}}-->
<p>Динамические окружения принадлежат одноимённому домену, определяемому следующим
образом:
%
\[
  \d \quad \Vset{ДинамическоеОкружение} = \Vset{Переменная} \to \Vset{Значение}
\]</p>

<p>\phantomlabel{denotational/dynamic/par:two-forms}
Для работы с динамическим окружением предназначены две специальные формы:
<code><span class="func">dynamic-let</span></code> и <code><span class="func">dynamic</span></code>. Форма <code><span class="func">dynamic-let</span></code> устанавливает
динамическую связь между \ii{переменной} и \ii{значением} на время вычисления
\ii{тела}. Она обрабатывает только одну переменную за раз, но это не проблема
(макросы). Форма <code><span class="func">dynamic</span></code> возвращает текущее значение динамической
переменной; или ошибку, если запрошенная переменная не существует. Так как
изменять динамические привязки мы запрещаем, то данное окружение связывает
переменные со значениями напрямую, без посредников в виде адресов. Семантика
рассмотренных форм показана
в таблице \ref{denotational/dynamic/fig:dynamic-semantics}, а вот их синтаксис:</p>


<!--\indexC{dynamic-let}-->
<!--\indexC{dynamic}-->
<pre>(dynamic-let (|\ii{переменная}| |\ii{значение}|) |\ii{тело}|...)
(dynamic |\ii{переменная}|)</pre>

<p>\begin{table}[!ht]
<!--\indexR{динамическое связывание!семантика}-->
<!--\indexR{д ельта0@$\delta_0$ (начальное окружение)}-->
<!--\indexE{d elta0@$\delta_0$ (начальное окружение)}-->
\begin{semantic}\begin{denotation}
$(\d_0\ \n) = \ii{wrong}\ \dc{"No such dynamic variable"}$                    \
$\Eval\sem*{(dynamic $\n$)}\r\d\k\s = (\k\ (\d\ \n)\ \s)$                     \
$\Eval\sem*{(dynamic-let ($\n$ $\p$) $\p^+$)}\r\d\k\s = $                     \|
$\quad(\Eval\sem{\pi}\ \r\ \d\ \lambda \e\s_1.
    (\Eval^+\sem{\p^+}\ \r\ \d[\n \to \e]\ \k\ \s_1)\ \s)$
\end{denotation}\end{semantic}%
\caption{Семантика специальных форм динамического связывания.}%
\label{denotational/dynamic/fig:dynamic-semantics}%
\end{table}</p>

<p>Приведённая денотация довольно очевидна. Формы получают значение из
динамического окружения или же расширяют его, таким образом мы получаем второе
пространство имён для динамических переменных, отделённое от пространства
лексических. И снова вы можете убедиться в огромной информативности подобной
записи: лишь несколькими греческими буквами описывается новое пространство имён.
Денотационная семантика одарит своей силой любого, кто сможет разобраться
в её тайнописи.</p>


<!--\indexR{обработка ошибок}-->
<p>Идея динамического окружения находит применение не только просто для переменных,
но и при обработке ошибок, для реализации переходов и иных механизмов управления
потоком исполнения \cite{hd90,qd93}. Рассмотрим, например, простой, собранный
на коленке механизм обработки ошибок: в случае неожиданной ситуации функция
создаёт объект, описывающий, что именно произошло, и передаёт его функции,
хранящейся в динамической переменной <code><span class="func">*error*</span></code>. Теперь можно на любые
вычисления навесить нужный нам обработчик ошибок, обернув эти вычисления в форму
<code><span class="func">dynamic-let</span></code>, устанавливающую необходимую функцию в <code><span class="func">*error*</span></code>. Например,
стандарт Scheme требует, чтобы попытка открыть несуществующий файл вызывала
ошибку, но, к сожалению, он не определяет функцию, позволяющую заранее
проверить, существует ли файл. Используя динамические переменные, мы можем
написать подобный предикат самостоятельно:</p>


<!--\indexC{file-exists"?}-->
<pre>(define (file-exists? filename)
  (dynamic-let (*error* (lambda (anomaly) #f))
    (call-with-input-file filename
      (lambda (port) #t) ) ) )</pre>

<p>Это приближённое определение, так как в действительности надо ещё проверить,
что <code><span class="func">*error*</span></code> вызвана потому, что файл действительно не существует, а не,
например, потому что мы исчерпали лимит открытых портов ввода. Для этого
необходимо знать структуру объектов, которые <code><span class="func">call-with-input-file</span></code> может
положить в <code><span class="func">anomaly</span></code>.</p>

<h2 id="denotational/sect:global">Глобальное окружение</h2>


<!--\indexR{глобальное окружение}-->
<!--\indexR{окружение!глобальное}-->
<!--\indexR{г амма@$\g$ (глобальное окружение)}-->
<!--\indexE{g amma@$\g$ (глобальное окружение)}-->
<p>В этом разделе мы изучим глобальное окружение, рассмотрев несколько вариантов
его денотации. Добавляется оно аналогично динамическому окружению $\d$. Как и
локальное окружение $\r$, глобальное окружение $\g$ переводит идентификаторы
в адреса. Глобальное окружение следует тенью за памятью: всякое вычисление
теперь принимает, возможно использует и передаёт дальше не только память, но и
глобальное окружение. В таблице \ref{denotational/global/fig:global-scheme}
приведена денотация ядра Scheme с глобальным окружением. Из неё пока исключены
ссылки на переменные и присваивание, их мы рассмотрим чуть позже.</p>

<p>\begin{table}[!p]
<!--\indexE{Scheme!семантика!глобальное окружение}-->
\begin{semantic}\begin{denotation}
$\Eval\sem*{(if $\p$ $\p_1$ $\p_2$)}\r\g\k\s =
    (\Eval\sem{\p}\ \r\ \g\ \lambda\e\g_1\s_1.($\.$\IF (\fn{boolify}\ \e)$    \\
                                           $\THEN  \Eval\sem{\p_1}   $        \\
                                           $\ELSE  \Eval\sem{\p_2}   $        \\
                                           $\ENDIF \r\ \g_1\ \k\ \s_1)\ \s)$\-\|
$\Eval\sem*{(lambda ($\n^*$) $\p^+$)}\r\g\k\s =$       \|
$\quad(\k\ \Inj{Значение}(\lambda\e^*\g_1\k_1\s_1.$\.
    $\IF   \#\e^* = \#\n^*$                            \\
    $\THEN {}$\*$\ii{allocate}\ \s_1\ \#\n^*$          \\
              \*$\lambda \s_2\a^*.$                    \\
                $(\Eval^+\sem{\p^+}\ \r[\n^* \to*{*}
                \a^*]\ \g_1\ \k_1\ \s_2[\a^* \to*{*} \e^*])$ \-\/
    $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$         \\
    $\ENDIF)\ \g\ \s)$                               \-\|
$\Eval\sem*{($\p$ $\p^*$)}\r\g\k\s =$                         \|
$\quad(\Eval\sem{\p}\ \r\ \g\ \lambda \f\g_1\s_1.
    (\Eval^*\sem{\p^*}\ \r\ \g_1\ \lambda \e^*\g_2\s_2.
        (\f\Prj{Функции}\ \e^*\ \g_2\ \k\ \s_2)\ \s_1)\ \s)$  \
$\Eval^*\sem{\p\ \p^*}\r\g\k\s =$                             \|
$\quad(\Eval\sem{\p}\ \r\ \g\ \lambda \e\g_1\s_1.
    (\Eval^*\sem{\p^*}\ \r\ \g_1\ \lambda \e^*\g_2\s_2.
        (\k\ \seq{\e} \append \e^*\ \g_2\ \s_2)\ \s_1)\ \s)$  \
$\Eval^*\sem{\,}\r\g\k\s = (\k\ \seq{}\ \g\ \s)$              \
$\Eval\sem*{(begin $\p^+$)}\r\g\k\s = (\Eval^+\sem{\p^+}\ \r\ \g\ \k\ \s)$\
$\Eval^+\sem{\p\ \p^+}\r\g\k\s = \big(\Eval\sem{\p}\ \r\ \g\ \lambda\e\g_1\s_1.
    (\Eval^+\sem{\p^+}\ \r\ \g_1\ \k\ \s_1)\ \s\big)$                  \
$\Eval^+\sem{\p}\r\g\k\s = (\Eval\sem{\p}\ \r\ \g\ \k\ \s)$            \
$(\s_0\ (\r_0\ \sem*{call/cc})) = $                                    \|
$\quad\Inj{Значение}($\*$\lambda \e^*\g\k\s. $                         \\
                $\IF   \#\e^* = 1$                                     \\
                $\THEN ($\.$\e^*\car1\Prj{Функции}$                    \\
                        $\langle\Inj{Значение}($\*$\lambda\e^*_1\g_1\k_1\s_1.$\\
                                    $\IF   \#\e^*_1 = 1$                      \\
                                    $\THEN (\k\ \e^*_1\car1\ \g_1\ \s_1)$     \\
                                    $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$\\
                                    $\ENDIF)\rangle\ \g\ \k\ \s)$  \-\-\\
                $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$             \\
                $\ENDIF)$
\end{denotation}\end{semantic}%
\caption{Scheme с глобальным окружением.}%
\label{denotational/global/fig:global-scheme}%
\end{table}</p>

<p>
\subsection{Глобальное окружение в Scheme}%
\label{denotational/global/ssect:in-scheme}</p>

<p>С помощью подобного базиса можно реализовать несколько вариантов глобального
окружения. В стандарте Scheme используется следующая вариация:
1) получить значение переменной можно только если она существует
и инициализирована;
2) изменять значение переменной можно только если она существует;
3) переопределение переменной эквивалентно присваиванию.</p>


<!--\indexR{ГлобальноеОкружение@\protect\Vset{ГлобальноеОкружение}}-->
<!--\indexR{ЛокальноеОкружение@\protect\Vset{ЛокальноеОкружение}}-->
<!--\indexE{no-binding@\protect\ii{no-binding}}-->
<!--\indexE{no-global-binding@\protect\ii{no-global-binding}}-->
<p>Чтобы выразить первые два правила, нам необходим способ проверки, определена ли
переменная в окружении. Для этого расширим область значений окружений: к домену
адресов прибавим специальное значение, которое не является адресом и обозначает
отсутствие привязки в окружении:
%
\begin{align*}
   \Vset{ЛокальноеОкружение}\colon& \quad \Vset{Переменная} \to \Vset{Адрес}
                                          + \{ \fn{no-binding} \}             \\
  \Vset{ГлобальноеОкружение}\colon& \quad \Vset{Переменная} \to \Vset{Адрес}
                                          + \{ \fn{no-global-binding} \}
\end{align*}</p>

<p>Теперь смысл ссылок и присваиваний должен быть ясен: сначала мы ищем локальную
переменную, если не находим, то продолжаем искать уже в глобальном окружении.
В итоге у нас на руках или адрес, с которым мы идём к памяти, или $\bot$,
который отдаётся как есть. Конечно, кроме этого ещё надо подправить начальные
окружения.</p>

<p>\begin{denotation}
$(\r_0\ \n) = \ii{no-binding}$                  \|
$(\g_0\ \n) = \ii{no-global-binding}$           \|
$\Eval\sem{\n}\r\g\k\s = {}$\.
  $\LET \a = (\r\ \n)$                          \\
  $\IN {}$\.$\IF   \a = \ii{no-binding}$        \\
            $\THEN {}$\.$\LET \a_1 = (\g\ \n)$  \\
                        $\IN {}$\.$\IF   \a_1 = \ii{no-global-binding}$       \\
                                  $\THEN \ii{wrong}\ \dc{"No such variable"}$ \\
                                  $\ELSE (\k\ (\s\ \a_1)\ \g\ \s)$            \\
                                  $\ENDIF$                                \-\-\\
            $\ELSE (\k\ (\s\ \a)\ \g\ \s)$      \\
            $\ENDIF$                        \-\-\|
$\Eval\sem*{(set! $\n$ $\p$)}\r\g\k\s = $       \|
$\quad(\Eval\sem{\p}\ \r\ \g\ \lambda \e\g_1\s_1.$\.
  $\LET \a = (\r\ \n)$                          \\
  $\IN {}$\.$\IF   \a = \ii{no-binding}$        \\
            $\THEN {}$\.$\LET \a_1 = (\g_1\ \n)$                              \\
                        $\IN {}$\.$\IF   \a_1 = \ii{no-global-binding}$       \\
                                  $\THEN \ii{wrong}\ \dc{"No such variable"}$ \\
                                  $\ELSE (\k\ \e\ \g_1\ \s_1[\a_1 \to \e])$   \\
                                  $\ENDIF$                                \-\-\\
            $\ELSE (\k\ \e\ \g_1\ \s_1[\a \to \e])$                           \\
            $\ENDIF \s)$
\end{denotation}</p>

<p>Пусть глобальные переменные определяются специальной формой <code><span class="func">define</span></code>, причём
для простоты положим, что она (пере)определяет исключительно <em class="term">глобальные</em>
переменные (даже если находится внутри определения функции). Поэтому назовём её
<code><span class="func">define-global</span></code>. Итак, запишем её денотацию, которая должна или создать новую
переменную, или изменить значение уже существующей:</p>


<!--\indexC{define-global}-->
<p>\begin{denotation}
$\Eval\sem*{(define-global $\n$ $\p$)}\r\g\k\s = $  \|
$\quad(\Eval\sem{\p}\ \r\ \g\ \lambda \e\g_1\s_1.$\.
  $\LET \a = (\g\ \n)$                              \\
  $\IN {}$\.$\IF   \a = \ii{no-global-binding}$     \\
            $\THEN \ii{allocate}\ \s_1\ 1\ $\*$
                 \lambda \s_2\a^*.$                 \\
                    $(\k\ \e\ \g_1[\n \to \a^*\car1]\ %
                          \s_2[\a^*\car1 \to \e])$\-\\
            $\ELSE (\k\ \e\ \g_1\ \s_1[\a \to \e])$ \\
            $\ENDIF \s)$
\end{denotation}</p>


<!--\indexR{г амма0@$\g_0$ (начальное окружение)}-->
<!--\indexE{g amma0@$\g_0$ (начальное окружение)}-->
<p>Единственная деталь, оставшаяся недоработанной, — это начальное состояние
глобального окружения $\g_0$. Сейчас в нём нет ни одной переменной, но мы
могли бы их туда добавить. Можно сделать так, чтобы в начальном глобальном
окружении были лишь примитивы, а можно добавить туда все мыслимые переменные:
раз уж все повторные определения переменной эквивалентны присваиванию ей, то
пусть и первое будет таким же.</p>

<p>
\subsection{Автоматически расширяемое окружение}%
\label{denotational/global/ssect:autoexpand}</p>


<!--\indexR{автоматически расширяемое окружение}-->
<!--\indexR{глобальное окружение!автоматически расширяемое}-->
<p>Некоторые диалекты Лиспа делают немного по-другому: в них первое присваивание
переменной эквивалентно её определению. Это можно легко реализовать, вместо
ошибки создавая новую переменную при присваивании.</p>

<p>\begin{denotation}
$\Eval\sem*{(set! $\n$ $\p$)}\r\g\k\s = $       \\
$\quad(\Eval\sem{\p}\ \r\ \g\ \lambda \e\g_1\s_1.$\.
  $\LET \a = (\r\ \n)$                          \\
  $\IN {}$\.$\IF   \a = \ii{no-binding}$        \\
            $\THEN {}$\.$\LET \a_1 = (\g_1\ \n)$                              \\
                        $\IN {}$\.$\IF   \a_1 = \ii{no-global-binding}$       \\
                                  $\THEN {}$\*$\ii{allocate}\ \s_1\ 1$        \\
                                              \*$\lambda\s_2\a^*.$            \\
                                                $(\k\ \e\ \g_1[\n
                                                 \to \a^*\car1]\ \s_2[\a^*\car1
                                                 \to \e])$                \-\-\\
                                  $\ELSE (\k\ \e\ \g_1\ \s_1[\a_1 \to \e])$   \\
                                  $\ENDIF$                                \-\-\\
            $\ELSE (\k\ \e\ \g_1\ \s_1[\a \to \e])$                           \\
            $\ENDIF \s)$
\end{denotation}</p>

<p>Преимущество такой вариации в том, что нам больше не требуется отдельная форма
<code><span class="func">define</span></code>. Недостаток же в том, что ошибки в именах переменных становятся
менее заметными, так как никаких предупреждений о неопределённых переменных уже
не выводится.</p>

<p>
\subsection{Гиперстатическое окружение}%
\label{denotational/global/ssect:hyperstatic}</p>


<!--\indexR{гиперстатическое окружение}-->
<!--\indexR{глобальное окружение!гиперстатическое}-->
<!--\indexR{окружение!глобальное!гиперстатическое}-->
<p>В гиперстатическом случае замыкания захватывают не только локальное окружение,
но и текущее состояние глобального. Это поведение реализуется простым изменением
определения абстракции из таблицы \ref{denotational/global/fig:global-scheme}:</p>


<!--\indexC{lambda}-->
<p>\begin{denotation}
$\Eval\sem*{(lambda ($\n^*$) $\p^+$)}\r\g\k\s =$       \|
$\quad(\k\ \Inj{Значение}(\lambda\e^*\g_1\k_1\s_1.$\.
    $\IF   \#\e^* = \#\n^*$                            \\
    $\THEN {}$\*$\ii{allocate}\ \s_1\ \#\n^*$          \\
              \*$\lambda \s_2\a^*.$                    \\
                $(\Eval^+\sem{\p^+}\ \r[\n^* \to*{*}
                 \a^*]\ \g\ \k_1\ \s_2[\a^* \to*{*} \e^*])$ \-\-\\
    $\ELSE \ii{wrong}\ \dc{"Incorrect arity"}$         \\
    $\ENDIF)\ \g\ \s)$
\end{denotation}</p>

<p>Если присваивание, как в Scheme, может изменять значения только существующих
переменных, то такое определение не вызывает проблем. Если же <code><span class="func">set!</span></code> может
работать как <code><span class="func">define</span></code>, то поведение уже не всегда очевидно. Например:</p>


<!--\indexC{weird}-->
<pre>(define (weird v)
  (set! a-new-variable v) )</pre>

<p>\noindent
Присваивание внутри <code><span class="func">weird</span></code> расширяет глобальное окружение, захваченное
замыканием. Но состояние этого окружения не сохраняется между вызовами
<code><span class="func">weird</span></code>, каждый из них начинает с чистого листа.</p>


<!--\indexC{global}-->
<!--\indexR{рекурсия!взаимная}-->
<p>Также, как мы упоминали ранее, гиперстатическое глобальное окружение не дружит
со взаимно рекурсивными функциями. Можно было бы ввести специальную форму для
множественных одновременных определений, но лучше создать новый механизм для
доступа к глобальным переменным: <code><span class="func">(global $\n$)</span></code>. Эта специальная форма
позволяет обратиться к глобальной переменной $\n$ в <em class="term">любом</em> контексте,
даже если существует одноимённая локальная переменная. Следовательно, мы сможем
определять глобальные взаимно рекурсивные функции следующим образом:</p>

<pre>(letrec ((odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
         (even? (lambda (n) (if (= n 0) #t (odd? (- n 1))))) )
  (define-global odd? odd?)
  (define-global even? even?) )</pre>

<p>\begin{denotation}
$\Eval\sem*{(global $\n$)}\r\g\k\s = {}$\.
  $\LET \a = (\g\ \n)$                                  \\
  $\IN {}$\.$\IF   \a = \ii{no-global-binding}$         \\
            $\THEN \ii{wrong}\ \dc{"No such variable"}$ \\
            $\ELSE (\k\ (\s\ \a)\ \g\ \s)$              \\
            $\ENDIF$                                \-\-\|
$\Eval\sem*{(define-global $\n$ $\p$)}\r\g\k\s = $      \|
$\quad(\Eval\sem{\p}\ \r\ \g\ \lambda \e\g_1\s_1.$\.
  $\LET \a = (\g\ \n)$                                  \\
  $\IN {}$\.$\IF   \a = \ii{no-global-binding}$         \\
            $\THEN {}$\*$\ii{allocate}\ \s_1\ 1$        \\
                      \*$\lambda \s_2\a^*.$             \\
                        $(\k\ \e\ \g_1[\n \to \a^*\car1]\ %
                          \s_2[\a^*\car1 \to \e])$  \-\-\\
            $\ELSE (\k\ \e\ \g_1\ \s_1[\a \to \e])$     \\
            $\ENDIF \s)$
\end{denotation}</p>

<p>И снова мы видим, как денотационная семантика позволяет элегантно описывать
разнообразные варианты окружений. Конечно, мы также могли бы легко объединить
определённые выше окружения, получив множественные пространства имён, как это
сделано в <span class="logo">Common Lisp</span>.</p>

<h2 id="denotational/sect:beneath">Под капотом у денотаций</h2>

<p>Предназначением данной главы было снять покров таинственности с денотационной
семантики. Здесь это сделано весьма неформально (кое-кто бы поправил:
"`кощунственно"'), так как именно такой подход полезен для популяризации
денотационной семантики. Мы постепенно уточняли определяемый язык с помощью
различных интерпретаторов, одновременно с этим используя всё более и более
ограниченный язык описания; в итоге к этой главе мы дошли до чистой математики,
до денотационного интерпретатора.</p>


<!--\indexR{денотация!исполнимость}-->
<p>Scheme и λ-исчисление — дальние родственники, но всё же
родственники. Поэтому вполне возможно сделать денотации исполнимыми, чтобы
получить возможность исправить ошибки в этих запутанных уравнениях. Возможность
перепроверить правильность денотаций с помощью компьютера очень важна: так можно
убедиться в том, что язык ведёт себя именно так, как задумано; это позволяет
экспериментировать с языком без опаски что-либо сломать. Так как денотации
почти непосредственно исполнимы, отсутствует необходимость писать сложный
интерпретатор и доказывать, что он правильно понимает их семантику.</p>


<!--\indexE{LISP0@LISP2\protect\TeX}-->
<p>Поэтому писать транслятор денотаций в исполнимый код приятно и полезно. Он
не уменьшает мощь λ-исчисления, хоть и накладывает одно ограничение:
все вызовы производятся по значению (используется «плохое» правило вычислений
Scheme). Но эта не такая уж и проблема. Заявляю при свидетелях: все денотации,
приведённые в данной главе, на самом деле выполнены на Scheme и пропущены через
небольшой препроцессор (LISP2\TeX), который перевёл их на греческий
<span class="cite">[<a href="z1_bibliography.xhtml#que93d">que93d</a>]</span>. % А я захардкодил все эти закарлючки самостоятельно, да.
Представьте себе, скольких трудов стоило бы сделать денотации
исполнимыми (и протестировать их), если бы для симуляции аппликативного
λ-исчисления (в котором, к тому же, ещё и порядок вычислений должен
быть неопределённым) использовался бы не аппликативный язык!</p>


<!--\indexR{абстракция!денотация}-->
<p>Вот пример исходного кода для денотации простой абстракции (с фиксированной
арностью). Можете сравнить его с соответствующим «греческим профилем»
на странице \pageref{denotational/sematics/fig:naked-scheme}.</p>

<pre>(define ((meaning-abstraction n* e+) r k s)
  (k (inValue (lambda (v* k1 s1)
                (if (= (length v*) (length n*))
                    (allocate s1 (length n*)
                              (lambda (s2 a*)
                                ((meaning*-sequence e+)
                                 (extend* r n a*)
                                 k1
                                 (extend* s2 a* v*) ) ) )
                    (wrong "Incorrect arity") ) ))
     s ) )</pre>


<!--\indexCS{define}{синтаксис}-->
<p>Здесь используется устаревшая форма <code><span class="func">define</span></code>, которая понимает \ic{(define
($\n$ . \ii{переменные}) $\p^*$)} как \ic{(define $\n$ (lambda \ii{переменные}
$\p^*$))}, где $\n$ описывает форму вызова определяемой функции.</p>

<p>Заданные подобным образом функции ставятся под начало синтаксического
анализатора, который по получаемому выражению определяет соответствующую
функцию для его обработки. Его структура вам давно знакома:</p>


<!--\indexC{meaning}-->
<pre>(define (meaning e)
  (if (atom? e)
      (if (symbol? e) (meaning-reference e)
                      (meaning-quotation e) )
      (case (car e)
        ((quote)  (meaning-quotatione (cadr e)))
        ((lambda) (meaning-abstraction (cadr e) (cddr e)))
        ((if)     (meaning-alternative (cadr e) (caddr e) (cadddr e)))
        ((begin)  (meaning-sequence (cdr e)))
        ((set!)   (meaning-assigment (cadr e) (caddr e)))
        (else     (meaning-application (car e) (cdre))) ) ) )</pre>

<p>
\section{\texorpdfstring{λ-исчисление и Scheme}%
{λ-исчисление и Scheme}}%
\label{denotational/sect:lambdify}</p>


<!--\indexR{Лисп!и лямбда-исчисление@и λ-исчисление}-->
<!--\indexE{Scheme!и лямбда-исчисление@и λ-исчисление}-->
<p>Так как для нас важен вопрос исполнимости денотаций, то следует подробнее
разобраться в различиях между Scheme и λ-исчислением. (Естественно,
имеется в виду «целомудренное» подмножество Scheme, не испорченное побочными
эффектами, присваиваниями и т. п.) Самое главное отличие лежит в порядке
вычислений. В λ-исчислении нет фиксированного порядка, есть только
не очень хорошие порядки, которых стоит избегать. В Scheme же всё по-другому:
здесь обязателен аппликативный порядок вычислений. То есть, хоть
последовательность вычисления аргументов и не определена, но все они должны быть
вычислены до применения функции. Кроме того, это же правило запрещает вычислять
тела <code><span class="func">lambda</span></code>-форм раньше времени.</p>


<!--\indexR{обещания}-->
<p>Вызовы по имени можно проэмулировать в Scheme с помощью <em class="term">обещаний</em>
(promises, также известны как thunks, futures или delays). Обещание — это
замыкание без параметров, инкапсулирующее отложенные вычисления. Мы можем дать
обещание что-то вычислить с помощью <code><span class="func">delay</span></code> и потребовать выполнения
обещания с помощью <code><span class="func">force</span></code>. Эти функции на Scheme определяются элементарно:</p>


<!--\indexC{delay}-->
<!--\indexC{force}-->
<pre>(define-syntax delay
  (syntax-rules ()
    ((delay expression) (lambda () expression)) ) )</p>

<p>(define (force promise) (promise))</pre>


<!--\indexR{вызов!по имени!эмуляция}-->
<p>Форма <code><span class="func">delay</span></code> замыкает вычисления вместе с их окружением в обещании, которое
можно выполнить, передав его <code><span class="func">force</span></code>. Используя обещания, можно легко
проэмулировать вызов по имени, преобразуя каждый вызов <code><span class="func">($f$ $a$ ... $z$)</span></code>
в <code><span class="func">($f$ (delay $a$) ... (delay $z$))</span></code>, а когда нам внутри понадобится
значение аргумента, мы его затребуем с помощью <code><span class="func">force</span></code>. Рассмотрим пример.
Вот выражение, с которым у нас были проблемы из-за аппликативного порядка
вычислений:</p>

<pre>(((lambda (x) (lambda (y) y))|\dialect{;<code><span class="func"> $\big((\lambda x. \lambda y.
                                                y\ (\omega\ \omega))\ z\big)$</span></code>}|
  ((lambda (x) (x x)) (lambda (x) (x x))) ) z )</pre>

<p>Использовав вышеуказанный приём, мы задерживаем вычисление $(\omega\ \omega)$ до
тех пор, пока его значение не потребуется (то есть навсегда), и возвращаем
правильное значение нормальной формы этого выражения — значение свободной
переменной <code><span class="func">z</span></code>.</p>

<pre>(((lambda (x) (lambda (y) (delay y)))
  (delay ((lambda (x) ((force x) (delay (force x))))
          (lambda (x) ((force x) (delay (force x)))) )) )
 (delay z) )</pre>


<!--\indexR{мемоизация}-->
<!--\indexR{вызов!по необходимости}-->
<p>Хотя это несомненно работает <span class="cite">[<a href="z1_bibliography.xhtml#dh92">dh92</a>]</span>, но вычисления выполняются
неэффективно. Не говоря уже о бессмысленных <code><span class="func">(delay (force x))</span></code>, сейчас
каждый вызов <code><span class="func">force</span></code> требует вычислить нам значение <em>заново</em>. А ведь
мы можем вычислить его один раз, сохранить где-нибудь и впоследствии просто
возвращать уже сохранённое значение. Такой приём называется вызовом по
необходимости или <em class="term">мемоизацией</em>. Для его использования потребуется изменить
определение <code><span class="func">delay</span></code>, чтобы обещание при его выполнении запоминало результат.
К счастью, Scheme прекрасно подходит для метапрограммирования, так что
реализация такого поведения не представляет труда:</p>


<!--\indexCS{delay}{<code><span class="func">memo-delay</span></code>}-->
<pre>(define-syntax memo-delay
  (synatax-rules ()
    ((memo-delay expression)
     (let ((already-computed? #f)
           (value 'wait) )
       (lambda ()
         (if (not already-computed?)
             (begin (set! value expression)
                    (set! already-computed? #t) ) )
         value ) ) ) ) )</pre>


<!--\indexR{анализ строгости}-->
<!--\indexR{ленивые вычисления}-->
<p>Конечно, вовсе необязательно преобразовывать все вызовы вручную, когда в языке
есть макросы, см. <span class="cite">[<a href="z1_bibliography.xhtml#dfh86">dfh86</a>]</span>. Если же мы желаем максимальной эффективности, то
существует техника <em class="term">анализа строгости</em> (strictness analysis), которая
определяет, какие объекты бессмысленно заворачивать в обещания, потому что они
вычисляются всегда <span class="cite">[<a href="z1_bibliography.xhtml#bhy88">bhy88</a>]</span>. Наконец, сами обещания можно представлять иным
образом, чтобы минимизировать затраты времени на проверку <code><span class="func">(if
(not already-computed?) ...)</span></code>. Обещания добавляют в Scheme ленивые вычисления,
где преобразования лишь описываются, а выполняются уже самостоятельно и
автоматически в нужное время. Однако такой стиль программирования вызывает
очевидные затруднения при отладке, а также не особо сочетается с побочными
эффектами и продолжениями. Сравним, например, следующие программы
из \cite{kw90,mor92}, они отличаются лишь на одну <code><span class="func">delay</span></code>, но дают
совершенно различные результаты:</p>

<pre>(pair? (call/cc (lambda (k) (list (k 33)))))
(pair? (call/cc (lambda (k) (list (delay (k 33))))))</pre>

<p>
\subsection{Круговорот продолжений в природе}%
\label{denotational/lambdify/ssect:cps}</p>


<!--\indexC{call/cc}-->
<p>Только совсем уж невнимательный читатель ещё не заметил, что все денотации были
записаны в <em class="term">стиле передачи продолжений</em> (\english{continuation passing
style}). Очевидно, что мы можем транслировать любую программу на Scheme,
использует она <code><span class="func">call/cc</span></code> или нет, в её денотационный эквивалент
в λ-исчислении. Но ведь сами $\lambda$-термы тоже однозначно
представляются в виде программ на Scheme, которые не используют <code><span class="func">call/cc</span></code>.
Вопрос: а можно ли преобразовать программу на Scheme, содержащую <code><span class="func">call/cc</span></code>,
в эквивалентную программу на Scheme, но без <code><span class="func">call/cc</span></code>?</p>

<p>Ответ: да, но в этом случае нам придётся передавать продолжения явно. К счастью,
с этим нет особых проблем, так как продолжения — это те же <code><span class="func">lambda</span></code>-формы.
В действительности, некоторые компиляторы <span class="cite">[<a href="z1_bibliography.xhtml#app92a">app92a</a>]</span> намеренно переводят
компилируемые программы сначала в такой промежуточный вид, чтобы избавиться от
«особенной» формы <code><span class="func">call/cc</span></code>. Однако, у этого приёма есть и недостатки: он
сильно вредит читабельности получаемого кода, а также иногда преждевременно
вносит упорядоченность в вычисления. Тем не менее, программы, как показано
в <span class="cite">[<a href="z1_bibliography.xhtml#sf92">sf92</a>]</span>, действительно остаются эквивалентными. Преобразование,
рассматриваемое здесь, вдохновлено работой <span class="cite">[<a href="z1_bibliography.xhtml#df90">df90</a>]</span>.
В разделе \ref{cc/call/cc/ssect:cc} рассматривается иной вариант.
\seePage[cc/call/cc/ssect:cc]</p>


<!--\indexE{CPS}-->
<!--\indexR{преобразование!в CPS}-->
<!--\indexR{стиль передачи продолжений (CPS)!CPS-преобразование}-->
<p>Перейдём к реализации. Мы полагаем, что отныне всякая функция принимает
дополнительный аргумент\footnote{Он передаётся первым, чтобы упростить
работу с функциями переменной арности.} — своё продолжение. То есть
\ic{\cont*{k}(foo bar ... hux)} превращается в <code><span class="func">(foo $k$ bar ... hux)</span></code>.
С продолжениями разобрались, с функциями тоже, остались специальные формы.
Их разбор и преобразование производится обычным способом. Продолжения в них
используются точно так же, как и в денотациях: для вычисления и хранения
промежуточных результатов, а также для передачи управления следующему коду
(оставшимся вычислениям).</p>


<!--\indexC{cps}-->
<pre>(define (cps e)
  (if (atom? e) (lambda (k) (k `,e))
      (case (car e)
        ((quote)  (cps-quote (cadr e)))
        ((if)     (cps-if (cadr e) (caddr e) (cadddr e)))
        ((begin)  (cps-begin (cdr e)))
        ((set!)   (cps-set! (cadr e) (caddr e)))
        ((lambda) (cps-abstraction (cadr e) (cddr e)))
        (else     (cps-application e)) ) ) )</pre>

<p>Транслятор <code><span class="func">cps</span></code> принимает программу, выполняет преобразования и возвращает
замыкание, являющееся той же программой в стиле передачи продолжений. Такая
программа принимает своё продолжение (такое же замыкание) и возвращает результат
вычислений, представляемый ещё одним замыканием. В итоге, <code><span class="func">cps</span></code> имеет
следующий своеобразный тип:
%
\[
  \Vset{Программа} \to
      \big((\Vset{Программа} \to \Vset{Программа}) \to \Vset{Программа}\big)
\]</p>

<p>Цитирование снова элементарно:</p>


<!--\indexC{cps-quote}-->
<pre>(define (cps-quote data)
  (lambda (k)
    (k `(quote ,data)) ) )</pre>

<p>Присваивание тоже просто записывается:</p>


<!--\indexC{cps-set"!}-->
<pre>(define (cps-set! variable form)
  (lambda (k)
    ((cps form)
     (lambda (a)
       (k `(set! ,variable ,a)) ) ) ) )</pre>

<p>\noindent
Мы вычисляем новое значение переменной <code><span class="func">(cps form)</span></code>, передаём его
промежуточному продолжению через переменную <code><span class="func">a</span></code>, затем передаём результат
присваивания дальнейшей программе.</p>

<p>Условный оператор действует аналогично:</p>


<!--\indexC{cps-if}-->
<pre>(define (cps-if bool formT formF)
  (lambda (k)
    ((cps bool)
     (lambda (b)
       `(if ,b ,((cps formT) k)
               ,((cps formF) k) ) ) ) ) )</pre>

<p>Упорядочить вычисления чуть сложнее:</p>


<!--\indexC{cps-begin}-->
<pre>(define (cps-begin e)
  (if (pair? e)
      (if (pair? (cdr e))
          (let ((void (gensym "void")))
            (lambda (k)
              ((cps (car e))
               (lambda (a)
                 ((cps-begin (cdr e))
                  (lambda (b)
                    (k `((lambda (,void) ,b) ,a)) ) ) ) ) ) )
          (cps (car e)) )
      (cps '()) ) )</pre>

<p>\noindent
Здесь интересным местом является способ игнорирования промежуточных значений.</p>

<p>Самое сложное — это обработка <code><span class="func">lambda</span></code>-форм. Им всем надо добавить
ещё один аргумент — продолжение — и гарантировать правильность его
передачи. Кроме этого мы введём небольшую оптимизацию для простых функций
(которые быстро выполняются и всегда возвращают результат). Список
<code><span class="func">primitives</span></code> определяет перечень таких функций.\footnote*{Правильная
оптимизация вызовов предопределённых примитивов рассматривается
в разделе \ref{fast/fast/ssect:integrating}.}</p>


<!--\indexC{cps-application}-->
<!--\indexC{cps-terms}-->
<!--\indexC{cps-abstraction}-->
<pre>(define (cps-application e)
  (lambda (k)
    (if (memq (car e) primitives)
        ((cps-terms (cdr e))
         (lambda (t*)
           (k `(,(car e) ,@t*)) ) )
        ((cps-terms e)
         (lambda (t*)
           (let ((d (gensym)))
             `(,(car t*) (lambda (,d) ,(k d))
                         . ,(cdr t*) ) ) ) ) ) ) )</p>

<p>(define primitives '(cons car cdr list * + - = pair? eq?))</p>

<p>(define (cps-terms e*)
  (if (pair? e*)
      (lambda (k)
        ((cps (car e*))
         (lambda (a)
           ((cps-terms (cdr e*))
            (lambda (a*)
              (k (cons a a*)) ) ) ) ) )
      (lambda (k) (k '())) ) )</p>

<p>(define (cps-abstraction variables body)
  (lambda (k)
    (k (let ((c (gensym "cont")))
         `(lambda (,c . ,variables)
            ,((cps `(begin ,@body))
              (lambda (a) `(,c ,a)) ) ) )) ) )</pre>

<p>\noindent
Готово. Посмотрим, во что данная трансформация превратит факториал:</p>


<!--\indexC{fact}-->
<pre>(set! fact (lambda (n)
             (if (= n 1) 1
                 (* n (fact (- n 1))) ) ))
|$\leadsto$| (set! fact
         (lambda (cont112 n)
           (if (= n 1)
               (cont112 1)
               (fact (lambda (g113) (cont112 (* n g113)))
                     (- n 1) ) ) ) )</pre>

<p>Теперь мы автоматически получаем то, что раньше были вынуждены писать вручную.
Заметьте, что преобразование превратило программу в последовательность простых
вызовов функций: сравнений, арифметики и продолжений. Нет никаких дополнительных
особых случаев, кроме специальных форм.</p>

<p>После CPS-преобразования форма \ic{\cont*{k}(call/cc f)} превращается
в <code><span class="func">(call/cc $k$ f)</span></code>, а сама функция <code><span class="func">call/cc</span></code> становится вообще
тривиальной: <code><span class="func">(lambda (k f) (f k k))</span></code>, поэтому мы на ней и
не останавливались. Единственная загвоздка в том, чтобы сами продолжения,
возвращаемые <code><span class="func">call/cc</span></code>, оставались функциями. То есть, чтобы форма
<code><span class="func">(procedure? (apply call/cc (list call/cc)))</span></code> возвращала истину.</p>

<p>Одним из достоинств стиля передачи продолжений является то, что благодаря явному
указанию, когда что вычислять и кому возвращать результат, становится без
разницы, нормальный ли порядок принят в языке реализации или аппликативный.
В обоих случаях мы получим одинаковое поведение. Поэтому использование обещаний
совместно с подобным стилем позволяет сократить разрыв между Scheme
и λ-исчислением <span class="cite">[<a href="z1_bibliography.xhtml#dh92">dh92</a>]</span>.</p>

<h3 id="denotational/lambdify/ssect:dynamic">Динамическое окружение</h3>


<!--\indexR{динамическое окружение}-->
<!--\indexR{окружение!динамическое}-->
<p>В предыдущем разделе денотации натолкнули нас на идею преобразования программ,
позволяющего избавиться от <code><span class="func">call/cc</span></code>. Ранее мы рассматривали динамическое
окружение; а ведь мы можем аналогичным образом избавиться и от форм
<code><span class="func">dynamic-let</span></code> и <code><span class="func">dynamic</span></code>. Для этого потребуется явно ввести динамическое
окружение и определить соответствующее преобразование программ.</p>


<!--\indexE{D@$\protect\Dana$, преобразование}-->
<!--\indexR{преобразование!динамического окружения ($\protect\Dana$)}-->
<p>Предположим, у нас есть идентификатор, который не используется ни в одной
программе. Назовём его $\d$. Свяжем его с динамическим окружением — функцией,
которая по имени динамической переменной возвращает её значение. Предположим,
что у нас есть функция <code><span class="func">update</span></code>, которая умеет расширять подобное окружение
\seePage[assignment/implementation/ssect:environment], которая доступна
отовсюду, которую нельзя переопределить, перекрыть локальными переменными
и т. п. Используя всё это, можно реализовать преобразования $\Dana$
и $\Dana^*$, приведённые
в таблице \ref{denotational/lambdify/dynamic/fig:transform}.</p>

<p>\begin{table}[!ht]\setlength{\tabcolsep}{0.3em}\small%
\begin{tabular}{lcl}
$\Dana^*\sem{\,}$ & $\to$ & \\
$\Dana^*\sem{\p\ \p^*}$
    & $\to$ &
  $\Dana\sem{\p}\ \Dana^*\sem{\p^*}$                              \\
%
$\Dana\sem*{(if $\p_c$ $\p_t$ $\p_f$)}$
    & $\to$ &
  \ic{(if $\Dana\sem{\p_c}$ $\Dana\sem{\p_t}$ $\Dana\sem{\p_f}$)} \\
%
$\Dana\sem*{(begin $\p^*$)}$
    & $\to$ &
  \ic{(begin $\Dana^*\sem{\p^*}$)}                                \\
%
$\Dana\sem*{($\p$ $\p^*$)}$
    & $\to$ &
  \ic{($\Dana\sem{\p}$ $\d$ $\Dana^*\sem{\p^*}$)}                 \\
%
$\Dana\sem*{(lambda ($\n^*$) $\p^*$)}$
    & $\to$ &
  \ic{(lambda ($\d$ $\n^*$) $\Dana^*\sem{\p^*}$)}                 \\
%
$\Dana\sem*{(dynamic $\n$)}$ & $\to$ & <code><span class="func">($\d$ (quote $\n$))</span></code>   \\
%
$\Dana\sem*{(dynamic-let ($\n$ $\p$) $\p^+$)}$
    & $\to$ &
  \ic{(let (($\d$ (update $\d$ (quote $\n$) $\p$))) $\Dana^*\sem{\p^+}$)}
\end{tabular}%
\caption{Трансформация, убирающая динамическое окружение.}%
\label{denotational/lambdify/dynamic/fig:transform}%
\end{table}</p>

<p>Таким образом мы можем проэмулировать динамическое окружение, если не можем или
не хотим встраивать его поддержку в ядро языка. Последний штрих: начальное
динамическое окружение. Программа $\p$ преобразуется в</p>

<pre>(let ((|$\d$| (lambda (n) (error "No such dynamic variable" n)))) |$\Dana\sem{\p}$|)</pre>

<p>В итоге можно сделать следующий вывод: денотации специальных форм языка иногда
способны показать, что некоторые формы вовсе не такие уж и специальные.</p>

<h2 id="denotational/sect:conclusions">Заключение</h2>

<p>Данная глава венчает серию интерпретаторов, определяющих Scheme всё точнее и
точнее с использованием всё более ограниченных средств. Денотационная семантика,
по крайней мере в рассмотренном виде, позволяет очень точно и лаконично
описывать <em class="term">ядро</em> языка. Она плохо подходит для описания всего языка, его
мельчайших деталей, так как на таком уровне нотация уже чрезмерно усложняется.</p>

<p>В данной главе среди важных вещей мы не рассмотрели сравнение функций, денотацию
констант, а также всевозможные не особо важные тонкости, которые редко заметны и
ещё реже используются. Денотационная семантика прекрасно подходит для
набрасывания общей формы языка, но проработка деталей с её помощью становится
неимоверно скучной.</p>

<p>Существует огромное множество вещей, которые можно описать с помощью
денотационной семантики. Например, организовать параллелизм с помощью техники
пошаговых вычислений <span class="cite">[<a href="z1_bibliography.xhtml#que90c">que90c</a>]</span>. Или распределённое хранение и обработку
данных <span class="cite">[<a href="z1_bibliography.xhtml#que92b">que92b</a>]</span>. Но есть также вещи, которые таким образом описывать
неудобно <span class="cite">[<a href="z1_bibliography.xhtml#mcd93">mcd93</a>]</span>. К примеру, вывод типов довольно сложно выразить
денотационно, именно поэтому существует естественная семантика <span class="cite">[<a href="z1_bibliography.xhtml#kah87">kah87</a>]</span>.</p>


<h2 id="denotational/sect:exercises">Упражнения</h2>

<h5 class="exercise" id="denotational/ex:truly-random">Упражнение <span class="seq">0.0</span></h5>
<!--\indexR{интерпретатор!E@$\protect\Eval$}-->
<!--\indexE{E-@$\protect\Eval$, интерпретатор}-->
<p>Рассмотрим ещё один способ денотации аппликации. Докажите, что он эквивалентен
показанному в разделе \ref{denotational/semantics/ssect:application}.</p>

<p>\begingroup
\def\rev#1{\overline{\mathstrut\kern-0.1em #1 \kern0.1em}}
\begin{denotation}
$\Eval\sem*{($\p$ $\p^*$)}\r\k\s =
    (\Eval\sem{\p}\ \r\ \lambda \f\s_1.
        (\rev\Eval\sem{\p^*}\ \seq{}\ \r\ \lambda \e^*\s_2.
            (\f|_{\Vset{Функции}}\ \e^*\ \k\ \s_2)\ \s_1)\ \s)$   \|
$\rev\Eval\sem{\,}\e^*\r\k\s = (\k\ (\ii{reverse}\ e^*)\ \s)$     \|
$\rev\Eval\sem{\p\ \p^*}\e^*\r\k\s = (\Eval\sem{\p}\ \r\ \lambda \e\s_1.
    (\rev\Eval\sem{\p^*}\ \seq{\e}\append\e^*\ \r\ \k\ \s_1)\ \s)$
\end{denotation}
\endgroup</p>


<h5 class="exercise" id="denotational/ex:label">Упражнение <span class="seq">0.0</span></h5>
<!--\indexC{label}-->
<p>Определения из раздела \ref{denotational/sect:lambda} слишком затрудняют
описание рекурсивных функций. Мы могли бы, как в <span class="logo">Lisp 1.5</span>, ввести специальную
форму <code><span class="func">label</span></code>. В Scheme форма <code><span class="func">(label $\n$ (lambda ...))</span></code> эквивалентна
<code><span class="func">(letrec (($\n$ (lambda ...))) $\n$)</span></code>. Определите семантику аналогичного
оператора <code><span class="func">label</span></code> для λ-исчисления.</p>


<h5 class="exercise" id="denotational/ex:dynamic-fallback">Упражнение <span class="seq">0.0</span></h5>
<p>Измените денотацию <code><span class="func">dynamic</span></code> таким образом, чтобы в случае отсутствия
динамической переменной с искомым именем возвращалась одноимённая переменная
из глобального окружения.</p>


<h5 class="exercise" id="denotational/ex:quantum">Упражнение <span class="seq">0.0</span></h5>
<!--\indexR{порядок вычислений!неопределённый}-->
<p>Напишите макрос, который бы эмулировал неопределённый порядок вычисления
аргументов в такой реализации Scheme, где аргументы вычисляются слева направо.
В вашем распоряжении есть унарная функция <code><span class="func">random-permutation</span></code>, которая
принимает целое число $n$ и возвращает случайную перестановку
чисел $0, \dots, n - 1$.</p>

<p>
\section*{Рекомендуемая литература}</p>

<p>Я настойчиво рекомендую обратить внимание на книги <span class="cite">[<a href="z1_bibliography.xhtml#sto77">sto77</a>]</span> и <span class="cite">[<a href="z1_bibliography.xhtml#sch86">sch86</a>]</span>.
В обеих содержатся просто горы информации о денотационной семантике, а также
примеры денотирования языков.</p>

<p>Тем же, кого серьёзно зацепило λ-исчисление, стоит приняться за
классическую книгу <span class="cite">[<a href="z1_bibliography.xhtml#bar84">bar84</a>]</span>.</p>

<p>\endgroup % \ChapterFiveSpecials</p>

<p></body>
</html>
