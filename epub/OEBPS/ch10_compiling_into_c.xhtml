<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru">

<head>
    <title>Компиляция в Си</title>
    <link rel="stylesheet" type="text/css" href="zz_lisp.css"/>
</head>

<body id="chapter:cc">

<h1><span class="seq">Глава 10.</span> Компиляция в Си</h1>

<!--\indexR{язык!целевой}-->
<p><span class="initial"><span class="letter">И</span> ещё одна глава</span> о компиляции.
Но в этот раз мы разберём несколько новых подходов, в частности, плоские окружения, а ещё
у нас сменился целевой язык: теперь им будет Си. Подобное сочетание языков
поднимает несколько своеобразных вопросов, стоящих рассмотрения. С одной
стороны, брак с представителем более высокого сословия сулит определённые
выгоды: например, бесплатные низкоуровневые оптимизации и доступ к огромному
количеству библиотек на все случаи жизни. Но роз без шипов не бывает, так что
взамен мы отдаём хвостовую рекурсию и вдобавок получаем кучу проблем со сборкой
мусора.</p>

<div class="bigskip"/>

<!--\indexR{компиляция!в язык высокого уровня}-->
<p>Компиляция в язык высокого уровня, вроде Си, интересна во многих отношениях. Так
как целевой язык несомненно богаче ассемблера, то всё же можно надеяться на
несколько более близкий к оригиналу результат, нежели бесформенный ералаш
байт-кодов. Далее, компиляторы Си существуют практически для любой платформы,
что благотворно сказывается на переносимости. Более того, эти компиляторы
не вчера родились и имеют в своём распоряжении существенный арсенал оптимизаций,
а также неплохо справляются с рутинными низкоуровневыми задачами вроде
распределения регистров, расположения данных в памяти, выбора режимов адресации
— обо всём этом можно забыть, сфокусировавшись исключительно на
высокоуровневом аспекте компиляции.</p>

<p>С другой стороны, выбор языка высокого уровня в качестве целевого накладывает
определённые философские и практические ограничения. Подобные языки обычно
разрабатываются под определённый стиль программирования и, чаще всего, без
особого внимания к вопросу кодогенерации. В результате обнаруживаются
разнообразные «стеклянные стены» вроде не более 32 аргументов у функций, или
16 максимальных уровней вложенности блоков, и так далее. Нормальные пользователи
их даже не замечают, а вот глупые программы-генераторы то и дело натыкаются.
Бывает, что какой-то жалкий макрос раздувает программу в 5, 10, а то и в 20 раз
при переводе на Си, а потом этого монстра ещё пытаются скормить компилятору.</p>

<p>Более того, если модель исполнения целевого языка имеет мало общего с моделью
языка исходного, это плохо сказывается как на сложности самого процесса
преобразования, так и на эффективности использования возможностей целевого
языка. Си разрабатывался как язык системного программирования (изначально для
написания UNIX), поэтому в нём намеренно применяется явное управление памятью.
Вследствие этого могут возникать невероятно каверзные ошибки, если программист
не будет предельно осторожен с указателями, — иначе это лишь вопрос времени,
когда программа выйдет из-под контроля и начнёт творить непоправимое. В Лиспе
подобная ситуация невозможна в принципе, это безопасный язык в плане управления
памятью.</p>

<p>Вдобавок ко всему, Си не особо подходит для функционального стиля
программирования, где вызовы функций и рекурсия случаются на каждом шагу.
Компиляторы тщательнее оптимизируют императивные аспекты языка, поэтому
программисты стараются избегать менее эффективных в данном случае функциональных
алгоритмов, что даёт разработчикам компиляторов моральное право уделять меньше
внимания их оптимизации, так как они всё равно редко используются. Такой вот
замкнутый круг.</p>

<p>Как бы то ни было, нельзя сказать, что Си непопулярен в качестве целевого языка
компиляции Лиспа. Достаточно упомянуть Kyoto <span class="logo">Common Lisp</span>
<span class="cite">[<a href="z1_bibliography.xhtml#yh85">YH85</a>]</span> (а также
улучшенный Уильямом Скэлтером AKCL), WCL <span class="cite">[<a href="z1_bibliography.xhtml#hen92b">Hen92b</a>]</span>,
CLICC <span class="cite">[<a href="z1_bibliography.xhtml#hof93">Hof93</a>]</span>,
ECoLisp <span class="cite">[<a href="z1_bibliography.xhtml#att95">Att95</a>]</span>,
Scheme<span class="math"><span class="rel">→</span></span>C <span class="cite">[<a href="z1_bibliography.xhtml#bar89">Bar89</a>]</span>,
Sqil <span class="cite">[<a href="z1_bibliography.xhtml#sen91">Sén91</a>]</span>,
ILOG Talk <span class="cite">[<a href="z1_bibliography.xhtml#ilo94">ILO94</a>]</span>,
Bigloo <span class="cite">[<a href="z1_bibliography.xhtml#ser94">Ser94</a>]</span>.</p>

<p>Наш компилятор им не соперник. Это лишь набросок, однако имеющий достаточное
количество интересных деталей. Конечно, можно было бы пойти простым путём
(кто-то поправит: тривиальным) — взять компилятор в байт-код из
<a href="ch07_compilation.xhtml">седьмой главы</a> и переработать его, чтобы он
выводил код на Си, а не байты. Ведь для каждой машинной инструкции определена её
операционная семантика, так что не составит труда перевести их все на Си. Однако
нас ожидает совершенно иной путь, пролегающий сквозь страну плоских окружений.
<span class="see">[см. раздел <a href="ch06_fast_interpretation.xhtml#fast/fast/variations/ssect:flat">6.1.9</a>]</span> Рассматриваемый компилятор будет
многопроходным. Объектное представление обрабатываемых программ значительно
облегчит их анализ и трансформацию. По сути, именно систематический
объектно-ориентированный подход делает излагаемый в данной главе материал столь
элегантным и расширяемым.</p>


<h2 id="cc/sect:objectification"><span class="seq">10.1.</span> Объектификация</h2>

<!--\indexR{объектификация}-->
<p>В разделе <a href="ch09_macros.xhtml#macros/macrosystem/ssect:object">9.11.1</a>
рассматривался алгоритм преобразования программ в объектную форму. Он раскрывает
все макросы и в конечном итоге возвращает готовый объект класса
<code><span class="class">Program</span></code>. Чтобы разбавить это весьма
лаконичное описание, вашему вниманию предлагается
рисунок <a href="#cc/objectification/pic:result">10.1</a> с результатом объектификации
следующей далее программы. В ней, если присмотреться, можно найти каждый
изученный нами существенный аспект Scheme. Страницы не безграничны, так что
имена классов записаны сокращённо, а часть дерева и вовсе не показана. На
протяжении этой главы мы не раз будем возвращаться к данному примеру.</p>

<pre>(<span class="special">begin</span>
  (<span class="special">set!</span> <span class="var">index</span> <span class="num">1</span>)
  ((<span class="special">lambda</span> (<span class="var">cnter</span> . <span class="var">tmp</span>)
     (<span class="special">set!</span> <span class="var">tmp</span> (<span class="func">cnter</span> (<span class="special">lambda</span> (<span class="var">i</span>) (<span class="special">lambda</span> <span class="var">x</span> (<span class="func">cons</span> <span class="var">i</span> <span class="var">x</span>)))))
     (<span class="special">if</span> <span class="var">cnter</span> (<span class="func">cnter</span> <span class="var">tmp</span>) <span class="var">index</span>) )
   (<span class="special">lambda</span> (<span class="var">f</span>)
     (<span class="special">set!</span> <span class="var">index</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">index</span>))
     (<span class="func">f</span> <span class="var">index</span>) )
   '<span class="var">foo</span>) )        <span class="math"><span class="rel">→</span></span> (<span class="num">2</span> <span class="num">3</span>)</pre>

<p>\begin{figure}\centering
\input{figures/fig10.1}
\caption{Объектифицированный код.}%
\label{cc/objectification/pic:result}
\end{figure}</p>


<h2 id="cc/sect:code-walk"><span class="seq">10.2.</span> Обход кода</h2>

<!--\indexR{обход кода}-->
<!--\indexR{синтаксическое дерево}-->
<p>Обход кода является чрезвычайно важным приёмом при построении компиляторов.
<span class="cite">[<a href="z1_bibliography.xhtml#cur89">Cur89</a>,
<a href="z1_bibliography.xhtml#wat93">Wat93</a>]</span>
Суть его состоит в обходе построенного ранее дерева,
представляющего обрабатываемую программу. В процессе него собирается информация,
в узлах дерева оставляются разнообразные пометки, и так далее; всё это делается
ради облегчения следующего этапа — кодогенерации. Порядок обхода, а также
используемые структуры данных сильно зависят от поставленных целей, поэтому
какого-либо универсального алгоритма не существует. Если вдуматься, то все наши
интерпретаторы — это именно обходчики кода, которые исполняют его в процессе;
и предобработчик <code><span class="func">meaning</span></code> из <a href="ch06_fast_interpretation.xhtml">главы про быструю интерпретацию</a>
также является специализированным обходчиком.</p>

<!--\indexR{метаметод}-->
<!--\indexR{методы!метаметоды}-->
<p>Мы будем использовать всего один способ обхода дерева, но выполняемые в это
время действия могут быть различными. Для такого случая отлично подходит идиома
<em class="term">метаметода</em> (или метода высшего порядка, если хотите). Функция
<code><span class="func">update-walk!</span></code> принимает следующие аргументы: обобщённую функцию <i>g</i>,
объект <i>o</i> класса <code><span class="class">Program</span></code>, а также неопределённое количество
дополнительных аргументов для <i>g</i>. Для каждого поля <i>f</i> объекта <i>o</i>,
содержащего экземпляр <code><span class="class">Program</span></code>, она заменяет его значение результатом
аппликации <code>(<i>g</i> <i>f</i>)</code>. Возвращаемым значением <code><span class="func">update-walk!</span></code>
является обновлённый объект. Надеюсь, теперь вам стало понятно, зачем класс
<code><span class="class">Arguments</span></code>, представляющий аргументы аппликаций, сделан наследником
<code><span class="class">Program</span></code>: ведь аргументы тоже вычисляются и их надо исследовать в процессе
обхода.</p>

<!--\indexC{update-walk"!}-->
<pre>(<span class="special">define</span> (<span class="func">update-walk!</span> <span class="var">g</span> <span class="var">o</span> . <span class="var">args</span>)
  (<span class="func">for-each</span> (<span class="special">lambda</span> (<span class="var">field</span>)
              (<span class="syntax">let</span> ((<span class="var">vf</span> (<span class="func">field-value</span> <span class="var">o</span> <span class="var">field</span>)))
                (<span class="syntax">when</span> (<span class="func">Program?</span> <span class="var">vf</span>)
                  (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="special">if</span> (<span class="func">null?</span> <span class="var">args</span>) (<span class="func">g</span> <span class="var">vf</span>)
                               (<span class="func">apply</span> <span class="var">g</span> <span class="var">vf</span> <span class="var">args</span>) )))
                    (<span class="func">set-field-value!</span> <span class="var">o</span> <span class="var">v</span> <span class="var">field</span>) ) ) ) )
            (<span class="func">Class-fields</span> (<span class="func">object-&gt;class</span> <span class="var">o</span>)) )
  <span class="var">o</span> )</pre>

<p>Может показаться, что такой подход чересчур уж всё упрощает, но это
действительно весьма удобная функция для преобразования программ, как вы сами
убедитесь в дальнейшем. Очевидно, что некоторые этапы различных трансформаций
возможно объединить и выполнить за один обход дерева, ускорив тем самым
обработку. Однако, мы оградим себя от соблазна во имя чёткого разделения
эффектов применяемых трансформаций.</p>


<h2 id="cc/sect:boxes"><span class="seq">10.3.</span> Пакуем коробки</h2>

<!--\indexR{преобразование!в коробочный стиль}-->
<!--\indexR{коробки!преобразование}-->
<p>Для начала давайте заменим все локальные присваивания операциями над коробками.
Подобное преобразование уже разбиралось ранее
<span class="see">[см. раздел <a href="ch04_assignment_and_side_effects.xhtml#assignment/assignment/ssect:boxes">4.1.1</a>]</span>, поэтому оно будет хорошим примером
использования <code><span class="func">update-walk!</span></code>.</p>

<p>Итак, каждое присваивание локальной переменной должно быть изменено на помещение
соответствующего значения в коробку. Естественно, обращения к переменным тоже
преобразуются в извлечения значений из соответствующих коробок. Интерфейсом
к обходчику кода служат обобщённые функции, так что приведённые выше
преобразования надо выразить в виде одной из них. Как вы помните, коробочное
преобразование выполнялось рекурсивно для всего выражения — точно так же
должна действовать и обобщённая функция. Её совместная работа с обходчиком —
это залог успеха и основа могущества данного союза.</p>

<!--\indexC{insert-box"!}-->
<pre>(<span class="syntax">define-generic</span> (<span class="func">insert-box!</span> (<span class="var">o</span> <span class="class">Program</span>))
  (<span class="func">update-walk!</span> <span class="var">insert-box!</span> <span class="var">o</span>) )</pre>

<p>Мы введём три новых класса узлов синтаксического дерева для представления новых
понятий, необходимых при работе с коробками. Подробно каждый из классов будет
рассмотрен позже, вместе с соответствующими этапами преобразования.</p>

<!--\indexC{Box-Read}-->
<!--\indexC{Box-Write}-->
<!--\indexC{Box-Creation}-->
<pre>(<span class="syntax">define-class</span> <span class="class">Box-Read</span>     <span class="class">Program</span> (<span class="var">reference</span>))
(<span class="syntax">define-class</span> <span class="class">Box-Write</span>    <span class="class">Program</span> (<span class="var">reference</span> <span class="var">form</span>))
(<span class="syntax">define-class</span> <span class="class">Box-Creation</span> <span class="class">Program</span> (<span class="var">variable</span>))</pre>

<p>Благодаря удачному решению помечать во время объектификации изменяемые локальные
переменные флагом <code><span class="var">mutable?</span></code>, заменить обращения к подобным переменным
вызовами <code><span class="func">Box-Read</span></code> становится элементарно:</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">insert-box!</span> (<span class="var">o</span> <span class="class">Local-Reference</span>))
  (<span class="special">if</span> (<span class="func">Local-Variable-mutable?</span> (<span class="func">Local-Reference-variable</span> <span class="var">o</span>))
      (<span class="func">make-Box-Read</span> <span class="var">o</span>)
      <span class="var">o</span> ) )</pre>

<p>Преобразование присваиваний сравнимо по сложности. Присваивание локальной
переменной однозначно переводится в <code><span class="func">Box-Write</span></code>. Нужно только не забыть
о рекурсивной природе преобразования и вызвать обходчик для выражения,
вычисляющего новое значение переменной.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">insert-box!</span> (<span class="var">o</span> <span class="class">Local-Assignment</span>))
  (<span class="func">make-Box-Write</span> (<span class="func">Local-Assignment-reference</span> <span class="var">o</span>)
                  (<span class="func">insert-box!</span> (<span class="func">Local-Assignment-form</span> <span class="var">o</span>)) ) )</pre>

<p>В данный момент программа считает, что все изменяемые переменные уже разложены
по коробкам; нам остаётся лишь оправдать её ожидания. Локальные изменяемые
переменные создаются исключительно <code><span class="special">lambda</span></code>- и <code><span class="syntax">let</span></code>-формами, то есть
узлами классов <code><span class="class">Function</span></code> и <code><span class="class">Fix-Let</span></code><a class="footref" href="zz_footnotes.xhtml#foot10.1"><sup>1</sup></a>.
Идея состоит в том, чтобы поместить создание коробок перед
телом этих форм. <span class="see">[см. раздел <a href="ch04_assignment_and_side_effects.xhtml#ch4-box-transform">4.1.1</a>]</span> Просто и
понятно, так что приступаем к написанию соответствующих специализаций функции
<code><span class="func">insert-box!</span></code>. Каждая из них заказывает у вспомогательной функции необходимое
количество коробок, после чего вставляет полученные экземпляры <code><span class="class">Box-Creation</span></code>
куда следует.</p>

<!--\indexC{boxify-mutable-variables}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">insert-box!</span> (<span class="var">o</span> <span class="class">Function</span>))
  (<span class="func">set-Function-body!</span>
   <span class="var">o</span> (<span class="func">insert-box!</span>
      (<span class="func">boxify-mutable-variables</span> (<span class="func">Function-body</span> <span class="var">o</span>)
                                (<span class="func">Function-variables</span> <span class="var">o</span>) ) ) )
  <span class="var">o</span> )

(<span class="syntax">define-method</span> (<span class="func">insert-box!</span> (<span class="var">o</span> <span class="class">Fix-Let</span>))
  (<span class="func">set-Fix-Let-arguments!</span> <span class="var">o</span> (<span class="func">insert-box!</span> (<span class="func">Fix-Let-arguments</span> <span class="var">o</span>)))
  (<span class="func">set-Fix-Let-body!</span>
   <span class="var">o</span> (<span class="func">insert-box!</span>
      (<span class="func">boxify-mutable-variables</span> (<span class="func">Fix-Let-body</span> <span class="var">o</span>)
                                (<span class="func">Fix-Let-variables</span> <span class="var">o</span>) ) ) )
  <span class="var">o</span> )

(<span class="special">define</span> (<span class="func">boxify-mutable-variables</span> <span class="var">form</span> <span class="var">variables</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">variables</span>)
      (<span class="special">if</span> (<span class="func">Local-Variable-mutable?</span> (<span class="func">car</span> <span class="var">variables</span>))
          (<span class="func">make-Sequence</span>
           (<span class="func">make-Box-Creation</span> (<span class="func">car</span> <span class="var">variables</span>))
           (<span class="func">boxify-mutable-variables</span> <span class="var">form</span> (<span class="func">cdr</span> <span class="var">variables</span>)) )
          (<span class="func">boxify-mutable-variables</span> <span class="var">form</span> (<span class="func">cdr</span> <span class="var">variables</span>)) )
      <span class="var">form</span> ) )</pre>

<p>Готово. Мы полностью определили коробочное преобразование с помощью всего лишь
четырёх предельно понятных методов. Результат его выполнения можно увидеть на
рисунке <a href="#cc/boxes/pic:result">9.2</a> (показана только изменившаяся часть).</p>

<p>\begin{figure}\centering
\input{figures/fig10.2}
\caption{\protect{\dc{(lambda (cnter . tmp) (set! tmp ...) (if ... (... tmp) ...))}.}}%
\label{cc/boxes/pic:result}
\end{figure}</p>


<h2 id="cc/sect:no-nest"><span class="seq">10.4.</span> Избавляемся от вложенных функций</h2>

<!--\indexR{функции!вложенные}-->
<!--\indexR{лямбда-поднятие@$\lambda$-поднятие}-->
<!--\indexE{lambda-lifting@$\lambda$-lifting}-->
<!--\indexR{комбинаторы}-->
<!--\indexR{свободные переменные}-->
<!--\indexR{переменные!свободные}-->
<p>Язык Си не позволяет определять функции внутри других функций. Иными словами,
вложенные <code><span class="special">lambda</span></code>-формы нельзя прямо перевести на Си. Следовательно, от них
необходимо избавиться, преобразовав программу в набор комбинаторов — функций
без свободных переменных. К счастью, это довольно известное преобразование,
называемое <em class="term">λ-поднятием</em> (λ-lifting) — в результате
него <code><span class="special">lambda</span></code>-формы поднимаются вверх, до самой поверхности, не оставляя
ни одной свободной переменной в глубине программы. Существует множество
вариантов реализации подобного преобразования, по-разному обращающихся
с исходными функциями и сохраняющих те или иные их аспекты, например:
<span class="cite">[<a href="z1_bibliography.xhtml#ws94">WS94</a>,
<a href="z1_bibliography.xhtml#kh89">KH89</a>,
<a href="z1_bibliography.xhtml#ch94">CH94</a>]</span>.</p>

<!--\indexR{замыкания (closures)}-->
<!--\indexC{invoke}-->
<p>Результатом вычисления любой <code><span class="special">lambda</span></code>-формы является замыкание — сущность,
сохраняющая в себе окружение, где она была создана. При вызове замыкания
специальная функция (известная как <code><span class="func">invoke</span></code>) берёт на себя работу по
организации вычисления тела данного замыкания в правильном окружении,
составленном из аргументов функции, находящихся в окружении вызова, и свободных
переменных, извлекаемых из замкнутого окружения. Фактически, это единственная
функция, которой известна истинная природа замыканий, поэтому мы можем довольно
легко изменить их структуру, не потревожив остальные части программы: ведь
каждая аппликация в конечном итоге выполняется <code><span class="func">invoke</span></code>.</p>

<!--\indexR{ОО-подъём}-->
<!--\indexE{OO-lifting}-->
<p>Рассмотрим упомянутое преобразование на примере <em class="term">ОО-подъёма</em>, описанного
в <span class="cite">[<a href="z1_bibliography.xhtml#que94">Que94</a>]</span>. Как обычно, морской свинкой будет факториал:</p>

<!--\indexC{fact}-->
<pre>(<span class="special">define</span> (<span class="func">fact</span> <span class="var">n</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) (<span class="func">k</span> <span class="num">1</span>)
      (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>) (<span class="special">lambda</span> (<span class="var">r</span>) (<span class="func">k</span> (<span class="func">*</span> <span class="var">n</span> <span class="var">r</span>))) ) ) )</pre>

<p>От <code><span class="special">lambda</span></code>-формы со свободными переменными <code><span class="var">k</span></code> и <code><span class="var">n</span></code> можно избавиться
следующим образом:</p>

<pre>(<span class="syntax">define-class</span> <span class="class">Fact-Closure</span> <span class="class">Object</span> (<span class="var">n</span> <span class="var">k</span>))

(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">f</span> <span class="class">Fact-Closure</span>) <span class="var">r</span>)
  (<span class="func">invoke</span> (<span class="func">Fact-Closure-k</span> <span class="var">f</span>) (<span class="func">*</span> (<span class="func">Fact-Closure-n</span> <span class="var">f</span>) <span class="var">r</span>)) )

(<span class="special">define</span> (<span class="func">fact</span> <span class="var">n</span> <span class="var">k</span>)
  (<span class="special">if</span> (<span class="func">=</span> <span class="var">n</span> <span class="num">0</span>) (<span class="func">invoke</span> <span class="var">k</span> <span class="num">1</span>)
      (<span class="func">fact</span> (<span class="func">-</span> <span class="var">n</span> <span class="num">1</span>) (<span class="func">make-Fact-Closure</span> <span class="var">n</span> <span class="var">k</span>)) ) )</pre>

<!--\indexR{плоские окружения}-->
<!--\indexR{окружение!плоское}-->
<p>Суть преобразования состоит в замене неявной структуры создаваемого анонимного
замыкания явным объектом класса <code><span class="class">Fact-Closure</span></code>, содержащим все необходимые
свободные переменные (здесь это <code><span class="var">n</span></code> и <code><span class="var">k</span></code>). После этого остаётся только
научить <code><span class="func">invoke</span></code> корректным образом обрабатывать подобные объекты.</p>


<!--\indexR{преобразование!замыканий в комбинаторы}-->
<p>Для выполнения такого преобразования вначале надо как-то получить и где-то
сохранить список свободных переменных обрабатываемых функций. Для этого введём
новый класс преобразованных функций — <code><span class="class">Flat-Function</span></code>, а их свободные
переменные будем собирать в списки из <code><span class="class">Free-Environment</span></code>, заканчивающиеся на
<code><span class="class">No-Free</span></code>. Как и их братья <code><span class="class">Arguments</span></code> и <code><span class="class">No-Argument</span></code>, эти два класса
являются наследниками <code><span class="class">Program</span></code>, потому что представляют вычислимые понятия.
Обращения к свободным переменным тоже будут преобразованы в специальные объекты
класса <code><span class="class">Free-Reference</span></code>.</p>

<!--\indexC{Flat-Function}-->
<!--\indexC{Free-Environment}-->
<!--\indexC{Free-Reference}-->
<!--\indexC{No-Free}-->
<pre>(<span class="syntax">define-class</span> <span class="class">Flat-Function</span>    <span class="class">Function</span>  (<span class="var">free</span>))
(<span class="syntax">define-class</span> <span class="class">Free-Environment</span> <span class="class">Program</span>   (<span class="var">first</span> <span class="var">others</span>))
(<span class="syntax">define-class</span> <span class="class">No-Free</span>          <span class="class">Program</span>   ())
(<span class="syntax">define-class</span> <span class="class">Free-Reference</span>   <span class="class">Reference</span> ())</pre>

<p>Реализуется это преобразование, естественно, с помощью обходчика кода. Функция
<code><span class="func">lift!</span></code> будет служить удобным интерфейсом, а всю чёрную работу мы переложим
на обобщённую функцию <code><span class="func">lift-procedures!</span></code>. Помимо обрабатываемой функции, она
принимает два вспомогательных аргумента: абстракцию <code><span class="var">flatfun</span></code>, которая
в конечном итоге будет содержать все свободные переменные, и список <code><span class="var">vars</span></code>,
где лежат все переменные, который на данный момент связаны. По умолчанию
<code><span class="func">lift-procedures!</span></code> просто рекурсивно вызывается для всех дочерних узлов
обрабатываемой программы.</p>

<!--\indexC{lift"!}-->
<!--\indexC{lift-procedures"!}-->
<pre>(<span class="special">define</span> (<span class="func">lift!</span> <span class="var">o</span>)
  (<span class="func">lift-procedures!</span> <span class="var">o</span> <span class="hash">#f</span> <span class="hash">'()</span>) )

(<span class="syntax">define-generic</span> (<span class="func">lift-procedures!</span> (<span class="var">o</span> <span class="class">Program</span>) <span class="var">flatfun</span> <span class="var">vars</span>)
  (<span class="func">update-walk!</span> <span class="var">lift-procedures!</span> <span class="var">o</span> <span class="var">flatfun</span> <span class="var">vars</span>) )</pre>

<p>Преобразование определяется всего тремя методами. Первый из них отвечает за
обработку обращений к свободным переменным и поддержание списка <code><span class="var">flatfun</span></code>
в адекватном состоянии. Функция <code><span class="func">adjoin-free-variable!</span></code> помогает с занесением
новых свободных переменных в этот список.</p>

<!--\indexC{adjoin-free-variable"!}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">lift-procedures!</span> (<span class="var">o</span> <span class="class">Local-Reference</span>) <span class="var">flatfun</span> <span class="var">vars</span>)
  (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">Local-Reference-variable</span> <span class="var">o</span>)))
    (<span class="special">if</span> (<span class="func">memq</span> <span class="var">v</span> <span class="var">vars</span>) <span class="var">o</span>
        (<span class="special">begin</span> (<span class="func">adjoin-free-variable!</span> <span class="var">flatfun</span> <span class="var">o</span>)
               (<span class="func">make-Free-Reference</span> <span class="var">v</span>) ) ) ) )

(<span class="special">define</span> (<span class="func">adjoin-free-variable!</span> <span class="var">flatfun</span> <span class="var">ref</span>)
  (<span class="syntax">when</span> (<span class="func">Flat-Function?</span> <span class="var">flatfun</span>)
    (<span class="syntax">let</span> <span class="func">check</span> ((<span class="var">free*</span> (<span class="func">Flat-Function-free</span> <span class="var">flatfun</span>)))
      (<span class="special">if</span> (<span class="func">No-Free?</span> <span class="var">free*</span>)
          (<span class="func">set-Flat-Function-free!</span>
           <span class="var">flatfun</span> (<span class="func">make-Free-Environment</span>
                    <span class="var">ref</span> (<span class="func">Flat-Function-free</span> <span class="var">flatfun</span>) ) )
          (<span class="syntax">unless</span> (<span class="func">eq?</span> (<span class="func">Reference-variable</span> <span class="var">ref</span>)
                       (<span class="func">Reference-variable</span>
                        (<span class="func">Free-Environment-first</span> <span class="var">free*</span>) ) )
            (<span class="func">check</span> (<span class="func">Free-Environment-others</span> <span class="var">free*</span>)) ) ) ) ) )</pre>

<!--\indexR{приводимые!формы}-->
<!--\indexR{форма!приводимая}-->
<p>Как известно, форма <code><span class="syntax">let</span></code> создаёт локальные привязки, поэтому перед
обработкой тела <code><span class="class">Fix-Let</span></code> необходимо поместить все свежесозданные связанные
переменные в список <code><span class="var">vars</span></code>. Ещё одним неоспоримым фактом является то, что
приводимые формы, к которым относится <code><span class="syntax">let</span></code>, лишь вводят новые переменные и
не требуют создания замыканий. Это очень важная оптимизация, и мы отнюдь
не хотим её лишиться.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">lift-procedures!</span> (<span class="var">o</span> <span class="class">Fix-Let</span>) <span class="var">flatfun</span> <span class="var">vars</span>)
  (<span class="func">set-Fix-Let-arguments!</span>
   <span class="var">o</span> (<span class="func">lift-procedures!</span> (<span class="func">Fix-Let-arguments</span> <span class="var">o</span>) <span class="var">flatfun</span> <span class="var">vars</span>) )
  (<span class="syntax">let</span> ((<span class="var">newvars</span> (<span class="func">append</span> (<span class="func">Fix-Let-variables</span> <span class="var">o</span>) <span class="var">vars</span>)))
    (<span class="func">set-Fix-Let-body!</span>
     <span class="var">o</span> (<span class="func">lift-procedures!</span> (<span class="func">Fix-Let-body</span> <span class="var">o</span>) <span class="var">flatfun</span> <span class="var">newvars</span>) )
    <span class="var">o</span> ) )</pre>

<p>Наконец, остался самый сложный случай — абстракции. Тело абстракции
анализируется и все её свободные переменные собираются в объекте
<code><span class="class">Flat-Function</span></code>. Так как свободные переменные вложенной абстракции сами могут
оказаться свободными в содержащей её абстракции, то для них обходчик вызывается
ещё раз, чтобы протолкнуть их как можно выше. Сейчас самое время порадоваться
принятому ранее решению сделать список свободных переменных наследником
<code><span class="class">Program</span></code>.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">lift-procedures!</span> (<span class="var">o</span> <span class="class">Function</span>) <span class="var">flatfun</span> <span class="var">vars</span>)
  (<span class="syntax">let*</span> ((<span class="var">localvars</span> (<span class="func">Function-variables</span> <span class="var">o</span>))
         (<span class="var">body</span>      (<span class="func">Function-body</span> <span class="var">o</span>))
         (<span class="var">newfun</span> (<span class="func">make-Flat-Function</span> <span class="var">localvars</span> <span class="var">body</span> (<span class="func">make-No-Free</span>))) )
    (<span class="func">set-Flat-Function-body!</span>
     <span class="var">newfun</span> (<span class="func">lift-procedures!</span> <span class="var">body</span> <span class="var">newfun</span> <span class="var">localvars</span>) )
    (<span class="syntax">let</span> ((<span class="var">free*</span> (<span class="func">Flat-Function-free</span> <span class="var">newfun</span>)))
      (<span class="func">set-Flat-Function-free!</span>
       <span class="var">newfun</span> (<span class="func">lift-procedures!</span> <span class="var">free*</span> <span class="var">flatfun</span> <span class="var">vars</span>) ) )
    <span class="var">newfun</span> ) )</pre>

<p>Как полагается, на рисунке <a href="#cc/no-nest/pic:result">10.3</a> показан результат
применения рассмотренного преобразования к нашему бессменному примеру.</p>

<p>\begin{figure}\centering
\input{figures/fig10.3}
\caption{\protect\dc{(lambda (i) (lambda x (cons i x)))}.}%
\label{cc/no-nest/pic:result}
\end{figure}</p>


<h2 id="cc/sect:collecting"><span class="seq">10.5.</span> Собираем цитаты и функции</h2>

<!--\indexR{миграция!цитат}-->
<!--\indexR{миграция!вложенных функций}-->
<p>Предыдущее преобразование не изменяло расположения функций: вложенные
<code><span class="special">lambda</span></code>-формы так и остались вложенными,
пусть и без свободных переменных.
Нет, мы не забыли об этом! Просто немного задержались, чтобы выполнить перенос
вместе со следующим преобразованием — извлечением цитат. Во время следующего
обхода кода мы извлечём все используемые цитаты и определения функций, чтобы
перенести их на глобальный уровень, как этого требует Си. Здесь понадобятся
всего два метода.</p>

<p>Функция <code><span class="func">extract-things!</span></code> преобразовывает объекты <code><span class="class">Program</span></code> в объекты
<code><span class="class">Flattened-Program</span></code>. Новый класс является наследником <code><span class="class">Program</span></code> и имеет
три дополнительных поля: <code><span class="var">form</span></code> для собственно программы, <code><span class="var">quotations</span></code> для
списка цитат и <code><span class="var">definitions</span></code> для определений функций. До значений цитат можно
добраться через глобальные переменные нового класса <code><span class="class">Quotation-Variable</span></code>.
Функции мы просто пронумеруем, выдав каждой из них уникальный <code><span class="var">index</span></code>.
Наконец, создание замыканий перекладывается на новый тип узлов синтаксического
дерева — <code><span class="class">Closure-Creation</span></code>. (Не волнуйтесь, скоро вам станет ясно, почему
всё сделано именно так.)</p>

<!--\indexC{Flattened-Program}-->
<!--\indexC{Quotation-Variable}-->
<!--\indexC{Function-Definition}-->
<!--\indexC{Closure-Creation}-->
<pre>(<span class="syntax">define-class</span> <span class="class">Flattened-Program</span>   <span class="class">Program</span> (<span class="var">form</span> <span class="var">quotations</span> <span class="var">definitions</span>))
(<span class="syntax">define-class</span> <span class="class">Quotation-Variable</span>  <span class="class">Variable</span> (<span class="var">value</span>))
(<span class="syntax">define-class</span> <span class="class">Function-Definition</span> <span class="class">Flat-Function</span> (<span class="var">index</span>))
(<span class="syntax">define-class</span> <span class="class">Closure-Creation</span>    <span class="class">Program</span> (<span class="var">index</span> <span class="var">variables</span> <span class="var">free</span>))</pre>

<p>Строго говоря, <code><span class="func">extract-things!</span></code> работает не одна, а вместе с обобщённой
функцией <code><span class="func">extract!</span></code>. Взаимодействие подразумевает обмен информацией. Дабы
не прибегать для этого к глобальным переменным (например, ради распараллеливания
компиляции), мы будем возвращать результат через специальный аргумент,
передаваемый обобщённой функции.</p>

<!--\indexC{extract-things}-->
<!--\indexC{extract"!}-->
<pre>(<span class="special">define</span> (<span class="func">extract-things!</span> <span class="var">o</span>)
  (<span class="syntax">let</span> ((<span class="var">result</span> (<span class="func">make-Flattened-Program</span> <span class="var">o</span> <span class="hash">'()</span> <span class="hash">'()</span>)))
    (<span class="func">set-Flattened-Program-form!</span> <span class="var">result</span> (<span class="func">extract!</span> <span class="var">o</span> <span class="var">result</span>))
    <span class="var">result</span> ) )

(<span class="syntax">define-generic</span> (<span class="func">extract!</span> (<span class="var">o</span> <span class="class">Program</span>) <span class="var">result</span>)
  (<span class="func">update-walk!</span> <span class="var">extract!</span> <span class="var">o</span> <span class="var">result</span>) )</pre>

<p>Цитаты просто собираются в отведённом для них поле, а все обращения к ним
заменяются обращениями к соответствующим глобальным переменным,
инициализированным значениями исходных цитат.</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">extract!</span> (<span class="var">o</span> <span class="class">Constant</span>) <span class="var">result</span>)
  (<span class="syntax">let*</span> ((<span class="var">qv*</span> (<span class="func">Flattened-Program-quotations</span> <span class="var">result</span>))
         (<span class="var">qv</span>  (<span class="func">make-Quotation-Variable</span> (<span class="func">length</span> <span class="var">qv*</span>)
                                       (<span class="func">Constant-value</span> <span class="var">o</span>) )) )
    (<span class="func">set-Flattened-Program-quotations!</span> <span class="var">result</span> (<span class="func">cons</span> <span class="var">qv</span> <span class="var">qv*</span>))
    (<span class="func">make-Global-Reference</span> <span class="var">qv</span>) ) )</pre>

<p>Абстракции находятся в узлах типа <code><span class="class">Flat-Function</span></code>, которые преобразуются
в экземпляры <code><span class="class">Closure-Creation</span></code>. Процесс можно было бы оптимизировать,
избежав дублирования кода для одинаковых абстракций, научив
<code><span class="func">adjoin-definition!</span></code> отыскивать повторения. Также может показаться странным,
что столько внимания уделяется спискам свободных переменных изначальных
абстракций. Это делается исключительно для облегчения определения арности
функций во время генерации Си-кода.</p>

<!--\indexC{adjoin-definition"!}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">extract!</span> (<span class="var">o</span> <span class="class">Flat-Function</span>) <span class="var">result</span>)
  (<span class="syntax">let*</span> ((<span class="var">newbody</span>   (<span class="func">extract!</span> (<span class="func">Flat-Function-body</span> <span class="var">o</span>) <span class="var">result</span>))
         (<span class="var">variables</span> (<span class="func">Flat-Function-variables</span> <span class="var">o</span>))
         (<span class="var">freevars</span>  (<span class="syntax">let</span> <span class="func">extract</span> ((<span class="var">free</span> (<span class="func">Flat-Function-free</span> <span class="var">o</span>)))
                      (<span class="special">if</span> (<span class="func">Free-Environment?</span> <span class="var">free</span>)
                          (<span class="func">cons</span> (<span class="func">Reference-variable</span>
                                 (<span class="func">Free-Environment-first</span> <span class="var">free</span>) )
                                (<span class="func">extract</span>
                                 (<span class="func">Free-Environment-others</span> <span class="var">free</span>) ) )
                          <span class="hash">'()</span> ) ))
         (<span class="var">index</span> (<span class="func">adjoin-definition!</span>
                 <span class="var">result</span> <span class="var">variables</span> <span class="var">newbody</span> <span class="var">freevars</span> )) )
    (<span class="func">make-Closure-Creation</span> <span class="var">index</span> <span class="var">variables</span> (<span class="func">Flat-Function-free</span> <span class="var">o</span>)) ) )

(<span class="special">define</span> (<span class="func">adjoin-definition!</span> <span class="var">result</span> <span class="var">variables</span> <span class="var">body</span> <span class="var">free</span>)
  (<span class="syntax">let*</span> ((<span class="var">definitions</span> (<span class="func">Flattened-Program-definitions</span> <span class="var">result</span>))
         (<span class="var">newindex</span> (<span class="func">length</span> <span class="var">definitions</span>)) )
    (<span class="func">set-Flattened-Program-definitions!</span>
     <span class="var">result</span> (<span class="func">cons</span> (<span class="func">make-Function-Definition</span>
                   <span class="var">variables</span> <span class="var">body</span> <span class="var">free</span> <span class="var">newindex</span> )
                  <span class="var">definitions</span> ) )
    <span class="var">newindex</span> ) )</pre>

<p>И снова, на рисунке <a href="#cc/collecting/pic:result">10.4</a> показан результат применения
преобразования к иной части примера.</p>

<p>\begin{figure}\centering
\input{figures/fig10.4}
\caption{\protect\dc{(begin (set! index 1) ((lambda ...) ... ))}.}%
\label{cc/collecting/pic:result}
\end{figure}</p>

<p id="cc/collecting/par:main">Наконец, вся программа превращается в вызов одной
огромной функции. То есть <span class="math"><span class="ord var">π</span></span>
становится <code>((<span class="special">lambda</span> () <span class="math"><span class="ord var">π</span></span>))</code>.</p>

<!--\indexC{closurize-main"!}-->
<pre>(<span class="special">define</span> (<span class="func">closurize-main!</span> <span class="var">o</span>)
  (<span class="syntax">let</span> ((<span class="var">index</span> (<span class="func">length</span> (<span class="func">Flattened-Program-definitions</span> <span class="var">o</span>))))
    (<span class="func">set-Flattened-Program-definitions!</span>
     <span class="var">o</span> (<span class="func">cons</span> (<span class="func">make-Function-Definition</span>
              <span class="hash">'()</span> (<span class="func">Flattened-Program-form</span> <span class="var">o</span>) <span class="hash">'()</span> <span class="var">index</span> )
             (<span class="func">Flattened-Program-definitions</span> <span class="var">o</span>) ) )
    (<span class="func">set-Flattened-Program-form!</span>
     <span class="var">o</span> (<span class="func">make-Regular-Application</span>
        (<span class="func">make-Closure-Creation</span> <span class="var">index</span> <span class="hash">'()</span> (<span class="func">make-No-Free</span>))
        (<span class="func">make-No-Argument</span>) ) )
    <span class="var">o</span> ) )</pre>


<h2 id="cc/sect:tmp"><span class="seq">10.6.</span> Собираем временные переменные</h2>

<p>У автора всегда есть решительное преимущество перед читателем в том, что он
знает, что хочет получить, а вы пока ещё не знаете, что получится в результате.
В надежде на оригинальность, выражения Scheme было решено переводить
в выражения Си. Это выглядит немного эксцентричным, так как язык Си вообще-то
построен вокруг инструкций (statements), а не выражений (expressions), но такое
представление позволяет сохранить структуру Scheme в получаемой на выходе
программе. Правда, в этом случае возникает проблема с переводом узлов типа
<code><span class="class">Fix-Let</span></code>, так как в языке Си нельзя
создавать локальные переменные внутри выражений<a class="footref" href="zz_footnotes.xhtml#foot10.2"><sup>2</sup></a>, только с помощью
отдельных инструкций. Поэтому мы вынуждены будем пробежаться по всем
<code><span class="class">Fix-Let</span></code> и провести учёт всех локальных переменных, вводимых ими, чтобы
впоследствии корректно их объявить.</p>

<p>Естественно, для этого выполняется ещё один проход по коду. Задачей данного
прохода будет сбор всех локальных переменных форм
<code><span class="class">Fix-Let</span></code> в одном месте,
а также их переименование для предотвращения коллизий. Функции, имеющие
временные локальные переменные, мы будем представлять подклассом
<code><span class="class">Function-Definition</span></code>,
называемым <code><span class="class">With-Temp-Function-Definition</span></code>.</p>


<!--\indexC{With-Temp-Function-Definition}-->
<pre>(<span class="syntax">define-class</span> <span class="class">With-Temp-Function-Definition</span> <span class="class">Function-Definition</span>
  ( <span class="var">temporaries</span> ) )</pre>

<p>Функция <code><span class="func">gather-temporaries!</span></code> реализует преобразование. Она полагается на
обобщённую функцию <code><span class="func">collect-temporaries!</span></code>, работающую в паре с обходчиком.
Вторым аргументом данной функции является объект, куда она будет складывать
обнаруженные переменные, а третий хранит список соответствий старых имён новым,
необходимый для выполнения переименований.</p>

<!--\indexC{gather-temporaries"!}-->
<!--\indexC{collect-temporaries"!}-->
<pre>(<span class="special">define</span> (<span class="func">gather-temporaries!</span> <span class="var">o</span>)
  (<span class="func">set-Flattened-Program-definitions!</span>
   <span class="var">o</span> (<span class="func">map</span> (<span class="special">lambda</span> (<span class="var">def</span>)
            (<span class="syntax">let</span> ((<span class="var">flatfun</span> (<span class="func">make-With-Temp-Function-Definition</span>
                            (<span class="func">Function-Definition-variables</span> <span class="var">def</span>)
                            (<span class="func">Function-Definition-body</span> <span class="var">def</span>)
                            (<span class="func">Function-Definition-free</span> <span class="var">def</span>)
                            (<span class="func">Function-Definition-index</span> <span class="var">def</span>)
                            <span class="hash">'()</span> )))
              (<span class="func">collect-temporaries!</span> <span class="var">flatfun</span> <span class="var">flatfun</span> <span class="hash">'()</span>) ) )
          (<span class="func">Flattened-Program-definitions</span> <span class="var">o</span>) ) )
  <span class="var">o</span> )

(<span class="syntax">define-generic</span> (<span class="func">collect-temporaries!</span> (<span class="var">o</span> <span class="class">Program</span>) <span class="var">flatfun</span> <span class="var">r</span>)
  (<span class="func">update-walk!</span> <span class="var">collect-temporaries!</span> <span class="var">o</span> <span class="var">flatfun</span> <span class="var">r</span>) )</pre>

<p>Для завершения преобразования остаётся определить три новых метода. Локальные
переменные при необходимости могут переименовываться, то же самое касается и
переменных в коробках:</p>

<pre>(<span class="syntax">define-method</span> (<span class="func">collect-temporaries!</span> (<span class="var">o</span> <span class="class">Local-Reference</span>) <span class="var">flatfun</span> <span class="var">r</span>)
  (<span class="syntax">let*</span> ((<span class="var">variable</span> (<span class="func">Local-Reference-variable</span> <span class="var">o</span>))
         (<span class="var">v</span> (<span class="func">assq</span> <span class="var">variable</span> <span class="var">r</span>)) )
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">v</span>) (<span class="func">make-Local-Reference</span> (<span class="func">cdr</span> <span class="var">v</span>))
                  <span class="var">o</span> ) ) )

(<span class="syntax">define-method</span> (<span class="func">collect-temporaries!</span> (<span class="var">o</span> <span class="class">Box-Creation</span>) <span class="var">flatfun</span> <span class="var">r</span>)
  (<span class="syntax">let*</span> ((<span class="var">variable</span> (<span class="func">Box-Creation-variable</span> <span class="var">o</span>))
         (<span class="var">v</span> (<span class="func">assq</span> <span class="var">variable</span> <span class="var">r</span>)) )
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">v</span>) (<span class="func">make-Box-Creation</span> (<span class="func">cdr</span> <span class="var">v</span>))
                  <span class="var">o</span> ) ) )</pre>

<p>Самый сложный метод, конечно же, будет для <code><span class="class">Fix-Let</span></code>. Сначала он рекурсивно
вызывается для всех её аргументов, после чего переименовывает локальные
переменные с помощью функции <code><span class="func">new-renamed-variable</span></code>. Затем эти новые
переменные добавляются в определение обрабатываемой формы, а
<code><span class="func">collect-temporaries!</span></code> ещё раз рекурсивно вызывается уже для её тела,
помещённого в обновлённое окружение.</p>

<!--\indexC{adjoin-temporary-variables"!}-->
<pre>(<span class="syntax">define-method</span> (<span class="func">collect-temporaries!</span> (<span class="var">o</span> <span class="class">Fix-Let</span>) <span class="var">flatfun</span> <span class="var">r</span>)
  (<span class="func">set-Fix-Let-arguments!</span>
   <span class="var">o</span> (<span class="func">collect-temporaries!</span> (<span class="func">Fix-Let-arguments</span> <span class="var">o</span>) <span class="var">flatfun</span> <span class="var">r</span>) )
  (<span class="syntax">let*</span> ((<span class="var">newvars</span> (<span class="func">map</span> <span class="var">new-renamed-variable</span> (<span class="func">Fix-Let-variables</span> <span class="var">o</span>)))
         (<span class="var">newr</span> (<span class="func">append</span> (<span class="func">map</span> <span class="var">cons</span> (<span class="func">Fix-Let-variables</span> <span class="var">o</span>) <span class="var">newvars</span>) <span class="var">r</span>)) )
    (<span class="func">adjoin-temporary-variables!</span> <span class="var">flatfun</span> <span class="var">newvars</span>)
    (<span class="func">set-Fix-Let-variables!</span> <span class="var">o</span> <span class="var">newvars</span>)
    (<span class="func">set-Fix-Let-body!</span>
     <span class="var">o</span> (<span class="func">collect-temporaries!</span> (<span class="func">Fix-Let-body</span> <span class="var">o</span>) <span class="var">flatfun</span> <span class="var">newr</span>) )
    <span class="var">o</span> ) )

(<span class="special">define</span> (<span class="func">adjoin-temporary-variables!</span> <span class="var">flatfun</span> <span class="var">newvars</span>)
  (<span class="syntax">let</span> <span class="func">adjoin</span> ((<span class="var">temps</span> (<span class="func">With-Temp-Function-Definition-temporaries</span>
                       <span class="var">flatfun</span> ))
               (<span class="var">vars</span> <span class="var">newvars</span>) )
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">vars</span>)
        (<span class="special">if</span> (<span class="func">memq</span> (<span class="func">car</span> <span class="var">vars</span>) <span class="var">temps</span>)
            (<span class="func">adjoin</span> <span class="var">temps</span> (<span class="func">cdr</span> <span class="var">vars</span>))
            (<span class="func">adjoin</span> (<span class="func">cons</span> (<span class="func">car</span> <span class="var">vars</span>) <span class="var">temps</span>) (<span class="func">cdr</span> <span class="var">vars</span>)) )
        (<span class="func">set-With-Temp-Function-Definition-temporaries!</span>
         <span class="var">flatfun</span> <span class="var">temps</span> ) ) ) )</pre>

<p>Переименованные переменные выделяются в собственный подкласс. Ещё нам
потребуется счётчик для обеспечения уникальности их имён.</p>

<!--\indexC{Renamed-Local-Variable}-->
<!--\indexC{renaming-variable-counter}-->
<!--\indexC{new-renamed-variable}-->
<pre>(<span class="syntax">define-class</span> <span class="class">Renamed-Local-Variable</span> <span class="class">Variable</span> (<span class="var">index</span>))

(<span class="special">define</span> <span class="var">renaming-variable-counter</span> <span class="num">0</span>)

(<span class="syntax">define-generic</span> (<span class="func">new-renamed-variable</span> (<span class="var">variable</span>)))

(<span class="syntax">define-method</span> (<span class="func">new-renamed-variable</span> (<span class="var">variable</span> <span class="class">Local-Variable</span>))
  (<span class="special">set!</span> <span class="var">renaming-variable-counter</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">renaming-variable-counter</span>))
  (<span class="func">make-Renamed-Local-Variable</span>
   (<span class="func">Variable-name</span> <span class="var">variable</span>) <span class="var">renaming-variable-counter</span> ) )</pre>


<h2 id="cc/sect:pause"><span class="seq">10.7.</span> Передышка</h2>

<p>Следующая программа на Scheme является финальным результатом метаморфоз,
произошедших с показанным в самом начале главы примером. Итого:</p>

<ol>
  <li>Изменяемые переменные разложены по коробками.</li>
  <li>Вложенные функции не используются.</li>
  <li>Все цитаты и определения функций вынесены наверх.</li>
  <li>Временные переменные создаются явно.</li>
</ol>

<pre>(<span class="special">define</span> <span class="var">quote_5</span> '<span class="var">foo</span>)                    <span class="comment">; собранные цитаты</span>
(<span class="syntax">define-class</span> <span class="class">Closure_0</span> <span class="class">Object</span> ())       <span class="comment">; абстракция <code>(<span class="special">lambda</span> (<span class="var">f</span>) ...)</code></span>
(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">self</span> <span class="class">Closure_0</span>) <span class="var">f</span>)
  (<span class="special">begin</span>
    (<span class="special">set!</span> <span class="var">index</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">index</span>))
    (<span class="func">invoke</span> <span class="var">f</span> <span class="var">index</span>) ) )                 <span class="comment">; вызов функции</span>
(<span class="syntax">define-class</span> <span class="class">Closure_1</span> <span class="class">Object</span> (<span class="var">i</span>))      <span class="comment">; абстракция <code>(<span class="special">lambda</span> (<span class="var">x</span>) ...)</code></span>
(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">self</span> <span class="class">Closure_1</span>) . <span class="var">x</span>)
  (<span class="func">cons</span> (<span class="func">Closure_1-i</span> <span class="var">self</span>)               <span class="comment">; свободная переменная <code><span class="var">i</span></code></span>
        <span class="var">x</span> ) )
(<span class="syntax">define-class</span> <span class="class">Closure_2</span> <span class="class">Object</span> ())       <span class="comment">; абстракция <code>(<span class="special">lambda</span> (<span class="var">i</span>) ...)</code></span>
(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">self</span> <span class="class">Closure_2</span>) <span class="var">i</span>)
  (<span class="func">make-Closure_1</span> <span class="var">i</span>) )                   <span class="comment">; создание замыкания</span>
(<span class="syntax">define-class</span> <span class="class">Closure_3</span> <span class="class">Object</span> ())       <span class="comment">; абстракция <code>(<span class="special">lambda</span> () <span class="math"><span class="ord var">π</span></span>)</code></span>
(<span class="syntax">define-method</span> (<span class="func">invoke</span> (<span class="var">self</span> <span class="class">Closure_3</span>))
  ((<span class="special">lambda</span> (<span class="var">cnter_1</span> <span class="var">tmp_2</span>)               <span class="comment">; переименование в действии</span>
     (<span class="special">set!</span> <span class="var">index</span> <span class="num">1</span>)
     (<span class="special">set!</span> <span class="var">cnter_1</span> (<span class="func">make-Closure_0</span>))     <span class="comment">; инициализация</span>
     (<span class="special">set!</span> <span class="var">tmp_2</span> (<span class="func">cons</span> <span class="var">quote_5</span> <span class="hash">'()</span>))     <span class="comment">; <span class="quad-stub" style="width: 1em"/>временных переменных</span>
     (<span class="special">set!</span> <span class="var">tmp_2</span> (<span class="func">make-box</span> <span class="var">tmp_2</span>))       <span class="comment">; укладываем в коробку</span>
     (<span class="func">box-write!</span> <span class="var">tmp_2</span>                   <span class="comment">; <span class="quad-stub" style="width: 1em"/>изменяемую переменную</span>
                 (<span class="func">invoke</span> <span class="var">cnter_1</span> (<span class="func">make-Closure_2</span>)) )
     (<span class="special">if</span> <span class="var">cnter_1</span>
         (<span class="func">invoke</span> <span class="var">cnter_1</span> (<span class="func">box-read</span> <span class="var">tmp_2</span>))
         <span class="var">index</span> ) ) ) )
(<span class="func">invoke</span> (<span class="func">make-Closure_3</span>))                <span class="comment">; точка входа</span></pre>


<h2 id="cc/sect:gen"><span class="seq">10.8.</span> Генерируем Си</h2>

<p>Наконец, мы готовы выполнить мистический обряд кодогенерации. Осталось лишь
дать несколько предварительных пояснений. Ваш покорный слуга не мнит себя
мировым экспертом по языку Си и, в сущности, обязан своими знаниями тщательному
изучению книг вроде <span class="cite">[<a href="z1_bibliography.xhtml#iso90">ISO90</a>,
<a href="z1_bibliography.xhtml#hs91">HS91</a>,
<a href="z1_bibliography.xhtml#cek+89">CEK<sup>+</sup>89</a>]</span>.
Предполагается, что вы имеете
некоторое представление об этом языке, но не обременены предрассудками
о единственно верном способе его использования.</p>

<p>Абстрактное синтаксическое дерево полностью готово и только и ждёт, чтобы его
скомпилировали, а вернее сказать, <em>распечатали</em> на языке Си. Благодаря
высокоуровневому представлению программ, генерация кода не представляет особых
сложностей. Функция <code><span class="func">compile-&gt;C</span></code> принимает S-выражение, выполняет над ним
рассмотренные ранее преобразования и в конце концов выводит в порт <code><span class="var">out</span></code>
опрятный исходный код на Си.</p>

<!--\indexC{compile->C}-->
<!--\indexC{generate-C-program}-->
<pre>(<span class="special">define</span> (<span class="func">compile-&gt;C</span> <span class="var">e</span> <span class="var">out</span>)
  (<span class="special">set!</span> <span class="var">g.current</span> <span class="hash">'()</span>)
  (<span class="syntax">let</span> ((<span class="var">prg</span> (<span class="func">extract-things!</span> (<span class="func">lift!</span> (<span class="func">Sexp-&gt;object</span> <span class="var">e</span>)))))
    (<span class="func">gather-temporaries!</span> (<span class="func">closurize-main!</span> <span class="var">prg</span>))
    (<span class="func">generate-C-program</span> <span class="var">out</span> <span class="var">e</span> <span class="var">prg</span>) ) )

(<span class="special">define</span> (<span class="func">generate-C-program</span> <span class="var">out</span> <span class="var">e</span> <span class="var">prg</span>)
  (<span class="func">generate-header</span>             <span class="var">out</span> <span class="var">e</span>)
  (<span class="func">generate-global-environment</span> <span class="var">out</span> <span class="var">g.current</span>)
  (<span class="func">generate-quotations</span>         <span class="var">out</span> (<span class="func">Flattened-Program-quotations</span> <span class="var">prg</span>))
  (<span class="func">generate-functions</span>          <span class="var">out</span> (<span class="func">Flattened-Program-definitions</span> <span class="var">prg</span>))
  (<span class="func">generate-main</span>               <span class="var">out</span> (<span class="func">Flattened-Program-form</span> <span class="var">prg</span>))
  (<span class="func">generate-trailer</span>            <span class="var">out</span>)
  <span class="var">prg</span> )</pre>

<p>Как и любая программа на Си, а в более широком смысле, как и любое животное,
получаемая программа состоит из головы, тела и хвоста. В голове находятся
желания, умения и мысли, поэтому там размещается комментарий с исходным
выражением на Scheme (выводимым нестандартной функцией <code><span class="func">pp</span></code>), а также
директива препроцессора, подключающая к программе заголовочный файл
<code>scheme.h</code>, где будут находиться все необходимые ей определения. Для вывода
строк программы здесь и далее используется ещё одна нестандартная функция
<code><span class="func">format</span></code>.</p>

<!--\indexC{generate-header}-->
<!--\indexC{generate-trailer}-->
<pre>(<span class="special">define</span> (<span class="func">generate-header</span> <span class="var">out</span> <span class="var">e</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"/* Compiler to C $Revision: 4.1$<span class="pp">~%</span>"</span>)
  (<span class="func">pp</span> <span class="var">e</span> <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>*/<span class="pp">~%</span><span class="pp">~%</span>#include <span class="esc">\"</span>scheme.h<span class="esc">\"</span><span class="pp">~%</span>"</span>) )

(<span class="special">define</span> (<span class="func">generate-trailer</span> <span class="var">out</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>/* End of generated code */<span class="pp">~%</span>"</span>) )</pre>

<p>В хвосте, как видите, нет ничего интересного; всё самое важное находится в теле
программы. Результат компиляции нашего подопытного примера приведён в разделе <a href="#cc/gen/init/src:result">10.8.8</a>. Возможно, вам захочется взглянуть на
него, прежде чем переходить к изучению анатомии генератора.</p>


<h3 id="cc/gen/ssect:global"><span class="seq">10.8.1.</span> Глобальное окружение</h3>

<p>Глобальные переменные, используемые программой, можно разделить на две группы:
предопределённые переменные, вроде <code><span class="func">car</span></code> или
<code><span class="func">+</span></code>, и изменяемые глобальные
переменные. Считается, что предопределённые переменные неизменяемы, а их
значения физически располагаются в специальной библиотеке, которая будет
подключена при компоновке. В отличие от них, окружение глобальных изменяемых
переменных должно быть сформировано именно у нас в программе. Для этого мы
используем информацию, которую собрали в
<code><span class="var">g.current</span></code> во время предобработки.</p>

<p>Используемый подход к генерации строится на предположении, что программа
компилируется целиком, а не отдельными модулями. (Раздельная компиляция, как
вы помните, вызывает множество специфичных затруднений.
<span class="see">[см. раздел <a href="ch07_compilation.xhtml#compilation/sect:separate">7.10</a>]</span>
Мы не будем их рассматривать повторно, дабы не раздувать эту главу в пару раз.)</p>

<p>Для облегчения понимания и повышения читабельности кода, генератор щедро
использует макросы Си. Например, глобальные переменные объявляются макросом
<code class="c"><span class="pre">SCM_DefineGlobalVariable</span></code>.
Вторым аргументом этот макрос принимает строку
с изначальным именем<a class="footref" href="zz_footnotes.xhtml#foot10.3"><sup>3</sup></a> переменной на Scheme. Это может
оказаться полезным при отладке.</p>

<!--\indexC{generate-global-environment}-->
<!--\indexC{generate-global-variable}-->
<pre>(<span class="special">define</span> (<span class="func">generate-global-environment</span> <span class="var">out</span> <span class="var">gv*</span>)
  (<span class="syntax">when</span> (<span class="func">pair?</span> <span class="var">gv*</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>/* Global environment: */<span class="pp">~%</span>"</span>)
    (<span class="func">for-each</span> (<span class="special">lambda</span> (<span class="var">gv</span>) (<span class="func">generate-global-variable</span> <span class="var">out</span> <span class="var">gv</span>))
              <span class="var">gv*</span> ) ) )

(<span class="special">define</span> (<span class="func">generate-global-variable</span> <span class="var">out</span> <span class="var">gv</span>)
  (<span class="syntax">let</span> ((<span class="func">name</span> (<span class="func">Global-Variable-name</span> <span class="var">gv</span>)))
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_DefineGlobalVariable(<span class="pp">~A</span>,<span class="esc">\"</span><span class="pp">~A</span><span class="esc">\"</span>);<span class="pp">~%</span>"</span>
            (<span class="func">IdScheme-&gt;IdC</span> <span class="var">name</span>) <span class="var">name</span> ) ) )</pre>

<!--\indexR{идентификаторы в Си}-->
<p>Вот мы и встретились с первым затруднением: не все идентификаторы Scheme
являются допустимыми в Си. Функция <code><span class="func">IdScheme-&gt;IdC</span></code> занимается преобразованием
идентификаторов Scheme в корректные идентификаторы Си. Она должна избавиться от
всех мешающих символов, оставив при этом имя более-менее понятным, чтобы можно
было догадаться о его исходном написании. Естественно, вариантов такого
преобразования огромное множество, но мы просто заменим все недопустимые символы
допустимыми, после чего убедимся в уникальности полученного имени. Код, который
это делает, не то, чтобы особо интересен, но в самом начале книги у нас был
уговор: ничего не утаивать. Переменная <code><span class="var">Scheme-&gt;C-names-mapping</span></code> хранит
словарик имён, изначально содержащий несколько сложных случаев.</p>

<!--\indexC{IdScheme->IdC}-->
<pre>(<span class="special">define</span> <span class="var">Scheme-&gt;C-names-mapping</span>
  '( (<span class="var">*</span>        . <span class="string">"TIMES"</span>)
     (<span class="var">&lt;</span>        . <span class="string">"LESSP"</span>)
     (<span class="var">pair?</span>    . <span class="string">"CONSP"</span>)
     (<span class="var">set-cdr!</span> . <span class="string">"RPLACD"</span>)
     <span class="comment">; и другие</span>
     ) )
(<span class="special">define</span> (<span class="func">IdScheme-&gt;IdC</span> <span class="var">name</span>)
  (<span class="syntax">let</span> ((<span class="var">v</span> (<span class="func">assq</span> <span class="var">name</span> <span class="var">Scheme-&gt;C-names-mapping</span>)))
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">v</span>) (<span class="func">cdr</span> <span class="var">v</span>)
        (<span class="syntax">let</span> ((<span class="var">str</span> (<span class="func">symbol-&gt;string</span> <span class="var">name</span>)))
          (<span class="syntax">let</span> <span class="func">retry</span> ((<span class="var">Cname</span> (<span class="func">compute-Cname</span> <span class="var">str</span>)))
            (<span class="special">if</span> (<span class="func">Cname-clash?</span> <span class="var">Cname</span> <span class="var">Scheme-&gt;C-names-mapping</span>)
                (<span class="func">retry</span> (<span class="func">compute-another-Cname</span> <span class="var">str</span>))
                (<span class="special">begin</span> (<span class="special">set!</span> <span class="var">Scheme-&gt;C-names-mapping</span>
                             (<span class="func">cons</span> (<span class="func">cons</span> <span class="var">name</span> <span class="var">Cname</span>)
                                   <span class="var">Scheme-&gt;C-names-mapping</span> ) )
                       <span class="var">Cname</span> ) ) ) ) ) ) )</pre>

<p>Обнаруженные конфликты имён разрешаются просто: добавлением уникального номера.</p>

<!--\indexC{Cname-clash?}-->
<!--\indexC{compute-Cname}-->
<pre>(<span class="special">define</span> (<span class="func">Cname-clash?</span> <span class="var">Cname</span> <span class="var">mapping</span>)
  (<span class="syntax">let</span> <span class="func">check</span> ((<span class="var">mapping</span> <span class="var">mapping</span>))
    (<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">mapping</span>)
         (<span class="syntax">or</span> (<span class="func">string=?</span> <span class="var">Cname</span> (<span class="func">cdar</span> <span class="var">mapping</span>))
             (<span class="func">check</span> (<span class="func">cdr</span> <span class="var">mapping</span>)) ) ) ) )

(<span class="special">define</span> <span class="var">compute-another-Cname</span>
  (<span class="syntax">let</span> ((<span class="var">counter</span> <span class="num">1</span>))
    (<span class="special">lambda</span> (<span class="var">str</span>)
      (<span class="special">set!</span> <span class="var">counter</span> (<span class="func">+</span> <span class="num">1</span> <span class="var">counter</span>))
      (<span class="func">compute-Cname</span> (<span class="func">format</span> <span class="hash">#f</span> <span class="string">"<span class="pp">~A</span>_<span class="pp">~A</span>"</span> <span class="var">str</span> <span class="var">counter</span>)) ) ) )

(<span class="special">define</span> (<span class="func">compute-Cname</span> <span class="var">str</span>)
  (<span class="special">define</span> (<span class="func">mapcan</span> <span class="var">f</span> <span class="var">l</span>)
    (<span class="special">if</span> (<span class="func">not</span> (<span class="func">pair?</span> <span class="var">l</span>)) <span class="hash">'()</span>
        (<span class="func">append</span> (<span class="func">f</span> (<span class="func">car</span> <span class="var">l</span>)) (<span class="func">mapcan</span> <span class="var">f</span> (<span class="func">cdr</span> <span class="var">l</span>))) ) )
  (<span class="special">define</span> (<span class="func">convert-char</span> <span class="var">char</span>)
    (<span class="syntax">case</span> <span class="var">char</span>
      ((<span class="hash">#\_</span>)             '(<span class="hash">#\_</span> <span class="hash">#\_</span>))
      ((<span class="hash">#\?</span>)             '(<span class="hash">#\p</span>))
      ((<span class="hash">#\!</span>)             '(<span class="hash">#\i</span>))
      ((<span class="hash">#\&lt;</span>)             '(<span class="hash">#\l</span>))
      ((<span class="hash">#\></span>)             '(<span class="hash">#\g</span>))
      ((<span class="hash">#\=</span>)             '(<span class="hash">#\e</span>))
      ((<span class="hash">#\-</span> <span class="hash">#\/</span> <span class="hash">#\*</span> <span class="hash">#\:</span>) <span class="hash">'()</span>)
      (<span class="syntax">else</span>              (<span class="func">list</span> <span class="var">char</span>)) ) )
  (<span class="syntax">let</span> ((<span class="var">cname</span> (<span class="func">mapcan</span> <span class="var">convert-char</span> (<span class="func">string-&gt;list</span> <span class="var">str</span>))))
    (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">cname</span>)
        (<span class="func">list-&gt;string</span> <span class="var">cname</span>)
        <span class="strign">"weird"</span> ) ) )</pre>

<p>Единичные подчёркивания гарантированно не встречаются в генерируемых именах,
поэтому их можно спокойно использовать для именования разнообразных внутренних
переменных, не опасаясь коллизий с переменными исходной программы. Рассмотренное
преобразование, конечно, не справится с чем-то вроде <code><span class="var">1+</span></code>,
но кого волнуют имена, запрещённые стандартом Scheme?</p>


<h3 id="cc/gen/ssect:quote"><span class="seq">10.8.2.</span> Цитаты</h3>

<!--\indexR{цитаты!склеивание}-->
<!--\indexR{склеивание цитат}-->
<p>Цитаты должны переводиться в структуры данных Си, чтобы ими можно было
пользоваться в программе. Мы поступим рационально, переводя их сразу в готовые
определения структур данных, а не в код, который их создаст во время исполнения.
Также мы оптимизируем занимаемый цитатами объём памяти, выделив в них и
определив отдельно все общие подвыражения.</p>

<p>Функция <code><span class="func">generate-quotations</span></code> назначена ответственной за выполнение данных
обещаний. Для простоты мы не будем реализовывать поддержку векторов, длинной
арифметики и всех нецелых чисел.</p>

<!--\indexC{generate-quotations}-->
<pre>(<span class="special">define</span> (<span class="func">generate-quotations</span> <span class="var">out</span> <span class="var">qv*</span>)
  (<span class="syntax">when</span> (<span class="func">pair?</span> <span class="var">qv*</span>)
    (<span class="func">format</span> <span class="var">out</span> <span class="string">"<span class="pp">~%</span>/* Quotations: */<span class="pp">~%</span>"</span>)
    (<span class="func">scan-quotations</span> <span class="var">out</span> <span class="var">qv*</span> (<span class="func">length</span> <span class="var">qv*</span>) <span class="hash">'()</span>) ) )</pre>

<p>Настоящую работу выполняет <code><span class="func">scan-quotations</span></code>: просматривает собранные
цитаты, представляемые объектами класса <code><span class="class">Quotation-Variable</span></code>, и генерирует
соответствующий код. Она также старается создавать как можно меньше
промежуточных цитат, разделяя максимум информации между ними. Предикат
<code><span class="func">already-seen-value?</span></code> подсказывает ей, когда такое возможно.</p>

<!--\indexC{scan-quotations}-->
<!--\indexC{already-seen-value"?}-->
<pre>(<span class="special">define</span> (<span class="func">scan-quotations</span> <span class="var">out</span> <span class="var">qv*</span> <span class="var">i</span> <span class="var">results</span>)
  (<span class="syntax">when</span> (<span class="func">pair?</span> <span class="var">qv*</span>)
    (<span class="syntax">let*</span> ((<span class="var">qv</span>       (<span class="func">car</span> <span class="var">qv*</span>))
           (<span class="var">value</span>    (<span class="func">Quotation-Variable-value</span> <span class="var">qv</span>))
           (<span class="var">other-qv</span> (<span class="func">already-seen-value?</span> <span class="var">value</span> <span class="var">results</span>)) )
      (<span class="syntax">cond</span>
        (<span class="var">other-qv</span>
          (<span class="func">generate-quotation-alias</span> <span class="var">out</span> <span class="var">qv</span> <span class="var">other-qv</span>)
          (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cdr</span> <span class="var">qv*</span>) <span class="var">i</span> (<span class="func">cons</span> <span class="var">qv</span> <span class="var">results</span>)) )
        ((<span class="func">C-value?</span> <span class="var">value</span>)
          (<span class="func">generate-C-value</span> <span class="var">out</span> <span class="var">qv</span>)
          (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cdr</span> <span class="var">qv*</span>) <span class="var">i</span> (<span class="func">cons</span> <span class="var">qv</span> <span class="var">results</span>)) )
        ((<span class="func">symbol?</span> <span class="var">value</span>) (<span class="func">scan-symbol</span> <span class="var">out</span> <span class="var">value</span> <span class="var">qv*</span> <span class="var">i</span> <span class="var">results</span>) )
        ((<span class="func">pair?</span> <span class="var">value</span>)   (<span class="func">scan-pair</span> <span class="var">out</span> <span class="var">value</span> <span class="var">qv*</span> <span class="var">i</span> <span class="var">results</span>) )
        (<span class="syntax">else</span> (<span class="func">generate-error</span> <span class="string">"Unsupported constant"</span> <span class="var">qv</span>)) ) ) ) )

(<span class="special">define</span> (<span class="func">already-seen-value?</span> <span class="var">value</span> <span class="var">qv*</span>)
  (<span class="syntax">and</span> (<span class="func">pair?</span> <span class="var">qv*</span>)
       (<span class="special">if</span> (<span class="func">equal?</span> <span class="var">value</span> (<span class="func">Quotation-Variable-value</span> (<span class="func">car</span> <span class="var">qv*</span>)))
           (<span class="func">car</span> <span class="var">qv*</span>)
           (<span class="func">already-seen-value?</span> <span class="var">value</span> (<span class="func">cdr</span> <span class="var">qv*</span>)) ) ) )</pre>

<p>Имена всех цитат в генерируемом коде будут начинаться на <code>thing</code>. Если
в программе нашлась пара эквивалентных цитат, то достаточно одну из них везде
заменить другой. Функция <code><span class="func">generate-quotation-alias</span></code> перекладывает эту работу
на препроцессор Си. Чтобы облегчить чтение сгенерированного кода, рядом
помещается комментарий со значением цитаты.</p>

<!--\indexC{generate-quotation-alias}-->
<pre>(<span class="special">define</span> (<span class="func">generate-quotation-alias</span> <span class="var">out</span> <span class="var">qv1</span> <span class="var">qv2</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> thing<span class="pp">~A</span> /* <span class="pp">~S</span> */<span class="pp">~%</span>"</span>
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv1</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv2</span>)
          (<span class="func">Quotation-Variable-value</span> <span class="var">qv2</span>) ) )</pre>

<!--\indexR{значения!атомарные}-->
<p>Предикат <code><span class="func">C-value?</span></code> проверяет, можно ли данную цитату прямо перевести на Си.
Если да, то она передаётся функции <code><span class="func">generate-C-value</span></code>, чтобы она выполнила
этот перевод. Непосредственными значениями являются пустой список, булевы
значения, (короткие) целые числа и строки. Все эти значения Scheme можно сразу
представить соответствующими значениями Си. Предположим на время, что у нас уже
есть необходимые макросы, раскрывающиеся в правильные описания строк, чисел,
истины, лжи и пустого списка. Все они начинаются на <code>SCM_</code>. Без сомнения,
гуру Си также заметят, что наши числа являются знаковыми 31-битными
в дополнительном коде.</p>

<!--\indexC{C-value?}-->
<!--\indexC{generate-C-value}-->
<pre>(<span class="special">define</span> <span class="var">*maximal-fixnum*</span> <span class="num">+1073741823</span>)
(<span class="special">define</span> <span class="var">*minimal-fixnum*</span> <span class="num">-1073741824</span>)

(<span class="special">define</span> (<span class="func">C-value?</span> <span class="var">value</span>)
  (<span class="syntax">or</span> (<span class="func">null?</span> <span class="var">value</span>)
      (<span class="func">boolean?</span> <span class="var">value</span>)
      (<span class="syntax">and</span> (<span class="func">integer?</span> <span class="var">value</span>)
           (<span class="func">&lt;=</span> <span class="var">*minimal-fixnum*</span> <span class="var">value</span> <span class="var">*maximal-fixnum*</span>) )
      (<span class="func">string?</span> <span class="var">value</span>) ) )

(<span class="special">define</span> (<span class="func">generate-C-value</span> <span class="var">out</span> <span class="var">qv</span>)
  (<span class="syntax">let</span> ((<span class="var">value</span> (<span class="func">Quotation-Variable-value</span> <span class="var">qv</span>))
        (<span class="var">index</span> (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>)) )
    (<span class="syntax">cond</span>
      ((<span class="func">null?</span> <span class="var">value</span>)
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> SCM_nil /* () */<span class="pp">~%</span>"</span>
                <span class="var">index</span> ) )
      ((<span class="func">boolean?</span> <span class="var">value</span>)
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> <span class="pp">~A</span> /* <span class="pp">~S</span> */<span class="pp">~%</span>"</span>
                <span class="var">index</span> (<span class="special">if</span> <span class="var">value</span> <span class="string">"SCM_true"</span> <span class="string">"SCM_false"</span>) <span class="var">value</span> ) )
      ((<span class="func">integer?</span> <span class="var">value</span>)
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> SCM_Int2Fixnum(<span class="pp">~A</span>)<span class="pp">~%</span>"</span>
                <span class="var">index</span> <span class="var">value</span> ) )
      ((<span class="func">string?</span> <span class="var">value</span>)
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_DefineString(thing<span class="pp">~A</span>_object, <span class="esc">\"</span><span class="pp">~A</span><span class="esc">\"</span>);<span class="pp">~%</span>"</span>
                <span class="var">index</span> <span class="var">value</span> )
        (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> SCM_Wrap(&amp;thing<span class="pp">~A</span>_object)<span class="pp">~%</span>"</span>
                <span class="var">index</span> <span class="var">index</span> ) ) ) ) )</pre>

<!--\indexR{значения!составные}-->
<p>Если цитируются составные значения (точечные пары или символы), то вначале они
разбиваются на части, чтобы по возможности повторно использовать предыдущие
определения. Символы состоят из знаков, образующих строку с их именем. Строки
создаются перед символами.</p>

<!--\indexC{scan-symbol}-->
<!--\indexC{generate-symbol}-->
<pre>(<span class="special">define</span> (<span class="func">scan-symbol</span> <span class="var">out</span> <span class="var">value</span> <span class="var">qv*</span> <span class="var">i</span> <span class="var">results</span>)
  (<span class="syntax">let*</span> ((<span class="var">qv</span> (<span class="func">car</span> <span class="var">qv*</span>))
         (<span class="var">str</span> (<span class="func">symbol->string</span> <span class="var">value</span>))
         (<span class="var">strqv</span> (<span class="func">already-seen-value?</span> <span class="var">str</span> <span class="var">results</span>)) )
    (<span class="syntax">cond</span> (<span class="var">strqv</span>
            (<span class="func">generate-symbol</span> <span class="var">out</span> <span class="var">qv</span> <span class="var">strqv</span>)
            (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cdr</span> <span class="var">qv*</span>) <span class="var">i</span> (<span class="func">cons</span> <span class="var">qv</span> <span class="var">results</span>)) )
          (<span class="syntax">else</span>
            (<span class="syntax">let</span> ((<span class="var">newqv</span> (<span class="func">make-Quotation-Variable</span> <span class="var">i</span> <span class="var">str</span>)))
              (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cons</span> <span class="var">newqv</span> <span class="var">qv*</span>)
                               (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>) <span class="var">results</span> ) ) ) ) ) )

(<span class="special">define</span> (<span class="func">generate-symbol</span> <span class="var">out</span> <span class="var">qv</span> <span class="var">strqv</span>)
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"SCM_DefineSymbol(thing<span class="pp">~A</span>_object, thing<span class="pp">~A</span>); /* <span class="pp">~S</span> */<span class="pp">~%</span>"</span>
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">strqv</span>)
          (<span class="func">Quotation-Variable-value</span> <span class="var">qv</span>) )
  (<span class="func">format</span> <span class="var">out</span> <span class="string">"#define thing<span class="pp">~A</span> SCM_Wrap(&amp;thing<span class="pp">~A</span>_object)<span class="pp">~%</span>"</span>
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>) ) )</pre>

<p>Точечные пары состоят из двух частей — <code><span class="var">car</span></code> и <code><span class="var">cdr</span></code>, —
обрабатываемых последовательно. При этом учитывается, что их значения могут
оказаться эквивалентными как ранее определённым цитатам, так и друг другу. Их
вывод реализован в стиле передачи продолжений.</p>

<!--\indexC{scan-pair}-->
<!--\indexC{generate-pair}-->
<pre>(<span class="special">define</span> (<span class="func">scan-pair</span> <span class="var">out</span> <span class="var">value</span> <span class="var">qv*</span> <span class="var">i</span> <span class="var">results</span>)
  (<span class="syntax">let*</span> ((<span class="var">qv</span>  (<span class="func">car</span> <span class="var">qv*</span>))
         (<span class="var">d</span>   (<span class="func">cdr</span> <span class="var">value</span>))
         (<span class="var">dqv</span> (<span class="func">already-seen-value?</span> <span class="var">d</span> <span class="var">results</span>)) )
    (<span class="special">if</span> <span class="var">dqv</span>
        (<span class="syntax">let*</span> ((<span class="var">a</span>   (<span class="func">car</span> <span class="var">value</span>))
               (<span class="var">aqv</span> (<span class="func">already-seen-value?</span> <span class="var">a</span> <span class="var">results</span>)) )
          (<span class="special">if</span> <span class="var">aqv</span>
              (<span class="special">begin</span>
                (<span class="func">generate-pair</span> <span class="var">out</span> <span class="var">qv</span> <span class="var">aqv</span> <span class="var">dqv</span>)
                (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cdr</span> <span class="var">qv*</span>)
                                 <span class="var">i</span> (<span class="func">cons</span> <span class="var">qv</span> <span class="var">results</span>) ) )
              (<span class="syntax">let</span> ((<span class="var">newaqv</span> (<span class="func">make-Quotation-Variable</span> <span class="var">i</span> <span class="var">a</span>)))
                (<span class="func">scan-quotations</span> <span class="var">out</span> (<span class="func">cons</span> <span class="var">newaqv</span> <span class="var">qv*</span>)
                                 (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>) <span class="var">results</span> ) ) ) )
        (<span class="syntax">let</span> ((<span class="var">newdqv</span> (<span class="func">make-Quotation-Variable</span> <span class="var">i</span> <span class="var">d</span>)))
          (<span class="func">scan-quotations</span>
           <span class="var">out</span> (<span class="func">cons</span> <span class="var">newdqv</span> <span class="var">qv*</span>) (<span class="func">+</span> <span class="var">i</span> <span class="num">1</span>) <span class="var">results</span> ) ) ) ) )

(<span class="special">define</span> (<span class="func">generate-pair</span> <span class="var">out</span> <span class="var">qv</span> <span class="var">aqv</span> <span class="var">dqv</span>)
  (<span class="func">format</span> <span class="var">out</span>
          <span class="string">"SCM_DefinePair(thing<span class="pp">~A</span>_object, thing<span class="pp">~A</span>, thing<span class="pp">~A</span>); /* <span class="pp">~S</span> */<span class="pp">~%</span>"</span>
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">aqv</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">dqv</span>)
          (<span class="func">Quotation-Variable-value</span> <span class="var">qv</span>) )
  (<span class="func">format</span> <span class="var">out</span>
          <span class="string">"#define thing<span class="pp">~A</span> SCM_Wrap(&amp;thing<span class="pp">~A</span>_object)<span class="pp">~%</span>"</span>
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>)
          (<span class="func">Quotation-Variable-name</span> <span class="var">qv</span>) ) )</pre>

<p>Теперь давайте рассмотрим пример, а затем поговорим обо всех этих загадочных
макросах.</p>


<h3 id="cc/gen/ssect:decl"><span class="seq">10.8.3.</span> Объявление данных</h3>

<p>Возьмём простую программу, состоящую из единственной цитаты: <code>(<span class="special">quote</span> ((<span class="hash">#F</span>
<span class="hash">#T</span>) (<span class="var">FOO</span> . <span class="string">"FOO"</span>) <span class="num">33</span> <span class="var">FOO</span> . <span class="string">"FOO"</span>))</code>. Её компиляция выдаёт следующий результат,
слегка приправленный комментариями. Наслаждайтесь!</p>

<div class="snippet">
<pre class="c">/* Compiler to C $Revision: 4.1$
'((#F #T) (FOO . "FOO") 33 FOO . "FOO") */

#include "scheme.h"

/* Quotations: */
SCM_DefineString(thing4_object, "FOO");
#define thing4 SCM_Wrap(&amp;thing4_object)
SCM_DefineSymbol(thing5_object, thing4);        /* FOO */
#define thing5 SCM_Wrap(&amp;thing5_object)
SCM_DefinePair(thing3_object, thing5, thing4);  /* (FOO . "FOO") */
#define thing3 SCM_Wrap(&amp;thing3_object)
#define thing6 SCM_Int2Fixnum(33)
SCM_DefinePair(thing2_object, thing6, thing3);  /* (33 FOO . "FOO") */
#define thing2 SCM_Wrap(&amp;thing2_object)
SCM_DefinePair(thing1_object, thing3, thing2);
                                  /* ((FOO . "FOO") 33 FOO . "FOO") */
#define thing1 SCM_Wrap(&amp;thing1_object)
#define thing9 SCM_nil                           /* ()  */
#define thing10 SCM_true                         /* \#T  */
SCM_DefinePair(thing8_object, thing10, thing9);  /* (#T) */
#define thing8 SCM_Wrap(&amp;thing8_object)
#define thing11 SCM_false                        /* \#F */
SCM_DefinePair(thing7_object, thing11, thing8);  /* (#F #T) */
#define thing7 SCM_Wrap(&amp;thing7_object)
SCM_DefinePair(thing0_object, thing7, thing1);
                          /* ((#F #T) (FOO . "FOO") 33 FOO . "FOO") */
#define thing0 SCM_Wrap(&amp;thing0_object)

/* ... */</pre></div>

<p>Первым делом создаётся строка <code><span class="func">"FOO"</span></code>. Для этого используется макрос
<code><span class="func">SCM\_DefineString</span></code>. Первым аргументом он принимает имя нового объекта на Си.
Вторым — собственно строку. Похожим образом с помощью макроса
<code><span class="func">SCM\_DefineSymbol</span></code> создаётся символ. Первым аргументом идёт имя на Cи, за
ним — строка с именем на Scheme. Точечные пары создаются аналогично с помощью
макроса <code><span class="func">SCM\_DefinePair</span></code>: первым аргументом — имя на Си, вторым и третьим
— содержимое <code><span class="func">car</span></code> и <code><span class="func">cdr</span></code> соответственно.</p>

<p>Предопределённые объекты вроде булевых значений и пустого списка, конечно же,
не создаются каждый раз заново. Вместо этого используются напрямую их имена:
<code><span class="func">SCM\_true</span></code>, <code><span class="func">SCM\_false</span></code> и <code><span class="func">SCM\_nil</span></code>.</p>

<p>Позже \seePage[cc/sect:data] мы подробнее разберём представление в памяти
значений Scheme. Процесс компиляции слабо связан с используемой конкретной
реализацией структур данных. На данный момент достаточно знать лишь её
интерфейс: объекты инициализируются директивами вида <code><span class="func">SCM\_Define...</span></code>, а
ссылку на инициализированный объект можно получить с помощью <code><span class="func">SCM\_Wrap</span></code>.
Целые числа преобразуются в объекты Scheme макросом <code><span class="func">SCM\_Int2Fixnum</span></code>.
К любому объекту можно обратиться, использовав его имя, начинающееся на
<code><span class="func">thing</span></code>. Например, <code><span class="func">thing4</span></code> означает строку <code><span class="func">"FOO"</span></code>, а <code><span class="func">thing6</span></code> —
это число 33. Точнее, <code><span class="func">thing4</span></code> — это указатель на объект
<code><span class="func">thing4\_object</span></code>, который уже хранит настоящую строку.</p>

<p>Строка <code><span class="func">"FOO"</span></code> общая для всех объектов: в выражении <code>(FOO . "FOO")</code>
объекты <code><span class="func">thing4</span></code> и <code><span class="func">thing3</span></code> ссылаются на один и тот же
<code><span class="func">thing4\_object</span></code>.</p>

<h3 id="cc/gen/ssect:exprs">Компиляция выражений</h3>

<p>Главной задачей компилятора, конечно же, является перевод выражений Scheme
в выражения Си. Как было сказано ранее, мы намеренно преобразуем выражения
в аналогичные выражения, а не наборы инструкций с тем же смыслом. Поступив так,
мы определённо получим на выходе более понятный код, в котором будет лучше видна
структура исходной программы. Однако, несмотря на очевидную мудрость подобного
решения, оно поднимает пару непростых вопросов, так как идёт вразрез
с философией языка Си. В Си отдельные инструкции предпочтительнее выражений.
Не то, чтобы это было особой проблемой для компилятора — ему-то без разницы;
это будет проблемой для человека, который сядет отлаживать подобную программу.
Беда в том, что интерактивные отладчики вроде <code><span class="func">gdb</span></code> обычно понимают пошаговый
режим исполнения как исполнение программы по инструкциям — а инструкции
в нашем случае будут отнюдь не маленькие. Если бы мы решили компилировать Scheme
в инструкции Си вместо выражений, то в итоге у нас получилось бы нечто похожее
на рассмотренный ранее компилятор в байт-код. \seePage[chapter:compilation]</p>

<p>Компиляция выражений выполняется обобщённой функцией <code><span class="func">->C</span></code>. Она принимает
два аргумента: исходное выражение и порт, куда следует записать результат. Так
как результат компиляции сразу же переносится в файл, то код необходимо
генерировать строго последовательно, без возвратов и исправлений задним числом,
за один проход.
\seePage[compilation/lang-and-target/par:backtracking]</p>


<!--\indexC*{c}{->C}-->
<pre>(define-generic (->C (e Program) out))</pre>

<p>В отличие от предыдущих трансформаций, в этот раз мы не будем использовать
обобщённый обходчик (так как у нас нет действия по умолчанию), а просто
перечислим методы обработки каждого типа узлов синтаксического дерева. Эти
методы довольно просты по своей структуре, так как им надо лишь правильно
выводить соответствующие инструкции Си.</p>

<p>Язык Си имеет весьма строгий синтаксис с чётко прописанными приоритетами,
ассоциативностью операций и т. д. Эти правила мало кто из программистов помнит
наизусть целиком, поэтому при малейших сомнениях все пользуются скобками. Мы же
возведём эту практику в абсолют и будем ставить их всегда. Что бы там
ни говорили сишники о плохом вкусе, но исходным языком сейчас является Лисп,
так что в программе должны быть скобочки. Много скобочек. Поэтому мы определим
специальный макрос, чтобы удобно их ставить:</p>


<!--\indexC{between-parentheses}-->
<pre>(define-syntax between-parentheses
  (syntax-rules ()
    ((between-parentheses out . body)
     (let ((out out))
       (format out "(")
       (begin . body)
       (format out ")") ) ) ) )</pre>

<h4 id="cc/gen/exprs/sssect:refs">Обращения к переменным</h4>

<p>В программе могут использоваться переменные разного вида, но в общем случае
одна переменная Scheme соответствует одной переменной Си. Метод обработки
обращений к переменным сразу же перепоручает всю работу обобщённой функции
<code><span class="func">reference->C</span></code>, а она, в свою очередь, по умолчанию просит всё сделать
следующую функцию — <code><span class="func">variable->C</span></code>. Такая слабая связанность методов
облегчит их дальнейшую специализацию.</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Reference</span></code>}-->
<!--\indexC{reference->C}-->
<!--\indexC{variable->C}-->
<pre>(define-method (->C (e Reference) out)
  (reference->C (Reference-variable e) out) )</p>

<p>(define-generic (reference->C (v Variable) out)
  (variable->C v out) )</p>

<p>(define-generic (variable->C (variable) out))</pre>

<p>Обычно переменная получает новое имя на Си, похожее на её исходное, за
исключением случаев, когда она была переименована или же ссылается на цитату.</p>

<pre>(define-method (variable->C (variable Variable) out)
  (format out (IdScheme->IdC (Variable-name variable))) )</p>

<p>(define-method (variable->C (variable Renamed-Local-Variable) out)
  (format out -A_ A"
          (IdScheme->IdC (Variable-name variable))
          (Renamed-Local-Variable-index variable) ) )</p>

<p>(define-method (variable->C (variable Quotation-Variable) out)
  (format out "thing A" (Quotation-Variable-name variable)) )</pre>

<p>Отдельно обрабатываются обращения к глобальным переменным, не являющимся
предопределёнными. Фактически, это свободные переменные всей программы. Как вы
помните, в данной реализации подобные переменные создаются автоматически, при их
первом упоминании. К сожалению, компилятор никак не анализирует значения этих
переменных, поэтому проверки на инициализированность должны проводиться во время
исполнения программы. За этим проследит макрос <code><span class="func">SCM\_CheckedGlobal</span></code>.
\seeEx[cc/ex:global-check]</p>

<pre>(define-method (reference->C (v Global-Variable) out)
  (format out "SCM_CheckedGlobal")
  (between-parentheses out
    (variable->C v out) ) )</pre>

<p>Кроме того, ещё остаются обычные свободные переменные. Для них тоже припасён
специальный макрос.</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Free-Reference</span></code>}-->
<pre>(define-method (->C (e Free-Reference) out)
  (format out "SCM_Free")
  (between-parentheses out
    (variable->C (Free-Reference-variable e) out) ) )</pre>

<h4 id="cc/gen/exprs/sssect:assignments">Присваивания</h4>

<p>С присваиваниями всё ещё легче, так как они бывают лишь двух видов: присваивание
глобальным переменным и модификация содержимого коробок. Случай глобальных
переменных прямо переводится в присваивание соответствующей глобальной
переменной языка Си.</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Global-Assignment</span></code>}-->
<pre>(define-method (->C (e Global-Assignment) out)
  (between-parentheses out
    (variable->C (Global-Assignment-variable e) out)
    (format out " = ")
    (->C (Global-Assignment-form e) out) ) )</pre>

<h4 id="cc/gen/exprs/sssect:boxes">Коробки</h4>

<p>Что касается коробок, то над ними возможны всего три операции. Макрос
<code><span class="func">SCM\_Content</span></code> позволяет смотреть или изменять содержимое коробок, а
библиотечная функция <code><span class="func">SCM\_allocate\_box</span></code> берёт на себя их создание.</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Box-Read</span></code>}-->
<!--\indexCS*{c}{->C}{<code><span class="func">Box-Write</span></code>}-->
<!--\indexCS*{c}{->C}{<code><span class="func">Box-Creation</span></code>}-->
<pre>(define-method (->C (e Box-Read) out)
  (format out "SCM_Content")
  (between-parentheses out
    (->C (Box-Read-reference e) out) ) )</p>

<p>(define-method (->C (e Box-Write) out)
  (between-parentheses out
    (format out "SCM_Content")
    (between-parentheses out
      (->C (Box-Write-reference e) out) )
    (format out " = ")
    (->C (Box-Write-form e) out) ) )</p>

<p>(define-method (->C (e Box-Creation) out)
  (variable->C (Box-Creation-variable e) out)
  (format out " = SCM_allocate_box")
  (between-parentheses out
    (variable->C (Box-Creation-variable ) out) ) )</pre>

<h4 id="cc/gen/exprs/sssect:alternatives">Ветвления</h4>

<p>К счастью, в Си есть тернарный оператор, позволяющий записывать ветвления
выражениями вида <code>($\pi_0$ ? $\pi_1$ : $\pi_2$)</code>. Так как в Scheme любое
значение, не тождественное <code><span class="func">\#f</span></code>, считается истиной, мы должны это явно
проверять. И, конечно, не забываем о скобках!</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Alternative</span></code>}-->
<!--\indexC{boolean->C}-->
<pre>(define-method (->C (e Alternative) out)
  (between-parentheses out
    (boolean->C (Alternative-condition e) out)
    (format out -%? ")
    (->C (Alternative-consequent e) out)
    (format out -%: ")
    (->C (Alternative-alternant e) out) ) )</p>

<p>(define-generic (boolean->C (e) out)
  (between-parentheses out
    (->C e out)
    (format out " != SCM_false") ) )</pre>


<!--\indexR{вывод типов}-->
<!--\indexR{инлайнинг}-->
<!--\indexR{встраивание}-->
<!--\indexR{представление!логических значений}-->
<!--\indexR{логические значения!в Си}-->
<p>Внимательный читатель уже заметил, что проверка условия не всегда выполняется
с максимальной эффективностью. В программах очень часто встречаются выражения
вида <code>(if (pair? x) ...)</code>. Вызов предиката <code><span class="func">pair?</span></code> здесь честно возвращает
логические значения Scheme, но в данном случае он мог бы сразу выдать значение,
удобное для Си. Мелочь, конечно, но копейка рубль бережёт. Одним вариантом
оптимизации является специализация функции <code><span class="func">boolean->C</span></code> для вызовов
предопределённых предикатов. Также можно отождествить логические значения Scheme
и Си, условившись считать ложью значение <code><span class="func">NULL</span></code>. Наконец, частичный вывод
типов выражений позволяет избавиться от этой и прочих излишних проверок и
преобразований, см. \cite{shi91,ser93,wc94}.</p>

<h4 id="cc/gen/exprs/sssect:sequences">Последовательные вычисления</h4>

<p>Для последовательного вычисления подвыражений в Си тоже есть специальная
конструкция: <code>($\pi_1$, ..., $\pi_n$)</code>.</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Sequence</span></code>}-->
<pre>(define-method (->C (e Sequence) out)
  (between-parentheses out
    (->C (Sequence-first e) out)
    (format out ", %")
    (->C (Sequence-last e) out) ) )</pre>

<h3 id="cc/gen/ssect:apply">Компиляция аппликаций</h3>

<p>Мы разделили аппликации функций на несколько категорий: нормальные вызовы
функций, приводимые формы (аппликации, где на месте функции находится
абстракция) и обращения к предопределённым примитивам. Этим трём категориям
аппликаций соответствуют узлы синтаксического дерева <code><span class="func">Regular-Application</span></code>,
<code><span class="func">Fix-Let</span></code> и <code><span class="func">Predefined-Application</span></code>.</p>

<p>Нормальные вызовы функций вида <code>($f$ $x_1$ ... $x_n$)</code> преобразуются
в выражения Си <code>SCM\_invoke($f$, $n$, $x_1$, ...\,, $x_n$)</code>, где $n$ — это
количество аргументов, переданных функции, а <code><span class="func">SCM\_invoke</span></code> — специальная
вспомогательная функция. Мы определим несколько макросов, чтобы сделать вызовы
функций с малым числом аргументов более читабельными:</p>


<!--\indexC*{SCM_invoke0}{SCM\_invoke\protect<i>n</i>}-->
<p>\begin{code:c}
#define SCM_invoke0(f)          SCM_invoke(f, 0)
#define SCM_invoke1(f, x)       SCM_invoke(f, 1, x)
#define SCM_invoke2(f, x, y)    SCM_invoke(f, 2, x, y)
#define SCM_invoke3(f, x, y, z) SCM_invoke(f, 3, x, y, z)
\end{code:c}</p>

<p>Вызовы большей арности компилируются напрямую в <code><span class="func">SCM\_invoke</span></code>:</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Regular-Application</span></code>}-->
<pre>(define-method (->C (e Regular-Application) out)
  (let ((n (number-of (Regular-Application-arguments e))))
    (cond ((< n 4)
           (format out "SCM_invoke A" n)
           (between-parentheses out
             (->C (Regular-Application-function e) out)
             (->C (Regular-Application-arguments e) out) ) )
          (else
           (format out "SCM_invoke")
           (between-parentheses out
             (->C (Regular-Application-function e) out)
             (format out ",  A" n)
             (->C (Regular-Application-arguments e) out) ) ) ) ) )</pre>


<!--\indexR{стековые фреймы!объединение}-->
<!--\indexR{фреймы стека!объединение}-->
<p>Приводимые формы просто переводятся в последовательность выражений Си,
соответствующих их телу. Наконец-то усилия по предварительному анализу кода
и идентификации временных переменных начинают приносить плоды. Благодаря им
становится возможным выполнить так называемое <em class="term">объединение фреймов</em> (frame
coalescing); это известная оптимизация \cite{as94,pj87}, касающаяся временных
переменных: вместо множества маленьких выделений-освобождений памяти сразу
взять один большой кусок для целого набора переменных. А если под все временные
переменные уже выделена память, то связывание их со значениями сводится лишь
к присваиваниям. В терминах Лиспа данное преобразование приводит к объединению
локальных <code><span class="func">let</span></code>-форм, переносу их на уровень выше и возможному переименованию
соответствующих переменных.\footnote*{Конечно, при этом можно применять и более
агрессивные оптимизации. Например, в приведённом примере переменные <code><span class="func">x1</span></code>
и <code><span class="func">x2</span></code> невозможно использовать одновременно, так что они могут физически
совпадать в памяти.}</p>

<p>{\def\E{\hbox to 0pt{\kern0.1em$\leadsto$}}
\begin{code:lisp}
(begin                   (let (x1 x2)
  |$e_1$|                       |$e_1$|
  (let ((x |$\pi_1$|))            (set! x1 |$\pi_1$|)
    |$\pi_2$| )            |\E|       |$\pi_2[<code><span class="func">x</span></code> \to <code><span class="func">x1</span></code>]$|
  |$e_2$|                       |$e_2$|
  (let ((x |$\pi_3$|))            (set! x2 |$\pi_3$|)
    |$\pi_4$| ) )                 |$\pi_4[<code><span class="func">x</span></code> \to <code><span class="func">x2</span></code>]$| )
\end{code:lisp}}</p>


<!--\indexR{продолжения (continuations)}-->
<!--\indexR{коробки}-->
<p>В общем случае это преобразование ошибочно: например, если благодаря
продолжениям $e_1$ вернёт значение во второй раз, а $\pi_2$ захватывает
значение <code><span class="func">x</span></code>, то новая переменная <code><span class="func">x</span></code>, переименованная в <code><span class="func">x1</span></code>, сохранит
привязку <code><span class="func">x</span></code> из параллельной ветви стека.
\seePage[fast/fast/begin/application/par:call/cc] Тем не менее, в данном случае
всё хорошо, так как клоны <code><span class="func">x1</span></code> всё же будут отличаться: значение <code><span class="func">x1</span></code>
будет завёрнуто в коробку, а вместо <code><span class="func">set!</span></code> будет <code><span class="func">Box-Write</span></code>; так что хоть
коробка и останется той же, но привязка для её содержимого будет создана заново.</p>

<p>Остаётся только правильно инициализировать каждую локальную переменную. Так как
ранее был проведён их анализ и переименование, то конфликтов областей видимости
не будет. Простая обобщённая функция <code><span class="func">bindings->C</span></code> без проблем справится
с инициализацией.</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Fix-Let</span></code>}-->
<!--\indexC{bindings->C}-->
<pre>(define-method (->C (e Fix-Let) out)
  (between-parentheses out
    (bindings->C (Fix-Let-variables e) (Fix-Let-arguments e) out)
    (->C (Fix-Let-body e) out) ) )</p>

<p>(define-generic (bindings->C variables (arguments) out))</p>

<p>(define-method (bindings->C variables (e Arguments) out)
  (variable->C (car variables) out)
  (format out " = ")
  (->C (Arguments-first e) out)
  (format out ", %")
  (bindings->C (cdr variables) (Arguments-others e) out) )</p>

<p>(define-method (bindings->C variables (e No-Argument) out)
  (format out "") )</pre>


<!--\indexR{встраивание}-->
<!--\indexR{инлайнинг}-->
<p>Наконец, остаётся случай аппликации, когда функцией является значение
предопределённой переменной, — такие вызовы <em>встраиваются</em> напрямую
в код. Примитивам нет нужды пользоваться <code><span class="func">SCM\_invoke</span></code>. Они будут написаны
на Си и включены в состав библиотеки времени исполнения, которая подключается
к любой скомпилированной программе. Примитивы знают о внутренних структурах
данных, так что могут обойтись без относительно дорогого (и бесполезного
в данном случае) вызова <code><span class="func">SCM\_invoke</span></code>.</p>


<!--\indexR{функции!примитивы!генератор вызовов}-->
<!--\indexR{примитивы!генератор вызовов}-->
<p>Так как точная форма прямого вызова примитива зависит от его реализации, мы
поступим следующим образом: расширим класс дескрипторов, описывающих
функции-примитивы, дополнительным полем <code><span class="func">generator</span></code>, служащим для хранения
специальных функций-генераторов. Их задачей будет принять интересующую нас
аппликацию и выдать в порт соответствующий код на Си. Каким образом они его
получат — это личное дело генераторов, но чтобы облегчить им немного жизнь,
мы определим обобщённую функцию <code><span class="func">arguments->C</span></code>, рекурсивно применяющую
<code><span class="func">->C</span></code> к аргументам вызова.</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Predefined-Application</span></code>}-->
<!--\indexC{arguments->C}-->
<pre>(define-generic (arguments->C (e) out))</p>

<p>(define-method (arguments->C (e No-Argument) out) #t)</p>

<p>(define-method (arguments->C (e Arguments) out)
  (->C (Arguments-first e) out)
  (->C (Arguments-others e) out) )</p>

<p>(define-method (->C (e Predefined-Application) out)
  ((Functional-Description-generator
    (Predefined-Variable-description
     (Predefined-Application-variable e) ) ) e out ) )</pre>

<h3 id="cc/gen/ssect:predef-env">Предопределённое окружение</h3>

<p>Если мы собрались пользоваться предопределёнными функциями, то о них вначале
необходимо рассказать компилятору. Для этого определяется специальный макрос
<code><span class="func">defprimitive</span></code>:</p>


<!--\indexC{Functional-Description}-->
<!--\indexC{defprimitive}-->
<pre>(define-class Functional-Description Object
  ( comparator arity generator ) )</p>

<p>(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name Cname arity)
     (let ((v (make-Predefined-Variable 'name
               (make-Functional-Description
                = arity
                (make-predefined-application-generator 'Cname) ) )))
       (set! g.init (cons v g.init))
       'name ) ) ) )</pre>

<p>Итак, компилятору известно имя примитива на Scheme и Си, а также его арность.
На выходе ожидается вызов функции Си: то есть имя функции, за которым в скобках
следуют аргументы, разделённые запятыми. Функция
<code><span class="func">make-predefined-application-generator</span></code> создаёт генераторы подобных вызовов.</p>


<!--\indexC{make-predefined-application-generator}-->
<pre>(define (make-predefined-application-generator Cname)
  (lambda (e out)
    (format out -A" Cname)
    (between-parentheses out
      (arguments->C (Predefined-Application-arguments e) out) ) ) )</pre>

<p>Приведём несколько примеров для всем знакомых функций:</p>

<pre>(defprimitive cons "SCM_cons" 2)
(defprimitive car "SCM_car" 1)
(defprimitive + "SCM_Plus" 2)
(defprimitive = "SCM_EqnP" 2)</pre>


<!--\indexR{соглашения именования!макросов и примитивов}-->
<p>Отсюда видно, что вызов <code><span class="func">cons</span></code> будет компилироваться в вызов функции
<code><span class="func">SCM\_cons</span></code>, а примитив <code><span class="func">+</span></code> — в макрос <code><span class="func">SCM\_Plus</span></code>.
\seePage[cc/data/values/par:macros] Макрос можно отличить от функции по
прописной первой букве имени. Некоторые примитивы из соображений компактности
кода эффективнее реализовывать именно как макросы.</p>

<h3 id="cc/gen/ssect:func">Компиляция функций</h3>


<!--\indexR{арность}-->
<!--\indexR{представление!арности}-->
<p>Выполненные ранее трансформации преобразовали все абстракции в явно создаваемые
замыкания, которым соответствуют объекты класса <code><span class="func">Closure-Creation</span></code>. В Си за
создание замыканий будет отвечать библиотечная функция <code><span class="func">SCM\_close</span></code>. Первым
аргументом она принимает адрес Си-функции (завёрнутый в макрос
<code><span class="func">SCM\_CfunctionAddress</span></code>), соответствующий телу абстракции; за адресом следует
арность создаваемого замыкания, а в конце списка расположены количество
замыкаемых значений и, собственно, сами значения. Данные значения извлекаются
из поля <code><span class="func">free</span></code> обрабатываемой абстракции. Количество аргументов функций
с фиксированной арностью записывается просто соответствующим числом.
Но если это функция с переменной арностью, то ей может быть передано любое
количество аргументов, не меньшее некоторого $i$; этот случай будет
представляться числом $-i - 1$. К примеру, арность функции <code><span class="func">list</span></code> равна $-1$.</p>


<!--\indexCS*{c}{->C}{<code><span class="func">Closure-Creation</span></code>}-->
<!--\indexCS*{c}{->C}{<code><span class="func">No-Free</span></code>}-->
<!--\indexCS*{c}{->C}{<code><span class="func">Free-Environment</span></code>}-->
<!--\indexC{generate-arity}-->
<pre>(define-method (->C (e Closure-Creation) out)
  (format out "SCM_close")
  (between-parentheses out
    (format out "SCM_CfunctionAddress(function_ A),  A,  A"
            (Closure-Creation-index e)
            (generate-arity (Closure-Creation-variables e))
            (number-of (Closure-Creation-free e)) )
    (->C (Closure-Creation-free e) out) ) )</p>

<p>(define (generate-arity variables)
  (let count ((variables variables) (arity 0))
    (if (pair? variables)
        (if (Local-Variable-dotted? (car variables))
            (- (+ arity 1))
            (count (cdr variables) (+ 1 arity)) )
        arity ) ) )</p>

<p>(define-method (->C (e No-Free) out)
  #t )</p>

<p>(define-method (->C (e Free-Environment) out)
  (format out ", ")
  (->C (Free-Environment-first e) out)
  (->C (Free-Environment-others e) out) )</pre>

<p>Все абстракции компилируемой программы собираются в соответствующем
поле объекта <code><span class="func">Flattened-Program</span></code> в виде списка объектов класса
<code><span class="func">With-Temp-Function-Definition</span></code>. Каждому из них сопоставляется
эквивалентная функция на Си.</p>


<!--\indexC{generate-functions}-->
<pre>(define (generate-functions out definitions)
  (format out -%/* Functions: */ %")
  (for-each (lambda (def)
              (generate-closure-structure out def)
              (generate-possibly-dotted-definition out def) )
            (reverse definitions) ) )</pre>


<!--\indexC*{function}{function\_}-->
<!--\indexR{таблица символов}-->
<p>Для повышения удобочитаемости генерируемого кода снова используются макросы,
чтобы скрыть детали реализации. Для каждого замыкания генерируется функция,
содержащая его тело, а также структура данных, которая будет хранить
замкнутые переменные. Имена создаваемых сущностей строятся по простому
принципу: корень <code><span class="func">function\_</span></code> $+$ номерной суффикс, взятый из поля
<code><span class="func">index</span></code> объекта <code><span class="func">Function-Definition</span></code>.\footnote*{Имена функций вида
<code><span class="func">function\_$i$</span></code>, очевидно, никак не связаны с именами соответствующих им
глобальных переменных. Если не пренебрегать таблицей символов, как это сделано
здесь, то вполне можно выводить более понятные имена.}</p>

<p>Внутренняя структура замыканий формируется макросом <code><span class="func">SCM\_DefineClo\-sure</span></code>.
Первым аргументом он получает номер соответствующей функции, а вторым — имена
захватываемых замыканием переменных, разделённые точками с запятой.</p>


<!--\indexC{generate-closure-structure}-->
<pre>(define (generate-closure-structure out definition)
  (format out "SCM_DefineClosure(function_ A, "
          (Function-Definition-index definition) )
  (generate-local-temporaries (Function-Definition-free definition)
                              out )
  (format out "); %") )</pre>

<p>Функция <code><span class="func">generate-possibly-dotted-definition</span></code> генерирует определение тела
замыкания в виде функции Си, учитывая его арность. Прототип этой функции
формирует макрос <code><span class="func">SCM\_DeclareFunction</span></code>, принимающий её имя как аргумент.
Локальные переменные функции определяются с помощью макросов
<code><span class="func">SCM\_DeclareLocalVariable</span></code> и <code><span class="func">SCM\_DeclareLocalDottedVariable</span></code>. Они
принимают имя создаваемой переменной, а также её порядковый номер в списке
переменных функции. Правда, этот номер нужен только для сборки списка,
связываемого с точечной переменной. С телом функции вообще нет проблем: просто
применяем к нему <code><span class="func">->C</span></code> и не забываем вернуть вычисленное значение с помощью
оператора <code><span class="func">return</span></code>.</p>


<!--\indexC{generate-possibly-dotted-definition}-->
<pre>(define (generate-possibly-dotted-definition out definition)
  (format out -%SCM_DeclareFunction(function_ A) %{ %"
          (Function-Definition-index definition) )
  (let ((vars (Function-Definition-variables definition))
        (index -1) )
    (for-each (lambda (v)
                (set! index (+ 1 index))
                (cond ((Local-Variable-dotted? v)
                       (format out "SCM_DeclareLocalDottedVariable(") )
                      ((Variable? v)
                       (format out "SCM_DeclareLocalVariable(") ) )
                (variable->C v out)
                (format out ",  A); %" index) )
              vars )
    (let ((temps (With-Temp-Function-Definition-temporaries
                  definition )))
      (when (pair? temps)
        (generate-local-temporaries temps out)
        (format out -%") ) )
    (format out "return ")
    (->C (Function-Definition-body definition) out)
    (format out "; %} % %") ) )</pre>

<p>Список локальных переменных формируется функцией
<code><span class="func">generate-local-temporaries</span></code>:</p>


<!--\indexC{generate-local-temporaries}-->
<pre>(define (generate-local-temporaries temps out)
  (when (pair? temps)
    (format out "SCM ")
    (variable->C (car temps) out)
    (format out "; ")
    (generate-local-temporaries (cdr temps) out) ) )</pre>

<h3 id="cc/gen/ssect:init">Последний штрих</h3>


<!--\indexC{main}-->
<p>Сейчас наш компилятор способен переварить любую программу на Scheme, но для
получения полноценной программы на Си ей не хватает функции <code><span class="func">main</span></code>. Именно
этой функции соответствует то замыкание, в которое была обернута вся программа,
когда мы избавлялись от вложенных <code><span class="func">lambda</span></code>-форм.
\seePage[cc/collecting/par:main] Единственным спорным вопросом здесь является включение в главную функцию вызова
<code><span class="func">SCM\_print</span></code>, выводящего на экран результат работы программы. В общем случае
это не нужно — есть множество полезных и при этом молчаливых программ
(например, <code><span class="func">gcc</span></code>). Но для нас более удобным будет сразу же видеть достижения
наших небольших программок.</p>


<!--\indexC{generate-main}-->
<pre>(define (generate-main out form)
  (format out -%/* Expression: */ %")
  (format out "int main(void) %{ %")
  (format out "    SCM_print")
  (between-parentheses out
    (->C form out) )
  (format out "; %    return 0; %} %") )</pre>


<!--\indexR{компиляция!в Си}-->
<p>Конечно, о представлении данных ещё не было сказано ничего конкретного, равно
как и о реализации библиотеки времени исполнения, но у нас уже есть полностью
рабочий компилятор вместе с огромным желанием испытать его в деле. Натравим его
на подопытный пример, приведённый в начале главы.
\seePage[cc/sect:objectification] И-и-и\textdots\ вот что получается на
выходе (отступы расставлены вручную для читабельности):</p>

<p>\begin{code:c-frame}[numbers=left, title={\snippet{o/chap10ex.c}},
    label=cc/gen/init/src:result]
/* Compiler to C $Revision: 4.1$
(BEGIN
  (SET! INDEX 1)
  ((LAMBDA
     (CNTER . TMP)
     (SET! TMP (CNTER (LAMBDA (I) (LAMBDA X (CONS I X)))))
     (IF CNTER (CNTER TMP) INDEX))
    (LAMBDA (F) (SET! INDEX (+ 1 INDEX)) (F INDEX))
    'FOO))
*/</p>

<p>#include "scheme.h"</p>

<p>/* Global environment: */
SCM_DefineGlobalVariable(INDEX, "INDEX");</p>

<p>/* Quotations: */
#define thing3 SCM_nil                      /* () */
SCM_DefineString(thing4_object, "FOO");
#define thing4 SCM_Wrap(&thing4_object)
SCM_DefineSymbol(thing2_object, thing4);    /* FOO */
#define thing2 SCM_Wrap(&thing2_object)
#define thing1 SCM_Int2Fixnum(1)
#define thing0 thing1                       /* 1 */</p>

<p>/* Functions: */
SCM_DefineClosure(function_0, );</p>

<p>SCM_DeclareFunction(function_0)
{
    SCM_DeclareLocalVariable(F, 0);
    return ((INDEX = SCM_Plus(thing1,
                              SCM_CheckedGlobal(INDEX))),
            SCM_invoke1(F,
                        SCM_CheckedGlobal(INDEX)));
}</p>

<p>SCM_DefineClosure(function_1, SCM I; );</p>

<p>SCM_DeclareFunction(function_1)
{
    SCM_DeclareLocalDottedVariable(X, 0);
    return SCM_cons(SCM_Free(I),
                    X);
}
`\ForLayout{display}{\vskip-0.166\baselineskip}`
SCM_DefineClosure(function_2, );
`\ForLayout{display}{\vskip-0.166\baselineskip}`
SCM_DeclareFunction(function_2)
{
    SCM_DeclareLocalVariable(I, 0);
    return SCM_close(SCM_CfunctionAddress(function_1), -1, 1, I);
}
`\ForLayout{display}{\vskip-0.166\baselineskip}`
SCM_DefineClosure(function_3, );
`\ForLayout{display}{\vskip-0.166\baselineskip}`
SCM_DeclareFunction(function_3)
{
    SCM TMP_2; SCM CNTER_1;
    return ((INDEX = thing0),
            (CNTER_1 = SCM_close(SCM_CfunctionAddress(function_0), 1, 0),
             TMP_2 = SCM_cons(thing2,
                              thing3),
             (TMP_2 = SCM_allocate_box(TMP_2),
              ((SCM_Content(TMP_2) =
               SCM_invoke1(CNTER_1, SCM_close(SCM_CfunctionAddress
                                              (function_2), 1, 0))),
               ((CNTER_1 != SCM_false)
                ? SCM_invoke1(CNTER_1,
                              SCM_Content(TMP_2))
                : SCM_CheckedGlobal(INDEX))))));
}
`\ForLayout{display}{\vskip-0.166\baselineskip}`
/* Expression: */
int main(void)
{
    SCM_print(SCM_invoke0(SCM_close(SCM_CfunctionAddress(function_3),
                                    0, 0)));
    return 0;
}
`\ForLayout{display}{\vskip-0.166\baselineskip}`
/* End of generated code */
\end{code:c-frame}</p>

<p>Также стоит взглянуть функции <code><span class="func">function\_1</span></code> и <code><span class="func">function\_2</span></code> в раскрытом
виде, без макросов (кроме <code><span class="func">va\_list</span></code>). Остальные выражения раскрываются
аналогично.</p>

<p>\begin{code:c}
struct function_1 {
    SCM     (*behavior)(void);
    long    arity;
    SCM     I;
};</p>

<p>SCM function_1(struct function_1 *self_,
               unsigned long size_,
               va_list arguments_)
{
    SCM X = SCM_list(size_ - 0, arguments_);
    return SCM_cons(((self_)->I), X);
}</p>

<p>struct function_2 {
    SCM     (*behavior)(void);
    long    arity;
};</p>

<p>SCM function_2(struct function_2 *self_,
               unsigned long size_,
               va_list arguments_)
{
    SCM I = va_arg(arguments_, SCM);
    return SCM_close(((SCM(*)(void)) function_1), -1, 1, 1);
}
\end{code:c}</p>

<p>Если откомпилировать получившуюся программу любым компилятором, поддерживающим
стандарт C90 (например, <code><span class="func">gcc</span></code>), подключив к ней необходимые библиотеки,
о которых мы упоминали, то получится (весьма небольшой) исполнимый файл,
который (весьма быстро\footnote{Большая часть потраченного времени уходит на
загрузку; собственно исполнение занимает пренебрежимо малую его часть. Если
данные вычисления повторить 10\,000 раз, то время выполнения программы
увеличится всего до одной секунды.}) выдаёт ожидаемый результат.%
\footnote*{Замеры производились на Sony News 3200 с процессором MIPS R3000
на борту.}</p>

<p>\begin{shell}
% gcc -ansi -pedantic chap10ex.c scheme.o schemelib.o
% time a.out
(2 3)
0.010u 0.000s 0:00.00 0.0% 3+5k 0+0io 0pf+0w
% size a.out
text    data    bss     dec     hex
28762   4096    32      32800   8020
\end{shell}</p>

<p>\ForLayout{display}{\smallskip}</p>

<h2 id="cc/sect:data">Представление данных</h2>


<!--\indexC*{scheme.h}{"scheme.h"}-->
<!--\indexC{malloc}-->
<!--\indexR{сборка мусора}-->
<p>В этом разделе мы займёмся разбором макросов, описываемых в файле
<code><span class="func">"scheme.h"</span></code>. Нет нужды повторять, что целью данного <em>упражнения</em>
является ознакомление, объяснение и демонстрация разнообразных приёмов, а
не создание самого быстрого и эффективного в мире компилятора. Поэтому мы
не будем обременять себя проблемами управления памятью; все выделения памяти
выполняются простыми вызовами <code><span class="func">malloc</span></code>, так что при желании будет весьма
просто подключить к программам сторонний консервативный сборщик мусора,
например, известный Boehm GC <span class="cite">[<a href="z1_bibliography.xhtml#bw88">bw88</a>]</span>.</p>


<!--\indexR{динамическая типизация}-->
<!--\indexR{выравнивание}-->
<p>В Лиспе и Scheme принята динамическая типизация, то есть тип любого значения
всегда можно узнать во время исполнения программы. Соответственно, эту
информацию необходимо где-то хранить. Одной из основных головных болей
разработчиков реализаций динамически типизированных языков является как раз
эффективное связывание значений с их типами. Мало того, значения ещё могут быть
различного размера, так как некоторые из них представляют собой произвольные
наборы других значений. С этой проблемой можно справиться, применив косвенную
адресацию — указатели всегда имеют постоянный размер. Объекты будут
динамически создаваться в памяти, обращаться к ним будем посредством указателей,
а их типы можно размещать, например, в начале выделенных фрагментов памяти.
Неудобство (по сравнению со статически типизированными языками, где вопросы
с типами уже решены до исполнения программы) здесь в том, что простые значения
вроде чисел не могут быть эффективно использованы напрямую, только через
указатели. Ситуацию можно исправить несколькими способами. Один из них основан
на том, что в современных компьютерах данные в памяти выравниваются по границе
четырёх или восьми байт, что оставляет два-три младших бита адресов
неиспользуемыми. Этими битами можно закодировать информацию о виде значения, на
которое ссылается указатель. А если значение является числом, то почему бы
не записать его вместо адреса? Мы так и поступим с целыми числами, сделав работу
с ними более эффективной, но отдав за это один значащий бит, что несколько
уменьшит диапазон непосредственно представимых значений. Конечно, есть и другие
варианты, неплохую их подборку можно найти в <span class="cite">[<a href="z1_bibliography.xhtml#gud93">gud93</a>]</span>.</p>


<!--\indexR{представление!объектов Scheme на Си}-->
<p>Возвращаемся к насущному; взгляните на рисунок \ref{cc/data/pic:tagptr}.
Значения Scheme представляются такими значениями Си, что если их младший бит
равен единице, то остальные биты считаются представлением некоторого целого
числа. Например, на 32-битных машинах получаются 31-битные числа. Если же
младший бит нулевой, то это адрес первого поля соответствующего значения Scheme.
Тип этого значения расположен <em>перед</em>\footnote{Пустой указатель в Си
(<code><span class="func">NULL</span></code>) чаще всего численно равен нулю. Естественно, он не является
допустимым значением Scheme, так как нелегко будет отыскать в памяти
адрес $-1$.} его полями, как у <span class="cite">[<a href="z1_bibliography.xhtml#dps94a">dps94a</a>]</span>. Сами значения представляются
обычными структурами данных Си. Их тип — как вы уже, наверное, догадались
— называется <code><span class="func">SCM</span></code>.</p>


<!--\indexC{SCM}-->
<p>\begin{code:c}
typedef union SCM_object *SCM;
\end{code:c}</p>

<p>\begin{figure}\centering
\input{figures/fig10.5}
\caption{Представление значений Scheme в Си.}%
\label{cc/data/pic:tagptr}
\end{figure}</p>


<!--\indexC*{SCM_FixnumP}{SCM\_FixnumP}-->
<!--\indexC*{SCM_Fixnum2Int}{SCM\_Fixnum2Int}-->
<!--\indexC*{SCM_Int2Fixnum}{SCM\_Int2Fixnum}-->
<p>Макрос <code><span class="func">SCM\_FixnumP</span></code> позволяет отличить целые числа от указателей.
Приведением типов занимаются макросы <code><span class="func">SCM\_Fixnum2Int</span></code> и
<code><span class="func">SCM\_Int2Fixnum</span></code>. Например, числу 37 в Scheme соответствует число 75 в Си.</p>

<p>\begin{code:c}
#define SCM_FixnumP(x)    ((unsigned long)(x) & 1UL)
#define SCM_Fixnum2Int(x) ((long)(x) » 1)
#define SCM_Int2Fixnum(i) ((SCM)(((i) « 1) | 1UL))
\end{code:c}</p>

<p>Если значение <code><span class="func">SCM</span></code> не является числом, то это указатель на объект типа
<code><span class="func">SCM\_object</span></code>. Данное объединение все типы данных, поддерживаемые языком.
Некоторых типов там нет, в частности: чисел с плавающей запятой, векторов,
портов. Но самое важное в Scheme — точечные пары,\footnote*{Как вы помните,
<code><span class="func">cdr</span></code> лучше располагать перед <code><span class="func">car</span></code>, потому что пары — это всё же
основной элемент связных списков, а <code><span class="func">cdr</span></code> при обходе списка просматривается
чаще, как утверждается в <span class="cite">[<a href="z1_bibliography.xhtml#cla79">cla79</a>]</span>.} замыкания и продолжения — мы
обязательно реализуем.</p>


<!--\indexC*{SCM_object}{SCM\_object}-->
<p>\begin{code:c}
union SCM_object {
    struct SCM_pair {
        SCM cdr;
        SCM car;
    } pair;

    struct SCM_string {
        char Cstring[8];
    } string;

    struct SCM_symbol {
        SCM pname;
    } symbol;</p>

<p>    struct SCM_box {
        SCM content;
    } box;</p>

<p>    struct SCM_subr {
        SCM (*behavior)(void);
        long arity;
    } subr;</p>

<p>    struct SCM_closure {
        SCM (*behavior)(void);
        long arity;
        SCM environment[1];
    } closure;</p>

<p>    struct SCM_escape {
        struct SCM_jmp_buf *stack_address;
    } escape;
};
\end{code:c}</p>

<p>Полноценные значения Scheme, представляемые <code><span class="func">SCM\_object</span></code>, должны содержать
внутри себя собственный тип. Мы будем его хранить весьма специфичным образом.
Собственно метка типа представляется перечислением <code><span class="func">SCM\_tag</span></code>. Числовые
константы выбраны так, чтобы гарантировать некоторое количество незначащих
битов, например, для нужд сборщика мусора. В памяти метка должна располагаться
не абы как, а быть строго выровненной по размеру <code><span class="func">SCM</span></code> — именно для этого
в объединение <code><span class="func">SCM\_header</span></code> добавлена заглушка <code><span class="func">ignored</span></code>. Наконец, объекты
вместе с информацией об их типе будут представляться объединениями
<code><span class="func">SCM\_unwrapped\_object</span></code>.</p>


<!--\indexC*{SCM_tag}{SCM\_tag}-->
<!--\indexC*{SCM_header}{SCM\_header}-->
<!--\indexC*{SCM_unwrapped_object}{SCM\_unwrapped\_object}-->
<p>\begin{code:c}
enum SCM_tag {
    SCM_NULL_TAG      = 0xAAA0,
    SCM_PAIR_TAG      = 0xAAA1,
    SCM_BOOLEAN_TAG   = 0xAAA2,
    SCM_UNDEFINED_TAG = 0xAAA3,
    SCM_SYMBOL_TAG    = 0xAAA4,
    SCM_STRING_TAG    = 0xAAA5,
    SCM_SUBR_TAG      = 0xAAA6,
    SCM_CLOSURE_TAG   = 0xAAA7,
    SCM_ESCAPE_TAG    = 0xAAA8,
};</p>

<p>union SCM_header {
    enum SCM_tag tag;
    SCM ignored;
};</p>

<p>union SCM_unwrapped_object {
    struct SCM_unwrapped_immediate_object {
        union SCM_header header;
    };</p>

<p>    struct SCM_unwrapped_pair {
        union SCM_header header;
        SCM cdr;
        SCM car;
    } pair;

    struct SCM_unwrapped_string {
        union SCM_header header;
        char Cstring[8];
    } string;

    struct SCM_unwrapped_symbol {
        union SCM_header header;
        SCM pname;
    } symbol;</p>

<p>    struct SCM_unwrapped_subr {
        union SCM_header header;
        SCM (*behavior)(void);
        long arity;
    } subr;</p>

<p>    struct SCM_unwrapped_closure {
        union SCM_header header;
        SCM (*behavior)(void);
        long arity;
        SCM environment[1];
    } closure;</p>

<p>    struct SCM_unwrapped_escape {
        union SCM_header header;
        struct SCM_jmp_buf *stack_address;
    } escape;
};
\end{code:c}</p>

<p>Следующие макросы помогают с приведением и определением типов объектов. Они
будут полезными по большей части лишь библиотечным функциями, потому как только
им необходимо различать <code><span class="func">SCM</span></code> и <code><span class="func">SCMref</span></code>.</p>


<!--\indexC{SCMref}-->
<!--\indexC*{SCM_Wrap}{SCM\_Wrap}-->
<!--\indexC*{SCM_Unwrap}{SCM\_Unwrap}-->
<!--\indexC*{SCM_2tag}{SCM\_2tag}-->
<p>\begin{code:c}
typedef union SCM_unwrapped_object *SCMref;</p>

<p>#define SCM_Wrap(x)   ((SCM)    (((union SCM_header*) x) + 1))
#define SCM_Unwrap(x) ((SCMref) (((union SCM_header*) x) - 1))
#define SCM_2tag(x)   ((SCM_Unwrap((SCM) x))->object.header.tag)
\end{code:c}</p>

<p>Наконец, адреса функций, написанных на Си, будут храниться (но
не использоваться) как указатели на функции без аргументов, возвращающие
<code><span class="func">SCM</span></code>. Макрос <code><span class="func">SCM\_CfunctionAddress</span></code> приводит их к этому типу.</p>


<!--\indexC*{SCM_CfunctionAddress}{SCM\_CfunctionAddress}-->
<p>\begin{code:c}
#define SCM_CfunctionAddress(Cfunction) ((SCM (*)(void)) Cfunction)
\end{code:c}</p>

<h3 id="cc/data/ssect:values">Объявления значений</h3>

<p>Кроме всего прочего, <code><span class="func">scheme.h</span></code> определяет специальные макросы для
статического создания значений Scheme. Их имена начинаются на <code><span class="func">SCM\_Define</span></code>.
Чтобы получить точечную пару, достаточно объявить новую переменную типа
<code><span class="func">SCM\_unwrapped\_pair</span></code>. Символы и прочие значения объявляются аналогично.
Всякий раз сначала создаётся объект, а затем берётся его адрес и превращается
в корректное значение Scheme с помощью <code><span class="func">SCM\_Wrap</span></code>.</p>


<!--\indexC*{SCM_DefinePair}{SCM\_DefinePair}-->
<!--\indexC*{SCM_DefineSymbol}{SCM\_DefineSymbol}-->
<p>\begin{code:c}
#define SCM_DefinePair(pair, car, cdr)  \
  static struct SCM_unwrapped_pair pair = {{SCM_PAIR_TAG}, cdr, car}
#define SCM_DefineSymbol(symbol, name)  \
  static struct SCM_unwrapped_symbol symbol = {{SCM_SYMBOL_TAG}, name}
\end{code:c}</p>


<!--\indexR{представление!строк}-->
<p>Со строками всё немного сложнее, так как в Си нельзя статически инициализировать
структуры переменного размера. Также следует быть очень осторожными со строками
Си: не перепутать их содержимое с адресом и не забыть о нулевом байте в конце.
Мы решим данные затруднения, объявляя для каждой статической строки личную
структуру. Собственно содержимое строк будет представляться родными строками Си.</p>


<!--\indexC*{SCM_DefineString}{SCM\_DefineString}-->
<p>\begin{code:c}
#define SCM_DefineString(Cname, string) \
  struct Cname##_struct {               \
      union SCM_header header;          \
      char Cstring[1 + sizeof(string)]; \
  };                                    \
  static struct Cname##_struct Cname =  \
      {{SCM_STRING_TAG}, string}
\end{code:c}</p>

<p>Также нам будут необходимы несколько предопределённых значений. Для программ
важны только их имена и типы, поэтому они объявляются как непосредственные
значения. Мы воспользуемся <code><span class="func">SCM\_Wrap</span></code> для приведения их к типу <code><span class="func">SCM</span></code>.</p>


<!--\indexC*{SCM_DefineImmediateObject}{SCM\_DefineImmediateObject}-->
<!--\indexC*{SCM_true}{SCM\_true}-->
<!--\indexC*{SCM_false}{SCM\_false}-->
<!--\indexC*{SCM_nil}{SCM\_nil}-->
<p>\begin{code:c}
#define SCM_DefineImmediateObject(name, tag) \
  struct SCM_unwrapped_immediate_object name = {{tag}}
`\ForLayout{display}{\vskip-0.333\baselineskip}`
SCM_DefineImmediateObject(SCM_true_object,  SCM_BOOLEAN_TAG)
SCM_DefineImmediateObject(SCM_false_object, SCM_BOOLEAN_TAG)
SCM_DefineImmediateObject(SCM_nil_object,   SCM_PAIR_TAG)
`\ForLayout{display}{\vskip-0.333\baselineskip}`
#define SCM_true  SCM_Wrap(&SCM_true_object)
#define SCM_false SCM_Wrap(&SCM_false_object)
#define SCM_nil   SCM_Wrap(&SCM_nil_object)
\end{code:c}</p>

<p>Логические значения Scheme не тождественны логическим значениям Си, поэтому
соответствующее преобразование не будет лишним. Определим для этого макрос
<code><span class="func">SCM\_2bool</span></code>:</p>


<!--\indexC*{SCM_2bool}{SCM\_2bool}-->
<p>\begin{code:c}
#define SCM_2bool(i) ((i) ? SCM_true : SCM_false)
\end{code:c}</p>


<!--\indexR{проверки типов}-->
<!--\indexR{соглашения именования!предикатов в Си}-->
<p>Также мы определим несколько вспомогательных макросов для проверки типов и
простейших операций со значениями. Предикаты имеют суффикс <code><span class="func">P</span></code>, который
означает, что они возвращают логические значения Си.</p>


<!--\indexC*{SCM_Car}{SCM\_Car}-->
<!--\indexC*{SCM_Cdr}{SCM\_Cdr}-->
<!--\indexC*{SCM_NullP}{SCM\_NullP}-->
<!--\indexC*{SCM_PairP}{SCM\_PairP}-->
<p>\begin{code:c}
#define SCM_Car(x)     (SCM_Unwrap(x)->pair.car)
#define SCM_Cdr(x)     (SCM_Unwrap(x)->pair.cdr)
#define SCM_NullP(x)   ((x) == SCM_nil)
#define SCM_EqP(x, y)  ((x) == (y))</p>

<p>#define SCM_PairP(x)   \
  ((!SCM_FixnumP(x)) && (SCM_2tag(x) == SCM_PAIR_TAG))</p>

<p>#define SCM_SymbolP(x) \
  ((!SCM_FixnumP(x)) && (SCM_2tag(x) == SCM_SYMBOL_TAG))</p>

<p>#define SCM_StringP(x) \
  ((!SCM_FixnumP(x)) && (SCM_2tag(x) == SCM_STRING_TAG))
\end{code:c}</p>

<p>\phantomlabel{cc/data/values/par:macros}
Естественно, макросы вроде <code><span class="func">SCM\_Car</span></code> и <code><span class="func">SCM\_Cdr</span></code> будут использоваться
исключительно в тех случаях, когда компилятор <em>знает</em>, что значение имеет
подходящий тип. Следующие макросы для арифметических действий, например, этого
заранее знать не могут, поэтому в них проверки типов выполняются явно. Конечно,
таким образом мы лишаемся возможной оптимизации в случае, если типы всё же
будут известны,\footnote*{Некоторые компиляторы Си достаточно сообразительны,
чтобы избавиться от части ненужных проверок, но, как известно, хочешь сделать
хорошо — сделай это сам.} но этот вопрос уже обсуждался: с точки зрения
педагогики важнее показать всю массу вариантов, нежели рассмотреть в деталях
пару-тройку лучших. Если бы мы хотели добиться максимальной эффективности,
компилятор был бы устроен совсем не так и выдавал бы совершенно иной код.</p>


<!--\indexC*{SCM_Plus}{SCM\_Plus}-->
<!--\indexC*{SCM_GtP}{SCM\_GtP}-->
<p>\begin{code:c}
#define SCM_Plus(x, y)                                     \
  ((SCM_FixnumP(x) && SCM_FixnumP(y))                      \
   ? SCM_Int2Fixnum(SCM_Fixnum2Int(x) + SCM_Fixnum2Int(y)) \
   : SCM_error(SCM_ERR_PLUS))</p>

<p>#define SCM_GtP(x, y)                                      \
  ((SCM_FixnumP(x) && SCM_FixnumP(y))                      \
   ? SCM_2bool(SCM_Fixnum2Int(x) > SCM_Fixnum2Int(y))      \
   : SCM_error(SCM_ERR_GTP))
\end{code:c}</p>

<h3 id="cc/data/ssect:global">Глобальные переменные</h3>


<!--\indexR{неинициализированные переменные}-->
<!--\indexR{переменные!неинициализированные}-->
<p>Для получения значения глобальной переменной используется макрос
\ic{SCM\discretionary{\_}{}{\_}CheckedGlobal}, который проверяет, была ли она
инициализирована или нет. Следовательно, необходимо выделить какое-то
определённое значение Си для обозначения неинициализированных переменных Scheme
— назовём его \ic{SCM\discretionary{\_}{}{\_}undefined}. Изменяемые
глобальные переменные при создании просто инициализируются (в Си) этим
значением, показывающим, что (в Scheme) они ещё не были инициализированы.</p>


<!--\indexC*{SCM_undefined}{SCM\_undefined}-->
<!--\indexC*{SCM_CheckedGlobal}{SCM\_CheckedGlobal}-->
<!--\indexC*{SCM_DefineInitializedGlobalVariable}{SCM\_DefineInitializedGlobalVariable}-->
<!--\indexC*{SCM_DefineGlobalVariable}{SCM\_DefineGlobalVariable}-->
<p>\begin{code:c}
SCM_DefineImmediateObject(SCM_undefined_object, SCM_UNDEFINED_TAG);
#define SCM_undefined SCM_Wrap(&SCM_undefined_object)</p>

<p>#define SCM_CheckedGlobal(Cname) \
  ((Cname != SCM_undefined) ? Cname
                            : SCM_error(SCM_ERR_UNINITIALIZED))</p>

<p>#define SCM_DefineInitializedGlobalVariable(Cname, string, value) \
  SCM Cname = SCM_Wrap(value)</p>

<p>#define SCM_DefineGlobalVariable(Cname, string)      \
  SCM_DefineInitializedGlobalVariable(Cname, string, \
                                             &SCM_undefined_object)
\end{code:c}</p>

<p>Ещё одной важным делом является связывание предопределённых значений
с предопределёнными переменными. Например, если мы хотим пользоваться
в программах <code><span class="func">NIL</span></code> для обозначения пустого списка <code>()</code>, то следует
определить в Си глобальную переменную <code><span class="func">NIL</span></code> со значением
<code><span class="func">SCM\_nil\_object</span></code>. Это определение (вместе с множеством других) находится
в файле <code><span class="func">schemelib.c</span></code>:</p>

<p>\begin{code:c}
SCM_DefineInitializedGlobalVariable(NIL, "NIL", &SCM_nil_object);
SCM_DefineInitializedGlobalVariable(F,   "F",   &SCM_false_object);
SCM_DefineInitializedGlobalVariable(T,   "T",   &SCM_true_object);
\end{code:c}</p>

<p>Многое можно выразить с помощью этих трёх значений, но нам бы хотелось иметь
в распоряжении также и знакомые функции: <code><span class="func">CONS</span></code>, <code><span class="func">CAR</span></code> и т. д. Они
определяются макросом <code><span class="func">SCM\_DefinePredefinedFunctionVariable</span></code>. Вот его
определение вместе с несколькими примерами:</p>


<!--\indexC*{SCM_DefinePredefinedFunctionVariable}{SCM\_DefinePredefinedFunctionVariable}-->
<p>\begin{code:c}
#define SCM_DefinePredefinedFunctionVariable(subr, string,           \
                                             arity, Cfunction)       \
  static struct SCM_unwrapped_subr subr##_object =                   \
      {{SCM_SUBR_TAG}, Cfunction, arity};                            \
  SCM_DefineInitializedGlobalVariable(subr, string, &(subr##_object))</p>

<p>SCM_DefinePredefinedFunctionVariable(CAR,  "CAR",  1, SCM_car);
SCM_DefinePredefinedFunctionVariable(CONS, "CONS", 2, SCM_cons);
SCM_DefinePredefinedFunctionVariable(EQN,  -",    2, SCM_eqnp);
SCM_DefinePredefinedFunctionVariable(EQ,   "EQ?",  2, SCM_eqp);
\end{code:c}</p>

<p>Значения изменяемых глобальных переменных размещаются в коробках. Просмотр или
изменение подобных значений выполняются с помощью макроса <code><span class="func">SCM\_Content</span></code>,
определяемого следующим образом:</p>


<!--\indexC*{SCM_Content}{SCM\_Content}-->
<p>\begin{code:c}
#define SCM_Content(e) ((e)->box.content)
\end{code:c}</p>

<h3 id="cc/data/ssect:func">Определения функций</h3>

<p>Осталось лишь рассмотреть представление в памяти функций. Важно тщательно
проработать этот аспект, так как от него существенно зависят возможности
взаимодействия Scheme и Си.</p>

<p>Примитивы с фиксированной арностью представляются функциями Си той же арности.
Следовательно, функцию <code><span class="func">cons</span></code> можно будет вызвать простым и легко
запоминающимся способом: \ic{SCM\_cons(<i>a</i>, <i>d</i>)}.</p>


<!--\indexR{представление!замыканий}-->
<p>Остальные функции, являющиеся полноценными объектами Scheme, требуют б\'{о}льших
усилий. Им может быть передано любое количество аргументов. Они могут быть
результатами вычислений. При вызовах через <code><span class="func">apply</span></code> аргументы им передаются
по-особому. Реализовать всё это, да ещё и эффективно — отнюдь не тривиальная
задача. И снова, желая показать всё множество вариаций, мы позволим себе
применить для обычных функций слегка необычный, но весьма последовательный
во всех смыслах подход (понимая, однако, что его быстродействие оставляет желать
лучшего). \seeEx[cc/ex:boost-calls]</p>

<p>Замыкания будут представляться специальными структурами. Первые два поля
содержат указатель на соответствующую функцию и её арность. Остальные хранят
значения замкнутых свободных переменных. Макрос <code><span class="func">SCM\_Define\-Closure</span></code>
определяет соответствующие типы структур Си для всех используемых замыканий.</p>


<!--\indexC*{SCM_DefineClosure}{SCM\_DefineClosure}-->
<p>\begin{code:c}
#define SCM_DefineClosure(struct_name, fields) \
  struct struct_name {                         \
      SCM (*behavior)(void);                   \
      long arity;                              \
      fields                                   \
  }
\end{code:c}</p>


<!--\indexR{переменная арность!в Си}-->
<p>Первым аргументом замыканий, вызываемых <code><span class="func">SCM\_invoke</span></code>, являются они сами;
так реализуется возможность доступа к замкнутому окружению. Если функция
вызывается с неправильным количеством аргументов — это ошибка, о которой
необходимо сообщить. Проверка арности перекладывается на <code><span class="func">SCM\_invoke</span></code>, так
что функции могут быть уверены в количестве аргументов. Единственным непонятным
моментом остаются функции с переменной арностью: здесь, видимо, придётся явно
передавать им количество аргументов, так как в Си нет возможности его узнать.
Поэтому будем считать, что все функции вторым аргументом принимают количество
фактических аргументов вызова, а сами аргументы всегда передаются с помощью
специального механизма Си, определённого в заголовочном файле <code><span class="func"><stdarg.h></span></code>
(ранее <code><span class="func"><varargs.h></span></code>). Как мы и говорили, это не самое элегантное из
возможных решений; подход, используемый для примитивов, гораздо эффективнее.</p>


<!--\indexC*{self}{self\_}-->
<!--\indexC*{size}{size\_}-->
<!--\indexC*{arguments}{arguments\_}-->
<p>Аргументы объявляемых функций Си (<code><span class="func">self\_</span></code>, <code><span class="func">size\_</span></code> и <code><span class="func">arguments\_</span></code>)
названы так, чтобы их нельзя было спутать с переменными Scheme (вспомните
о подчёркиваниях). Единственным интересным моментом остаётся инициализация
точечной переменной, собирающая в список все оставшиеся аргументы. Список так
список, зачем же ещё существует функция <code><span class="func">SCM\_list</span></code>.</p>


<!--\indexC*{SCM_DeclareFunction}{SCM\_DeclareFunction}-->
<!--\indexC*{SCM_DeclareLocalVariable}{SCM\_DeclareLocalVariable}-->
<!--\indexC*{SCM_DeclareLocalDottedVariable}{SCM\_DeclareLocalDottedVariable}-->
<!--\indexC*{SCM_Free}{SCM\_Free}-->
<p>\begin{code:c}
#define SCM_DeclareFunction(Cname) \
  SCM Cname(struct Cname *self_,   \
            unsigned long size_, va_list arguments_)</p>

<p>#define SCM_DeclareLocalVariable(Cname, index) \
  SCM Cname = va_arg(arguments_, SCM)</p>

<p>#define SCM_DeclareLocalDottedVariable(Cname, index) \
  SCM Cname = SCM_list(size_ - index, arguments_)</p>

<p>#define SCM_Free(Cname) ((self_)->Cname)
\end{code:c}</p>

<p>И всё же в данном подходе есть что-то хорошее: вы только посмотрите, как
просто, понятно и красиво выражаются обращения к свободным переменным!</p>

<h2 id="cc/sect:runtime">Библиотека времени исполнения</h2>


<!--\indexC*{SCM_print}{SCM\_print}-->
<!--\indexR{библиотека!времени исполнения}-->
<!--\indexR{функции!библиотечные}-->
<p>Библиотека времени исполнения (runtime library) — это набор функций,
написанных на Си. Эти функции реализуют возможности, необходимые для полноценной
работы программ, поэтому данная библиотека должна быть подключена ко всякой хоть
сколь-нибудь нетривиальной программе. Конечно, здесь мы лишь набросаем её общие
черты и не будем реализовывать большую часть утилитарных функций вроде
<code><span class="func">string-ref</span></code> или <code><span class="func">close-output-port</span></code>. Будут рассмотрены только самые
важные, типичные библиотечные функции (в частности, здесь нет функции
<code><span class="func">SCM\_print</span></code>, которая используется в генерируемой нами <code><span class="func">main</span></code>).</p>

<h3 id="cc/runtime/ssect:alloc">Выделение памяти</h3>

<p>В Си за управление памятью отвечает лично программист, так что сборщика мусора
у нас не будет, потому как его написание с нуля заняло бы слишком много времени.
За информацией об этом можете обратиться, например, к \cite{spi90,wil92}.%
{\fnstyle{\RaggedRight}\trnote*{Или к более современной книге:
\textit{Richard Jones, Antony Hosking, Eliot Moss.} The Garbage Collection
Handbook: The Art of Automatic Memory Management. — Chapman {\&} Hall/CRC,
2012. — 511 p.}} Интеграцию с Бёмовским сборщиком мусора <span class="cite">[<a href="z1_bibliography.xhtml#bw88">bw88</a>]</span> оставляем
вам в качестве упражнения.</p>

<p>Наиболее очевидная функция, требующая выделения памяти, — это <code><span class="func">cons</span></code>. Она
должна создать новую точечную пару, заполнить её поля (включая поле типа) и
вернуть адрес созданной пары в виде объекта типа <code><span class="func">SCM</span></code>.</p>


<!--\indexC*{SCM_cons}{SCM\_cons}-->
<!--\indexC{cons}-->
<p>\begin{code:c}
SCM SCM_cons(SCM a, SCM d)
{
    SCMref cell = malloc(sizeof(struct SCM_unwrapped_pair));
    if (!cell)
    {
        SCM_error(SCM_ERR_CANT_ALLOC);
    }

    cell->pair.header.tag = SCM_PAIR_TAG;
    cell->pair.car = a;
    cell->pair.cdr = d;
    return SCM_Wrap(cell);
}
\end{code:c}</p>

<p>Замыкания создаются функцией <code><span class="func">SCM\_close</span></code>. Их арность может быть любой, что
обосновывает использование функций переменной арности языка Си. Итак, нам надо
создать объект с типом <code><span class="func">SCM\_CLOSURE\_TAG</span></code> и заполнить его поля полученными
значениями. Порядок перечисления значений должен в точности совпадать
с порядком полей.</p>


<!--\indexC*{SCM_close}{SCM\_close}-->
<p>\begin{code:c}
SCM SCM_close(SCM (*Cfunction)(void), long arity,
              unsigned long size, ...)
{
    unsigned long i;
    va_list args;
    SCMref result = malloc(sizeof(struct SCM_unwrapped_closure)
                           + (size - 1) * sizeof(SCM));
    if (!result)
    {
        SCM_error(SCM_ERR_CANT_ALLOC);
    }</p>

<p>    result->closure.header.tag = SCM_CLOSURE_TAG;
    result->closure.behavior   = Cfunction;
    result->closure.arity      = arity;
    va_start(args, size);
    for (i = 0; i < size; i++) {
        result->closure.environment[i] = va_arg(args, SCM);
    }
    va_end(args);

    return SCM_Wrap(result);
}
\end{code:c}</p>

<h3 id="cc/runtime/ssect:pairs">Функции над парами</h3>


<!--\indexR{проверки типов}-->
<!--\indexR{динамическая типизация}-->
<p>Функции <code><span class="func">car</span></code> и <code><span class="func">set-car!</span></code> очень просты, но не следует их путать
с одноимёнными макросами. Данные функции типобезопасны в том смысле, что они
проверяют типы аргументов перед тем, как лезть непонятно куда в память. В общем
случае у каждой безопасной функции есть небезопасный аналог, который можно
использовать только тогда, когда компилятор полностью уверен в типе аргументов.
Несмотря на то, что Лисп динамически типизирован, программы на нём обычно
таковы, что как минимум две трети проверок типов, по мнению
\cite{hen92a,wc94,ser94}, можно смело убирать. Дело в том, что программисты
помнят о типах, выполняют часть проверок у себя в голове и не передают функциям
что попало. Хорошие компиляторы осведомлены о существовании «белкового
препроцессора» и оптимизируют код с учётом этого обстоятельства.</p>


<!--\indexC*{SCM_car}{SCM\_car}-->
<!--\indexC*{SCM_set_cdr}{SCM\_set\_cdr}-->
<!--\indexC{car}-->
<!--\indexC{set-cdr"!}-->
<p>\begin{code:c}
SCM SCM_car(SCM x)
{
    if (SCM_PairP(x)) {
        return SCM_Car(x);
    }
    else return SCM_error(SCM_ERR_CAR);
}</p>

<p>SCM SCM_set_cdr(SCM x, SCM d)
{
    if (SCM_PairP(x)) {
        SCM_Unwrap(x)->pair.cdr = d;
        return x;
    }
    else return SCM_error(SCM_ERR_SET_CDR);
}
\end{code:c}</p>

<p>Неплохо будет также рассмотреть функцию <code><span class="func">list</span></code>. Она может принимать
произвольное число аргументов, поэтому первым её аргументом идёт это самое
число. (Понятно, что в Си не стоит записывать итерацию с помощью рекурсии, но
соблазн был слишком велик.)</p>


<!--\indexC*{SCM_list}{SCM\_list}-->
<p>\begin{code:c}
SCM SCM_list(unsigned long count, va_list arguments)
{
    if (count == 0) {
        return SCM_nil;
    }
    else {
        SCM car = va_arg(arguments, SCM);
        return SCM_cons(car, SCM_list(count - 1, arguments));
    }
}
\end{code:c}</p>

<p>Возникающие в процессе работы ошибки никак не перехватываются и
не обрабатываются. Если возникают какие-либо проблемы, то просто вызывается
макрос <code><span class="func">SCM\_error</span></code>. Он сообщает наверх о том, что и где произошло, выводя
код ошибки, имя провинившегося файла и номер строки в нём.</p>


<!--\indexC*{SCM_error}{SCM\_error}-->
<!--\indexC*{SCM_signal_error}{SCM\_signal\_error}-->
<p>\begin{code:c}
#define SCM_error(code) SCM_signal_error(code, __LINE__, __FILE__)</p>

<p>SCM SCM_signal_error(unsigned long code,
                     unsigned long line,
                     const char *file)
{
    fflush(stdout);
    fprintf(stderr, "Error %ul, line %ul, file %s.\n", code, line, file);
    exit(code);
}
\end{code:c}</p>

<h3 id="cc/runtime/ssect:invoke">Вызовы функций</h3>


<!--\indexC{invoke}-->
<!--\indexC{apply}-->
<p>Самыми важными (и хитроумными) из функций, вызывающих другие функции, являются
<code><span class="func">SCM\_invoke</span></code> и <code><span class="func">apply</span></code>. Присутствие здесь примитива <code><span class="func">apply</span></code> не особо
удивительно — он же должен знать протокол вызова функций, чтобы ему
следовать.</p>


<!--\indexR{функции!протокол вызова}-->
<!--\indexR{протокол вызова функций}-->
<p>За исключением вызовов, интегрированных непосредственно в код (то есть
реализованных через прямые обращения к макросам или функциям на Си), все
остальные вызовы выполняются внутренней функцией <code><span class="func">SCM\_invoke</span></code>. Первым
аргументом она принимает вызываемую функцию, за которой следуют количество и
значения аргументов для неё. Как и в предыдущих интерпретаторах,
<code><span class="func">SCM\_invoke</span></code> отвечает за все возможные вызовы. Она анализирует тип первого
аргумента, чтобы выбрать правильный метод обработки (или выругаться об ошибке
типизации). Затем она извлекает вызываемый объект, выясняет поддерживаемую им
арность и сравнивает её с фактической. Наконец, она выполняет собственно вызов,
передавая функции аргументы соответствующим образом. В нашем случае есть три
различных протокола вызова. Это далеко не исчерпывающий список возможных
вариантов; например, вместо указания количества аргументов можно просто
дописывать в конец какое-то специальное значение (именно так поступает Bigloo,
используя для этой цели <code><span class="func">NULL</span></code>).</p>

<p>\begin{itemize}
  \item Примитивы с фиксированной арностью (вроде <code><span class="func">SCM\_cons</span></code>)
        вызываются просто и без всяких ухищрений. Эти вызовы можно
        отнести к виду $f(x, y, z)$.</p>

<p>  \item Примитивы с переменной арностью (вроде <code><span class="func">SCM\_list</span></code>) должны
        знать количество полученных аргументов. Оно передаётся
        дополнительным аргументом, поэтому вызов имеет вид
        $f(n, x_1, x_2, \dots, x_n)$.</p>

<p>  \item Замыканиям необходимо получить не только все аргументы вызова,
        но также и значения свободных переменных, которые фактически
        хранятся внутри самих замыканий. Поэтому для них надо выполнять
        вызовы вида $f(f, n, x_1, x_2, \dots, x_n)$.
\end{itemize}</p>

<p>Естественно, мы могли бы улучшить эти протоколы, привести их к единому виду,
возможно, даже избавиться от некоторых. Но это потом, сейчас у нас есть вполне
конкретные требования к <code><span class="func">SCM\_invoke</span></code>. Несмотря на внушительные размеры,
она довольно регулярна по своей структуре. (Обработка продолжений будет
рассмотрена в следующем разделе.)</p>


<!--\indexC{invoke}-->
<!--\indexC*{SCM_invoke}{SCM\_invoke}-->
<p>\begin{code:c}
SCM SCM_invoke(SCM function, unsigned long number, ...)
{
    /* `Вряд ли у нас получится вызвать число` */
    if (SCM_FixnumP(function)) {
        return SCM_error(SCM_ERR_CANNOT_APPLY);
    }</p>

<p>    switch (SCM_2tag(function)) {
      case SCM_SUBR_TAG: {
        SCM (*behavior)(void) = (SCM_Unwrap(function)->subr).behavior;
        long arity = (SCM_Unwrap(function)->subr).arity;</p>

<p>        /* `Фиксированная арность` */
        if (arity >= 0) {
            if (arity != number) {
                return SCM_error(SCM_ERR_WRONG_ARITY);
            }
            if (arity == 0) {
                return behavior();
            }
            else {
                SCM result;
                va_list args;
                va_start(args, number);
                switch (number) {
                  case 1: {
                    SCM a0 = va_arg(args, SCM);
                    result = ((SCM (*)(SCM)) behavior)(a0);
                    break;
                  }
                  case 2: {
                    SCM a0 = va_arg(args, SCM);
                    SCM a1 = va_arg(args, SCM);
                    result = ((SCM (*)(SCM, SCM)) behavior)(a0, a1);
                    break;
                  }
                  case 3: {
                    SCM a0 = va_arg(args, SCM);
                    SCM a1 = va_arg(args, SCM);
                    SCM a2 = va_arg(args, SCM);
                    result = ((SCM (*)(SCM,SCM,SCM)) behavior)
                             (a0, a1, a2);
                    break;
                  }
                  default:
                    /* `Не существует примитивов большей арности` */
                    return SCM_error(SCM_ERR_INTERNAL);
                }
                va_end(args);
                return result;
            }
        }
        /* `Переменная арность` */
        else {
            if (number < SCM_MinimalArity(arity)) {
                return SCM_error(SCM_ERR_MISSING_ARGS);
            }
            else {
                SCM result;
                va_list args;
                va_start(args, number);
                result = ((SCM (*)(unsigned long, va_list)) behavior)
                         (number, args);
                va_end(args);
                return result;
            }
        }
      }</p>

<p>      case SCM_CLOSURE_TAG: {
        SCM result;
        va_list args;
        SCM (*behavior)(void) =
                (SCM_Unwrap(function)->closure).behavior;
        long arity = (SCM_Unwrap(function)->closure).arity;</p>

<p>        if (arity >= 0 && number != arity) {
            return SCM_error(SCM_ERR_WRONG_ARITY);
        }
        if (number < SCM_MinimalArity(arity)) {
            return SCM_error(SCM_ERR_MISSING_ARGS);
        }
`\ForLayout{display}{\vskip-\baselineskip}`
        va_start(args, number);
        result = ((SCM (*)(SCM, unsigned long, va_list)) behavior)
                 (function, number, args);
        va_end(args);
        return result;
      }</p>

<p>      /* `Невызываемо!` */
      default:
        SCM_error(SCM_ERR_CANNOT_APPLY);
    }
}
\end{code:c}</p>


<!--\indexR{переменная арность!в Си}-->
<!--\indexC{CALL-ARGUMENTS-LIMIT}-->
<p>Реализация примитива <code><span class="func">apply</span></code> имеет сравнимые размеры. Так как это примитив
переменной арности, то свои аргументы он получает в виде <code><span class="func">va\_list</span></code>,
содержащего применяемую функцию и список аргументов для неё. Но здесь возникает
проблема с тем, что в C90 отсутствует\trnote{В C99 появился макрос
<code><span class="func">va\_copy</span></code>, позволяющий сделать это безопасно.} способ передать другой
функции аргументы, оставшиеся в <code><span class="func">va\_list</span></code>. Что ж, придётся с этим смириться
и разбирать все возможные арности вручную. Печально, конечно, но нам придётся
ограничить максимальное количество аргументов <code><span class="func">apply</span></code>. Стандартизацией
<span class="logo">Common Lisp</span> однозначно руководили реалисты, поэтому там определена специальная
константа <code><span class="func">CALL-ARGUMENTS-LIMIT</span></code>, хранящая максимально допустимое количество
аргументов. По стандарту она не может быть меньше 50. Мы ограничимся\footnote{%
Если вам здесь видится нечеловеческое ущемление прав, то сперва узнайте предел
вашей любимой реализации Scheme.} всего 14, из которых здесь покажем обработку
лишь первых четырёх.</p>


<!--\indexC{apply}-->
<!--\indexC*{SCM_apply}{SCM\_apply}-->
<p>\begin{code:c}
SCM SCM_apply(unsigned long number, va_list arguments)
{
    unsigned long i;
    SCM args[31];
    SCM last_arg;
    SCM fun = va_arg(arguments, SCM);</p>

<p>    for (i = 0; i < number - 1; i++) {
        args[i] = va_arg(arguments, SCM);
    }
    last_arg = args[--i];
    while (SCM_PairP(last_arg)) {
        args[i++] = SCM_Car(last_arg);
        last_arg = SCM_Cdr(last_arg);
    }
    if (!SCM_NullP(last_arg)) {
        SCM_error(SCM_ERR_APPLY_ARG);
    }</p>

<p>    switch (i) {
      case 0: return SCM_invoke(fun, 0);
      case 1: return SCM_invoke(fun, 1, args[0]);
      case 2: return SCM_invoke(fun, 2, args[0], args[1]);
      case 3: return SCM_invoke(fun, 3, args[0], args[1], args[2]);
      /* ... */
      default: return SCM_error(SCM_ERR_APPLY_SIZE);
    }
}
\end{code:c}</p>

<p>Всё равно C90 не поддерживает более 32 параметров функций, так что на 50 в нашем
случае можно и не надеяться. Пуристы, наверное, уже давно обратили внимание на
(ненужную?) проверку того, что в конце списка аргументов <code><span class="func">apply</span></code>
действительно находится <code>()</code>.</p>

<div class="bigskip"/>


<!--\indexR{хвостовые вызовы}-->
<!--\indexR{вызов!хвостовой}-->
<p>Существенной проблемой прямого использования функций Си является то, что Си
не гарантирует оптимизацию хвостовых вызовов. Поэтому некоторые программы, без
проблем выполняющиеся на Scheme, при буквальном переводе на Си будут умирать
от переполнения стека. Некоторые компиляторы Scheme в Си (например, Scheme$\to$C
или Bigloo) применяют множество хитроумных алгоритмов, чтобы избежать подобных
аварий. Они генерируют специальный код для рекурсии, итерации через рекурсию
и так далее, но, к сожалению, абсолютно все варианты предусмотреть невозможно,
и обязательно найдётся программа, которая всё сломает. Альтернативным решением
является отказ от использования стека Си для представления продолжений Scheme.</p>

<p>
\section{\texorpdfstring{\protect<code><span class="func">call/cc</span></code>: быть или не быть}%
{call/cc: быть или не быть}}%
\label{cc/sect:call/cc}</p>

<p>Мы только что закончили рассмотрение принципов компиляции основной части
конструкций Scheme в программы на Си. Несмотря на то, что многие стандартные
функции не реализованы, важнейшие из них всё же присутствуют (хоть, возможно,
и не в самом эффективном виде). Все, кроме функций для работы с продолжениями.
Для начала мы реализуем функцию <code><span class="func">call/ep</span></code>, предоставляющую продолжения
с динамическим временем жизни, как в Лиспе. Она будет использовать
<code><span class="func">setjmp</span></code>\slash<code><span class="func">longjmp</span></code>.</p>

<p>Во второй же части данного раздела мы разберёмся с тем, как реализовать
на Си истинно неограниченные продолжения Scheme.</p>

<p>
\subsection{\texorpdfstring{Функция \protect<code><span class="func">call/ep</span></code>}{Функция call/ep}}%
\label{cc/call/cc/ssect:ep}</p>


<!--\indexC{call/ep}-->
<!--\indexC{setjmp}-->
<!--\indexC{longjmp}-->
<p>Функция <code><span class="func">call/ep</span></code> во всём идентична <code><span class="func">call/cc</span></code>, за исключением того, что
продолжения, создаваемые ею, хоть и являются полноценными объектами Scheme, но
не могут быть использованы вне соответствующей формы <code><span class="func">call/ep</span></code>, которая
ограничивает время их жизни временем исполнения собственного тела.
\seePage[escape/sect:comparing] Для её реализации применяется подход,
аналогичный показанному в седьмой главе, где в стек помещалась специальная
метка, служившая точкой прибытия для продолжений. Теперь такой меткой будет
локальная переменная типа <code><span class="func">jmp\_buf</span></code>. Вот необходимые для этого функции:</p>


<!--\indexC*{SCM_allocate_continuation}{SCM\_allocate\_continuation}-->
<!--\indexC*{SCM_jmp_buf}{SCM\_jmp\_buf}-->
<!--\indexC*{SCM_callep}{SCM\_callep}-->
<p>\begin{code:c}
SCM SCM_allocate_continuation(struct SCM_jmp_buf *address)
{
    SCMref continuation = malloc(sizeof(struct SCM_unwrapped_escape));
    if (!continuation)
    {
        SCM_error(SCM_ERR_CANT_ALLOC);
    }
`\ForLayout{display}{\vskip-0.25\baselineskip}`
    continuation->escape.header.tag    = SCM_ESCAPE_TAG;
    continuation->escape.stack_address = address;
    return SCM_Wrap(continuation);
}
`\ForLayout{display}{\vskip-0.25\baselineskip}`
struct SCM_jmp_buf {
    SCM back_pointer;
    SCM jumpvalue;
    jmp_buf xen;
};
`\ForLayout{display}{\vskip-0.25\baselineskip}`
SCM SCM_callep(SCM f)
{
    struct SCM_jmp_buf scmjb;
    SCM continuation = SCM_allocate_continuation(&scmjb);
    scmjb.back_pointer = continuation;
`\ForLayout{display}{\vskip-0.25\baselineskip}`
    if (setjmp(scmjb.xen)) {
        return scmjb.jumpvalue;
    }
    else {
        return SCM_invoke1(f, continuation);
    }
}
\end{code:c}</p>


<!--\indexR{стек!направление роста}-->
<p>Активация продолжений обрабатывается функцией <code><span class="func">SCM\_invoke</span></code>, которая перед
выполнением перехода ещё проверит арность вызова. Следующий фрагмент кода,
реализующий данную обработку, должен быть добавлен в приведённое ранее
определение <code><span class="func">SCM\_invoke</span></code>. Перед выполнением перехода достаточно (ввиду
отсутствия форм <code><span class="func">unwind-protect</span></code>) убедиться в том, что продолжение указывает
на соответствующий ему <code><span class="func">jmp\_buf</span></code>, а мы находимся <em>выше</em> этого
<code><span class="func">jmp\_buf</span></code> на стеке. К сожалению, для второй проверки необходимо знать
направление роста стека. Будем считать, что макрос <code><span class="func">SCM\_STACK\_HIGHER</span></code>
раскрывается в соответствующее отношение порядка. Определение этого макроса,
естественно, возлагается на реализацию; благо, нужную информацию легко получить
небольшой программкой на абсолютно портируемом Си. Обычно (по крайней мере
в \UNIX) стек растёт вниз, поэтому можете считать, что <code><span class="func">SCM\_STACK\_HIGHER</span></code>
раскрывается в <code><span class="func"><=</span></code>.</p>


<!--\indexC*{SCM_invoke}{SCM\_invoke}-->
<p>\begin{code:c}
    case SCM_ESCAPE_TAG:
      if (number == 1) {
          struct SCM_jmp_buf *address =
              SCM_Unwrap(function)->escape.stack_address;
          if (SCM_EqP(address->back_pointer, function) &&
              ((void*) &address SCM_STACK_HIGHER (void*) address))
          {
              va_list args;
              va_start(args, number);
              address->jumpvalue = va_arg(args, SCM);
              va_end(args);
              longjmp(address->xen, 9);
          }
          else {
              /* `Слишком поздно!` */
              return SCM_error(SCM_ERR_OUT_OF_EXTENT);
          }
      }
      else {
          return SCM_error(SCM_ERR_MISSING_ARGS);
      }
\end{code:c}</p>

<p>Эффективность <code><span class="func">call/ep</span></code>, о которой говорилось при рассмотрении компилятора
в байт-код, сейчас несколько приуменьшилась, так как переходы с помощью
<code><span class="func">longjmp</span></code> печально известны своей «стремительностью». Они неплохи для
реализации исключений, но при постоянном использовании существенно замедляют
исполнение программ. Однако, мы лишь хотели показать пример интеграции Лиспа
и Си, поэтому ничего особо страшного в этом нет.</p>

<p>
\subsection{\texorpdfstring{Функция \protect<code><span class="func">call/cc</span></code>}{Функция call/cc}}%
\label{cc/call/cc/ssect:cc}</p>


<!--\indexC{call/cc}-->
<p>Ура! Если вы скучаете по настоящим продолжениям, то скоро ваши мечты сбудутся.
До этого <code><span class="func">call/cc</span></code> чаще всего реализовывалась с помощью магии — неявного
вызова уже существующей <code><span class="func">call/cc</span></code> языка реализации. К сожалению, в Си такой
функции нет, так что пришло время <em>написать</em> её самостоятельно. Однако для
этого необходимо знать, как здесь устроен стек. Проблема в том, что в Си нет
переносимого способа взаимодействия с ним. Вернее, нет <em>простого</em> способа
— всегда можно написать кучу платформоспецифичных вариантов и выбирать из них
нужный с помощью <code><span class="func">\#ifdef</span></code>. Для этой книги такой вариант не подходит, так что
попробуем подойти с другой стороны: приведём программу к стилю передачи
продолжений (CPS). Тогда и продолжения будут как на ладони, и компилятор
останется почти неизменным.</p>

<h4 id="cc/call/cc/cc/ssect:explicit">Делаем продолжения явными</h4>


<!--\indexE{CPS}-->
<!--\indexR{преобразование!в CPS}-->
<!--\indexR{стиль передачи продолжений (CPS)!CPS-преобразование}-->
<p>Предлагаемое преобразование эквивалентно показанному ранее, только выполняется
оно с помощью нового обходчика кода \seePage[denotational/lambdify/ssect:cps]
Работа ведётся над уже объектифицированным исходным кодом.</p>

<p>У CPS-преобразования, выполняемого в лоб, есть недостаток: оно очень щедро
использует <code><span class="func">let</span></code>-формы, но при этом не заботится об эффективности и
представляет их так называемыми административными редексами. Поэтому после
выполнения этого преобразования мы ещё раз пройдёмся по коду, возвращая
программу во вменяемый вид. Этим займётся функция <code><span class="func">letify</span></code>. Итак, ядро
компилятора с поддержкой продолжений:</p>


<!--\indexC{compile->C}-->
<pre>(define (compile->C e out)
  (set! g.current '())
  (let* ((ee (letify (cpsify (Sexp->object e)) '()))
         (prg (extract-things! (lift! ee))) )
    (gather-temporaries! (closurize-main! prg))
    (generate-C-program out e prg) ) )</pre>

<p>Извлечение продолжений выполняет функция <code><span class="func">cpsify</span></code>. Она организует совместную
работу обходчика <code><span class="func">update-walk!</span></code> и функции <code><span class="func">->CPS</span></code>. Также нам понадобятся
два новых класса: класс продолжений, чтобы отличать обычные функции от
функций-продолжений, и класс псевдопеременных, представляющих временные
переменные неявно используемых (в исходном коде на Scheme) продолжений.</p>


<!--\indexC{Continuation}-->
<!--\indexC{Pseudo-Variable}-->
<!--\indexC{cpsify}-->
<!--\indexC{new-Variable}-->
<pre>(define-class Continuation    Function ())
(define-class Pseudo-Variable Local-Variable ())
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define (cpsify e)
  (let ((v (new-Variable)))
    (->CPS e (make-Continuation (list v) (make-Local-Reference v))) ) )
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define new-Variable
  (let ((counter 0))
    (lambda ()
      (set! counter (+ 1 counter))
      (make-Pseudo-Variable counter #f #f) ) ) )</pre>

<p>Функция <code><span class="func">->CPS</span></code> первым аргументом принимает объект, представляющий
вычисления, а вторым — продолжение, которому надо передать результат этих
вычислений. В общем случае ничего кроме этого делать и не надо. Начальным
продолжением, которому <code><span class="func">cpsify</span></code> передаёт результат выполнения всей программы,
является тождество $\lambda x . x$.</p>


<!--\indexC*{CPS}{->CPS}-->
<!--\indexC{convert2Regular-Application}-->
<pre>(define-generic (->CPS (e Program) k)
  (convert2Regular-Application k e) )
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define (convert2Regular-Application k . args)
  (make-Regular-Application k (convert2arguments args)) )</pre>

<p>Теперь остаётся лишь определить методы для всех остальных узлов синтаксического
дерева. Последовательные вычисления? Элементарно: вычисляем одну форму сейчас,
а остальные передаём продолжению:</p>

<pre>(define-method (->CPS (e Sequence) k)
  (->CPS (Sequence-first e)
         (let ((v (new-Variable)))
           (make-Continuation
            (list v) (->CPS (Sequence-last e) k) ) ) ) )</pre>

<p>С ветвлением тоже всё просто, надо только помнить, что обе ветви пользуются
одним и тем же исходным продолжением:</p>

<pre>(define-method (->CPS (e Alternative) k)
  (->CPS (Alternative-condition e)
         (let ((v (new-Variable)))
           (make-Continuation
            (list v) (make-Alternative
                      (make-Local-Reference v)
                      (->CPS (Alternative-consequent e) k)
                      (->CPS (Alternative-alternant e) k) ) ) ) ) )</pre>

<p>И даже присваивания очевидны. Сначала вычисляется новое значение, продолжением
этих вычислений является обновление значения переменной и выполнение всего того,
что следует дальше за присваиванием:</p>

<pre>(define-method (->CPS (e Box-Write) k)
  (->CPS (Box-Write-form e)
         (let ((v (new-Variable)))
           (make-Continuation
            (list v) (convert2Regular-Application
                      k (make-Box-Write
                         (Box-Write-reference e)
                         (make-Local-Reference v) ) ) ) ) ) )</p>

<p>(define-method (->CPS (e Global-Assignment) k)
  (->CPS (Global-Assignment-form e)
         (let ((v (new-Variable)))
           (make-Continuation
            (list v) (convert2Regular-Application
                      k (make-Global-Assignment
                         (Global-Assignment-variable e)
                         (make-Local-Reference v) ) ) ) ) ) )</pre>


<!--\indexR{редексы!административные}-->
<!--\indexR{административные редексы}-->
<!--\indexR{приводимые!формы}-->
<!--\indexR{форма!приводимая}-->
<p>А вот введение локальных переменных <code><span class="func">let</span></code>-формами уже сложнее. Дело в том,
что продолжение <code><span class="func">k</span></code> надо протащить внутрь узлов <code><span class="func">Fix-Let</span></code> как новую
переменную. Самый простой способ этого добиться — превратить все <code><span class="func">Fix-Let</span></code>
обратно в приводимые формы (аппликации непосредственно задаваемых абстракций)
на время выполнения CPS-преобразования. Такие вспомогательные формы называются
<em>административными</em> редексами <span class="cite">[<a href="z1_bibliography.xhtml#sf92">sf92</a>]</span>. Хоть они выглядят не особо
красиво и замедляют наивную интерпретацию, это лишь временное промежуточное
представление. На эффективность результата компиляции эти (и все остальные)
редексы не повлияют — они будут обнаружены и оптимизированы функцией
<code><span class="func">letify</span></code>.</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>

<pre>(define-method (->CPS (e Fix-Let) k)
  (->CPS (make-Regular-Application
          (make-Function (Fix-Let-variables e) (Fix-Let-body e))
          (Fix-Let-arguments e) )
         k ) )</pre>

<p>Все функции получают по дополнительному аргументу, представляющему продолжение
их вызова.</p>

<pre>(define-method (->CPS (e Function) k)
  (convert2Regular-Application k
   (let ((k (new-Variable)))
     (make-Function (cons k (Function-variables e))
                    (->CPS (Function-body e)
                           (make-Local-Reference k) ) ) ) ) )</pre>

<p>Аппликации функций должны выполняться с учётом этого нововведения. Все аргументы
последовательно вычисляются перед применением к ним функции. Порядок вычисления
обычный: слева направо.</p>


<!--\indexC{arguments->CPS}-->
<pre>(define-method (->CPS (e Predefined-Application) k)
  (let* ((args (Predefined-Application-arguments e))
         (vars (let name ((args args))
                 (if (not (Arguments? args)) '()
                     (cons (new-Variable)
                           (name (Arguments-others args)) ) ) ))
         (application
          (convert2Regular-Application k
           (make-Predefined-Application
            (Predefined-Application-variable e)
            (convert2arguments
             (map make-Local-Reference vars) ) ) ) ) )
    (arguments->CPS args vars application) ) )</p>

<p>(define-method (->CPS (e Regular-Application) k)
  (let* ((fun (Regular-Application-function e))
         (args (Regular-Application-arguments e))
         (varfun (new-Variable))
         (vars (let name ((args args))
                 (if (not (Arguments? args)) '()
                     (cons (new-Variable)
                           (name (Arguments-others args)) ) ) ))
         (application
          (make-Regular-Application
           (make-Local-Reference varfun)
           (make-Arguments k (convert2arguments
                              (map make-Local-Reference vars) )) ) ) )
    (->CPS fun (make-Continuation
                (list varfun)
                (arguments->CPS args vars application) )) ) )</p>

<p>(define (arguments->CPS args vars appl)
  (if (pair? args)
      (->CPS (Arguments-first args)
             (make-Continuation
              (list (car vars))
              (arguments->CPS (Arguments-others args)
                              (cdr vars) appl ) ) )
      appl ) )</pre>

<p>\ForLayout{display}{\endgroup}</p>

<h4 id="cc/call/cc/cc/ssect:letify">Оптимизируем редексы</h4>


<!--\indexR{синтаксическое дерево}-->
<!--\indexC{clone}-->
<p>Функция <code><span class="func">letify</span></code>, упомянутая ранее, отвечает за обратное преобразование
приводимых форм в <code><span class="func">let</span></code>-формы. Заодно её можно использовать для исправления
других неудобств CPS-преобразования. Когда функция <code><span class="func">->CPS</span></code> обрабатывает
ветвление, она передаёт каждой ветви физически одно и то же продолжение. Из-за
этого в итоге получается не дерево, а направленный ациклический граф. Некоторые
из последующих преобразований могут не дружить с такими графами, поэтому
<code><span class="func">letify</span></code>, чтобы гарантированно избежать проблем в будущем, скопирует все дуги
графа в новое дерево (где разделяемые дуги превратятся в пары одинаковых
ветвей). Предположим, у нас для этого есть обобщённая функция <code><span class="func">clone</span></code>,
способная скопировать любой объект {\Meroonet}. \seeEx[objects/ex:clone]
Применение её к переменным отчасти напоминает переименование, выполняемое
<code><span class="func">collect-temporaries!</span></code>.</p>


<!--\indexC{letify}-->
<pre>(define-generic (letify (o Program) env)
  (update-walk! letify (clone o) env) )
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define-method (letify (o Function) env)
  (let* ((vars (Function-variables o))
         (body (Function-body o))
         (new-vars (map clone vars)) )
    (make-Function
     new-vars
     (letify body (append (map cons vars new-vars) env)) ) ) )
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define-method (letify (o Local-Reference) env)
  (let* ((v (Local-Reference-variable o))
         (r (assq v env)) )
    (if (pair? r)
        (make-Local-Reference (cdr r))
        (letify-error "Disappeared variable" o) ) ) )
|\ForLayout{display}{\vskip-\baselineskip}|
(define-method (letify (o Regular-Application) env)
  (if (Function? (Regular-Application-function o))
      (letify (process-closed-application
               (Regular-Application-function o)
               (Regular-Application-arguments o) )
              env )
      (make-Regular-Application
       (letify (Regular-Application-function o) env)
       (letify (Regular-Application-arguments o) env) ) ) )</p>

<p>(define-method (letify (o Fix-Let) env)
  (let* ((vars (Fix-Let-variables o))
         (new-vars (map clone vars)) )
    (make-Fix-Let
     new-vars
     (letify (Fix-Let-arguments o) env)
     (letify (Fix-Let-body o)
             (append (map cons vars new-vars) env) ) ) ) )</p>

<p>(define-method (letify (o Box-Creation) env)
  (let* ((v (Box-Creation-variable o))
         (r (assq v env)) )
    (if (pair? r)
        (make-Box-Creation (cdr r))
        (letify-error "Disappeared variable" o) ) ) )</p>

<p>(define-method (clone (o Pseudo-Variable)) (new-Variable))</pre>

<h4 id="cc/call/cc/cc/ssect:runtime">Дорабатываем библиотеку</h4>

<p>Возможно, вам не совсем понятно, что мы приобретаем, выполнив данное
преобразование. Идея в том, чтобы сделать продолжения явными, — то есть
сделать реализацию <code><span class="func">call/cc</span></code> тривиальной. Продолжения в таком случае являются
просто замыканиями, никогда не возвращающими значений. Вот определение
<code><span class="func">SCM\_callcc</span></code>. Раз это обычная функция, то первым аргументом она принимает
продолжение своего вызова; да, теперь она бинарна. Функция
<code><span class="func">SCM\_invoke\_continuation</span></code> определяется перед ней, так как компилятору Си
не нравится беспорядок.</p>


<!--\indexC*{SCM_invoke_continuation}{SCM\_invoke\_continuation}-->
<!--\indexC*{SCM_callcc}{SCM\_callcc}-->
<!--\indexC{call/cc}-->
<p>\begin{code:c}
SCM SCM_invoke_continuation(SCM self, unsigned long number,
                            va_list arguments)
{
    SCM current_k = va_arg(arguments, SCM);
    SCM value     = va_arg(arguments, SCM);
    return SCM_invoke1(SCM_Unwrap(self)->closure.environment[0], value);
}</p>

<p>SCM SCM_callcc(SCM k, SCM f)
{
    SCM reified_k =
        SCM_close(SCM_CfunctionAddress(SCM_invoke_continuation),
                  2, 1, k);
    return SCM_invoke2(f, k, reified_k);
}</p>

<p>SCM_DefinePredefinedFunctionVariable(CALLCC, "CALL/CC", 2, SCM_callcc);
\end{code:c}</p>


<!--\indexR{функции!протокол вызова}-->
<!--\indexR{протокол вызова функций}-->
<!--\indexC*{SCMq}{SCMq\_}-->
<p>Все остальные библиотечные функции остались нетронутыми, а ведь их протокол
вызова претерпел некоторые изменения в связи с появлением продолжений. Если
CPS-преобразование выдаст что-то вроде <code>(let ((f car)) (f '(a b)))</code>, то наш
компилятор-дурачок так и не поймёт, что это на самом деле просто вызов примитива
<code>(car '(a b))</code> (а то и вовсе <code>(quote a)</code>, если провести свёртку констант).
Он честно вычислит значение глобальной переменной <code><span class="func">CAR</span></code> и выполнит вызов
обычной функции, строго придерживаясь протокола: передав продолжение первым
аргументом, а точечную пару — вторым. Значением <code><span class="func">CAR</span></code> теперь должна быть
абстракция <code>(lambda (k p) (k (car p)))</code>, определённая через изначальный
примитив <code><span class="func">car</span></code>. С этой целью мы введём несколько вспомогательных макросов и
добавим каждой библиотечной функции дополнительный аргумент. Функции
с приставкой <code><span class="func">SCMq\_</span></code> являются новым интерфейсом функций, начинающихся
на <code><span class="func">SCM\_</span></code>.</p>


<!--\indexC*{SCM_DefineCPSsubr0}{SCM\_DefineCPSsubr<i>n</i>}-->
<p>\begin{code:c}
#define SCM_DefineCPSsubr2(new_name, old_name) \
  SCM new_name(SCM k, SCM x, SCM y)            \
  {                                            \
      return SCM_invoke1(k, old_name(x, y));   \
  }</p>

<p>#define SCM_DefineCPSsubrN(new_name, old_name)                \
  SCM new_name(unsigned long number, va_list arguments)       \
  {                                                           \
      SCM k = va_arg(arguments, SCM);                         \
      return SCM_invoke1(k, old_name(number - 1, arguments)); \
  }</p>

<p>SCM_DefineCPSsubr2(SCMq_gtp, SCM_gtp)
SCM_DefinePredefinedFunctionVariable(GREATERP, " > ", 3, SCMq_gtp);</p>

<p>SCM_DefineCPSsubrN(SCMq_list, SCM_list)
SCM_DefinePredefinedFunctionVariable(LIST, "LIST", -2, SCMq_list);
\end{code:c}</p>


<!--\indexC{apply}-->
<!--\indexC*{SCM_apply}{SCM\_apply}-->
<p>Единственной проблемной функцией остаётся <code><span class="func">apply</span></code>. Она использует протокол
вызова напрямую, так что о появившихся продолжениях ей придётся рассказывать
лично:</p>

<p>\begin{code:c}
SCM SCMq_apply(unsigned long number, va_list arguments)
{
    unsigned long i;
    SCM args[30];
    SCM last_arg;
    SCM k   = va_arg(arguments, SCM);
    SCM fun = va_arg(arguments, SCM);
`\ForLayout{display}{\vskip-0.333\baselineskip}`
    for (i = 0; i < number - 2; i++) {
        args[i] = va_arg(arguments, SCM);
    }
    last_arg = args[--i];
    while (SCM_PairP(last_arg)) {
        args[i++] = SCM_Car(last_arg);
        last_arg = SCM_Cdr(last_arg);
    }
    if (!SCM_NullP(last_arg)) {
        SCM_error(SCM_ERR_APPLY_ARG);
    }
`\ForLayout{display}{\vskip-0.333\baselineskip}`
    switch (i) {
      case 0: return SCM_invoke(fun, 1, k);
      case 1: return SCM_invoke(fun, 2, k, args[0]);
      case 2: return SCM_invoke(fun, 3, k, args[0], args[1]);
      case 3: return SCM_invoke(fun, 3, k, args[0], args[1], args[2]);
      /* ... */
      default: return SCM_error(SCM_ERR_APPLY_SIZE);
    }
}
\end{code:c}</p>

<h4 id="cc/call/cc/cc/ssect:example">Пример</h4>


<!--\indexR{компиляция!в Си}-->
<p>Давайте возьмём наш подопытный пример и посмотрим, что же выдаст новый
компилятор. Хоть мы и получаем в итоге код на Си, в нём безошибочно узнаётся
стиль передачи продолжений.</p>

<p>\begin{code:c-frame}[title={\snippet{o/chap10kex.c}}, numbers=left,
    label=cc/call/cc/cc/example/src:subj]
/* Compiler to C \$Revision: 4.1\$
(BEGIN
  (SET! INDEX 1)
  ((LAMBDA
     (CNTER . TMP)
     (SET! TMP (CNTER (LAMBDA (I) (LAMBDA X (CONS I X)))))
     (IF CNTER (CNTER TMP) INDEX))
    (LAMBDA (F) (SET! INDEX (+ 1 INDEX)) (F INDEX))
    'FOO))
*/</p>

<p>#include "scheme.h"</p>

<p>/* Global environment: */
SCM_DefineGlobalVariable(INDEX, "INDEX");</p>

<p>/* Quotations: */
#define thing3 SCM_nil                      /* () */
SCM_DefineString(thing4_object, "FOO");
#define thing4 SCM_Wrap(&thing4_object)
SCM_DefineSymbol(thing2_object, thing4);    /* FOO */
#define thing2 SCM_Wrap(&thing2_object)
#define thing1 SCM_Int2Fixnum(1)
#define thing0 thing1                       /* 1 */</p>

<p>/* Functions: */
SCM_DefineClosure(function_0, SCM I; );</p>

<p>SCM_DeclareFunction(function_0)
{
    SCM_DeclareLocalVariable(v_25, 0);
    SCM_DeclareLocalDottedVariable(X, 1);
    SCM v_27; SCM v_26;
    return (v_26 = SCM_Free(I),
            (v_27 = X,
             SCM_invoke1(v_25,
                         SCM_cons(v_26, v_27))));
}</p>

<p>SCM_DefineClosure(function_1, );</p>

<p>SCM_DeclareFunction(function_1)
{
    SCM_DeclareLocalVariable(v_24, 0);
    SCM_DeclareLocalVariable(I, 1);
    return SCM_invoke1(v_24,
                       SCM_close(SCM_CfunctionAddress(function_0),
                                 -2, 1, I));
}</p>

<p>SCM_DefineClosure(function_2, SCM v_15; SCM CNTER; SCM TMP; );</p>

<p>SCM_DeclareFunction(function_2)
{
    SCM_DeclareLocalVariable(v_21, 0);
    SCM v_20; SCM v_19; SCM v_18; SCM v_17;
    return (v_17 = (SCM_Content(SCM_Free(TMP)) = v_21),
            (v_18 = SCM_Free(CNTER),
             ((v_18 != SCM_false)
              ? (v_19 = SCM_Free(CNTER),
                 (v_20 = SCM_Content(SCM_Free(TMP)),
                  SCM_invoke2(v_19,
                              SCM_Free(v_15),
                              v_20)))
              : SCM_invoke1(SCM_Free(v_15),
                            SCM_CheckedGlobal(INDEX)))));
}</p>

<p>SCM_DefineClosure(function_3, );</p>

<p>SCM_DeclareFunction(function_3)
{
    SCM_DeclareLocalVariable(v_15, 0);
    SCM_DeclareLocalVariable(CNTER, 1);
    SCM_DeclareLocalVariable(TMP, 2);
    SCM v_23; SCM v_22; SCM v_16;
    return (v_16 = (TMP = SCM_allocate_box(TMP)),
            (v_22 = CNTER,
             (v_23 = SCM_close(SCM_CfunctionAddress(function_1), 2, 0),
              SCM_invoke2(v_22,
                          SCM_close(SCM_CfunctionAddress(function_2),
                                    1, 3, v_15, CNTER, TMP),
                          v_23))));
}</p>

<p>SCM_DefineClosure(function_4, );</p>

<p>SCM_DeclareFunction(function_4)
{
    SCM_DeclareLocalVariable(v_8, 0);
    SCM_DeclareLocalVariable(F, 1);
    SCM v_11; SCM v_10; SCM v_9; SCM v_12; SCM v_14; SCM v_13;
    return (v_13 = thing1,
            (v_14 = SCM_CheckedGlobal(INDEX),
             (v_12 = SCM_Plus(v_13, v_14),
              (v_9 = (INDEX = v_12),
               (v_10 = F,
                (v_11 = SCM_CheckedGlobal(INDEX),
                 SCM_invoke2(v_10,
                             v_8,
                             v_11)))))));
}</p>

<p>SCM_DefineClosure(function_5, );</p>

<p>SCM_DeclareFunction(function_5)
{
    SCM_DeclareLocalVariable(v_1, 0);
    return v_1;
}</p>

<p>SCM_DefineClosure(function_6, );</p>

<p>SCM_DeclareFunction(function_6)
{
    SCM v_5; SCM v_7; SCM v_6; SCM v_4; SCM v_3; SCM v_2; SCM v_28;
    return (v_28 = thing0,
            (v_2 = (INDEX = v_28),
             (v_3 = SCM_close(SCM_CfunctionAddress(function_3), 3, 0),
              (v_4 = SCM_close(SCM_CfunctionAddress(function_4), 2, 0),
               (v_6 = thing2,
                (v_7 = thing3,
                 (v_5 = SCM_cons(v_6, v_7),
                  SCM_invoke3(v_3,
                              SCM_close(SCM_CfunctionAddress(function_5),
                                        1, 0),
                              v_4,
                              v_5))))))));
}</p>

<p>/* Expression: */
int main(void)
{
    SCM_print(SCM_invoke0(SCM_close(
        SCM_CfunctionAddress(function_6), 0, 0)));</p>

<p>    return 0;
}</p>

<p>/* End of generated code */
\end{code:c-frame}</p>

<p>Как видите, размер получаемого файла вырос с 80 строк до 140. Функций стало
в два раза больше (шесть вместо трёх), да и локальных переменных им теперь
требуется не 2, а 22. Короче говоря, программа слегка растолстела. И работать
стала примерно в полтора раза медленнее. После того, как из <code><span class="func">main</span></code> был убран
вызов <code><span class="func">SCM\_print</span></code>, вычисления обёрнуты в цикл на 10\,000 итераций, а
программа скомпилирована с ключом <code><span class="func">-O1</span></code>, время работы CPS-версии по сравнению
с оригинальной увеличилось с \hbox{1,1} секунды до \hbox{1,7}. Памяти обоим
вариантам требуется одинаковое количество, но в первом случае эта память берётся
из стека (где аппаратная поддержка и компилятор Си творят чудеса), тогда как
явные продолжения создаются в куче, что не только само по себе медленно, но и
плохо сказывается на работе кеша. Хотя, как показано в <span class="cite">[<a href="z1_bibliography.xhtml#as94">as94</a>]</span>, от большей
части недостатков такого подхода вполне можно избавиться.</p>

<p>\begin{shell}
% gcc -ansi -pedantic chap10kex.c scheme.o schemeklib.o
% time a.out
(2 3)
0.000u 0.020s 0:00.00 0.0% 3+3k 0+0io 0pf+0w
% size a.out
text    data    bss     dec     hex
32768   4096    32      36896   9020
\end{shell}</p>


<!--\indexR{хвостовые вызовы}-->
<p>Рассмотренное преобразование само по себе никак не оптимизирует хвостовую
рекурсию, а значит, возможность переполнения стека никуда не делась. Фактически,
CPS даже усугубляет ситуацию тем, что здесь постоянно вызываются функции, но
ни одна из них никогда не возвращает значения. Функции вызываются, стек растёт,
но все <code><span class="func">return</span></code> выполняются последними, так что уменьшаться он будет лишь
в самом работы программы. Вряд ли не особо большой стек Си продержится до этого
момента. Одно из возможных решений показано в <span class="cite">[<a href="z1_bibliography.xhtml#bak95">bak95</a>]</span>: просто делать время
от времени <code><span class="func">longjmp</span></code>, чтобы избавиться от уже ненужных записей активаций.</p>

<h2 id="cc/sect:ffi">Взаимодействие с Си</h2>


<!--\indexR{внешний интерфейс}-->
<p>Так как наш небольшой компилятор использует структуры и функции языка Си для
представления данных и программ, то генерируемый им код способен без особых
проблем взаимодействовать с другим кодом на Си. Наличие <em>внешнего
интерфейса</em> (foreign function interface) чрезвычайно важно для любого языка
программирования, так как это позволяет получить доступ к уже написанным
и отлаженным библиотекам на других языках. Особенно это касается языка Си,
являющегося стандартом де-факто на интерфейсы библиотек. Рассмотрим пример
использования подобного интерфейса, чтобы вы осознали его полезность, а также
трудности, возникающие в процессе реализации.</p>

<p>Стандартная функция <code><span class="func">system</span></code> принимает строку, передаёт её командному
интерпретатору операционной системы и возвращает обратно код возврата,
полученный в результате выполнения команд из переданной строки. Предположим,
у нас есть макрос <code><span class="func">defforeignprimitive</span></code>, позволяющий определить для
компилятора интерфейс этой функции:</p>


<!--\indexC{defforeignprimitive}-->
<pre>(defforeignprimitive system int ("system" string) 1)</pre>


<!--\indexR{маршалинг}-->
<p>Теперь компилятор будет понимать форму <code>(system $\pi$)</code> следующим образом:
сначала выполняется проверка, что $\pi$ это действительно строка, затем
вызывается функция <code><span class="func">system</span></code>, после чего возвращённое ею значение
(типа <code><span class="func">int</span></code>) преобразуется в целое число Scheme и становится значением всей
формы. Так как строки Scheme и Си представляются почти одинаково, то это
преобразование выполняется легко, чего не скажешь, правда, о других возможных
типах данных. Проблемы <em class="term">маршалинга</em> (так называются данные преобразования)
подробнее рассматриваются в \cite{rm92,dps94a}.</p>

<p>Конечно, одних преобразований типов недостаточно для полной интеграции языков.
Функция <code><span class="func">system</span></code> должна стать полноценным объектом Scheme. Должно быть
возможным вызвать её с помощью <code><span class="func">apply</span></code> или, например, сохранить в переменной.
Всё это подразумевает существование некоторого класса значений, представляющих
внешние функции.</p>

<h2 id="cc/sect:conclusions">Заключение</h2>

<p>В данной главе был рассмотрен компилятор из Scheme в Си. Мы написали собственную
библиотеку времени исполнения, но с равным успехом можно было использовать любую
другую, например, библиотеку Bigloo <span class="cite">[<a href="z1_bibliography.xhtml#ser94">ser94</a>]</span>, SIOD <span class="cite">[<a href="z1_bibliography.xhtml#car94">car94</a>]</span> или SCM
<span class="cite">[<a href="z1_bibliography.xhtml#jaf94">jaf94</a>]</span>. В процессе мы обсудили проблемы, возникающие при компиляции в язык
высокого уровня, различия между Scheme и Си, а также преимущества разумного
сотрудничества двух языков.</p>

<p>Читателю настоятельно рекомендуется сравнить полученный компилятор
с компилятором в байт-код. Кроме того, остаётся ещё множество других идей,
стоящих реализации, например:</p>

<p>\begin{itemize}
  \item использование <code><span class="func">read</span></code> для чтения и создания цитат;</p>

<p>  \item отказ от родного стека Си (и его протокола вызова функций)
        в пользу независимого стека, заточенного под Scheme;</p>

<p>  \item поддержка раздельной компиляции, модулей и т. д.
        \seePage[chapter:compilation]
\end{itemize}</p>


<!--\indexR{раскрутка (bootstrapping)}-->
<!--\indexC{eval}-->
<!--\indexC{load}-->
<p>Также можно было бы оценить стоимость (в плане увеличения размера библиотеки и
уменьшения скорости работы) реализации динамических аспектов языка: функции
<code><span class="func">load</span></code> или её упрощённого аналога — <code><span class="func">eval</span></code>. Пусть это останется
(трудным) упражнением для читателя. Для тех же, кто с ним справится, припасено
ещё одно: скомпилировать полученный компилятор самим собой.</p>


<h2 id="cc/sect:exercises">Упражнения</h2>

<h5 class="exercise" id="cc/ex:boost-calls">Упражнение <span class="seq">0.0</span></h5>
<p>Вызовы замыканий можно ускорить, адаптировав для них протокол вызова
предопределённых примитивов с фиксированной арностью: то есть вызывать их как
$f(f, x, y)$. Доработайте компилятор соответствующим образом.</p>


<h5 class="exercise" id="cc/ex:global-check">Упражнение <span class="seq">0.0</span></h5>
<!--\indexC*{SCM_CheckedGlobal}{SCM\_CheckedGlobal}-->
<p>Доступ к глобальным переменным был бы эффективнее, если бы при чтении не было
обязательных проверок на инициализированность, выполняемых
<code><span class="func">SCM\_CheckedGlobal</span></code>. Придумайте, как выделить все переменные, для которых
эти проверки не требуются, потому что можно быть уверенным в том, что они уже
имеют некоторое значение.</p>

<p>\begin{project}
Рассмотренный в этой главе компилятор преобразует дерево объектов в код
на процедурном языке Си. Адаптируйте его для генерации кода на
объектно-ориентированном Си$++$.
\end{project}</p>

<p>\begin{project}
А теперь попробуйте написать компилятор в специализированный низкоуровневый
язык для кодогенерации — Си$--$.
\end{project}</p>

<p>
\section*{Рекомендуемая литература}\label{cc/sect:recommended-reading}</p>

<p>В последнее время наблюдается существенный интерес к компиляции языков высокого
уровня в низкоуровневый Си. Ницан Сеньяк отлично раскрыл эту тему в своей
диссертации <span class="cite">[<a href="z1_bibliography.xhtml#sen91">sen91</a>]</span>, равно как и Мануэль Серрано в статье <span class="cite">[<a href="z1_bibliography.xhtml#ser93">ser93</a>]</span>.
Если вы уже успели влюбиться по уши в подобный подход, то будьте осторожны
с исходным кодом Bigloo <span class="cite">[<a href="z1_bibliography.xhtml#ser94">ser94</a>]</span> — можно ведь и не вынырнуть!</p>

</body>
</html>
