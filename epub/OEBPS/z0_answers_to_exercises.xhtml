<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru"></p>

<p><body>
\chapter{Ответы к упражнениям}\phantomlabel{chapter:ex-answers}% hyperref</p>

<p>% -- Глава 1 ------------------------</p>

<p>\exanswer{basics/ex:tracer}</p>

<p>Просто поместите трассирующий код в соответствующее место — обработку вызовов
функций:</p>


<!--\indexC{tracing.evaluate}-->
<pre>(define (tracing.evaluate exp env)
  (if ...
      ...
      (case (car exp)
        ...
        (else (let ((fn   (evaluate (car e) env))
                    (args (evlis (cdr e) env)) )
                (display `(calling ,(car e) with . ,args)
                         *trace-port* )
                (let ((result (invoke fn args)))
                  (display `(returning from ,(car e) with ,result)
                           *trace-port* )
                  result ) )) ) ) )</pre>

<p>Обратите внимание на два момента. Во-первых, здесь используется <em>имя</em>
функции, а не её значение. Обычно сообщения в таком случае получаются понятнее.
Во-вторых, <code><span class="func">display</span></code> осуществляет вывод в настраиваемый <code><span class="func">*trace-port*</span></code>.
Это облегчает перенаправление результатов трассировки в специальное окно, или
в лог-файл, или в стандартный поток вывода.</p>

<p>
\exanswer{basics/ex:excess-recursion}</p>

<p><span class="cite">[<a href="z1_bibliography.xhtml#wan80b">wan80b</a>]</span> приписывает изобретение этой оптимизации Дэниелу Фридмену и
Дэвиду Уайзу. Она позволяет избавиться от бессмысленного вычисления выражения
<code>(evlis '() env)</code> в конце последовательности. Кроме того, значение <code><span class="func">env</span></code>
неизменно в процессе вычисления элементов последовательности, поэтому его можно
не включать лишний раз в список аргументов рекурсивно вызываемой функции.
В среднем, <code><span class="func">evlis</span></code> имеет дело со списками длиной порядка трёх-четырёх
элементов, и у каждого из них обязательно есть конец, так что эта оптимизация
оказывается весьма полезной. Кроме того, она экономит один вызов предиката.</p>


<!--\indexC{evlis}-->
<pre>(define (evlis exps env)
  (define (evlis exps)
    ;; <code>(assume (pair? exps))</code>
    (if (pair? (cdr exps))
        (cons (evaluate (car exps) env)
              (evlis (cdr exps)) )
        (list (evaluate (car exps) env)) ) )
  (if (pair? exps) (evlis exps) '()) )</pre>

<p>
\exanswer{basics/ex:new-extend}</p>

<p>Такое представление окружений известно как <em class="term">гирлянда</em> ввиду очевидного
визуального сходства. Здесь используется меньше точечных пар, но ценой этого
является некоторое замедление поиска и модификации значений переменных. Более
того, такая реализация <code><span class="func">extend</span></code> делает невозможной проверку арности для
функций с точечным аргументом.</p>


<!--\indexC{lookup}-->
<pre>(define (lookup id env)
  (if (pair? env)
      (let look ((names  (caar env))
                 (values (cdar env)) )
        (cond ((symbol? names)
               (if (eq? names id)
                   values
                   (lookup id (cdr env)) ) )
              ((null? names)
               (lookup id (cdr env)) )
              ((eq? (car names) id)
               (if (pair? values) (car values)
                   (wrong "Too few values") ) )
              (else (if (pair? values)
                        (look (cdr names) (cdr values))
                        (wrong "Too few values") )) ) )
      (wrong "No such binding" id) ) )</pre>

<p>\noindent
Реализация <code><span class="func">update!</span></code> аналогична по структуре.</p>

<p>
\exanswer{basics/ex:racks}</p>

<pre>(define (s.make-function variables body env)
  (lambda (values current.env)
    (for-each (lambda (var val)
                (putprop var 'apval (cons val (getprop var 'apval))) )
              variables values )
    (let ((result (eprogn body current.env)))
      (for-each (lambda (var)
                  (putprop var 'apval (cdr (getprop var 'apval))) )
                variables )
      result ) ) )</p>

<p>(define (s.lookup id env)
  (car (getprop id 'apval)) )</p>

<p>(define (s.update! id env value)
  (set-car! (getprop id 'apval) value) )</pre>

<p>
\exanswer{basics/ex:liar-liar!}</p>

<p>Так как эта проблема касается не только <code><span class="func"><</span></code>, то имеет смысл написать макрос,
определяющий предикаты правильно. Обратите внимание, что для определяющего
Лиспа значение <code><span class="func">the-false-value</span></code> является истиной.</p>


<!--\indexC{defpredicate}-->
<pre>(define-syntax defpredicate
  (syntax-rules ()
    ((defpredicate name value arity)
     (defprimitive name
      (lambda values (or (apply value values) the-false-value))
      arity ) ) ) )</p>

<p>(defpredicate < < 2)</pre>

<p>
\exanswer{basics/ex:def-list}</p>

<p>Главная сложность <code><span class="func">list</span></code> в том, что это функция с переменной арностью.
Однако, если вспомнить, как у нас представляются примитивы, то в голову приходит
отличная мысль:</p>


<!--\indexC{list}-->
<pre>(definitial list
  (lambda (values) values) )</pre>

<p>
\exanswer{basics/ex:def-call/cc}</p>

<p>Естественно, наиболее очевидный способ определить <code><span class="func">call/cc</span></code> — это
использовать <code><span class="func">call/cc</span></code>. Хитрость здесь в том, чтобы вложенная <code><span class="func">call/cc</span></code>
правильно вызвала передаваемую ей функцию определяемого Лиспа. Для этого её
надо вручную заворачивать в <code><span class="func">invoke</span></code>:</p>


<!--\indexC{call/cc}-->
<pre>(defprimitive call/cc
  (lambda (f)
    (call/cc (lambda (g)
               (invoke f
                (list (lambda (values)
                        (if (= (length values) 1)
                            (g (car values))
                            (wrong "Incorrect arity" g) ) )) ) )) )
  1 )</pre>

<p>
\exanswer{basics/ex:def-apply}</p>

<p>Здесь возникает та же проблема, что и с <code><span class="func">call/cc</span></code>: приходится работать
одновременно в двух мирах с двумя различными языками. Кроме того, функция
<code><span class="func">apply</span></code> имеет переменную арность, так что вдобавок требуется правильно
собрать в список аргументы вызываемой функции (и учесть, что у неё тоже может
быть точечный аргумент).</p>


<!--\indexC{apply}-->
<pre>(definitial apply
  (lambda (values)
    (if (>= (length values) 2)
        (let ((f (car values))
              (args (let flat ((args (cdr values)))
                      (if (null? (cdr args))
                          (car args)
                          (cons (car args) (flat (cdr args))) ) )) )
          (invoke f args) )
        (wrong "Incorrect arity" 'apply) ) ) )</pre>

<p>
\exanswer{basics/ex:def-end}</p>

<p>Просто захватите продолжение вызова интерпретатора и свяжите его с <code><span class="func">end</span></code>.
(К счастью, в Scheme синтаксис активации продолжений не отличается от вызова
функций.)</p>

<pre>(define (chapter1-scheme)
  (define (toplevel)
    (display (evaluate (read) env.global))
    (toplevel) )
  (call/cc (lambda (end)
             (defprimitive end end 1)
             (toplevel) )) )</pre>

<p>
\exanswer{basics/ex:slowpoke}</p>

<p>Конечно, результаты подобных сравнений одновременно зависят как от используемой
реализации, так и от рассматриваемых программ. Но в среднем можно сказать, что
разница в быстродействии будет порядка 5--15 раз <span class="cite">[<a href="z1_bibliography.xhtml#itw86">itw86</a>]</span>.</p>

<p>Даже так, главной задачей этого упражнения было подтолкнуть вас к осознанию
того, что <code><span class="func">evaluate</span></code> написана на фундаментальном Лиспе, поэтому с равным
успехом может быть исполнена как интерпретатором Scheme, так и интерпретатором
того языка, который сама же определяет, и которым сама же является.</p>

<p>
\exanswer{basics/ex:no-gensym}</p>

<p>Так как <em>список</em> упорядоченных выражений всегда можно представить в виде
пар упорядоченных выражений, то достаточно будет показать, как последовательно
вычислить два выражения. Идея состоит хитроумном использовании замыканий для
разрешения возможных конфликтов имён.</p>


<!--\indexC{begin}-->
<p>{\def\expr#1{<i>выражение</i>\sub{#1}}
\begin{code:lisp}
(begin |\expr{1}| |\expr{2}|) |\kern-0.27em\Equals|  ((lambda (void other) (other))
                                  |\expr{1}|
                                  (lambda () |\expr{2}|) )
\end{code:lisp}}</p>

<p>
% -- Глава 2 ------------------------</p>

<p>\exanswer{lisp1-2-omega/ex:funcall}</p>

<p>На Scheme оно переводится непосредственно как <code>(cons 1 2)</code>. Если быть
дотошным, то можно сделать так:</p>

<pre>(define (funcall f . args) (apply f args))
(define (function f) f)</pre>

<p>\noindent
Или то же самое с помощью макросов:</p>

<pre>(define-syntax funcall
  (syntax-rules ()
    ((funcall f arg ...) (f arg ...)) ) )</p>

<p>(define-syntax function
  (syntax-rules ()
    ((function f) f) ) )</pre>

<p>
\exanswer{lisp1-2-omega/ex:lexical}</p>

<p>Перед ответом на этот вопрос сначала попробуйте ответить на два других:</p>

<p>\begin{enumerate}
  \item Можно ли ссылаться на функцию <code><span class="func">bar</span></code> до того, как она была
        определена?</p>

<p>  \item Если <code><span class="func">bar</span></code> всё же была определена ранее, то как поведёт себя
        <code><span class="func">defun</span></code>: выдаст ошибку или переопределит функцию?
\end{enumerate}</p>

<p>А собственно результат исполнения программы зависит от того, что возвращает
специальная форма <code><span class="func">function</span></code>: <em>саму</em> функцию <code><span class="func">bar</span></code> или некоторое
значение, связанное с именем <code><span class="func">bar</span></code> в пространстве функций.</p>

<p>
\exanswer{lisp1-2-omega/ex:innovations}</p>

<p>За вызовы функций отвечает <code><span class="func">invoke</span></code>, так что достаточно просто научить её
не пугаться при виде чисел и списков. Вот так:</p>


<!--\indexC{invoke}-->
<pre>(define (invoke fn args)
  (cond ((procedure? fn) (fn args))
        ((number? fn)
         (if (= (length args) 1)
             (if (>= fn 0)
                 (list-ref (car args) fn)
                 (list-tail (car args) (- fn)) )
             (wrong "Incorrect arity" fn) ) )
        ((pair? fn)
         (map (lambda (f) (invoke f args)) fn) )
        (else (wrong "Cannot apply" fn)) ) )</pre>

<p>
\exanswer{lisp1-2-omega/ex:assoc-with-comparator}</p>

<p>Сложность здесь в том, что компаратор берётся из определяемого Лиспа и
возвращает логические значения оттуда же.</p>


<!--\indexC{assoc/de}-->
<pre>(definitial new-assoc/de
  (lambda (values current.denv)
    (if (= 3 (length values))
        (let ((tag        (car values))
              (default    (cadr values))
              (comparator (caddr values)) )
          (let look ((denv current.denv))
            (if (pair? denv)
                (if (eq? the-false-value
                         (invoke comparator (list tag (caar denv))
                                            current.denv ) )
                    (look (cdr denv))
                    (cdar denv) )
                (invoke default (list tag) current.denv) ) ) )
        (wrong "Incorrect arity" 'assoc/de) ) ) )</pre>

<p>
\exanswer{lisp1-2-omega/ex:dynamic}</p>

<p>Функция-обработчик <code><span class="func">specific-error</span></code> должна будет вывести соответствующее
сообщение о неизвестной динамической переменной.</p>


<!--\indexC{dynamic-let}-->
<!--\indexC{dynamic}-->
<!--\indexC{dynamic-set"!}-->
<pre>(define-syntax dynamic-let
  (syntax-rules ()
    ((dynamic-let () . body)
     (begin . body) )
    ((dynamic-let ((variable value) others ...) . body)
     (bind/de 'variable (list value)
              (lambda () (dynamic-let (others ...) . body)) ) ) ) )</p>

<p>(define-syntax dynamic
  (syntax-rules ()
    ((dynamic variable)
     (car (assoc/de 'variable specific-error)) ) ) )</p>

<p>(define-syntax dynamic-set!
  (syntax-rules ()
    ((dynamic-set! variable value)
     (set-car! (assoc/de 'variable specific-error) value) ) ) )</pre>

<p>
\exanswer{lisp1-2-omega/ex:write-put/get-prop}</p>

<p>Переменная <code><span class="func">properties</span></code>, замыкаемая обеими функциями, содержит список свойств
всех символов.</p>

<pre>(let ((properties '()))
  (set! putprop
        (lambda (symbol key value)
          (let ((plist (assq symbol properties)))
            (if (pair? plist)
                (let ((couple (assq key (cdr plist))))
                  (if (pair? couple)
                      (set-cdr! couple value)
                      (set-cdr! plist (cons (cons key value)
                                            (cdr plist) )) ) )
                (let ((plist (list symbol (cons key value))))
                  (set! properties (cons plist properties)) ) ) )
          value ) )
  (set! getprop
        (lambda (symbol key)
          (let ((plist (assq symbol properties)))
            (if (pair? plist)
                (let ((couple (assq key (cdr plist))))
                  (if (pair? couple)
                      (cdr couple)
                      #f ) )
                #f ) ) ) ) )</pre>

<p>
\exanswer{lisp1-2-omega/ex:label}</p>

<p>Просто добавьте следующие строки в <code><span class="func">evaluate</span></code>:</p>

<pre>...
((label)  ; Синтаксис: \ic{(label <i>имя</i> (lambda (<i>аргументы</i>) <i>тело</i>))}
 (let* ((name    (cadr e))
        (new-env (extend env (list name) (list 'void)))
        (def     (caddr e))
        (fun     (make-function (cadr def) (cddr def) new-env)) )
   (update! name new-env fun)
   fun ) )
...</pre>

<p>
\exanswer{lisp1-2-omega/ex:labels}</p>

<p>Достаточно добавить следующий фрагмент в <code><span class="func">f.evaluate</span></code>. Обратите внимание на
его схожесть с определением <code><span class="func">flet</span></code>; разница только в окружении, где создаются
локальные функции.</p>

<pre>...
((labels)
 (let ((new-fenv (extend fenv
                         (map car (cadr e))
                         (map (lambda (def) 'void) (cadr e)) )))
   (for-each (lambda (def)
               (update! (car def)
                        new-fenv
                        (f.make-function (cadr def) (cddr def)
                                         env new-fenv ) ) )
             (cadr e) )
   (f.eprogn (cddr e) env new-fenv) ) )
...</pre>

<p>
\exanswer{lisp1-2-omega/ex:orderless-letrec}</p>

<p>Так как форма <code><span class="func">let</span></code> сохраняет неопределённый порядок вычислений, то её
следует использовать для вычисления значений переменных формы <code><span class="func">letrec</span></code>.
Связывание же этих переменных с полученными значениями необходимо выполнять
отдельно. Имена для всех этих <i>temp</i>\sub{<i>i</i>} можно получить или с помощью
механизма макрогигены, или просто кучей вызовов <code><span class="func">gensym</span></code>.</p>

<pre>(let ((<i>переменная</i>\sub{1}| 'void)
      ...
      (<i>переменная</i>\sub{<i>n</i>}| 'void) )
  (let ((<i>temp</i>\sub{1}| <i>выражение</i>\sub{1}|)
        ...
        (<i>temp</i>\sub{<i>n</i>}| <i>выражение</i>\sub{<i>n</i>}|) )
    (set! <i>переменная</i>\sub{1}| <i>temp</i>\sub{1}|)
    ...
    (set! <i>переменная</i>\sub{<i>n</i>}| <i>temp</i>\sub{<i>n</i>}|)
    <i>тело</i> ) )</pre>

<p>
\exanswer{lisp1-2-omega/ex:fixn}</p>

<p>Вот вам вариант для бинарных функций. $\eta$-конверсия была модифицирована
соответствующим образом.</p>

<pre>(define fix2
  (let ((d (lambda (w)
             (lambda (f)
               (f (lambda (x y) (((w w) f) x y))) ) )))
    (d d) ) )</pre>

<p>\noindent
После этого довольно легко догадаться, как сделать $n$-арную версию:</p>

<pre>(define fixN
  (let ((d (lambda (w)
             (lambda (f)
               (f (lambda args (apply ((w w) f) args))) ) )))
    (d d) ) )</pre>

<p>
\exanswer{lisp1-2-omega/ex:nfixn}</p>

<p>Ещё одно умственное усилие — и вы увидите, что предыдущее определение
<code><span class="func">fixN</span></code> легко расширяется:</p>

<pre>(define 2fixN
  (let ((d (lambda (w)
             (lambda (f*)
               (list ((car f*)
                      (lambda a (apply (car ((w w) f*)) a))
                      (lambda a (apply (cadr ((w w) f*)) a)) )
                     ((cadr f*)
                      (lambda a (apply (car ((w w) f*)) a))
                      (lambda a (apply (cadr ((w w) f*)) a)) ) ) ) )))
    (d d) ) )</pre>

<p>После этого остаётся понять, когда именно должен быть вычислен терм
<code>((w w) f)</code>, и можно будет написать правильную универсальную версию:</p>

<pre>(define NfixN
  (let ((d (lambda (w)
             (lambda (f*)
               (map (lambda (f)
                      (apply f (map (lambda (i)
                                      (lambda a
                                        (apply (list-ref ((w w) f*) i)
                                               a ) ) )
                                    (iota 0 (length f*)) )) )
                    f* ) ) )))
    (d d) ) )</pre>

<p>Внимание: порядок функций важен. Если определение <code><span class="func">odd?</span></code> идёт первым в списке
функционалов, то именно эта функция будет связана с их первыми аргументами.</p>


<!--\indexC{iota}-->
<p>Функция <code><span class="func">iota</span></code> аналогична одноимённому примитиву $\iota$ языка APL:</p>

<pre>(define (iota start end)
  (if (< start end)
      (cons start (iota (+ 1 start) end))
      '() ) )</pre>

<p>
\exanswer{lisp1-2-omega/ex:klop}</p>

<p><span class="cite">[<a href="z1_bibliography.xhtml#bar84">bar84</a>]</span> приписывает эту функцию Яну Виллему Клопу. Можете проверить, что
<code>(klop (meta-fact) 5)</code> действительно возвращает <code><span class="func">120</span></code>.</p>

<p>Так как все внутренние переменные <code><span class="func">s</span></code>, <code><span class="func">c</span></code>, <code><span class="func">h</span></code>, <code><span class="func">e</span></code>, <code><span class="func">m</span></code>
связываются с одной <code><span class="func">r</span></code>, то их порядок в аппликации <code>(m e c h e s)</code>
не имеет значения. Важно только их количество. Вернее, согласованная арность:
можно оставить одну переменную <code><span class="func">w</span></code>, а можно использовать хоть весь алфавит
— в любом случае получится \comb{Y}\!.</p>

<p>
\exanswer{lisp1-2-omega/ex:hyper-fact}</p>

<p>Абсолютно неожиданный ответ: 120. Вам ведь понравилось выражать рекурсию
с помощью самоприменения, правда? Данное определение можно записать немного
по-другому, используя вложенные <code><span class="func">define</span></code>:</p>

<pre>(define (factfact n)
  (define (internal-fact f n)
    (if (= n 0) 1
        (* n (f f (- n 1))) ) )
  (internal-fact internal-fact n) )</pre>

<p>
% -- Глава 3 ------------------------</p>

<p>\begingroup
\def\cc#1{\ensuremath{\text{<code><span class="func">cc</span></code>}_{#1}}}
\def\tc#1{\text{<code><span class="func">#1</span></code>}}</p>

<p>\exanswer{escape/ex:cc-cc}</p>


<!--\indexC{the-current-continuation}-->
<p>Эту форму можно было назвать <code>(the-current-continuation)</code>, так как она
возвращает собственное продолжение. Давайте разберёмся, как у неё это
получается. Для понятности будем нумеровать используемые продолжения и функции,
а <code><span class="func">call/cc</span></code> сократим до просто <code><span class="func">cc</span></code>. Итак, вычисляемое выражение:
\ic{\cont{k_0}(\cc1 \cc2)}. $k_0$ — это продолжение данных вычислений.
Определение <code><span class="func">call/cc</span></code>:</p>

<pre>|\cont*{k}|(call/cc |$\phi$|)  |\is|  |\cont*{k}|(|$\phi$| |$k$|)</pre>

<p>\noindent
Следовательно, \ic{\cont{k_0}(\cc1 \cc2)} становится
\ic{\cont{k_0}(\cc2 $k_0$)}, которое в свою очередь переходит
в \ic{\cont{k_0}($k_0$ $k_0$)}, которое, очевидно, возвращает $k_0$.</p>

<p>
\exanswer{escape/ex:cc-cc-cc-cc}</p>

<p>Используя нотацию предыдущего упражнения, запишем: \ic{\cont{k_0}(({\cc1}
{\cc2})\:({\cc3} {\cc4}))}. Для простоты будем считать, что термы аппликаций
вычисляются слева направо. Тогда исходное выражение эквивалентно
\ic{\cont{k_0}(\cont{k_1}({\cc1} {\cc2})\:({\cc3} {\cc4}))}, где $k_1$ равно
$\lambda\phi . \tc{\cont{k_0}($\phi$ \cont{k_2}({\cc3} {\cc4}))}$, а $k_2$ это
$\lambda\epsilon . \tc{\cont{k_0}($k_1$ $\epsilon$)}$. Вычисление первого терма
приводит к \ic{\cont{k_0}($k_1$ $k_2$)}, а вычисление этого —
к \ic{\cont{k_0}($k_2$ \cont{k'_2}({\cc3} {\cc4}))}, где {$k'_2$} равно
$\lambda\epsilon . \tc{\cont{k_0}($k_2$ $\epsilon$)}$. Эта форма вычисляется
в \ic{\cont{k_0}($k_1$ $k'_2$)}, что впоследствии приводит
к \ic{\cont{k_0}($k_1$ $k''_2$)}, и так далее. Как видите, вычисления
зацикливаются. Можно доказать, что результат не зависит от порядка вычисления
термов аппликаций. Вполне вероятно, что это самая короткая программа на Лиспе,
выражающая бесконечный цикл.</p>

<p>\endgroup % \def cc, tc</p>

<p>
\exanswer{escape/ex:tagbody}</p>

<p>Метки разделяют тело <code><span class="func">tagbody</span></code> на отдельные последовательности выражений. Эти
последовательности оборачиваются в функции и помещаются в гигантскую форму
<code><span class="func">labels</span></code>. Формы <code><span class="func">go</span></code> преобразуются в вызовы соответствующих функций, но
данные вызовы выполняются специальным образом, чтобы <code><span class="func">go</span></code> получила правильное
продолжение. В итоге <code><span class="func">tagbody</span></code> становится этим:</p>

<p>\begingroup
\def\L#1{<i>метка</i>\sub{#1}}
\def\E#1{<i>выражения</i>\sub{#1}}
\begin{code:lisp}
(block EXIT
  (let ((LABEL (TAG (list 'tagbody))))
    (labels ((INIT  () |\E0|... (|\L1|))
             (|\L1| () |\E1|... (|\L2|))
             ...
             (|\L{<i>n</i>}| () |\E{<i>n</i>}|... (return-from EXIT nil)) )
      (setq LABEL (function INIT))
      (while #t
        (setq LABEL (catch TAG (funcall LABEL))) ) ) ) )
\end{code:lisp}
\endgroup</p>

<p>Формы \ic{(go <i>метка</i>)} становятся \ic{(throw TAG <i>метка</i>)}, а
\ic{(return <i>значение</i>)} превращается в \ic{(return-from EXIT
<i>значение</i>)}. Имена переменных, записанные <code><span class="func">ПРОПИСНЫМИ</span></code> буквами,
не должны конфликтовать с переменными, используемыми в теле <code><span class="func">tagbody</span></code>.</p>

<p>Такое сложное представление <code><span class="func">go</span></code> необходимо для того, чтобы обеспечить
переходам правильное продолжение: в форме <code>(bar (go L))</code> не надо вызывать
функцию <code><span class="func">bar</span></code> после того, как <code>(go L)</code> вернёт значение. Если этого
не сделать, то вот такая программа будет вести себя неправильно:</p>

<pre>(tagbody  A (return (+ 1 (catch 'foo (go B))))
          B (* 2 (throw 'foo 5)) )</pre>

<p>\noindent
См. также <span class="cite">[<a href="z1_bibliography.xhtml#bak92c">bak92c</a>]</span>.</p>

<p>
\exanswer{escape/ex:arity-optimize}</p>

<p>Введите новый класс функций:</p>

<pre>(define-class function-with-arity function (arity))</pre>

<p>\noindent
Затем измените обработку <code><span class="func">lambda</span></code>-форм, чтобы они возвращали именно такие
объекты:</p>

<pre>(define (evaluate-lambda n* e* r k)
  (resume k (make-function-with-arity n* e* r (length n*))) )</pre>

<p>\noindent
И, наконец, реализуйте оптимизированный протокол вызова данных функций:</p>

<pre>(define-method (invoke (f function-with-arity) v* r k)
  (if (= (function-with-arity-arity f) (length v*))
      (let ((env (extend-env (function-env f)
                             (function-variables f) v* )))
        (evaluate-begin (function-body f) env k) )
      (wrong "Incorrect arity" (function-variables f) v*) ) )</pre>

<p>
\exanswer{escape/ex:apply}</p>


<!--\indexC{apply}-->
<pre>(definitial apply
  (make-primitive 'apply
   (lambda (v* r k)
     (if (>= (length v*) 2)
         (let ((f (car v*))
               (args (let flat ((args (cdr v*)))
                       (if (null? (cdr args))
                           (car args)
                           (cons (car args) (flat (cdr args))) ) )) )
           (invoke f args r k) )
         (wrong "Incorrect arity" 'apply) ) ) ) )</pre>

<p>
\exanswer{escape/ex:dotted}</p>

<p>Определите новый класс функций по аналогии
с упражнением \ref{escape/ex:arity-optimize}.</p>

<pre>(define-class function-nary function (arity))</p>

<p>(define (evaluate-lambda n* e* r k)
  (resume k (make-function-nary n* e* (length n*))) )</p>

<p>(define-method (invoke (f function-nary) v* r k)
  (define (extend-env env names values)
    (if (pair? names)
        (make-variable-env
         (extend-env env (cdr names) (cdr values))
         (car names)
         (car values) )
        (make-variable-env env names values) ) )
  (if (>= (length v*) (function-nary-arity f))
      (let ((env (extend-env (function-env f)
                             (function-variables f)
                             v* )))
        (evaluate-begin (function-body f) env k) )
      (wrong "Incorrect arity" (function-variables f) v*) ) )</pre>

<p>
\exanswer{escape/ex:evaluate}</p>

<p>Реализуйте циклическое выполнение <code><span class="func">evaluate</span></code> с помощью начального
продолжения:</p>

<pre>(define (chapter3-interpreter-2)
  (letrec ((k.init (make-bottom-cont
                    'void (lambda (v) (display v)
                                      (toplevel) ) ))
           (toplevel (lambda () (evaluate (read r.init k.init)))) )
    (toplevel) ) )</pre>

<p>
\exanswer{escape/ex:cc-value}</p>

<p>Определите соответствующий класс значений-продолжений. Он должен инкапсулировать
продолжения языка реализации и предоставлять метод для их активации.
<code><span class="func">call/cc</span></code> теперь будет возвращать именно такие объекты.</p>


<!--\indexC{call/cc}-->
<pre>(define-class reified-continuation value (k))</p>

<p>(definitial call/cc
  (make-primitive 'call/cc
   (lambda (v* r k)
     (if (= 1 (length v*))
         (invoke (car v*) (list (make-reified-continuation k)) r k)
         (wrong "Incorrect arity" 'call/cc v*) ) ) ) )</p>

<p>(define-method (invoke (f reified-continuation) v* r k)
  (if (= 1 (length v*))
      (resume (reified-continuation-k f) (car v*))
      (wrong "Continuations expect one argument" v* r k) ) )</pre>

<p>
\exanswer{escape/ex:eternal}</p>

<p>Вычисление функции заканчивается возвратом значения. Перехватывайте все попытки
вернуть его.</p>

<pre>(defun eternal-return (thunk)     |\dialect<span class="logo">Common Lisp</span>|
  (labels ((loop ()
             (unwind-protect (thunk)
               (loop) ) ))
    (loop) ) )</pre>

<p>
\exanswer{escape/ex:crazy-cc}</p>

<p>Значения этих выражений: 33 и 44 соответственно. Функция <code><span class="func">make-box</span></code> создаёт
<em class="term">коробку</em>, которая может хранить в себе одно значение. Причём это значение
можно изменять без видимых побочных эффектов. Достигается такое поведение
с помощью <code><span class="func">call/cc</span></code> и <code><span class="func">letrec</span></code>. Если вспомнить, что <code><span class="func">letrec</span></code>
эквивалентна комбинации <code><span class="func">let</span></code> и <code><span class="func">set!</span></code>, то станет понятнее, каким образом
нам удаётся получить такой эффект. Полноценные продолжения Scheme, способные
сколько угодно раз возвращаться к прерванным вычислениям, позволяют отделить
неявную <code><span class="func">set!</span></code>-часть формы <code><span class="func">letrec</span></code> от её <code><span class="func">let</span></code>-части.</p>

<p>
\exanswer{escape/ex:generic-evaluate}</p>

<p>Сначала сделайте <code><span class="func">evaluate</span></code> обобщённой:</p>

<pre>(define-generic (evaluate (e) r k)
  (wrong "Not a program" e) )</pre>

<p>\noindent
Затем напишите для неё методы, вызывающие соответствующие функции:</p>

<pre>(define-method (evaluate (e quotation) r k)
  (evaluate-quote (quotation-value e) r k) )</p>

<p>(define-method (evaluate (e assignment) r k)
  (evaluate-set! (assignment-name e)
                 (assignment-form e)
                 r k ) )
...
\end{code:lisp}
\noindent
Также вам понадобятся новые классы объектов для представления различных частей
программ:</p>

<pre>(define-class program    Object  ())
(define-class quotation  program (value))
(define-class assignment program (name form))
...</pre>

<p>Всё, теперь остаётся только определить функцию, преобразующую текст программ
в объекты класса <code><span class="func">program</span></code>. Эта функция, называемая <code><span class="func">objectify</span></code>,
рассматривается в разделе \ref{macros/macrosystem/ssect:object}.</p>

<p>
\exanswer{escape/ex:throw}</p>

<p>Функция <code><span class="func">throw</span></code> определяется вот так:</p>

<pre>(definitial throw
  (make-primitive 'throw
   (lambda (v* r k)
     (if (= 2 (length v*))
         (catch-lookup k (car v*)
                       (make-throw-cont k
                        `(quote ,(cadr v*)) r ) )
         (wrong "Incorrect arity" 'throw v*) ) ) ) )</pre>

<p>Вместо того, чтобы определять новый метод для <code><span class="func">catch-lookup</span></code>, мы просто
подсунули ей фальшивое продолжение, чтобы заставить интерпретатор вести себя
ожидаемым образом: вычислить и вернуть второй аргумент <code><span class="func">throw</span></code>, когда
найдётся соответствующая форма <code><span class="func">catch</span></code>.</p>

<p>
\exanswer{escape/ex:cps-speed}</p>


<!--\indexE{CPS}-->
<!--\indexR{стиль передачи продолжений (CPS)}-->
<p>CPS-код медленнее обычного, так как он вынужден постоянно создавать замыкания
для явного представления продолжений.</p>

<p>Между прочим, CPS-преобразование не идемпотентно; то есть, применив его
к программе, уже переписанной в стиле передачи продолжений, мы получим ещё одну,
третью версию той же программы. Рассмотрим, например, определение факториала:</p>


<!--\indexC{fact}-->
<pre>(define (cps-fact n k)
  (if (= n 0) (k 1)
      (cps-fact (- n 1) (lambda (v) (k (* n v)))) ) )</pre>

<p>Очевидно, что <code><span class="func">k</span></code> — это просто аргумент функции <code><span class="func">cps-fact</span></code>. Он может
быть вообще чем угодно. В том числе и таким продолжением:</p>

<pre>(call/cc (lambda (k) (* 2 (cps-fact 4 k)))) |\is| 24</pre>

<p>
\exanswer{escape/ex:the-current-cc}</p>

<p>Функцию <code><span class="func">the-current-continuation</span></code> также можно определить подобно
упражнению \ref{escape/ex:cc-cc}.</p>


<!--\indexC{call/cc}-->
<pre>(define (cc f)
  (let ((reified? #f))
    (let ((k (the-current-continuation)))
      (if reified? k
          (begin (set! reified? #t)
                 (f k) ) ) ) ) )</pre>

<p>Большое спасибо Люку Моро за эту пару упражнений <span class="cite">[<a href="z1_bibliography.xhtml#mor94">mor94</a>]</span>.</p>

<p>
% -- Глава 4 ------------------------</p>

<p>\exanswer{assignment/ex:pure-min-max}</p>

<p>Количество способов написания этой функции огромно. Например, можно возвращать
промежуточные результаты или использовать продолжения:</p>


<!--\indexC{min-max}-->
<pre>(define (min-max1 tree)
  (define (mm tree)
    (if (pair? tree)
        (let ((a (mm (car tree)))
              (b (mm (cdr tree))) )
          (list (min (car a) (car d))
                (max (cadr a) (cadr d)) ) )
        (list tree tree) ) )
  (mm tree) )</p>

<p>(define (min-max2 tree)
  (define (mm tree k)
    (if (pair? tree)
        (mm (car tree)
            (lambda (mina maxa)
              (mm (cdr tree)
                  (lambda (mind maxd)
                    (k (min mina mind)
                       (max maxa maxd) ) ) ) ) )
        (k tree tree) ) )
  (mm tree list) )</pre>


<!--\indexE{deforestation}-->
<p>Первый вариант в процессе работы постоянно создаёт и тут же уничтожает кучу
списков. Ситуацию можно поправить с помощью известной оптимизации, называемой
<em class="term">deforestation</em> <span class="cite">[<a href="z1_bibliography.xhtml#wad88">wad88</a>]</span>. Она позволяет избавиться от лишних
промежуточных структур данных. Второй вариант в этом плане ничем не лучше:
просто вместо списков здесь замыкания. Исходная версия гораздо быстрее любого из
них (но она использует «невыносимо отвратительные» побочные эффекты).</p>

<p>
\exanswer{assignment/ex:lambda-cons}</p>

<p>Функции начинаются на <code><span class="func">q</span></code>, чтобы избежать путаницы.</p>


<!--\indexC{cons}-->
<!--\indexC{car}-->
<!--\indexC{cdr}-->
<pre>(define (qons a d) (lambda (msg) (msg a d)))
(define (qar pair) (pair (lambda (a d) a)))
(define (qdr pair) (pair (lambda (a d) d)))</pre>

<p>
\exanswer{assignment/ex:destructive-eq}</p>

<p>Идея в том, что две точечные пары идентичны, если модификация одной из них
приводит к изменениям в другой.</p>

<pre>(define (pair-eq? a b)
  (let ((tag (list 'tag))
        (old-car (car a)) )
    (set-car! a tag)
    (let ((result (eq? (car b) tag)))
      (set-car! a old-car)
      result ) ) )</pre>

<p>
\exanswer{assignment/ex:form-or}</p>

<p>Добавляете анализ новой специальной формы в <code><span class="func">evaluate</span></code>:</p>

<pre>...
((or) (evaluate-or (cadr e) (caddr e) r s k))
...</pre>

<p>\noindent
После этого определяете её как-то так:</p>

<pre>(define (evaluate-or e1 e2 r s k)
  (evaluate e1 r s (lambda (v ss)
                     (((v 'boolify)
                       (lambda () (k v ss))
                       (lambda () (evaluate e2 r k [s])) )) )) )</pre>

<p>Суть в том, что вычисление альтернативной ветки $\beta$ производится в старой
памяти <code><span class="func">s</span></code>, а не в новой <code><span class="func">ss</span></code>.</p>

<p>
\exanswer{assignment/ex:previous-value}</p>


<!--\indexR{возвращаемые значения!присваивания}-->
<!--\indexCS{set"!}{возвращаемое значение}-->
<!--\indexR{присваивание!возвращаемое значение}-->
<p>Вообще-то такая формулировка задания допускает разночтения: можно ведь
возвращать то значение переменной, которое она имела до вычисления её нового
значения, а можно вернуть и то, каким оно стало после.</p>

<pre>(define (pre-evaluate-set! n e r s k)
  (evaluate e r s
    (lambda (v ss)
      (k ([ss] (r n)) (update ss (r n) v)) ) ) )</p>

<p>(define (post-evaluate-set! n e r s k)
  (evaluate e r s
    (lambda (v ss)
      (k ([s] (r n)) (update ss (r n) v)) ) ) )</pre>

<p>\noindent
Это важно. Например, значение данного выражения зависит от реализации:</p>

<pre>(let ((x 1))
  (set! x (set! x 2)) )</pre>

<p>
\exanswer{assignment/ex:apply/cc}</p>

<p>Основная сложность в <code><span class="func">apply</span></code> — это правильно обработать список её
аргументов, созданный интерпретатором определяемого языка.</p>


<!--\indexC{apply}-->
<pre>(definitial apply
  (create-function
   -11 (lambda (v* s k)
         (define (first-pairs v*)
           ;; <code>(assume (pair? v*))</code>
           (if (pair? (cdr v*))
               (cons (car v*) (first-pairs (cdr v*)))
               '() ) )
         (define (terms-of v s)
           (if (eq? (v 'type) 'pair)
               (cons (s (v 'car)) (terms-of (s (v 'cdr)) s))
               '() ) )
         (if (>= (length v*) 2)
             (if (eq? ((car v*) 'type) 'function)
                 (((car v*) 'behavior)
                  (append (first-pairs (cdr v*))
                          (terms-of (car (last-pair (cdr v*))) s) )
                  s k )
                 (wrong "First argument not a function") )
             (wrong "Incorrect arity") ) ) ) )</pre>

<p>Функция <code><span class="func">call/cc</span></code> сохраняет каждое продолжение в собственной ячейке памяти,
чтобы сделать их уникальными.</p>


<!--\indexC{call/cc}-->
<pre>(definitial call/cc
  (create-function
   -13 (lambda (v* s k)
         (if (= 1 (length v*))
             (if (eq? ((car v*) 'type) 'function)
                 (allocate 1 s
                  (lambda (a* ss)
                    (((car v*) 'behavior)
                     (list (create-function
                            (car a*)
                            (lambda (vv* sss kk)
                              (if (= 1 (length vv*))
                                  (k (car vv*) sss)
                                  (wrong "Incorrect arity") ) ) ))
                     ss k ) ) )
                 (wrong "Argument not a function") )
             (wrong "Incorrect arity") ) ) ) )</pre>

<p>
\exanswer{assignment/ex:dotted}</p>

<p>Сложность здесь состоит в проверке совместимости количества фактически
полученных аргументов с арностью вызываемой функции, а также в преобразовании
списков и значений при передаче их между языками.</p>

<pre>(define (evaluate-nlambda n* e* r s k)
  (define (arity n*)
    (cond ((pair? n*) (+ 1 (arity (cdr n*))))
          ((null? n*) 0)
          (else       1) ) )</p>

<p>  (define (update-environment r n* a*)
    (cond ((pair? n*) (update-environment
                       (update r (car n*) (car a*))
                       (cdr n*) (cdr* a) ))
          ((null? n*) r)
          (else (update r n* (car a*))) ) )</p>

<p>  (define (update-store s a* v* n*)
    (cond ((pair? n*) (update-store (update s (car a*) (car v*))
                                    (cdr a*) (cdr v*) (cdr n*) ))
          ((null? n*) s)
          (else (allocate-list v* s (lambda (v ss)
                                      (update ss (car a*) v) ))) ) )
  (allocate 1 s
    (lambda (a* ss)
      (k (create-function
          (car a*)
          (lambda (v* s k)
            (if (compatible-arity? n* v*)
                (allocate (arity n*) s
                 (lambda (a* ss)
                   (evaluate-begin e*
                                   (update-environment r n* a*)
                                   (update-store ss a* v n*)
                                   k ) ) )
                (wrong "Incorrect arity") ) ) )
         ss ) ) ) )</p>

<p>(define (compatible-arity? n* v*)
  (cond ((pair? n*) (and (pair? v*)
                         (compatible-arity? (cdr n*) (cdr v*)) ))
        ((null? n*) (null? v*))
        ((symbol? n*) #t) ) )</pre>

<p>
% -- Глава 5 ------------------------</p>

<p>\begingroup\ChapterFiveSpecials</p>

<p>\exanswer{denotational/ex:truly-random}</p>

<p>Доказывается индукцией по количеству термов аппликации.</p>

<p>
\exanswer{denotational/ex:label}</p>

<p>\begin{denotation}
$\Lain\sem*{(label $\n$ $\p$)}\r =
    (\comb{Y}\ \lambda \e.(\Lain\sem{\p}\ \r[\n \to \e]))$
\end{denotation}</p>

<p>
\exanswer{denotational/ex:dynamic-fallback}</p>

<p>\begin{denotation}
$\Eval\sem*{(dynamic $\n$)}\r\d\k\s = {}$                                     \\
  $\LET \e = (\d\ \n)$                                                        \\
  $\IN {}$\.$\IF   \e = <i>no-dynamic-binding</i>$                              \\
            $\THEN {}$\.$\LET \a = (\g\ \n)$                                  \\
                        $\IN {}$\.$\IF   \a = <i>no-global-binding</i>$         \\
                                  $\THEN <i>wrong</i>\ <code><span class="func">"No such variable"</span></code>$ \\
                                  $\ELSE (\k\ (\s\ \a)\ \s)$                  \\
                                  $\ENDIF$                                \-\-\\
            $\ELSE (\k\ \e\ \s)$                                              \\
            $\ENDIF$
\end{denotation}</p>

<p>
\exanswer{denotational/ex:quantum}</p>

<p>Этот макрос помещает вычисление каждого терма в собственное замыкание, после
чего выполняет все эти вычисления в произвольном порядке, определяемом функцией
<code><span class="func">determine!</span></code>.</p>

<pre>(define-syntax unordered
  (syntax-rules ()
    ((unordered f) (f))
    ((unordered f arg ...)
     (determine! (lambda () f) (lambda () arg) ...) ) ) )</p>

<p>(define (determine! . thunks)
  (let ((results (iota 0 (length thunks))))
    (let loop ((permut (random-permutation (length thunks))))
      (if (pair? permut)
          (begin (set-car! (list-tail results (car permut))
                           (force (list-ref thunks (car permut))) )
                 (loop (cdr permut)) )
          (apply (car results) (cdr results)) ) ) ) )</pre>

<p>Заметьте, что порядок выбирается перед началом вычислений, так что такое
определение не совсем идентично денотации, приведённой в этой главе. Если
функция <code><span class="func">random-permutation</span></code> определена вот так:</p>

<pre>(define (random-permutation n)
  (shuffle (iota 0 n)) )</pre>

<p>\noindent
то последовательность вычислений выбирается действительно динамически:</p>

<pre>(define (d.determine! . thunks)
  (let ((results (iota 0 (length thunks))))
    (let loop ((permut (random-permutation (length thunks))))
      (if (pair? permut)
          (begin (set-car! (list-tail results (car permut))
                           (force (list-ref thunks (car permut))) )
                 (loop (shuffle (cdr permut))) )
          (apply (car results) (cdr results)) ) ) ) )</pre>

<p>\endgroup %\ChapterFiveSpecials</p>

<p>
% -- Глава 6 ------------------------</p>

<p>\exanswer{fast/ex:symbol-table}</p>

<p>Самый простой способ — это добавить <code><span class="func">CHECKED-GLOBAL-REF</span></code> ещё один аргумент
с именем соответствующей переменной:</p>

<pre>(define (CHECKED-GLOBAL-REF- i n)
  (lambda ()
    (let ((v (global-fetch i)))
      (if (eq? v undefined-value)
          (wrong "Uninitialized variable" n)
          v ) ) ) )</pre>

<p>Однако такой подход нерационально расходует память и дублирует информацию. Более
правильным решением будет создать специальную таблицу символов для хранения
соответствий между адресами переменных и их именами.</p>

<pre>(define sg.current.names (list 'foo))
(define (standalone-producer e)
  (set! g.current (original.g.current))
  (let* ((m (meaning e r.init #t))
         (size (length g.current))
         (global-names (map car (reverse g.current))) )
    (lambda ()
      (set! sg.current (make-vector size undefined-value))
      (set! sg.current.names global-names)
      (set! *env* sr.init)
      (m) ) ) )</p>

<p>(define (CHECKED-GLOBAL-REF+ i)
  (lambda ()
    (let ((v (global-fetch i)))
      (if (eq? v undefined-value)
          (wrong "Uninitialized variable"
                 (list-ref sg.current.names i) )
          v ) ) ) )</pre>

<p>
\exanswer{fast/ex:list}</p>

<p>Функция <code><span class="func">list</span></code> — это, конечно же, просто <code>(lambda l l)</code>. Вам надо
только выразить это определение с помощью комбинаторов:</p>

<pre>(definitial list ((NARY-CLOSURE (SHALLOW-ARGUMENT-REF 0) 0)))</pre>

<p>
\exanswer{fast/ex:disassemble}</p>

<p>Всё просто: достаточно переопределить каждый комбинатор <i>k</i> как \ic{(lambda
args `(<i>k</i> . ,args))} и распечатать результат предобработки.</p>

<p>
\exanswer{fast/ex:act-rec-before}</p>

<p>Решение в лоб: вычислять термы аппликации справа налево:</p>

<pre>(define (FROM-RIGHT-STORE-ARGUMENT m m* index)
  (lambda ()
    (let* [((v* (m*))
           (v  (m)) )]
      (set-activation-frame-argument! v* index v)
      v* ) ) )</p>

<p>(define (FROM-RIGHT-CONS-ARGUMENT m m* arity)
  (lambda ()
    (let* [((v* (m*))
           (v  (m)) )]
      (set-activation-frame-argument!
       v* arity (cons v (activation-frame-argument v* arity)) )
      v* ) ) )</pre>

<p>Также можно изменить не порядок вычисления аргументов, а определение
<code><span class="func">meaning*</span></code>, чтобы она создавала запись активации первой. В любом случае
эффективнее будет сначала вычислить функциональный терм (порядок вычисления
остальных аргументов здесь не важен), так как это позволяет узнать истинную
арность вызываемого замыкания и сразу создавать запись активации правильного
размера.</p>

<p>
\exanswer{fast/ex:redefine}</p>

<p>Определите синтаксис новой специальной формы в <code><span class="func">meaning</span></code>:</p>

<pre>... ((redefine) (meaning-redefine (cadr e))) ...</pre>

<p>\noindent
Затем реализуйте её предобработку:</p>

<pre>(define (meaning-redefine n)
  (let ((kind1 (global-variable? g.init n)))
    (if kind1
        (let ((value (vector-ref sg.init (cdr kind)))
              (kind2 (global-variable? g.current n)) )
          (if kind2
              (static-wrong "Already redefined variable" n)
              (let ((index (g.current-extend! n)))
                (vector-set! sg.current index value) ) ) )
        (static-wrong "Can't redefine variable" n) )
    (lambda () 2001) ) )</pre>

<p>Подобные переопределения производятся во время предобработки, ещё до исполнения
программы. Возвращаемое значение формы <code><span class="func">redefine</span></code> не важно.</p>

<p>
\exanswer{fast/ex:boost-thunks}</p>

<p>Вызов функции без аргументов не требует выделения памяти под переменные, то есть
расширения текущего окружения. Каждый дополнительный уровень окружения
увеличивает стоимость обращений к свободным переменным замыканий, что
сказывается на быстродействии. Реализуйте новый комбинатор и добавьте
в определение <code><span class="func">meaning-fix-abstraction</span></code> обработку соответствующего
специального случая.</p>

<pre>(define (THUNK-CLOSURE m+)
  (let ((arity+1 (+ 0 1)))
    (lambda ()
      (define (the-function v* sr)
        (if (= (activation-frame-argument-length v*) arity+1)
            (begin (set! *env* sr)
                   (m+) )
            (wrong "Incorrect arity") ) )
      (make-closure the-function *env*) ) ) )</p>

<p>(define (meaning-fix-abstraction n* e+ r tail?)
  (let ((arity (length n*)))
    (if (= arity 0)
        (let ((m+ (meaning-sequence e+ r #t)))
          (THUNK-CLOSURE m+) )
        (let* ((r2 (r-extend* r n*))
               (m+ (meaning-sequence e+ r2 #t)) )
          (FIX-CLOSURE m+ arity) ) ) ) )</pre>

<p>
% -- Глава 7 ------------------------</p>

<p>\exanswer{compilation/ex:dynamic}</p>

<p>Сначала создайте новый регистр:</p>

<pre>(define *dynenv* -1)</pre>

<p>\noindent
Затем сохраняйте его вместе с остальным окружением:</p>

<pre>(define (preserve-environment)
  (stack-push *dynenv*)
  (stack-push *env*) )</p>

<p>(define (restore-environment)
  (set! *env* (stack-pop))
  (set! *dynenv* (stack-pop)) )</pre>

<p>\noindent
Теперь динамическое окружение извлекается элементарно; лишь несколько изменилась работа со стеком:</p>

<pre>(define (search-dynenv-index)
  *dynenv* )</p>

<p>(define (pop-dynamic-binding)
  (stack-pop)
  (stack-pop)
  (set! *dynenv* (stack-pop)) )</p>

<p>(define (push-dynamic-binding index value)
  (stack-push *dynenv*)
  (stack-push value)
  (stack-push index)
  (set! *dynenv* (- *stack-index* 1)) )</pre>

<p>
\exanswer{compilation/ex:load}</p>

<p>Сама функция-то простая:</p>

<pre>(definitial load
  (let* ((arity 1)
         (arity+1 (+ 1 arity)) )
    (make-primitive
     (lambda ()
       (if (= arity+1 (activation-frame-argument-length *val*))
           (let ((filename (activation-frame-argument *val* 0)))
             (set! *pc* (install-object-file! filename)) )
           (signal-exception
            #t (list "Incorrect arity" 'load) ) ) ) ) ) )</pre>

<p>\noindent
Но вот при её использовании возникают определённые сложности. Всё дело
в продолжениях. Допустим, с помощью <code><span class="func">load</span></code> загружается следующий файл:</p>

<pre>(display 'attention)
(call/cc (lambda (k) (set! *k* k)))
(display 'caution)</pre>

<p>\noindent
Что случится, если после этого активировать продолжение <code><span class="func">*k*</span></code>? Правильно,
выведется символ <code><span class="func">caution</span></code>! А потом?</p>

<p>Кроме того, определения глобальных переменных из загружаемого файла не переходят
в текущий (что, согласитесь, будет сюрпризом для функций, которые от них
зависят).</p>

<p>
\exanswer{compilation/ex:global-value}</p>

<p>Всё просто:</p>

<pre>(definitial global-value
  (let* ((arity 1)
         (arity+1 (+ 1 arity)) )
    (define (get-index name)
      (let ((where (memq name sg.current.names)))
        (if where
            (- (length where) 1)
            (signal-exception
             #f (list "Undefined global variable" name) ) ) ) )
    (make-primitive
     (lambda ()
       (if (= arity+1 (activation-frame-argument-length *val*))
           (let* ((name (activation-frame-argument *val* 0))
                  (i (get-index name)) )
             (set! *val* (global-fetch i))
             (when (eq? *val* undefined-value)
               (signal-exception #f (list "Uninitialized variable" i)) )
             (set! *pc* (stack-pop)) )
           (signal-exception
            #t (list "Incorrect arity" 'global-value) ) ) ) ) ) )</pre>

<p>Во время вызова этой функции переменная может как просто не существовать, так и
ещё не иметь значения. Оба этих случая необходимо проверять.</p>

<p>
\exanswer{compilation/ex:shallow-dynamic}</p>

<p>Для начала добавьте в <code><span class="func">run-machine</span></code> инициализацию вектора текущего состояния
динамического окружения:</p>

<pre>... (set! *dynamics* (make-vector (+ 1 (length dynamics))
                                  undefined-value )) ...</pre>

<p>\noindent
После чего переопределите функции-аксессоры на новый лад:</p>

<pre>(define (find-dynamic-value index)
  (let ((v (vector-ref *dynamics* index)))
    (if (eq? v undefined-value)
        (signal-exception #f (list "No such dynamic binding" index))
        v ) ) )</p>

<p>(define (push-dynamic-binding index value)
  (stack-push (vector-ref *dynamics* index))
  (stack-push index)
  (vector-set! *dynamics* index value) )</p>

<p>(define (pop-dynamic-binding)
  (let* ((index (stack-pop))
         (old-value (stack-pop)) )
    (vector-set! *dynamics* index old-value) ) )</pre>

<p>Увы, но такое решение в общем случае неверно. В стеке сейчас сохраняются только
предыдущие значения динамических переменных, но не текущие. Следовательно, любой
переход или активация продолжения приведут к неправильному состоянию
динамического окружения, так как мы не сможем восстановить значение
<code><span class="func">*dynamics*</span></code> на момент входа в форму <code><span class="func">bind-exit</span></code> или <code><span class="func">call/cc</span></code>. Чтобы
реализовать данное поведение, необходима форма <code><span class="func">unwind-protect</span></code>; ну, или
можно отказаться от такого подхода в пользу дальнего связывания, где подобные
проблемы не возникают в принципе.</p>

<p>
\exanswer{compilation/ex:export-rename}</p>

<p>С помощью следующей функции можно выразить даже взаимные переименования вида
<code>((fact fib) (fib fact))</code>. Но не стоит этим злоупотреблять.</p>

<pre>(define (build-application-with-renaming-variables
         new-application-name application-name substitutions )
  (if (probe-file application-name)
      (call-with-input-file application-name
        (lambda (in)
          (let* ((dynamics     (read in))
                 (global-names (read in))
                 (constants    (read in))
                 (code         (read in))
                 (entries      (read in)) )
            (close-input-port in)
            (write-result-file
             new-application-name
             (list ";;; Renamed variables from " application-name)
             dynamics
             (let sublis ((global-names global-names))
               (if (pair? global-names)
                   (cons (let ((s (assq (car global-names)
                                        substitutions )))
                           (if (pair? s)
                               (cadr s)
                               (car global-names) ) )
                         (sublis (cdr global-names)) )
                   global-names ) )
             constants
             code
             entries ) ) ) )
      (signal-exception #f (list "No such file" application-name)) ) )</pre>

<p>
\exanswer{compilation/ex:unchecked-ref}</p>

<p>Сделать это просто, только не перепутайте коды инструкций и смещения!</p>

<pre>(define-instruction (CHECKED-GLOBAL-REF i) 8
  (set! *val* (global-fetch i))
  (if (eq? val undefined-value)
      (signal-exception #t (list "Uninitialized variable" i))
      (vector-set! *code* (- *pc* 2) 7) ) )</pre>

<p>
% -- Глава 8 ------------------------</p>

<p>\exanswer{reflection/ex:no-cycles}</p>

<p>Она может не волноваться об этом, потому как сравнивает переменные не по именам.
Такой подход правильно работает даже для списков с циклами.</p>

<p>
\exanswer{reflection/ex:optimize-ce}</p>

<p>Вот вам подсказка:</p>

<pre>(define (prepare e)
  (eval/ce `(lambda () ,e)) )</pre>

<p>
\exanswer{reflection/ex:no-capture}</p>

<pre>(define (eval/at e)
  (let ((g (gensym)))
    (eval/ce `(lambda (,g) (eval/ce ,g))) ) )</pre>

<p>
\exanswer{reflection/ex:defined}</p>

<p>Да, определив специальный обработчик исключений:</p>

<pre>(set! variable-defined?
      (lambda (env name)
        (bind-exit (return)
          (monitor (lambda (c ex) (return #f))
            (eval/b name env)
            #t ) ) ) )</pre>

<p>
\exanswer{reflection/ex:rnrs}</p>

<p>Реализацию специальной формы <code><span class="func">monitor</span></code>, которая используется в рефлексивном
интерпретаторе, мы молча пропустим, так как она принципиально непереносима.
В конце концов, если не делать ошибок, то <code><span class="func">monitor</span></code> эквивалентна <code><span class="func">begin</span></code>.
Строго говоря, остальной код, что следует далее, тоже не совсем легален, так
как использует переменные с именами специальных форм. Однако, большинство
реализаций Scheme допускают такие вольности.</p>

<p>Форма <code><span class="func">the-environment</span></code>, захватывающая привязки:</p>

<pre>(define-syntax the-environment
  (syntax-rules ()
    ((the-environment)
     (capture-the-environment make-toplevel make-flambda flambda?
      flambda-behavior prompt-in prompt-out exit it extend error
      global-env toplevel eval evlis eprogn reference quote if set!
      lambda flambda monitor ) ) ) )</p>

<p>(define-syntax capture-the-environment
  (syntax-rules ()
    ((capture-the-environment word ...)
     (lambda (name . value)
       (case name
         ((word) ((handle-location word) value)) ...
         ((display) (if (pair? value)
                        (wrong "Immutable" 'display)
                        show ))
         (else (if (pair? value)
                   (set-top-level-value! name (car value))
                   (top-level-value name) )) ) ) ) ) )</p>

<p>(define-syntax handle-location
  (syntax-rules ()
    ((handle-location name)
     (lambda (value)
       (if (pair? value) (set! name (car value))
           name ) ) ) ) )</pre>

<p>Функции <code><span class="func">variable-defined?</span></code>, <code><span class="func">variable-value</span></code> и <code><span class="func">set-variable-value!</span></code>,
манипулирующие захваченными полноценными окружениями:</p>

<pre>(define undefined (cons 'un 'defined))</p>

<p>(define-class Envir Object
  ( name value next ) )</p>

<p>(define (enrich env . names)
  (let enrich ((env env) (names names))
    (if (pair? names)
        (enrich (make-Envir (car names) undefined env)
                (cdr names) )
        env ) ) )</p>

<p>(define (variable-defined? name env)
  (if (Envir? env)
      (or (eq? name (Envir-name env))
          (variable-defined? name (Envir-next env)) )
      #f ) )</p>

<p>(define (variable-value name env)
  (if (Envir? env)
      (if (eq? name (Envir-name env))
          (let ((value (Envir-value env)))
            (if (eq? value undefined)
                (error "Uninitialized variable" name)
                value ) )
          (variable-value name (Envir-next env)) )
      (env name) ) )</pre>

<p>Как видите, окружения — это связные списки, заканчивающиеся замыканием.
Теперь рефлексивный интерпретатор может быть запущен!</p>

<p>
% -- Глава 9 ------------------------</p>

<p>\exanswer{macros/ex:repeat}</p>

<p>Используйте гигиеничные макросы Scheme:</p>

<pre>(define-syntax repeat1
  (syntax-rules (:while :unless :do)
    ((_ :while p :unless q :do body ...)
     (let loop ()
       (if p (begin (if (not q) (begin body ...))
                    (loop) )) ) ) ) )</pre>

<p>\noindent
Как вариант, можно всё сделать вручную с помощью <code><span class="func">define-abbreviation</span></code>:</p>

<pre>(with-aliases ((+let let) (+begin begin) (+when when) (+not not))
  (define-abbreviation (repeat2 . params)
    (let ((p    (list-ref  params 1))
          (q    (list-ref  params 3))
          (body (list-tail params 5))
          (loop (gensym)) )
      `(,+let ,loop ()
          (,+when ,p (,+begin (,+when (,+not ,q) . ,body)
                              (,loop) )) ) ) ) )</pre>

<p>
\exanswer{macros/ex:arg-sequence}</p>

<p>Вся хитрость в том, как представить числа с помощью одних только
макроопределений. Один из вариантов — это использовать списки такой же длины,
что и представляемое ими число. Тогда во время исполнения программы можно будет
получить нормальные числа с помощью функции <code><span class="func">length</span></code>.</p>

<pre>(define-syntax enumerate
  (syntax-rules ()
    ((enumerate) (display 0))
    ((enumerate e1 e2 ...)
     (begin (display 0)
            (enumerate-aux e1 (e1) e2 ...) ) ) ) )</p>

<p>(define-syntax enumerate-aux
  (syntax-rules ()
    ((enumerate-aux e1 len) (begin (display e1)
                                   (display (length 'len)) ))
    ((enumerate-aux e1 len e2 e3 ...)
     (begin (display e1)
            (display (length 'len))
            (enumerate-aux e2 (e2 . len) e3 ...) ) ) ) )</pre>

<p>
\exanswer{macros/ex:unique}</p>

<p>Достаточно переопределить функцию <code><span class="func">make-macro-environment</span></code> так, чтобы она
использовала текущий уровень, а не создавала следующий:</p>

<pre>(define (make-macro-environment current-level)
  (let ((metalevel [(delay current-level)]))
    (list (make-Magic-Keyword 'eval-in-abbreviation-world
           (special-eval-in-abbreviation-world metalevel) )
          (make-Magic-Keyword 'define-abbreviation
           (special-define-abbreviation metalevel) )
          (make-Magic-Keyword 'let-abbreviation
           (special-let-abbreviation metalevel) )
          (make-Magic-Keyword 'with-aliases
           (special-with-aliases metalevel) ) ) ) )</pre>

<p>
\exanswer{macros/ex:decompile}</p>

<p>Написать такой конвертер проще пареной репы. Единственный интересный момент —
это сборка списка аргументов функции. Здесь используется А-список для хранения
соответствий между аргументами и их именами.</p>

<pre>(define-generic (->Scheme (e) r))</p>

<p>(define-method (->Scheme (e Alternative) r)
  `(if ,(->Scheme (Alternative-condition e) r)
       ,(->Scheme (Alternative-consequent e) r)
       ,(->Scheme (Alternative-alternant e) r) ) )</p>

<p>(define-method (->Scheme (e Local-Assignment) r)
  `(set! ,(->Scheme (Local-Assignment-reference e) r)
         ,(->Scheme (Local-Assignment-form e) r) ) )</p>

<p>(define-method (->Scheme (e Reference) r)
  (variable->Scheme (Reference-variable e) r) )</p>

<p>(define-method (->Scheme (e Function) r)
  (define (renamings-extend r variables names)
    (if (pair? names)
        (renamings-extend (cons (cons (car variables) (car names)) r)
                          (cdr variables) (cdr names) )
        r ) )
  (define (pack variables names)
    (if (pair? variables)
        (if (Local-Variable-dotted? (car variables))
            (car names)
            (cons (car names) (pack (cdr variables) (cdr names))) )
        '() ) )
  (let* ((variables (Function-variables e))
         (new-names (map (lambda (v) (gensym))
                         variables ))
         (newr (renamings-extend r variables new-names)) )
    `(lambda ,(pack variables new-names)
       ,(->Scheme (Function-body e) newr) ) ) )</p>

<p>(define-generic (variable->Scheme (e) r))</pre>

<p>
\exanswer{macros/ex:study}</p>

<p>В текущем состоянии {\Meroonet} действительно существует в двух мирах
одновременно. Например, функция <code><span class="func">register-class</span></code> вызывается как во время
раскрытия макросов, так и в процессе динамической загрузки файлов.</p>

<p>
% -- Глава 10 -----------------------</p>

<p>\exanswer{cc/ex:boost-calls}</p>

<p>Во-первых, доработайте функцию <code><span class="func">SCM\_invoke</span></code>: возьмите за основу протокол
вызова примитивов и сделайте подобную специализацию для замыканий. Во-вторых,
не забудьте передать замыкание самому себе в качестве первого аргумента.
В-третьих, специализируйте также кодогенераторы для замыканий, чтобы сигнатуры
соответствующих функций совпадали с тем, чего ожидает <code><span class="func">SCM\_invoke</span></code>.</p>

<p>
\exanswer{cc/ex:global-check}</p>

<p>Добавьте глобальным переменным флажок, показывающий их инициализированность.
Его начальное значение устанавливается в функции
<code><span class="func">objectify-free-global-reference</span></code>.</p>

<pre>(define-class Global-Variable Variable (initialized?))
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define (objectify-free-global-reference name r)
  (let ((v (make-Global-Variable name #f)))
    (insert-global! v r)
    (make-Global-Reference v) ) )</pre>

<p>Затем встройте анализ глобальных переменных в компилятор. Он будет выполняться
обходчиком кода с помощью обобщённой функции <code><span class="func">inian!</span></code>.</p>


<!--\indexC{inian"!}-->
<pre>(define (compile->C e out)
  (set! g.current '())
  (let ((prg (extract-things!
              (lift! (initialization-analyze! (Sexp->object e))) )))
    (gather-temporaries! (closurize-main! prg))
    (generate-C-program out e prg) ) )
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define (initialization-analyze! e)
  (call/cc (lambda (exit)
             (inian! e (lambda () (exit 'finished))) )) )
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define-generic (inian! (e) exit)
  (update-walk! inian! e exit) )</pre>

<p>Задачей этой функции будет выявить все глобальные переменные, которые
гарантированно получили значение до того, как это значение кому-то
потребовалось. Сложность выполнения данного анализа зависит от желаемого уровня
общности. Мы выберем простой путь и определим все глобальные переменные, которые
всегда инициализируются.</p>

<pre>(define-method (inian! (e Global-Assignment) exit)
  (call-next-method)
  (let ((gv (Global-Assignment-variable e)))
    (set-Global-Variable-initialized! gv #t)
    (inian-warning "Surely initialized variable" gv)
    e ) )
|\ForLayout{display}{\vskip-\baselineskip}|
(define-method (inian! (e Global-Reference) exit)
  (let ((gv (Global-Reference-variable e)))
    (cond ((Predefined-Variable? gv) e)
          ((Global-Variable-initialized? gv) e)
          (else (inian-error "Surely uninitialized variable" gv)
                (exit) ) ) ) )
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define-method (inian! (e Alternative) exit)
  (inian! (Alternative-condition e) exit)
  (exit) )
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define-method (inian! (e Application) exit)
  (call-next-method)
  (exit) )
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define-method (inian! (e Function) exit) e)</pre>

<p>Анализатор проходит по коду, находит все присваивания глобальным переменным и
останавливается, когда программа становится слишком сложной; то есть когда он
встречает ветвление или вызов функции. Кстати, <code><span class="func">lambda</span></code>-формы не являются
«слишком сложным кодом», так как они всегда безошибочно вычисляются за
конечное время и не трогают глобальные переменные.</p>

<p>
% -- Глава 11 -----------------------</p>

<p>\exanswer{objects/ex:precise-predicate}</p>


<!--\indexC{Object"?}-->
<p>Предикат <code><span class="func">Object?</span></code> можно улучшить, добавив в векторы, которыми представляются
объекты, ещё одно поле, хранящее уникальную метку. Соответственно, также
потребуется изменить аллокаторы, чтобы они заполняли это поле во всех
создаваемых объектах. (И не забыть добавить его в примитивные классы, которые
определяются вручную.)</p>

<pre>(define *starting-offset* 2)
(define meroonet-tag (cons 'meroonet 'tag))
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define (Object? o)
  (and (vector? o)
       (>= (vector-length o) *starting-offset*)
       (eq? (vector-ref o 1) meroonet-tag) ) )</pre>

<p>При таком подходе предикат <code><span class="func">Object?</span></code> будет меньше ошибаться, но ценой этого
является некоторая потеря быстродействия. Однако, его всё равно можно обмануть,
ведь не мешает пользователю извлечь метку из любого объекта с помощью
<code><span class="func">vector-ref</span></code> и вставить её в какой-нибудь другой вектор.</p>

<p>
\exanswer{objects/ex:clone}</p>


<!--\indexC{clone}-->
<p>Так как это обобщённая функция, то её можно специализировать для конкретных
классов. Универсальная реализация слишком уж неэффективно расходует память:</p>

<pre>(define-generic (clone (o))
  (list->vector (vector->list o)) )</pre>

<p>
\exanswer{objects/ex:metaclass}</p>

<p>Определите новый класс классов: метакласс <code><span class="func">CountingClass</span></code>, у которого есть
поле для подсчёта создаваемых объектов.</p>

<pre>(define-class CountingClass Class (counter))</pre>

<p>К счастью, {\Meroonet} написана так, что для её расширения не требуется изменять
половину существующих определений. Новый метакласс можно определить как-то так:</p>

<pre>(define-meroonet-macro (define-CountingClass name super-name
                                             own-fields )
  (let ((class (register-CountingClass name super-name own-fields)))
    (generate-related-names class) ) )</p>

<p>(define (register-CountingClass name super-name own-fields)
  (CountingClass-initialize! (allocate-CountingClass)
                             name
                             (->Class super-name)
                             own-fields ) )</pre>

<p>Однако более правильным решением будет расширить синтаксис формы
<code><span class="func">define-class</span></code> так, чтобы она принимала тип создаваемого класса (по умолчанию
<code><span class="func">Class</span></code>). При этом потребуется сделать некоторые функции обобщёнными:</p>

<pre>(define-generic (generate-related-names (class)))</p>

<p>(define-method (generate-related-names (class Class))
  (Class-generate-related-names class) )</p>

<p>(define-generic (initialize! (o) . args))</p>

<p>(define-method (initialize! (o Class) . args)
  (apply Class-initialize o args) )</p>

<p>(define-method (initialize! (o CountingClass) . args)
  (set-CountingClass-counter! class 0)
  (call-next-method) )</pre>

<p>Обновлять значение поля <code><span class="func">counter</span></code> будут, конечно же, аллокаторы нового
метакласса:</p>

<pre>(define-method (generate-related-names (class CountingClass))
  (let* ((cname      (symbol-concatenate (Class-name class) '-class))
         (alloc-name (symbol-concatenate 'allocate- (Class-name class)))
         (make-name  (symbol-concatenate 'make- (Class-name class))) )
    `(begin ,(call-next-method)
            (set! ,alloc-name                 ; аллокатор
                  (let ((old ,alloc-name))
                    (lambda sizes
                      (set-CountingClass-counter! ,cname
                       (+ 1 (CountingClass-counter ,cname)) )
                      (apply old sizes) ) ) )
            (set! ,make-name                  ; конструктор
                  (let ((old ,make-name))
                    (lambda args
                      (set-CountingClass-counter! ,cname
                       (+ 1 (CountingClass-counter ,cname)) )
                      (apply old args) ) ) ) ) ) )</pre>

<p>В качестве заключения рассмотрим пример использования данного метакласса:</p>

<pre>(define-CountingClass CountedPoint Object (x y))</p>

<p>(unless (and (= 0 (CountingClass-counter CountedPoint-class))
             (allocate-CountedPoint)
             (= 1 (CountingClass-counter CountedPoint-class))
             (make-CountedPoint 11 22)
             (= 2 (CountingClass-counter CountedPoint-class)) )
  ;; не выполнится, если всё в порядке
  (meroonet-error "Failed test on CountedPoint") )</pre>

<p>
\exanswer{objects/ex:field-reflection}</p>

<p>Определите метакласс <code><span class="func">ReflectiveClass</span></code>, обладающий дополнительными полями:
<code><span class="func">predicate</span></code>, <code><span class="func">allocator</span></code> и <code><span class="func">maker</span></code>. Затем измените определение
генератора сопутствующих функций, чтобы он заполнял эти поля при создании
экземпляра класса. Аналогичные действия необходимо выполнить для классов полей
(наследников <code><span class="func">Field</span></code>).</p>

<pre>(define-class ReflectiveClass Class (predicate allocator maker))</p>

<p>(define-method (generate-related-names (class ReflectiveClass))
  (let ((cname      (symbol-concatenate (Class-name class) '-class))
        (pred-name  (symbol-concatenate (Class-name) '?))
        (alloc-name (symbol-concatenate 'allocate- (Class-name class)))
        (make-name  (symbol-concatenate 'make- (Class-name class))) )
    `(begin ,(call-next-method)
            (set-ReflectiveClass-predicate! ,cname ,pred-name)
            (set-ReflectiveClass-allocator! ,cname ,alloc-name)
            (set-ReflectiveClass-maker!     ,cname ,make-name) ) ) )</pre>

<p>
\exanswer{objects/ex:auto-generic}</p>

<p>Главная сложность здесь в том, как узнать, существует ли уже обобщённая
функция или нет. В Scheme нельзя определить, существует или нет глобальная
переменная, поэтому придётся искать имя функции в списке <code><span class="func">*generics*</span></code>.</p>

<pre>(define-meroonet-macro (define-method call . body)
  (parse-variable-specifications
   (cdr call)
   (lambda (discriminant variables)
     (let ((g (gensym)) (c (gensym)))
       `(begin
          [(unless (->Generic ',(car call))
            (define-generic ,call) )]
          (register-method
           ',(car call)
           (lambda (,g ,c)
             (lambda ,(flat-variables variables)
               (define (call-next-method)
                 ((if (Class-superclass ,c)
                      (vector-ref (Generic-dispatch-table ,g)
                                  (Class-number (Class-superclass ,c)) )
                      (Generic-default ,g) )
                  . ,(flat-variables variables) ) )
               . ,body ) )
           ',(cadr discriminant)
           ',(cdr call) ) ) ) ) ) )</pre>

<p>
\exanswer{objects/ex:next-method}</p>

<p>Просто добавьте в определение каждого метода пару локальных функций
<code><span class="func">call-next-method</span></code> и <code><span class="func">next-method?</span></code>. Несомненно, было бы лучше сделать
так, чтобы эти функции создавались только тогда, когда они действительно
используются, но это реализовать сложнее.</p>

<pre>(define-meroonet-macro (define-method call . body)
  (parse-variable-specifications
   (cdr call)
   (lambda (discriminant variables)
     (let ((g (gensym)) (c (gensym)))
       `(register-method
         ',(car call)
         (lambda (,g ,c)
           (lambda ,(flat-variables variables)
             [,@(generate-next-method-functions g c variables)]
             . ,body ) )
         ',(cadr discriminant)
         ',(cdr call) ) ) ) ) )</pre>

<p>Функция <code><span class="func">next-method?</span></code> похожа на <code><span class="func">call-next-method</span></code>, но она только ищет
суперметод, не вызывая его.</p>

<pre>(define (generate-next-method-functions g c variables)
  (let ((get-next-method (gensym)))
    `((define (,get-next-method)
        (if (Class-superclass ,c)
            (vector-ref (Generic-dispatch-table ,g)
                        (Class-number (Class-superclass ,c)) )
            (Generic-default ,g) ) )
      (define (call-next-method)
        ((,get-next-method) . ,(flat-variables variables)) )
      (define (next-method?)
        (not (eq? (,get-next-method) (Generic-default ,g))) ) ) ) )</pre>

<p></body>
</html>
