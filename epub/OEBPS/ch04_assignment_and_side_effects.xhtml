<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru"></p>

<p><body>
\chapter{Присваивание и побочные эффекты}\label{chapter:assignment}</p>

<p>\initial{0.25ex}{0.0ex}{П}{\kern0.65ex редыдущие главы} с их нескончаемыми
повторениями и вариациями чем-то напоминают «Болеро» Мориса Равеля. Но один
мотив, как вы могли заметить, в них отсутствовал: присваивание и побочные
эффекты. Чистые языки их презирают из-за некоторых скверных особенностей, но
поскольку в диалектах Лиспа их существование допускается, нам следует их
изучить. В этой главе подробно рассматривается присваивание, а также прочие
побочные эффекты. По мере нашего продвижения мы также будем вынуждены
отвлекаться на смежные темы вроде равенства и семантики цитирования.</p>

<div class="bigskip"/>


<!--\indexR{присваивание}-->
<p>Присваивание, пришедшее из традиционных алгоритмических языков, позволяет
в той или иной мере изменить значение, связанное с переменной. Это приводит
к необходимости сохранять состояние программы (в том или ином виде), где будет
записано, что такая-то переменная отныне имеет следующее значение. Для свободно
владеющих императивными языками смысл присваивания кажется простым и очевидным.
В этой главе мы покажем, как замыкания, а также наследие λ-исчисления,
усложняют понятия связывания и переменных.</p>

<p>Главная проблема с присваиванием (и побочными эффектами) состоит в том, чтобы
выбрать для их описания формальную теорию, которая не зависит от описываемых
свойств. То есть определить язык с присваиванием и побочными эффектами,
не используя для этого присваивание и побочные эффекты. Не то, чтобы мы их до
этого использовали повсюду; единственные побочные эффекты в наших предыдущих
интерпретаторах были сосредоточены в функции <code><span class="func">update!</span></code> (естественно, для
определения присваивания) и в определениях «хирургических инструментов» вроде
<code><span class="func">set-car!</span></code>, которые являлись лишь обёртками для родных функций языка
определения.</p>

<h2 id="assignment/sect:assignment">Присваивание</h2>

<p>Присваивание, как мы сказали, позволяет изменить значение переменной. Например,
давайте напишем программу для определения минимального и максимального элемента
в двоичном дереве, используя две переменные для хранения наименьшего и
наибольшего элемента из уже просмотренных. Мы получим что-то вроде следующего:</p>


<!--\indexC{min-max}-->
<p>\begin{code:lisp}
(define (min-max tree)
  (define (first-number tree)
    (if (pair? tree)
        (first-number (car tree))
        tree ) )
  (let* ((min (first-number tree))
         (max min) )
    (define (scan! tree)
      (cond ((pair? tree)
             (scan! (car tree))
             (scan! (cdr tree)) )
            (else (if (> tree max) (set! max tree)
                      (if (< tree min) (set! min tree)) )) ) )
    (scan! tree)
    (list min max) ) )
\end{code:lisp}</p>


<!--\indexR{побочные эффекты!доброкачественные}-->
<p>Функция <code><span class="func">min-max</span></code> проста для понимания и требует лишь два числа и две
точечные пары для работы. Алгоритм не особо отличается от того, который бы
получился на Паскале, и использует переменные точно так же, как они используются
в императивных языках. Но, что важно, побочные эффекты изменения значений этих
локальных переменных не видны снаружи функции <code><span class="func">min-max</span></code>, то есть не влияют
на остальные части программы. Это пример доброкачественных побочных эффектов:
программа становится более понятной и эффективной, чем написанная в чисто
функциональном стиле. \seeEx[assignment/ex:pure-min-max]</p>

<p>Присваивание локальным переменным, которые не используются совместно несколькими
функциями, не вызывает существенных проблем. Например, следующая функция
последовательно возвращает натуральные числа, начиная с нуля. Очевидно, что
значением переменной <code><span class="func">n</span></code> сразу после присваивания является только что
присвоенное значение.</p>

<p>\begin{code:lisp}
(define enumerate
  (let ((n -1))
    (lambda () (set! n (+ n 1))
               n ) ) )
\end{code:lisp}</p>


<!--\indexR{присваивание!и семантика подстановки}-->
<!--\indexR{семантика!подстановки}-->
<p>Каждый вызов <code><span class="func">enumerate</span></code> возвращает новое натуральное число. Функция
<code><span class="func">enumerate</span></code> имеет внутреннее состояние, представляемое переменной <code><span class="func">n</span></code>,
которая изменяется с каждым следующим вызовом функции. Но то, что <code><span class="func">n</span></code>
принадлежит замыканию, является проблемой. В λ-исчислении нет ни слова
о присваивании. Ведь когда мы применяем функцию в математике (и, соответственно,
в λ-исчислении), то просто заменяем в её теле все переменные
соответствующими значениями аргументов. Из-за присваивания данная семантика
подстановки становится неверной, а программы теряют ссылочную прозрачность.</p>

<p>Если подставить вместе переменной <code><span class="func">n</span></code> её начальное значение в <code><span class="func">enumerate</span></code>,
то эта функция возвращала бы не натуральные числа, а исключительно <code><span class="func">-1</span></code>.
Таким образом, присваивание вынуждает нас отказаться от модели вычислений
с мгновенной подстановкой значений. Теперь подстановка является отложенной и
выполняется только тогда, когда мы явно потребуем значение. Соответственно,
определённым образом расставленные присваивания могут изменить это значение до
подстановки.</p>

<p>Но с расположением присваиваний есть свои проблемы. Рассмотрим следующую
программу:</p>

<p>\begin{code:lisp}
(let ((name "Nemo"))
  (set! winner (lambda () name))
  (set! set-winner! (lambda (new-name) (set! name new-name)
                                       name ))
  (set!-winner "Me")
  (winner) )
\end{code:lisp}</p>


<!--\indexR{присваивание!и замыкания}-->
<p>Что же вернёт <code><span class="func">(winner)</span></code>: <code><span class="func">"Nemo"</span></code> или <code><span class="func">"Me"</span></code>? Другими словами,
влияет ли присваивание внутри <code><span class="func">set-winner!</span></code> на значение, возвращаемое
<code><span class="func">winner</span></code>?</p>

<p>И снова λ-исчисление хранит молчание. У него есть причины быть
немногословным: ведь присваивание чуждо ему. Ладно, мы вроде бы говорили, что
создание функции захватывает окружение определения; значит, функции <code><span class="func">winner</span></code>
и <code><span class="func">set!-winner</span></code> по крайней мере знают, что в момент их создания переменная
<code><span class="func">name</span></code> имела значение <code><span class="func">"Nemo"</span></code>. Также кажется очевидным, что
<code><span class="func">(set-winner! "Me")</span></code> вернёт <code><span class="func">"Me"</span></code>, так как там чёрным по белому написано,
что мы изменяем значение переменной <code><span class="func">name</span></code> на другое и возвращаем её текущее
значение. Проблема в том, а видит ли <code><span class="func">winner</span></code> это значение? Ведь мы изменяем
значение той же переменной <code><span class="func">name</span></code>, правда?</p>

<p>Буквальное понимание идеи замыкания приводит к мысли, что у каждого замыкания
хранятся личные копии свободных переменных со значениями, которые они имели на
момент создания замыкания. В таком случае предыдущая программа эквивалентна
следующей:</p>

<p>\begin{code:lisp}
(let ((name "Nemo"))
  (set! winner (lambda () name))
  (winner) )
\end{code:lisp}</p>

<p>В <span class="cite">[<a href="z1_bibliography.xhtml#sam79">sam79</a>]</span> предлагается считать эффекты присваиваний видимыми только тем,
кто это присваивание совершил. Тогда действительно <code><span class="func">set-winner!</span></code> вернёт новое
значение, а <code><span class="func">winner</span></code> всегда будет возвращать <code><span class="func">"Nemo"</span></code>. В таком мире
не существует привязок. Нет, конечно у переменных есть значения, но они намертво
установлены окружением. Если кому-то нужно значение переменной, то он может
запросить его у окружения. Если же это значение надо изменить, то просто взамен
старого окружения создаётся новое, где переменная имеет нужное значение.</p>


<!--\indexC{closure}-->
<!--\indexR{специальные формы!closure@\protect<code><span class="func">closure</span></code>}-->
<p>\phantomlabel{assignement/assignement/para:closure}
Такая точка зрения напоминает способ реализации замыканий в старых,
исключительно динамических диалектах Лиспа. Там замыкания создавались явным
использованием специальной формы <code><span class="func">closure</span></code>; она принимала первым аргументом
список переменных, которые надо сохранить, а вторым аргументом следовала
функция. В результате вызов <code><span class="func">(closure (x) (lambda (y) (+ x y)))</span></code> раскрывался
в \ic{(lambda (y) (let ((x '\ii{значение-<code><span class="func">x</span></code>})) (+ x y)))}. С одной стороны,
значение действительно захватывается, а с другой — всё укладывается
в парадигму подстановки, унаследованную от λ-исчисления.</p>

<p>Но данная модель вычислений значительно усложняет как присваивание, так
и совместное использование переменных. Возможны и другие варианты решения этой
проблемы; в <span class="cite">[<a href="z1_bibliography.xhtml#sj87">sj87</a>]</span> предлагается научить форму <code><span class="func">closure</span></code> самостоятельно
искать выделять свободные переменные в функции. Также, как предлагается
в \cite{bcsj86,sj93}, она может определённым образом модифицировать найденные
присваивания, чтобы избежать неудобств с присваиванием свободным переменным.</p>


<!--\indexR{привязки (bindings)}-->
<!--\indexR{объекты!второго класса}-->
<p>Scheme решает проблему иным путём, вводя понятие <em class="term">привязок</em>, что также
приводит к интересным <em>побочным эффектам</em>. Форма <code><span class="func">let</span></code> привязывает
к переменной <code><span class="func">name</span></code> значение <code><span class="func">"Nemo"</span></code>. Замыкания, создаваемые в теле
<code><span class="func">let</span></code>, захватывают не значение переменной <code><span class="func">name</span></code>, а её привязку. Таким
образом, ссылка на переменную <code><span class="func">name</span></code> вызывает поиск соответствующей привязки
с последующим извлечением значения из неё.</p>

<p>Присваивание действует аналогично: сначала ищется привязка, затем изменяется
хранимое значение. В таком случае привязки являются объектами второго класса,
которые не существуют отдельно от своих переменных. Присваивание переменной
изменяет не саму привязку, а значение, на которое она указывает.</p>

<h3 id="assignment/assignment/ssect:boxes">Коробки</h3>


<!--\indexR{коробки}-->
<p>Чтобы конкретизировать понятие привязок, давайте обратим внимание на А-списки.
В предыдущих интерпретаторах А-списки использовались для представления
окружений, их задачей было организовать для нас множество пар «переменная —
значение». Они представляются точечными парами. Когда нам требуется переменная,
мы ищем соответствующую точечную пару. В случае присваивания эта пара (точнее,
её <code><span class="func">cdr</span></code>) изменяет своё значение. Поэтому в данном случае именно точечные
пары являются воплощением привязок. Но это не единственный способ их
представления; например, привязки можно представлять с помощью <em class="term">коробок</em>
(boxes, также известны как cells). Новый уровень абстракции имеет большое
значение, так как мы полностью избавляемся от присваивания переменным, заменяя
его побочными эффектами операций над привязками.</p>

<p>Значение упаковывается в коробку с помощью функции <code><span class="func">make-box</span></code>. Можно
взглянуть на то, что в коробке, с помощью <code><span class="func">box-ref</span></code> и положить в неё
что-то другое с помощью <code><span class="func">box-set!</span></code>. Набросаем реализацию коробок в стиле
передачи сообщений:</p>


<!--\indexC{make-box}-->
<!--\indexC{box-ref}-->
<!--\indexC{box-set"!}-->
<p>\begin{code:lisp}
(define (make-box value)
  (lambda (msg)
    (case msg
      ((get) value)
      ((set!) (lambda (new-value) (set! value new-value))) ) ) )</p>

<p>(define (box-ref box)
  (box 'get) )</p>

<p>(define (box-set! box new-value)
  ((box 'set) new-value) )
\end{code:lisp}</p>

<p>Можно было бы реализовать их и без замыкания, используя точечные пары напрямую:</p>

<p>\begin{code:lisp}
(define (other-make-box value)
  (cons 'box value) )</p>

<p>(define (other-box-ref box)
  (cdr box) )</p>

<p>(define (other-box-set! box new-value)
  (set-cdr! box new-value) )
\end{code:lisp}</p>

<p>Или вообще создать класс:</p>

<p>\begin{code:lisp}
(define-class box Object (content))
\end{code:lisp}</p>


<!--\indexR{коробки!и изменяемость переменных}-->
<p>Во всех трёх случаях (даже четырёх, если считать
упражнение \ref{escape/ex:crazy-cc}) мы явно указываем на неопределённость
возвращаемого значения вызова <code><span class="func">set-box!</span></code>. Каждую переменную, значение которой
способно изменяться в процессе вычислений, можно представить как абстрактную
коробку, сосредотачивая таким образом все побочные эффекты в реализации этих
коробок. Заодно мы приобретаем возможность определить, изменяема ли переменная;
для этого достаточно посмотреть на определяющую её связывающую форму и
убедиться, что переменная упакована в коробку. (Это одна из заманчивых
возможностей лексических окружений: чёткое определение области видимости
переменных.)</p>

<p>\begin{center}%
\let\b\boxit \def\bc#1{\b{<code><span class="func">#1</span></code>}}%
\def\P{$\pi$}\def\p#1{$\pi_{#1}$}%
\def\EQ{$\:\Rightarrow\:$}%
\setlength{\tabcolsep}{2pt}%
\begin{tabular}{rcl}
                       \b{$x$} & \EQ & если $x = v$,
                                       то <code><span class="func">(box-ref $v$)</span></code>,
                                       иначе $x$                              \\
       \bc{(quote $\epsilon$)} & \EQ & <code><span class="func">(quote $\epsilon$)</span></code>                \\
   \bc{(if \p{c} \p{t} \p{f})} & \EQ & \ic{(if \b{\p{c}} \b{\p{t}} \b{\p{f}})}\\
  \bc{(begin \p{1} ... \p{n})} & \EQ & \ic{(begin \b{\p{1}} ... \b{\p{n}})}   \\
            \bc{(set! $x$ \P)} & \EQ & если $x = v$,
                                       то <code><span class="func">(box-set! $v$ \b\P)</span></code>,           \\
                               &     & иначе <code><span class="func">(set! $x$ \b\P)</span></code>             \\
\bc{(lambda (... $x$ ...) \P)} & \EQ & если $v \in \{{\dots}\,\ x\ \dots\}$,  \\
                               &     & то <code><span class="func">(lambda (... $x$ ...) \P)</span></code>,     \\
                               &     & иначе <code><span class="func">(lambda (... $x$ ...) \b\P)</span></code> \\
  \bc{(\p{0} \p{1} ... \p{n})} & \EQ & \ic{(\b{\p{0}} \b{\p{1}} ... \b{\p{n}})}
\end{tabular}\label{assignment/assignment/boxes/p:boxing}\end{center}</p>


<!--\indexR{преобразование!в коробочный стиль}-->
<!--\indexR{коробки!преобразование}-->
<p>В приведённой выше таблице собраны правила перевода программ
в «коробочный стиль». Запись \boxit{$\pi$} означает, что переменная $v$
в программе $\pi$ помещается в коробку. Как обычно, за именами переменных важно
тщательно следить, чтобы не случилось коллизий.</p>

<p>Остаётся ввести ещё одно правило для собственно раскладывания по коробкам
изменяемых переменных, чтобы полностью избавиться от присваиваний, заменив их
побочными эффектами:</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>

<p>{\def\x{$x$}\def\p{$\pi$}
\begin{code:lisp}
(lambda (... |\x| ...) |\p|) |$\land$| (set! |\x| ...)|${} \in \pi$|
|\is| (lambda (... |\x| ...) (let ((|\x| (make-box |\x|))) |\boxit[x]{\p}|))
\end{code:lisp}}</p>

<p>\noindent
В результате, предыдущий пример переписывается следующим образом:</p>

<p>\begin{code:lisp}
(let ((name (make-box "Nemo")))
  (set! winner (lambda () (box-ref name)))
  (set! set-winner! (lambda (new-name) (box-set! name new-name)
                                       (box-ref name) ))
  (set-winner! "Me") (winner) )
\end{code:lisp}</p>

<p>\ForLayout{display}{\endgroup}</p>


<!--\indexR{коробки!аналогии}-->
<!--\indexR{присваивание!семантика коробок}-->
<!--\indexR{коробки!недостатки}-->
<!--\indexR{ссылочная прозрачность}-->
<p>Именно коробки обычно используются, когда в функцию надо передать изменяемую
переменную; они фактически соответствуют ссылкам и указателям из иных языков.
Коробки убирают из языка присваивания переменным и сопутствующие неоднозначности
трактовки имени переменной: считать его ссылкой на переменную или же подставить
вместо него значение. Благодаря коробкам не требуется введение специальных
случаев при поиске значений переменных, так как <em>переменные</em> не могут быть
изменены — если надо, то изменяется содержимое коробок, на которые эти
переменные ссылаются. Конечно, изменение значения коробок требует побочных
эффектов, так что ссылочная прозрачность всё так же остаётся утерянной. Тем
не менее, это не мешает ввести систему типов содержимого коробок. С другой
стороны, их использование вызывает свои специфичные проблемы.</p>


<!--\indexR{привязки (bindings)!как полноценные объекты}-->
<!--\indexR{полноценные объекты!привязки}-->
<p>Во-первых, привязки теперь становятся полноценными объектами, а значит, их
можно передавать не только в <code><span class="func">box-ref</span></code> и <code><span class="func">box-set!</span></code>. Например, можно
скопировать привязку и дать ей альтернативное имя; это может быть и полезным,
например, при создании модулей.</p>

<p>Во-вторых, мы никак не можем контролировать использование коробок. Переменные
теперь можно изменять в общем случае где угодно, передав копию коробки под
другим именем. С лексическим присваиванием такой трюк не работает: для изменения
значения переменной необходимо статически указать её правильное имя. Это,
естественно, очень удобно для компилятора, так как он сразу же может понять,
существует ли эта переменная вообще, является ли она свободной, известно ли
о ней где-либо ещё; все это позволяет компилятору генерировать более эффективный
код.</p>

<p>Также не стоит забывать, что в физическом компьютере каждая переменная связана
со своим положением в памяти (адресом), где хранится её значение. При
присваивании изменяется не сама переменная (не её адрес), а именно расположенное
в памяти значение.</p>

<p>
\subsection{Присваивание свободным переменным}%
\label{assignment/assignment/ssect:free-vars}</p>

<p>Следующая проблема с присваиванием касается свободных переменных: какой смысл
оно имеет для них. Рассмотрим пример:</p>

<p>\begin{code:lisp}
(let ((passwd "timhukiTrolrk"))  ; Это реальный пароль!
  (set! can-access? (lambda (pw) (string=? password (crypt pw)))) )
\end{code:lisp}</p>

<p>Переменная <code><span class="func">can-access?</span></code> является свободной для этой формы. Более того, ей
присваивается значение. По правилам Scheme <code><span class="func">can-access?</span></code> должна быть
глобальной, так как её нет в локальных связывающих формах. Но ведь то, что она
<em>должна</em> быть где-то в глобальном окружении, вовсе не означает, что она
там есть! Что делать в таком случае? Мы уже разговаривали на эту тему
\seePage[lisp1-2-omega/recusion/simple/code:redefine], рассмотрев при этом
несколько вариантов поведения.</p>

<p>Что ещё можно делать с глобальной переменной, кроме присваивания? То же, что и
с любой другой: ссылаться на неё, захватывать в замыканиях, получать её
значение, определять перед использованием. Глобальное окружение переменных тоже
является пространством имён со своими правилами, так что давайте рассмотрим
подробнее различные варианты его реализации.</p>

<p>
\subsubsection{Всеобъемлющее глобальное окружение}%
\label{assignment/assignment/free-vars/sssect:universal}</p>


<!--\indexR{глобальное окружение!всеобъемлющее}-->
<!--\indexR{окружение!глобальное!всеобъемлющее}-->
<!--\indexR{всеобъемлющее окружение}-->
<p>Можно определить глобальное окружение как место, где все переменные
предварительно объявлены. Естественно, в действительности они объявляются
непосредственно перед первым использованием, но делается это незаметно и
автоматически <span class="cite">[<a href="z1_bibliography.xhtml#que95">que95</a>]</span>. В таком мире с каждым именем связана одна и только
одна переменная. Определение переменной здесь не имеет смысла, они все уже
определены. Изменение переменной тоже не вызывает проблем: мы уверены, что
изменяемая переменная существует. Соответственно, форма <code><span class="func">define</span></code> фактически
эквивалентна <code><span class="func">set!</span></code> и, как следствие, можно безболезненно «определять»
переменную несколько раз.</p>

<p>Единственная проблема возникает тогда, когда мы хотим получить значение
переменной, но этой переменной никогда не присваивали значения. Переменная есть,
но у неё нет значения. Часто результатом такой операции является сообщение
о «неопределённой переменной», но в данном случае формально она определена,
так что будет правильнее отвечать про «неинициализированную переменную».</p>

<p>Свойства данного окружения можно компактно представить следующей таблицей:</p>

<p>\begin{envtable}
Ссылка      & \ii{x}                                   \\
Значение    & \ii{x}                                   \\
Изменение   & \ic{(set! \ii{x} ...)}                   \\
Расширение  & запрещено                                \\
Определение & отсутствует, <code><span class="func">define</span></code> {\eq} <code><span class="func">set!</span></code> \\
\end{envtable}</p>

<p>Такой вариант окружения по-своему интересен: из-за того, что всё определено,
уходят многие проблемы. Взаимно рекурсивные функции всегда смогут добраться друг
до друга. Переопределить можно всё, что угодно. Но именно эти свойства являются
источником других потенциальных проблем; с глобальными переменными надо быть
осторожным, так как 1) они могут быть ещё не определены (но отобрать однажды
данное значение уже нельзя); 2) их значение может меняться, а это значит, что на
их текущее значение можно полагаться только в текущий момент. В частности, это
отбирает у нас инлайн-функции, ведь в случае изменения значений переменных
<code><span class="func">car</span></code> или <code><span class="func">cons</span></code> по идее придётся перекомпилировать всё, что их
использовало до этого, что ставит под вопрос оправданность такого рода
«оптимизаций».</p>

<p>Наконец, рассмотрим пример поведения переменных в данном окружении:</p>

<p>\begin{code:lisp}
g                      ; ошибка: <code><span class="func">g</span></code> не инициализирована
(define (P m) (* m g))
(define g 10)
(define g 9.81)        ; {\equals} <code><span class="func">(set! g 9.81)</span></code>
(P 10)       |\is| 98.1
(set! e 2.78)          ; определение <code><span class="func">e</span></code>
\end{code:lisp}</p>

<p>Короче говоря, такое глобальное окружение можно рассматривать как гигантскую
форму <code><span class="func">let</span></code>, определяющую все возможные переменные:</p>

<p>\begin{code:lisp}
(let (... a aa ... ab ... ac ...) |\ii{программа}|...)
\end{code:lisp}</p>

<p>
\subsubsection{Фиксированное глобальное окружение}%
\label{assignment/assignment/free-vars/sssect:frozen}</p>


<!--\indexR{глобальное окружение!фиксированное}-->
<!--\indexR{окружение!глобальное!фиксированное}-->
<!--\indexR{фиксированное окружение}-->
<p>Теперь представим, что с каждым именем связано не более одной глобальной
переменной и перечень определённых переменных является неизменяемым. Такая
ситуация возникает в скомпилированной программе без динамически генерируемого
кода (без вызовов <code><span class="func">eval</span></code>). Также, именно такое поведение было у всех наших
предыдущих интерпретаторов: мы не можем создавать глобальные переменные
в определяемом языке, все необходимые переменные создавались заранее с помощью
формы <code><span class="func">definitial</span></code> языка определения.</p>

<p>В таком окружении переменная существует только после явного создания с помощью
<code><span class="func">define</span></code>. Её значение можно считывать и изменять только после того, как
переменная была определена. Тем не менее, существование не более одной
переменной с уникальным именем всё же позволяет ссылаться на ещё не определённую
переменную. (Это необходимое условие для взаимной рекурсии.) Естественно, больше
одного раза определить глобальную переменную нельзя. В итоге, подобное окружение
обладает следующими свойствами:</p>

<p>\begin{envtable}
Ссылка      & \ii{x}                                                \\
Значение    & \ii{x}, но \ii{x} должна существовать                 \\
Изменение   & \ic{(set! \ii{x} ...)}, но \ii{x} должна существовать \\
Расширение  & <code><span class="func">define</span></code> (единожды)                                \\
Определение & запрещено                                             \\
\end{envtable}</p>

<p>Теперь попробуем запустить предыдущий пример в новом окружении:</p>

<p>\begin{code:lisp}
g                      ; ошибка: неизвестная переменная <code><span class="func">g</span></code>
(define (P m) (* m g)) ; опережающая ссылка на <code><span class="func">g</span></code>
(define g 10)
(define g 9.81)        ; ошибка: переопределение <code><span class="func">g</span></code>
(set! g 9.81)          ; изменение <code><span class="func">g</span></code>
(P 10)       |\is| 98.1
(set! e 2.78)          ; ошибка: неизвестная переменная <code><span class="func">e</span></code>
\end{code:lisp}</p>

<p>После этого легко сообразить, как перенести обычные программы в такое окружение.
Вся программа представляется последовательностью выражений $\pi_1\dots\pi_n$.
Она преобразуется в одно большое выражение следующим образом: проводится анализ
выражений $\pi_1\dots\pi_n$ для выделения всех свободных переменных; сами
выражения помещаются в тело <code><span class="func">let</span></code>-формы, которая определяет все свободные
переменные как неинициализированные локальные переменные; наконец, все
<code><span class="func">define</span></code>-формы заменяются эквивалентными <code><span class="func">set!</span></code>-формами.</p>

<p>Для пояснения рассмотрим следующую программу на Scheme:</p>

<p>\begin{code:lisp}
(define (crypt pw) ...)</p>

<p>(let ((passwd "timhukiTrolrk"))
  (set! can-access? (lambda (pw) (string=? passwd (crypt pw)))) )</p>

<p>(define (gatekeeper)
  (until (can-access? (read))
         (gatekeeper) ) )
\end{code:lisp}</p>

<p>Эта небольшая программка спрашивает у пользователя пароль и не отпускает его,
пока он не ответит правильно. Этот кибер-Цербер в новом окружении выглядит
вот так:</p>

<p>\begin{code:lisp}
(let (crypt make-can-access? can-access? gatekeeper)
  (set! crypt (lambda (pw) ...))
  (set! make-can-acceess?
        (lambda (passwd)
          (lambda (pw) (string?= passwd (crypt pw))) ) )
  (set! can-access? (make-can-access? "timhukiTrolrk"))
  (set! gatekeeper
        (lambda () (until (can-access? (read)) (gatekeeper))) )
  (gatekeeper) )|\begin{where}
                 \- car {\eq} car
                 \- cons {\eq} cons
                 \- ...
                 \end{where}|
\end{code:lisp}</p>

<p>Глобальные определения заменяются локальными переменными, которые остаются
неинициализированными до соответствующей <code><span class="func">define</span></code>-формы.%
\footnote*{К сожалению, непреднамеренно так вышло, что повторное определение
переменной сейчас имеет смысл. Для точного соответствия необходимо будет внести
коррективы в процедуру преобразования <code><span class="func">define</span></code> в <code><span class="func">set!</span></code> во избежание
переопределения переменных.} Конечно, встроенные функции вроде <code><span class="func">read</span></code>,
<code><span class="func">string=?</span></code> или <code><span class="func">string-append</span></code> всё так же остаются видимыми. В этом мире
глобальное окружение конечно и ограничено предопределёнными функциями (вроде
<code><span class="func">car</span></code> и <code><span class="func">cons</span></code>), а также свободными переменными наших программ.
Присваивания глобальным переменным, не являющимся свободными, запрещены —
свободных переменных, не присутствующих в глобальном окружении, быть не может
по определению нашего преобразования. Единственный способ вызвать данную ошибку
— это динамическое исполнение кода с помощью <code><span class="func">eval</span></code>.</p>

<p>
\subsubsection{Автоматически расширяемое глобальное окружение}%
\label{assignment/assignment/free-vars/sssect:auto-extended}</p>


<!--\indexR{глобальное окружение!автоматически расширяемое}-->
<!--\indexR{окружение!глобальное!автоматически расширяемое}-->
<!--\indexR{автоматически расширяемое окружение}-->
<p>Если мы хотим создать REPL для своего языка, то нам необходима возможность
динамического добавления переменных в глобальное окружение. Обычно это делается
с помощью специальной формы <code><span class="func">define</span></code>. Но можно сделать всё проще, используя
лишь присваивание: если переменная не существует, то присваивание ей определяет
её. В таком случае можно было бы писать просто:</p>

<p>\begin{code:lisp}
(let ((name "Nemo"))
  (set! winner (lambda () name))
  (set! set-winner! (lambda (new-name) (set! name new-name)
                                       name )) )
\end{code:lisp}</p>

<p>В предыдущих случаях нам бы пришлось перед этим написать два бессмысленных
утверждения вроде</p>

<p>\begin{code:lisp}
(define winner      |<code><span class="func">'жили-у-бабуси</span></code>|)
(define set-winner! |<code><span class="func">'два-весёлых-гуся</span></code>|)
\end{code:lisp}</p>


<!--\indexC{static}-->
<p>Это бы определило две переменные и дало им начальные значения (потому что
<code><span class="func">define</span></code> не умеет определять переменные без значений), которые тут же
изменяются на правильные соответствующими <code><span class="func">set!</span></code>. Как видим, с таким
окружением есть одна явная проблема: все переменные обязаны быть изменяемыми.
В ранних версиях Scheme <span class="cite">[<a href="z1_bibliography.xhtml#ss78b">ss78b</a>]</span> существовало специальное приспособление
— форма <code><span class="func">static</span></code>, — с помощью которой можно было\footnote{После того,
как <code><span class="func">define</span></code> объяснили, что \ic{(static \ii{переменная})} — это ссылка на
глобальную переменную, а не вызов унарной функции <code><span class="func">static</span></code>.} писать вот так:</p>

<p>\begin{code:lisp}
(let ((name "Nemo"))
  (define (static winner) (lambda () name))
  (define (static set-winner!)
    (lambda (new-name) (set! name new-name)
                       name ) ) )
\end{code:lisp}</p>

<p>Таким образом можно было определять глобальные переменные, имея доступ
к локальным, но при этом не пользуясь присваиваниями.</p>

<p>Хотя, несомненно, создавать глобальные переменные одним присваиванием удобно,
мы рискуем нечаянно загрязнить глобальное окружение переменными, которые должны
были быть локальными. Как вариант, можно разрешить создавать лишь локальные
переменные; например, только лексические с помощью <code><span class="func">let</span></code>, или, как
в <span class="cite">[<a href="z1_bibliography.xhtml#nor72">nor72</a>]</span>, только динамические переменные внутри <code><span class="func">prog</span></code>.\footnote*{%
Например, так сделано в {\TeX}е: определения, создаваемые <code><span class="func">\bslash def</span></code>,
автоматически отменяются при выходе из текущей группы.} К сожалению, это
не вернёт ссылочную прозрачность, а кроме того, вызовет известные сложности
с рекурсией.</p>

<p>
\subsubsection{Гиперстатическое глобальное окружение}%
\label{assignment/assignment/free-vars/sssect:hyperstatic}</p>


<!--\indexR{глобальное окружение!гиперстатическое}-->
<!--\indexR{окружение!глобальное!гиперстатическое}-->
<!--\indexR{гиперстатическое окружение}-->
<p>Есть ещё один вариант глобального окружения: в нём с одним именем может быть
связано несколько переменных, но новые переменные видны лишь тем формам, что
следуют за их определением. Вернёмся к нашему любимому примеру:</p>

<p>\begin{code:lisp}
g                      ; ошибка: неизвестная переменная <code><span class="func">g</span></code>
(define (P m) (* m g)) ; ошибка: неизвестная переменная <code><span class="func">g</span></code>
(define g 10)
(define (P m) (* m g))
(P 10)       |\is| 100
(define g 9.81)
(P 10)       |\is| 100    ; <code><span class="func">P</span></code> использует старое значение <code><span class="func">g</span></code>
(define (P m) (* m g))
(P 10)       |\is| 98.1
(set! e 2.78)          ; ошибка: неизвестная переменная <code><span class="func">e</span></code>
\end{code:lisp}</p>


<!--\indexR{замыкания (closures)}-->
<p>Здесь фраза «замыкание сохраняет свободные переменные из окружения
определения» понимается буквально. При первом определении <code><span class="func">P</span></code> в окружении
нет переменной <code><span class="func">g</span></code> — значит, это ошибка. Можно было бы допустить такое
определение и вызывать ошибку при вызове <code><span class="func">P</span></code>, но не стоит так делать, потому
что <code><span class="func">g</span></code> не динамическая переменная: если её не было при создании функции, то
она не появится и при вызове. Незачем откладывать сообщение об ошибочном
определении на потом.</p>

<p>Вторая версия <code><span class="func">P</span></code> запоминает тот факт, что <code><span class="func">g</span></code> равна 10 в окружении
определения. В замыкании сохраняется именно этот факт: «свободная
переменная <code><span class="func">g</span></code> имеет значение <code><span class="func">10</span></code>». Не важно, что случится с этой
переменной в дальнейшем, для <code><span class="func">P</span></code> она всегда равна десяти. Если мы хотим,
чтобы <code><span class="func">P</span></code> использовала новое значение, то <code><span class="func">P</span></code> надо переопределить.
Глобальное окружение является полностью лексическим; именно такое
<em class="term">гиперстатическое</em> окружение использует ML. Запишем его свойства в виде
привычной таблицы:</p>

<p>\begin{envtable}
Ссылка      & \ii{x}, но \ii{x} должна существовать                 \\
Значение    & \ii{x}, но \ii{x} должна существовать                 \\
Изменение   & \ic{(set! \ii{x} ...)}, но \ii{x} должна существовать \\
Расширение  & <code><span class="func">define</span></code>                                           \\
Определение & запрещено                                             \\
\end{envtable}</p>


<!--\indexR{рекурсия!взаимная}-->
<p>Но, как говорилось ранее, в таком случае возникают проблемы с рекурсивными
определениями. Для Лиспа необходима возможность определения как простых
рекурсивных функций, так и групп взаимно рекурсивных. В ML эта проблема решается
ключевым словом <code><span class="func">rec</span></code> для простой рекурсии и <code><span class="func">and</span></code> для одновременных
определений. В Scheme же есть <code><span class="func">let</span></code> и <code><span class="func">letrec</span></code> для аналогичных целей.</p>

<p>Наш пример в гиперстатическом окружении можно понимать следующим образом:</p>

<p>\begin{code:lisp}
g                                ; ошибка: неизвестная переменная <code><span class="func">g</span></code>
(let ((P (lambda (m) (* m g))))  ; ошибка: неизвестная переменная <code><span class="func">g</span></code>
  (let ((g 10))
    (let ((P (lambda (m) (* m g))))
      (P 10)
      (let ((g 9.81))
        ... ) ) ) )
\end{code:lisp}</p>

<p>Для полноты картины рассмотрим пример со взаимной рекурсией. Следующая программа
на ML:</p>

<p>\begin{code}[language=ML]
let rec odd n = if n = 0 then false else even (n - 1)
    and even n = if n = 0 then true else odd (n - 1)
\end{code}</p>

<p>\noindent
легко переводится на Scheme следующим образом:</p>

<p>\begin{code:lisp}
(letrec ((odd? (lambda (n) (if (= n 0) #f (even? (- n 1)))))
         (even? (lambda (n) (if (= n 0) #t (odd? (- n 1))))) )
  ... )
\end{code:lisp}</p>

<p>Гиперстатическое окружение обладает очевидным преимуществом: возможностью
выявлять неопределённые переменные статически. Кроме того, компилятору легко
обнаружить фактически неизменяемые переменные, что позволяет ему применять
некоторые оптимизации, основанные на статическом знании значения переменной.
Тем не менее, у такого окружения есть и недостатки: например, в случае ошибки
в определении приходится повторять все последующие определения, которые
использовали исправленное ошибочное.</p>

<p>
\subsection{Присваивание предопределённым переменным}%
\label{assignment/assignment/ssect:predefined}</p>


<!--\indexR{переменные!предопределённые}-->
<!--\indexR{предопределённые переменные}-->
<!--\indexR{присваивание!предопределённым переменным}-->
<p>Кроме обычных свободных переменных программы на Scheme ссылаются также на
предопределённые встроенные переменные вроде <code><span class="func">car</span></code> и <code><span class="func">read</span></code>. Естественно,
у нас есть неотъемлемое право присваивать им значения, но какой смысл несут
такие присваивания? Ведь часто интерпретатор опирается на неявные предположения
о программах, чтобы выполнять их быстрее. Например, в Лиспе почти никогда
не требуется переопределять <code><span class="func">car</span></code> и <code><span class="func">cdr</span></code>, поэтому они практически всегда
реализуются как инлайн-функции и подставляются напрямую в код как своеобразные
макросы. Переопределение любой из них сломает эту стройную систему, так как
новые обращения к <code><span class="func">car</span></code> должны будут использовать текущее значение, а
не встроенное; также неясно, что делать с предыдущими ссылками на подобные
переменные, которые были (вероятно) заменены инлайн-кодом.</p>

<p>В гиперстатическом окружении последняя проблема, к счастью, отпадает: предыдущие
ссылки будут видеть предыдущее значение. Но в динамическом глобальном окружении
нам придётся отыскать все вхождения <code><span class="func">car</span></code> и заменить их. Далее, по-видимому,
потребуется заменить ещё и все вхождения <code><span class="func">cadr</span></code>, которая является композицией
<code><span class="func">car</span></code> и <code><span class="func">cdr</span></code>. В действительности, никто не занимается этим безнадёжным
делом, так как это сложно, да и не похоже, что именно такой беспорядок ожидается
пользователем в результате переопределения.</p>


<!--\indexE{Scheme!неизменяемость примитивов}-->
<!--\indexR{примитивы!неизменяемость}-->
<p>Между прочим, Scheme запрещает изменять значения глобальных примитивных функций.
То есть создать свою глобальную переменную <code><span class="func">car</span></code> нам-то ничто не помешает,
но это никак не повлияет на <code><span class="func">cadr</span></code>. Аналогично, функция <code><span class="func">map</span></code> является
встроенной, так что новая <code><span class="func">car</span></code> не изменит её поведения, но, возможно, она
затронет поведение какой-нибудь <code><span class="func">mapc</span></code>, которая не входит в стандарт.</p>

<p>Часто глобальные примитивы изменяют для того, чтобы на скорую руку залатать
ошибку в интерпретаторе, или, например, с целью подменить глобальную функцию её
отладочным вариантом, который выводит на экран сообщения при каждом вызове. Тем
не менее, я дам вам дружеский совет: «Ради бога, не трогайте примитивы, если
у вас есть хоть капля сомнения в том, что именно получится в результате».</p>

<p>Подводя итог, гиперстатическое окружение ведёт себя просто, понятно и логично,
но для отладки более удобным оказывается динамическое.</p>

<h2 id="assignment/sect:side-effects">Побочные эффекты</h2>


<!--\indexR{вычисления!контекст}-->
<!--\indexR{контекст вычислений}-->
<!--\indexR{побочные эффекты}-->
<!--\indexR{память}-->
<p>До сих пор мы представляли вычисления упорядоченной тройкой выражения, окружения
и продолжения. Как бы красиво она не выглядела, но с её помощью нельзя выразить
присваивания, ввод-вывод и многое другое. Все эти глобальные изменения состояния
мира объединяются в понятие <em class="term">побочных эффектов</em> и для компьютера в конечном
итоге сводятся к определённым изменениям в его памяти, изменениям её состояния.</p>

<p>Рассмотрим на знакомых примерах, почему это так. Если мы читаем что-то из
потока, то где-то там изменяется положение метки, которая указывает на
последний считанный байт. (А это не что иное, как побочный эффект, который мы
получаем вдобавок к считанным данным.) Если мы уже вывели что-то на экран, то
компьютер успеет провести миллионы операций за десять миллисекунд до следующего
обновления экрана; а стереть напечатанное принтером он вообще не в состоянии.
Попросить пользователя ввести что-то с клавиатуры — это тоже необратимо. Как
видим, побочные эффекты вездесущи. На них основаны регистры, используемые для
вычислений; без них мы бы не смогли сохранять наши драгоценные программы. Нет,
конечно, можно представить себе идеальный мир, где компьютеры работают без
побочных эффектов, но кому нужен компьютер-аутист, которому ни объяснить, что от
него требуется, ни получить от него ответ. Благо, этот кошмар не застанет нас
наяву.</p>


<!--\indexR{присваивание!и побочные эффекты}-->
<!--\indexR{побочные эффекты!и присваивание}-->
<p>Мы уже видели, что присваивания можно заменить использованием коробок, но сами
коробки используют точечные пары. Вопрос: можно ли реализовать точечные пары без
точечных пар? Ответ: да, но для этого нам понадобится присваивание! Их можно
представить в виде замыкания, реагирующего на сообщения\footnote{Будем писать
эти имена через <code><span class="func">k</span></code>, чтобы не путать их с обычными.} <code><span class="func">car</span></code>, <code><span class="func">cdr</span></code>,
<code><span class="func">set-car!</span></code> и <code><span class="func">set-cdr!</span></code>:</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>


<!--\indexC{kons}-->
<!--\indexC{kar}-->
<!--\indexC{kdr}-->
<p>\begin{code:lisp}
(define (kons a d)
  (lambda (msg)
    (case msg
      ((car) a)
      ((cdr) d)
      ((set-car!) (lambda (new) (set! a new)))
      ((set-cdr!) (lambda (new) (set! d new))) ) ) )
|\ForLayout{display}{\vskip-0.4\baselineskip}|
(define (kar pair)
  (pair 'car) )
|\ForLayout{display}{\vskip-0.4\baselineskip}|
(define (set-kdr! pair value)
  ((pair 'set-cdr!) value) )
\end{code:lisp}</p>

<p>\ForLayout{display}{\endgroup}</p>


<!--\indexE{Scheme!проблемы типизации}-->
<p>И вновь определение оказывается не вполне точным, как справедливо замечено
в <span class="cite">[<a href="z1_bibliography.xhtml#fel90">fel90</a>]</span>, потому что теперь мы не можем различать точечные пары и
замыкания. При таком определении нельзя написать предикат <code><span class="func">pair?</span></code>, который
будет работать верно в любых условиях. Если не обращать внимания на эту проблему
(которую можно считать платой за возможность создавать свои типы данных), то
чётко видно, что присваивание и побочные эффекты тесно связаны и легко
выражаются друг через друга. Поэтому мы вынуждены или запретить использование
их обоих, или же признать их существование и научиться контролировать возможные
последствия. Какую именно форму использовать: присваивание переменным или прямую
модификацию памяти, — зависит от контекста и желаемых свойств.</p>

<h3 id="assignment/side-effects/ssect:equality">Равенство</h3>


<!--\indexR{сравнение!объектов}-->
<!--\indexR{взаимозаменимость}-->
<!--\indexR{эквивалентность}-->
<!--\indexR{равенство}-->
<p>%
<!--\indexR{упячка}-->
Одним из главных неприятных последствий существования побочных эффектов является
усложнение сравнения объектов. Когда можно считать два объекта равными?
По мнению Лейбница, объекты эквивалентны, если они взаимозаменимы. С точки
зрения программирования они взаимозаменимы, если мы не можем их различить.
Эквивалентность обладает свойством рефлексивности: любой объект эквивалентен
самому себе, так как очевидно, что он может заменить самого себя. Рефлексивность
можно считать слабой эквивалентностью, если понимать её буквально; ведь мы
именно так отличаем целые числа: каждое из них эквивалентно только самому себе.
Но всё усложняется, когда кроме самих объектов нам доступны ещё и преобразования
между ними. Например, пусть у нас есть два совершенно разных вычисления, вроде
<code><span class="func">(* 2 2)</span></code> и <code><span class="func">(+ 2 2)</span></code>), и мы интересуемся, одно и то же ли они,
взаимозаменимы ли они.</p>

<p>Если объекты можно изменять, то два объекта различны, если изменение одного
не влияет на другой. Заметьте, что мы говорим о <em>различии</em>, а не о
равенстве; но всё равно это достаточно важные классы объектов для понятия
равенства: изменяемые и неизменяемые.</p>


<!--\indexR{эквивалентность!атомов}-->
<!--\indexR{значения!атомарные}-->
<p>Кронекер говорил, что целые числа созданы Богом, поэтому логично считать, что
других чисел быть не может, и число 3 будет оставаться тем же самым числом 3
в любом выражении. Аналогично можно причислить к неизменяемым все другие
атомарные объекты (то есть те, которые не имеют составляющих частей), так что
к числам отправляются также знаки, булевы значения и пустой список. Все
остальные объекты являются составными, а значит, не первозданными и,
следовательно, не обязательно неизменными.</p>


<!--\indexR{идентичность}-->
<!--\indexR{значения!составные}-->
<!--\indexC{equal"?}-->
<!--\indexC{eq"?}-->
<p>Составные объекты вроде списков, строк и векторов логично считать равными, если
они состоят из равных частей. Именно такой смысл равенства олицетворяют
всевозможные варианты\footnote{Например, <code><span class="func">equalp</span></code> и <code><span class="func">tree-equal</span></code>
в <span class="logo">Common Lisp</span>.} предиката <code><span class="func">equal?</span></code>. К сожалению, если состав объектов можно
изменять, то равенство их в один момент времени не гарантирует сохранение
равенства в любой другой. Поэтому мы введём предикат <code><span class="func">eq?</span></code>, проверяющий
идентичность: два объекта равны в смысле <code><span class="func">eq?</span></code>, если они — это один и
тот же объект. Такую проверку можно очень эффективно реализовать, сравнив адреса
этих объектов: если они указывают на одно и то же место в памяти, то очевидно,
что это один и тот же объект.</p>

<div class="bigskip"/>


<!--\indexR{тождественность}-->
<p>Итак, сейчас у нас есть два предиката: <code><span class="func">eq?</span></code> для проверки идентичности и
<code><span class="func">equal?</span></code> для проверки структурного равенства. Но они оба впадают в крайности,
когда дело касается изменяемых объектов. Равенство тождественно идентичности для
неизменяемых объектов — два равных неизменяемых объекта такими и останутся
навсегда. Но изменяемые объекты тождественны (всегда равны) только тогда, когда
они идентичны (то есть суть один и тот же объект). Именно поэтому разумно
понимать эквивалентность как взаимозаменимость: объекты эквивалентны, если
ни одна программа не сможет их различить.</p>

<p>Предикат <code><span class="func">eq?</span></code> работает на самом низком уровне: он может сравнивать только
адреса ячеек памяти\footnote{В случае распределённых вычислений <code><span class="func">eq?</span></code> должен
также уметь сравнивать переменные, расположенные на различных компьютерах. Так
что низкоуровневость этого предиката ещё не означает молниеносность его работы.}
и непосредственные константы. Некоторые объекты могут представляться в памяти
по-разному, но быть при этом эквивалентными,\footnote*{Например, в Scheme
значение <code><span class="func">(eq? 33 33)</span></code> не определено. Для правильного сравнения чисел
существует <code><span class="func">eqv?</span></code>.} поэтому выходит, что <code><span class="func">eq?</span></code> не обладает критичной для
отношения эквивалентности рефлексивностью.</p>


<!--\indexC{eqv"?}-->
<!--\indexC{eql}-->
<p>Существует улучшенный вариант <code><span class="func">eq?</span></code>, называемый <code><span class="func">eqv?</span></code> в Scheme и <code><span class="func">eql</span></code>
в <span class="logo">Common Lisp</span>. В целом это тот же <code><span class="func">eq?</span></code>, но он работает немного медленнее,
чтобы точно убедиться в равенстве неизменяемых объектов. Например, при
сравнении чисел <code><span class="func">eqv?</span></code> проверит, что они равны, даже если они по-разному
представляются в памяти: с учётом всех форматов, длинной арифметики и т. п.</p>


<!--\indexR{точечные пары!неизменяемые}-->
<!--\indexR{связывание!неизменяемое}-->
<p>Если мы критически рассмотрим наши предыдущие интерпретаторы, то заметим, как
мало в них изменяемых объектов. Практически всё, за исключением привязок,
неизменяемо. Большая часть и так немногочисленных точечных пар никогда не видела
в лицо <code><span class="func">set-car!</span></code> или <code><span class="func">set-cdr!</span></code>. В некоторых диалектах ML, а также
в \CommonLisp, можно явно указывать неизменяемые поля объектов. Вот так,
например, определяется неизменяемая точечная пара:</p>

<p>\begin{code:lisp}
(defstruct immutable-pair     |\dialect<span class="logo">Common Lisp</span>|
  (car ’() :read-only t)
  (cdr ’() :read-only t) )
\end{code:lisp}</p>

<p>Такой способ, к примеру, удобен для представления цитированных точечных пар: их
можно один раз создать, разместить в отдельной области памяти и, давая на них
ссылку, можно быть уверенным, что их никто никогда не поменяет.</p>


<!--\indexC{egal}-->
<p>Генри Бейкер в <span class="cite">[<a href="z1_bibliography.xhtml#bak93">bak93</a>]</span> предложил унифицировать предикаты равенства,
объединив их в один — <code><span class="func">egal</span></code>,\trnote*{Немецкое слово egal и французское
\'egal буквально значат «равен».} определяемый следующим образом: если
сравниваемые объекты изменяемы, то он ведёт себя как <code><span class="func">eq?</span></code>, в противном
случае — как <code><span class="func">equal?</span></code>. Истинность данного предиката гарантирует
взаимозаменимость объектов. Это очень удобная функция, например, как показано
в \cite{qd93,que94}, для параллельного программирования.</p>


<!--\indexR{сравнение!циклических объектов}-->
<!--\indexR{циклические структуры данных}-->
<!--\indexCS{equal"?}{стоимость}-->
<p>Ещё одной проблемой являются циклические структуры данных. Их возможно
сравнивать, но это обходится дорого. Если <code><span class="func">equal?</span></code> не знает, как обращаться
с такими структурами, то она просто застрянет в бесконечном цикле. Но даже если
мы каким-то образом сможем определить наличие цикла, то всё ещё неясно, как
проводить сравнение. Допустим, у нас есть вот такие объекты:</p>

<p>\ForLayout{display}{\medskip}</p>

<p>% <MAGIC>
\input{figures/fig4.cycle}
% </MAGIC></p>

<p>\begin{code:lisp}
(define o1 (let ((pair (cons 1 2)))
             (set-car! pair pair)
             (set-cdr! pair pair)
             pair ))
(define o2 (let ((pair (cons (cons 1 2))))
             (set-car! (car pair) pair)
             (set-cdr! (car pair) pair)
             (set-cdr! pair pair)
             pair ))
\end{code:lisp}</p>

<p>Предположим, мы хотим вычислить <code><span class="func">(equal? o1 o1)</span></code>. Пусть <code><span class="func">equal?</span></code>
реализована так, что сначала вызывает <code><span class="func">eq?</span></code>, и только потом — если ей
переданы объекты, которые действительно могут быть не эквивалентны, — она
выполняет долгую структурную проверку. В таком случае мы сразу же получаем
ответ <code><span class="func">\#t</span></code>. Иначе <code><span class="func">equal?</span></code> попадает в бесконечный цикл.%
\footnote*{Я запускал этот пример на четырёх различных интерпретаторах Scheme и
два из них зациклились. Я не буду их называть, так как у них есть полное право
так делать. <span class="cite">[<a href="z1_bibliography.xhtml#kcr98">kcr98</a>]</span>}</p>

<p>Ладно, пусть результат <code><span class="func">(equal? o1 o1)</span></code> зависит от реализации; что насчёт
<code><span class="func">(equal? o1 o2)</span></code>? И опять ответ зависит от того, изменяемы ли или нет
точечные пары, из которых состоят <code><span class="func">o1</span></code> и <code><span class="func">o2</span></code>. Если они неизменяемы, то
без <code><span class="func">eq?</span></code> нельзя написать программу, которая бы смогла отличить <code><span class="func">o1</span></code>
от <code><span class="func">o2</span></code>. Таким образом, лучше воздержаться от сравнения циклических структур
данных с помощью <code><span class="func">equal?</span></code>.</p>

<div class="bigskip"/>


<!--\indexR{сравнение!символов}-->
<p>Рассмотренные предикаты поддерживают большую часть используемых типов данных, за
исключением символов и функций. Символы часто являются не совсем атомарными,
так как они могут содержать списки свойств. Но с точки зрения сравнения их можно
считать такими же неизменяемыми, как и числа, потому что символ однозначно
определяется своим именем; вся суть символов как раз в том, что не может быть
двух различных символов с одинаковыми именами.</p>


<!--\indexR{списки свойств}-->
<!--\indexR{символы!списки свойств}-->
<!--\indexR{хеш-таблицы}-->
<p>Что касается списков свойств, которые часто хранятся вместе с символами, то они
являются удобным дополнением, например, для хранения всевозможных метаданных
о глобальных переменных. В то же время, необходимо понимать ответственность за
введение данной возможности: для её поддержки требуются побочные эффекты;
свойства символа доступны глобально; для хранения каждого свойства требуются две
точечные пары; желательно организовать эффективный поиск значения по имени
свойства (например, на основе <em class="term">хеш-таблиц</em>\footnote{По моему скромному
мнению, изобретение хеш-таблиц является одним из величайших достижений
информатики.}).</p>

<p>
\subsection{Равенство функций}%
\label{assignment/side-effects/ssect:equality-func}</p>


<!--\indexR{сравнение!функций}-->
<!--\indexR{функции!сравнение}-->
<!--\indexR{функции!тождественность}-->
<p>Случай сравнения функций может показаться безнадёжным. Легко догадаться, что
функции эквивалентны, если они дают равные результаты для равных аргументов;
в таком случае очевидно, что они взаимозаменимы. Более формально
тождественность функций записывается так:
%
\[ f \equals g \iff \forall x \colon f(x) = g(x) \]</p>

<p>К сожалению, если бы всё было так просто запрограммировать\textdots\ Мы ведь
не можем всерьёз проверять все возможные значения аргументов. Поэтому придётся
или отказаться от идеи сравнимости функций, или же принять менее строгое
определение эквивалентности для них. Сложно сказать, эквивалентны ли
произвольные функции, но очень часто бывает легко выяснить, когда они
не эквивалентны (например, если они принимают разное количество аргументов).</p>

<p>Поэтому для функций можно определить приближённое сравнение, понимая при этом,
что оно может ошибаться, порой значительно. Естественно, пользоваться им можно
только в том случае, если мы точно знаем, когда и насколько его результат будет
ошибочным.</p>


<!--\indexCS{eqv"?}{для функций}-->
<p>Scheme определяет <code><span class="func">eqv?</span></code> для функций следующим образом: если есть хотя бы
один набор аргументов, который приводит к различным результатам применения
функций <code><span class="func">f</span></code> и <code><span class="func">g</span></code>, то данные функции не эквивалентны. И снова, здесь речь
идёт о различии, а не о равенстве.</p>

<p>Давайте рассмотрим ещё несколько примеров. Выражение <code><span class="func">(eqv? car cdr)</span></code> должно
возвращать ложь, так как результаты применения этих функций значительно
отличаются, например, для <code><span class="func">(a . b)</span></code>.</p>


<!--\indexR{тождественность!функций}-->
<p>Также очевидно, что <code><span class="func">(eqv? car car)</span></code> должна возвращать истину, так как
эквивалентность обязана быть рефлексивной. Но в некоторых реализациях данная
форма возвращает ложь, так как <code><span class="func">car</span></code> является инлайн-функцией и эта форма
фактически читается как <code><span class="func">(eqv? (lambda (x) (car x)) (lambda (x) (car x)))</span></code>.
{\RnRS} оставляет результат <code><span class="func">eqv?</span></code> при подобном сравнении на усмотрение
реализации.</p>

<p>А как сравнить <code><span class="func">cons</span></code> и <code><span class="func">cons</span></code>, не прибегая к спасительной рефлексивности?
Ведь функция <code><span class="func">cons</span></code> создаёт изменяемые структуры данных, так что даже если её
аргументы можно сравнить, то результаты вовсе не обязаны быть эквивалентными,
так как они размещаются в разных участках памяти. Таким образом, <code><span class="func">cons</span></code>
не тождественна <code><span class="func">cons</span></code>, и <code><span class="func">(eqv? cons cons)</span></code> должна вернуть ложь, так как
<code><span class="func">(eqv? (cons 1 2) (cons 1 2))</span></code> возвращает ложь!</p>


<!--\indexR{частичные функции}-->
<!--\indexR{функции!частичные}-->
<p>Вы всё ещё уверены, что <code><span class="func">car</span></code> должна быть равна <code><span class="func">car</span></code>? Есть и другие
проблемы. Например, в языке без проверки типов <code><span class="func">(car ’foo)</span></code> вызовет ошибку и
выброс исключения, но результаты его перехвата и обработки слабо предсказуемы и
зависят отнюдь не только от аргументов. Поэтому не все функции вообще могут
вернуть что-то сравнимое. Это касается всех частичных функций,\trnote*{Функция
$f\colon X \to Y$ называется частичной, если её значения на $X$ могут быть
не определены. Классический пример: операция вычитания для натуральных чисел
имеет тип $\mathbb{N} \times \mathbb{N} \to \mathbb{N}$, но определена не для
всех пар натуральных чисел $(a, b) \in \mathbb{N} \times \mathbb{N}$, только для
тех, где $a \geq b$.} которые используются вне своей фактической области
определения.</p>


<!--\indexR{замыкания (closures)!сравнение}-->
<p>Так что же делать? В различных языках применяются различные меры. Некоторые
языки имеют мощную систему типов, поэтому они в состоянии определить, когда
аргументы сравнения являются функциями; часть диалектов ML, например, этим
пользуется, запрещая сравнивать функции вообще. В Scheme форма <code><span class="func">lambda</span></code>
создаёт замыкания. Каждый вызов <code><span class="func">lambda</span></code> сохраняет в памяти замыкание,
которое имеет определённый адрес, так что функции можно сравнивать хотя бы по
этому адресу. Именно так и делает <code><span class="func">eqv?</span></code>, считая функции с одинаковым адресом
эквивалентными.</p>

<p>Однако, такое поведение может мешать некоторым оптимизациям. Рассмотрим функцию
с говорящим именем <code><span class="func">make-named-box</span></code>. Она принимает один аргумент (сообщение),
анализирует его и реагирует соответствующим образом. Это один из возможных
способов реализации объектов, именно его мы будем использовать для написания
интерпретатора в этой главе.</p>


<!--\indexC{make-named-box}-->
<p>\begin{code:lisp}
(define (make-named-box name value)
  (lambda (msg)
    (case msg
      ((type) (lambda () 'named-box))
      ((name) (lambda () name))
      ((ref)  (lambda () value))
      ((set!) (lambda (new-value) (set! value new-value))) ) ) )
\end{code:lisp}</p>

<p>Замечательно, мы научились привязывать к коробкам бирку с именем. Теперь
рассмотрим функцию внимательнее: замыкание, возвращаемое в ответ на сообщение
<code><span class="func">type</span></code>, не зависит от локальных переменных. Поэтому его можно вынести за
скобки:</p>

<p>\begin{code:lisp}
(define other-make-named-box
  (let ((type-closure (lambda () 'named-box)))
    (lambda (name value)
      (let ((name-closure  (lambda () name))
            (value-closure (lambda () value))
            (set!-closure  (lambda (new-value)
                             (set! value new-value) )) )
        (lambda (msg)
          (case msg
            ((type) type-closure)
            ((name) name-closure)
            ((ref)  value-closure)
            ((set!) set!-closure) ) ) ) ) ) )
\end{code:lisp}</p>

<p>\noindent
Отлично, <code><span class="func">type-closure</span></code> теперь создаётся только один раз для всех коробок, а
не при каждом разборе <code><span class="func">msg</span></code>.</p>

<p>Но что мы получим в результате следующего сравнения?</p>

<p>\begin{code:lisp}
(let ((box (make-named-box 'foo 33)))
  (|\ii{равны}|? (box 'type) (box 'type)) )
\end{code:lisp}</p>

<p>Это не совсем корректный вопрос, потому что здесь не указан предикат. Если это
<code><span class="func">eq?</span></code>, то ответ зависит от количества созданных копий <code><span class="func">(lambda ()
'named-box)</span></code>, если же это <code><span class="func">egal</span></code>, то расположение замыканий не играет роли и
ответом будет истина. Таким образом, семантика языка неявно зависит от
предоставляемых им предикатов сравнения.</p>

<p>Если <code><span class="func">lambda</span></code> создаёт замыкания в памяти, то у них всегда есть какой-то
адрес. Два замыкания с одинаковым адресом, очевидно, являются одним и тем же
замыканием, а потому эквивалентны. Соответственно, в Scheme следующая программа
ведёт себя верно:</p>

<p>\begin{code:lisp}
(let ((f (lambda (x y) (cons x y))))
  (eqv? f f) ) |\is| #t
\end{code:lisp}</p>

<p>\noindent
Так как <code><span class="func">eqv?</span></code> передан один и тот же объект, она вправе вернуть истину; даже
если <code><span class="func">(eqv? (f 1 2) (f 1 2))</span></code> возвращает ложь.</p>

<div class="bigskip"/>

<p>Как мы видим, при сравнении функций возникает множество вопросов, на которые
нельзя дать однозначный ответ. Предпочтения зависят от свойств эквивалентности,
которые желательно сохранить в языке, так как проверка математической
тождественности функций не представляется возможной. Свойства подобного
сравнения зависят от выбора авторов реализации языка. Иногда оно и вообще
оказывается под запретом. Хотя в этой книге сравнение функций всё же
используется для методов {\Meroonet} \seePage[objects/method/par:func-eq],
пожалуйста, если это возможно, старайтесь воздержаться от сравнения функций
в любом виде.</p>

<h2 id="assignment/sect:implementation">Реализация</h2>


<!--\indexR{обмен сообщениями}-->
<!--\indexR{замыкания (closures)}-->
<!--\indexR{сообщения}-->
<p>В этот раз мы напишем интерпретатор, основанный на замыканиях. Все его объекты
будут <code><span class="func">lambda</span></code>-формами, которые отправляют сообщения другим формам и
разбирают входящие сообщения с помощью уже знакомой вам идиомы <code><span class="func">(lambda (msg)
(case msg ...))</span></code>. Некоторые сообщения будут универсальными для всех объектов.
Сообщение <code><span class="func">boolify</span></code> запрашивает у объекта его булев эквивалент (то есть
<code><span class="func">\#t</span></code> или <code><span class="func">\#f</span></code> для нужд <code><span class="func">if</span></code>-форм), а сообщение <code><span class="func">type</span></code>, конечно же,
вернёт его тип.</p>

<p>Главной проблемой является способ реализации побочных эффектов. Формально,
переменная ссылается на привязку, которая указывает на значение этой переменной.
Говоря простым языком, переменная указывает на коробку (адрес), где лежит
её значение. Память — это функция, достающая из нужной коробки значение.
Окружение — это функция, достающая из кучи нужную коробку. Всё это просто и
понятно, но ровно до того момента, как мы попытаемся это запрограммировать.</p>


<!--\indexR{вычисления!контекст}-->
<!--\indexR{контекст вычислений}-->
<p>Память должна быть видна отовсюду. Можно было бы сделать её глобальной
переменной, но это не совсем элегантное решение, ведь вы знаете, сколько проблем
и неоднозначностей таит в себе глобальное окружение. Есть и другой способ
обеспечить видимость памяти для всех функций интерпретатора: передавать её как
аргумент в каждую функцию, а она будет передавать её в следующую (возможно,
изменив перед этим). Так и поступим; теперь вычисление описывается четвёркой из
<em class="term">выражения</em>, <em class="term">окружения</em>, <em class="term">продолжения</em> и <em class="term">памяти</em>.
В программе будем их коротко называть <code><span class="func">e</span></code>, <code><span class="func">r</span></code>, <code><span class="func">k</span></code> и <code><span class="func">s</span></code>.</p>


<!--\indexR{соглашения именования}-->
<!--\indexE{e @\protect<code><span class="func">e</span></code> (выражения)}-->
<!--\indexE{r @\protect<code><span class="func">r</span></code> (лексическое окружение)}-->
<!--\indexE{k @\protect<code><span class="func">k</span></code> (продолжения)}-->
<!--\indexE{v @\protect<code><span class="func">v</span></code> (значения)}-->
<!--\indexE{f @\protect<code><span class="func">f</span></code> (функции)}-->
<!--\indexE{n @\protect<code><span class="func">n</span></code> (идентификаторы)}-->
<!--\indexE{s @\protect<code><span class="func">s</span></code> (память)}-->
<!--\indexE{a @\protect<code><span class="func">a</span></code> (адреса)}-->
<p>Как обычно, функция <code><span class="func">evaluate</span></code> проводит синтаксический анализ своего
аргумента и вызывает соответствующую функцию-вычислитель. Не будем нарушать
установленную в предыдущих главах традицию именования сущностей, лишь расширим
список новыми типами:</p>

<p>\begin{center}\begin{tabular}{rl}
<code><span class="func">e</span></code>, <code><span class="func">et</span></code>, <code><span class="func">ec</span></code>, <code><span class="func">ef</span></code> & выражения, формы  \\
                           <code><span class="func">r</span></code> & окружения         \\
                  <code><span class="func">k</span></code>, <code><span class="func">kk</span></code> & продолжения       \\
                <code><span class="func">v</span></code>, <code><span class="func">void</span></code> & значения          \\
                           <code><span class="func">f</span></code> & функции           \\
                           <code><span class="func">n</span></code> & идентификаторы    \\
        <code><span class="func">s</span></code>, <code><span class="func">ss</span></code>, <code><span class="func">sss</span></code> & память            \\
                  <code><span class="func">a</span></code>, <code><span class="func">aa</span></code> & адреса (коробки)
\end{tabular}\end{center}</p>

<p>Так как у нас увеличилось количество аргументов функций, то отныне будем всегда
их перечислять в определённом порядке: <code><span class="func">e</span></code>, <code><span class="func">r</span></code>, <code><span class="func">s</span></code>, затем <code><span class="func">k</span></code>.</p>

<p>Итак, ядро интерпретатора:</p>


<!--\indexC{evaluate}-->
<p>\begin{code:lisp}
(define (evaluate e r s k)
  (if (atom? e)
      (if (symbol? e) (evaluate-variable e r s k)
          (evaluate-quote e r s k) )
      (case (car e)
        ((quote)  (evaluate-quote (cadr e) r s k))
        ((if)     (evaluate-if (cadr e) (caddr e) (cadddr e) r s k))
        ((begin)  (evaluate-begin (cdr e) r s k))
        ((set!)   (evaluate-set! (cadr e) (caddr e) r s k))
        ((lambda) (evaluate-lambda (cadr e) (cddr e) r s k))
        (else     (evaluate-application (car e) (cdr e) r s k)) ) ) )
\end{code:lisp}</p>

<h3 id="assignment/implementation/ssect:condition">Ветвление</h3>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>

<p>Условный оператор требует вспомогательного продолжения для выполнения ветвления
после вычисления условия.</p>


<!--\indexC{evaluate-if}-->
<p>\begin{code:lisp}
(define (evaluate-if ec et ef r s k)
  (evaluate ec r s
    (lambda (v ss)
      (evaluate ((v 'boolify) et ef) r ss k) ) ) )
\end{code:lisp}</p>

<p>Вспомогательное продолжение принимает не только вычисленное условие <code><span class="func">v</span></code>, но и
состояние памяти после вычисления. Следовательно, мы допускаем побочные эффекты
при вычислении условия:</p>

<p>\begin{code:lisp}
(if (begin (set-car! pair 'foo)
           (cdr pair) )
    (car pair) 2 ) |{\is} <code><span class="func">'foo</span></code> \textrm{или} <code><span class="func">2</span></code>|
\end{code:lisp}</p>


<!--\indexR{поиск с возвратом}-->
<p>Сейчас любые изменения памяти, выполненные в условии, видны в обеих ветках. Но
можно поступить иначе:</p>


<!--\indexCS{evaluate-if}{поиск с возвратом}-->
<p>\begin{code:lisp}
(define (evaluate-amnesic-if ec et ef r s k)
  (evaluate ec r s
    (lambda (v ss)
      (evaluate ((v 'boolify) et ef) r s     ; $<code><span class="func">s</span></code> \ne <code><span class="func">ss</span></code>$!
                k) ) ) )
\end{code:lisp}</p>

<p>В этом случае при вычислении веток мы пользуемся старым состоянием памяти,
которое было при вызове самой формы <code><span class="func">if</span></code>. Это необходимое свойство для языков
со встроенной поддержкой поиска с возвратом вроде Пролога.
\seeEx[assignment/ex:form-or]</p>


<!--\indexE{boolify@\protect<code><span class="func">'boolify</span></code>}-->
<!--\indexR{комбинаторы!T@\protect\comb{T}}-->
<!--\indexR{комбинаторы!F@\protect\comb{F}}-->
<p>Так как мы решили все объекты интерпретатора представлять функциями, то
в качестве логических значений нельзя использовать <code><span class="func">\#t</span></code> и <code><span class="func">\#f</span></code> языка
реализации. Кроме этого нам необходим способ приведения любых объектов
к логическому типу (ведь любой объект в Scheme, кроме <code><span class="func">\#f</span></code>, считается
логической истиной). Будем считать, что все объекты отвечают на сообщение
<code><span class="func">boolify</span></code>, возвращая своё логическое представление в виде одного из
комбинаторов λ-исчисления: <code><span class="func">(lambda (x y) x)</span></code> или
<code><span class="func">(lambda (x y) y)</span></code>.</p>

<p>\ForLayout{display}{\endgroup}% \lstset *skipamount</p>

<h3 id="assignment/implementation/ssect:sequence">Последовательность</h3>

<p>Хотя тут нет ничего интересного или нового, но повторить смысл последовательных
вычислений будет не лишним. Для простоты мы считаем, что <code><span class="func">begin</span></code> передана
как минимум одна форма.</p>


<!--\indexC{evaluate-begin}-->
<p>\begin{code:lisp}
(define (evaluate-begin e* r s k)
  (if (pair? (cdr e*))
      (evaluate (car e*) r s
        (lambda (void ss)
          (evaluate-begin (cdr e*) r ss k) ) )
      (evaluate (car e*) r s k) ) )
\end{code:lisp}</p>

<p>Здесь чётко видно, как мы последовательно вычисляем тело <code><span class="func">begin</span></code>, передаём
новое состояние памяти, но игнорируем значения всех вычисляемых выражений, кроме
последнего, которое обрабатывается отдельно.</p>

<h3 id="assignment/implementation/ssect:environment">Окружения</h3>

<p>Окружения представляются функциями, переводящими имена переменных в адреса.
Аналогично, память — это функция, переводящая адреса в значения. Начальное
окружение должно быть пустым:</p>


<!--\indexC{r.init}-->
<p>\begin{code:lisp}
(define (r.init id)
  (wrong "No binding for" id) )
\end{code:lisp}</p>


<!--\indexR{память!чисто функциональная}-->
<!--\indexR{чисто функциональные структуры данных}-->
<!--\indexR{побочные эффекты}-->
<p>Итак, как же нам выразить изменение окружения (или памяти), не используя
побочные эффекты или присваивание? В нашем случае это значит, что функция-память
должна после изменения по-другому реагировать на определённое значение, но
по-старому — на все остальные. Функция <code><span class="func">update</span></code> создаёт новую память
именно с таким поведением:</p>


<!--\indexC{update}-->
<p>\begin{code:lisp}
(define (update s a v)
  (lambda (aa)
    (if (eqv? a aa) v (s aa)) ) )
\end{code:lisp}</p>

<p>Здесь буквально записана эта идея. Вызов <code><span class="func">(update s a v)</span></code> вернёт новое,
изменённое состояние памяти, которое мы передадим следующей функции как текущее.
Также можно обобщить <code><span class="func">update</span></code> для изменения сразу нескольких значений:</p>


<!--\indexC{update*}-->
<p>\begin{code:lisp}
(define (update* s a* v*)
  ;; <code><span class="func">(assume (= (length a*) (length v*)))</span></code>
  (if (pair? a*)
      (update* (update s (car a*) (car v*)) (cdr a*) (cdr v*))
      s ) )
\end{code:lisp}</p>

<p>Функция <code><span class="func">update</span></code> одинаково хорошо работает как с памятью, так и
с окружениями. В ML это была бы полиморфная функция, так как окружения и память
имеют разные типы. Также необходимо учитывать, что <code><span class="func">update</span></code> требуется некий
критерий сравнения адресов, поэтому для их представления стоит выбрать
гарантированно сравнимые объекты: например, целые числа. Имена переменных мы
будем представлять символами. Оба типа данных прекрасно поддерживаются
<code><span class="func">eqv?</span></code>, поэтому в <code><span class="func">update</span></code> используется именно этот предикат.</p>

<p>
\subsection{Обращения к переменным}%
\label{assignment/implementation/ssect:reference}</p>

<p>Благодаря выбранному представлению памяти значение переменной получается
элементарно:</p>


<!--\indexC{evaluate-variable}-->
<p>\begin{code:lisp}
(define (evaluate-variable n r s k)
  (k (s (r n)) s) )
\end{code:lisp}</p>

<p>Сначала мы извлекаем адрес переменной <code><span class="func">(r n)</span></code> из окружения, затем ищем
соответствующее значение в памяти <code><span class="func">s</span></code> и передаём его продолжению <code><span class="func">k</span></code>. Так
как чтение памяти не вызывает побочных эффектов, то продолжению память
передаётся в неизменном виде.</p>

<h3 id="assignment/implementation/ssect:assignment">Присваивание</h3>

<p>Для присваивания необходимо промежуточное продолжение.</p>


<!--\indexC{evaluate-set"!}-->
<p>\begin{code:lisp}
(define (evaluate-set! n e r s k)
  (evaluate e r s
    (lambda (v ss)
      (k v (update ss (r n) v)) ) ) )
\end{code:lisp}</p>

<p>Новое значение переменной после вычисления передаётся продолжению, которое
записывает его в память по адресу переменной. Дальше промежуточное продолжение
передаёт обновлённое состояние памяти изначальному продолжению формы <code><span class="func">set!</span></code>.
Между прочим, возвращаемое значение этого варианта присваивания вполне
определено: это текущее значение переменной после присваивания.</p>

<p>Принцип работы памяти без побочных эффектов и причины представления её как
функции теперь должны быть окончательно понятны: фактически, память
представляется историей изменений своего состояния. Мы никогда не изменяем
записи в этом списке и не удаляем их — только добавляем новые, переопределяя
таким образом функцию-память. Конечно, если сравнивать его с реальной памятью,
данный вариант является жутко неэффективным и избыточным, но ведение истории
изменений имеет свои плюсы. \seeEx[assignment/ex:previous-value] По крайней
мере, можно взять эту идею на вооружение хотя бы частично.</p>

<h3 id="assignment/implementation/ssect:application">Аппликация</h3>

<p>Перед применением функции необходимо вычислить все элементы формы вызова.
Вычислять их можно, как известно, в произвольном порядке. Пусть это будет
порядок слева направо.</p>


<!--\indexC{evaluate-application}-->
<p>\begin{code:lisp}
(define (evaluate-application e e* r s k)
  (define (evaluate-arguments e* r s k)
    (if (pair? e*)
        (evaluate (car e*) r s
          (lambda (v ss)
            (evaluate-arguments (cdr e*) r ss
              (lambda (v* sss)
                (k (cons v v*) sss) ) ) ) )
        (k '() s) ) )
  (evaluate e r s
    (lambda (f ss)
      (evaluate-arguments e* r ss
        (lambda (v* sss)
          (if (eq? (f 'type) 'function)
              ((f 'behavior) v* sss k)
              (wrong "Not a function" f) ) ) ) ) ) )
\end{code:lisp}</p>


<!--\indexE{behavior@\protect<code><span class="func">'behavior</span></code>}-->
<p>Здесь функция, которая обычно называлась <code><span class="func">evlis</span></code>, является локальной и
называется <code><span class="func">evaluate-arguments</span></code>. Она вычисляет аргументы слева направо и
собирает их в список. Затем функция (первый элемент формы) применяется
к аргументам вместе с памятью после их вычисления и продолжением вызова функции.
Обратите внимание на то, как лаконично и точно записаны эти идеи.</p>

<p>Функции представляются специальными замыканиями, так что напрямую их применять
нельзя. Поэтому вводится сообщение <code><span class="func">behavior</span></code> для извлечения поведения
функции: кода, который будет применён к аргументам.</p>

<h3 id="assignment/implementation/ssect:abstraction">Абстракция</h3>


<!--\indexCS{lambda}{и память}-->
<p>Для простоты будем считать, что специальная форма <code><span class="func">lambda</span></code> поддерживает
только функции с фиксированным количеством аргументов. При создании функции
происходит две вещи: в памяти выделяется ячейка, затем создаётся особый объект
— замыкание, — которое и размещается в только что выделенной ячейке
памяти. Очевидно, что созданную функцию надо где-то хранить для дальнейшего
использования, поэтому форма <code><span class="func">lambda</span></code> вынуждена изменять состояние памяти.
Работа по созданию и сохранению замыканий перекладывается на функцию
<code><span class="func">create-function</span></code>, которой передаётся адрес выделенного участка памяти и код
функции — именно тот, который должно вернуть замыкание в ответ на сообщение
<code><span class="func">behavior</span></code>.</p>


<!--\indexC{evaluate-lambda}-->
<p>\begin{code:lisp}
(define (evaluate-lambda n* e* r s k)
  (allocate 1 s
    (lambda (a* ss)
      (k (create-function
          (car a*)
          (lambda (v* s k)
            (if (= (length n*) (length v*))
                (allocate (length n*) s
                  (lambda (a* ss)
                    (evaluate-begin e*
                                    (update* r  n* a*)
                                    (update* ss a* v*)
                                    k ) ) )
                (wrong "Incorrect arity") ) ) )
          ss ) ) ) )
\end{code:lisp}</p>

<p>При вызове функции, созданной <code><span class="func">lambda</span></code>, сначала проверяется количество
переданных аргументов, затем в памяти в момент вызова выделяется место для
аргументов функции, после чего они инициализируются переданными значениями и,
наконец, управление передаётся собственно функции.</p>


<!--\indexR{функции!в Фортране}-->
<p>Возможен и другой вариант реализации:</p>

<p>\begin{code:lisp}
(define (evaluate-ftn-lambda n* e* r s k)
  (allocate (+ 1 (length n*)) s
    (lambda (a* ss)
      (k (create-function
          (car a*)
          (lambda (v* s k)
            (if (= (length n*) (length v*))
                (evaluate-begin e*
                                (update* r n* (cdr a*))
                                (update* s (cdr a*) v*)
                                k )
                (wrong "Incorrect arity") ) ) )
      ss ) ) ) )
\end{code:lisp}</p>

<p>\noindent
В этом случае место в памяти под аргументы выделяется один раз при создании
замыкания; так поступает, например, Фортран. Но, к сожалению, такой подход
лишает нас рекурсии, ведь теперь нет возможности хранить несколько отдельных
наборов аргументов для каждого вызова функции. В Фортране подобное решение
принято по той причине, что раз там нет динамического создания функций, то
память для аргументов можно выделить ещё при компиляции, что приводит к росту
производительности. Правда, ценой рекурсии и замыканий — главных достоинств
функциональных языков.</p>

<h3 id="assignment/implementation/ssect:memory">Память</h3>


<!--\indexR{сборка мусора}-->
<p>Память представляется функцией, принимающей адреса и возвращающей значения.
Кроме этого нам нужна возможность выделять в памяти новые адреса, гарантированно
свободные для использования; этим будет заниматься функция <code><span class="func">allocate</span></code>. Она
принимает три аргумента: необходимое количество адресов, память и продолжение,
которому она передаст список выделенных адресов и новое состояние памяти, где по
соответствующим адресам хранятся значения «не инициализировано». Именно на эту
функцию возложена вся работа по управлению памятью, в частности, сборка мусора.
Это отдельная сложная тема,\trnote*{Достаточно неплохое введение в сборку мусора
есть в первом томе «Искусства программирования» Дональда Кнута.} которой мы
не будем здесь касаться и предположим, что память у нас бесконечная —
то есть мы всегда можем найти необходимое количество свободных адресов.</p>


<!--\indexC{allocate}-->
<p>\begin{code:lisp}
(define (allocate n s k)
  (if (> n 0)
      (let ((a (new-location s)))
        (allocate (- n 1)
                  (expand-store a s)
                  (lambda (a* ss)
                    (k (cons a a*) ss) ) ) )
      (k '() s) ) )
\end{code:lisp}</p>

<p>Функция <code><span class="func">new-location</span></code> ищет первый свободный адрес в памяти. Это настоящая
чистая функция в том смысле, что <code><span class="func">(eqv? (new-location s) (new-location s))</span></code>
всегда возвращает истину. Если выделять ячейки в памяти последовательно, то
достаточно будет хранить последний выделенный адрес для определения следующего
свободного. Резервируется ячейка памяти с помощью функции <code><span class="func">expand-store</span></code>.</p>


<!--\indexC{expand-store}-->
<!--\indexC{new-location}-->
<p>\begin{code:lisp}
(define (expand-store high-location s)
  (update s 0 high-location) )</p>

<p>(define (new-location s)
  (+ 1 (s 0) ) )
\end{code:lisp}</p>

<p>Как видим, адрес последней выделенной ячейки сам хранится в памяти по адресу 0.
Память отзывается на два типа сообщений: запрос адреса свободной ячейки (при
передаче нуля) и запрос значения по адресу (при передаче иных адресов). Это
просто и удобно для реализации. Естественно, также необходимо определить
изначальное состояние памяти, где не выделено ни одной ячейки:</p>


<!--\indexC{s.init}-->
<p>\begin{code:lisp}
(define s.init
  (expand-store 0 (lambda (a) (wrong "No such address" a))) )
\end{code:lisp}</p>

<p>
\subsection{Представление значений}%
\label{assignment/implementation/ssect:values}</p>

<p>Мы решили представлять данные внутри интерпретатора в виде замыканий,
обменивающихся сообщениями. Для простоты ограничимся пустым списком, булевыми
значениями, символами, числами, точечными парами и функциями. Рассмотрим эти
типы данных по очереди.</p>


<!--\indexE{type@\protect<code><span class="func">'type</span></code>}-->
<!--\indexE{boolify@\protect<code><span class="func">'boolify</span></code>}-->
<p>Все значения будут основываться на функции, которая отвечает как минимум на два
сообщения: 1) запрос типа (<code><span class="func">type</span></code>); 2) приведение к логическому типу
(<code><span class="func">boolify</span></code>). Значения конкретных типов данных будут реагировать на свои
специфичные сообщения. Таким образом, все определения значений имеют следующий
скелет:</p>

<p>\begin{code:lisp}
(lambda (msg)
  (case msg
    ((type)    ...)
    ((boolify) ...)
    ... ) )
\end{code:lisp}</p>

<p>Существует только один пустой список и, в соответствии с \RnRS, для <code><span class="func">if</span></code> он
является истиной.</p>


<!--\indexC{the-empty-list}-->
<p>\begin{code:lisp}
(define the-empty-list
  (lambda (msg)
    (case msg
      ((type)    'null)
      ((boolify) (lambda (x y) x)) ) ) )
\end{code:lisp}</p>

<p>Булевы значения создаются функцией <code><span class="func">create-boolean</span></code>:</p>


<!--\indexC{create-boolean}-->
<p>\begin{code:lisp}
(define (create-boolean value)
  (let ((combinator (if value (lambda (x y) x)
                              (lambda (x y) y) )))
    (lambda (msg)
      (case msg
        ((type)    'boolean)
        ((boolify) combinator) ) ) ) )
\end{code:lisp}</p>


<!--\indexE{name@\protect<code><span class="func">'name</span></code>}-->
<p>Символы имеют имя, которое они назовут, если их вежливо попросить с помощью
<code><span class="func">name</span></code>. Мы будем представлять их имена родными символами Scheme.</p>


<!--\indexC{create-symbol}-->
<p>\begin{code:lisp}
(define (create-symbol v)
  (lambda (msg)
    (case msg
      ((type)    'symbol)
      ((name)    v)
      ((boolify) (lambda (x y) x)) ) ) )
\end{code:lisp}</p>


<!--\indexE{value@\protect<code><span class="func">'value</span></code>}-->
<p>Числа же будут отвечать на сообщение <code><span class="func">value</span></code>:</p>


<!--\indexC{create-number}-->
<p>\begin{code:lisp}
(define (create-number v)
  (lambda (msg)
    (case msg
      ((type)    'number)
      ((value)    v)
      ((boolify) (lambda (x y) x)) ) ) )
\end{code:lisp}</p>


<!--\indexE{behavior@\protect<code><span class="func">'behavior</span></code>}-->
<!--\indexE{tag@\protect<code><span class="func">'tag</span></code>}-->
<p>Функции имеют более развитый словарный запас из двух сообщений: <code><span class="func">tag</span></code>
и <code><span class="func">behavior</span></code>. Сообщение <code><span class="func">behavior</span></code>, конечно же, вернёт код функции;
<code><span class="func">tag</span></code> хранит адрес, по которому эта функция расположена в памяти.</p>


<!--\indexC{create-function}-->
<p>\begin{code:lisp}
(define (create-function tag behavior)
  (lambda (msg)
    (case msg
      ((type)     'function)
      ((boolify)  (lambda (x y) x))
      ((tag)      tag)
      ((behavior) behavior) ) ) )
\end{code:lisp}</p>


<!--\indexR{точечные пары!представление}-->
<!--\indexR{представление!точечных пар}-->
<!--\indexC{cdr}-->
<p>Остались только точечные пары. Точечная пара — это объект, состоящий из
двух значений, каждое из которых можно изменять независимо. Поэтому мы будем их
представлять в виде двух адресов: один будет ссылаться на <code><span class="func">car</span></code>, второй —
на <code><span class="func">cdr</span></code>. Это может показаться необычным, так как традиционно точечные пары
представляются не двумя отдельными коробками, а одной коробкой с двумя
отделениями.\footnote*{Причём по результатам серьёзных исследований
вроде \cite{cla79,cg77}, желательно, чтобы значение <code><span class="func">cdr</span></code> (а не <code><span class="func">car</span></code>),
было доступно непосредственно. Другим преимуществом такого расположения может
быть то, что точечные пары используются для представления связных списков,
поэтому можно ввести общий класс «связных объектов» с единственным
полем <code><span class="func">cdr</span></code>.} Это бы позволило чуть быстрее обращаться к её компонентам, а
также применить известную технику размещения точечных пар в параллельных
массивах: хранить <code><span class="func">car</span></code> и <code><span class="func">cdr</span></code> пар в двух отдельных массивах, но по
одинаковым индексам; тогда адресом пары будет именно этот индекс. Но мы
останемся верны идее привязок и будем хранить пары в виде двух адресов.</p>

<p>Для удобства мы также введём функцию, выделяющую в памяти целые списки. Она
принимает список значений, которые необходимо разместить в памяти, собственно
память и продолжение, которому эта функция передаст созданный список и новое
состояние памяти.</p>


<!--\indexC{allocate-list}-->
<!--\indexC{allocate-pair}-->
<!--\indexC{create-pair}-->
<p>\begin{code:lisp}
(define (allocate-list v* s k)
  (define (consify v* k)
    (if (pair? v*)
        (consify (cdr v*) (lambda (v ss)
                            (allocate-pair (car v*) v ss k) ))
        (k the-empty-list s) ) )
  (consify v* k) )</p>

<p>(define (allocate-pair a d s k)
  (allocate 2 s
   (lambda (a* ss)
     (k (create-pair (car a*) (cadr a*))
        (update (update ss (car a*) a) (cadr a*) d) ) ) ) )</p>

<p>(define (create-pair a d)
  (lambda (msg)
    (case msg
      ((type)    'pair)
      ((boolify) (lambda (x y) x))
      ((set-car) (lambda (s v) (update s a v)))
      ((set-cdr) (lambda (s v) (update s d v)))
      ((car)     a)
      ((cdr)     d) ) ) )
\end{code:lisp}</p>

<p>
\subsection{Сравнение с объектным подходом}%
\label{assignment/implementation/ssect:cmp-to-oop}</p>


<!--\indexR{замыкания (closures)!и объекты}-->
<!--\indexR{объекты!как замыкания}-->
<p>Замыкания, реагирующие на сообщения, с помощью которых мы представляем значения
внутри интерпретатора, во многом напоминают объекты из предыдущей главы. Тем
не менее, между подобными объектами-замыканиями и объектами {\Meroonet} есть
ряд отличий. Объекты-замыкания хранят поддерживаемые методы внутри; нет
возможности добавлять однажды созданным объектам новые методы. Понятия классов
и подклассов здесь присутствуют лишь умозрительно. В то же время, обобщённые
функции позволяют расширять поведение объектов в любое время и в любом месте.
С помощью обобщённых функций можно реализовать как методы, так и мультиметоды.
Объекты из предыдущей главы поддерживают наследование, что позволяет выносить
общие свойства в базовые классы, избегая дублирования кода. Поэтому не стоит
думать об объектах как о «замыканиях для бедных», как считают некоторые
фанатики Scheme, ведь даже объекты из предыдущей главы оказались значительно
выразительнее. Хотя это не значит, что замыкания ни на что не способны
<span class="cite">[<a href="z1_bibliography.xhtml#ar88">ar88</a>]</span>.</p>

<h3 id="assignment/implementation/ssect:init-env">Начальное окружение</h3>

<p>Как обычно, мы определим два вспомогательных макроса, которые помогут создать
начальное окружение (а также состояние памяти). Под каждую глобальную переменную
необходимо выделить ячейку памяти, адрес которой будет храниться в глобальном
окружении. Макрос <code><span class="func">definitial</span></code> выделяет память и кладёт туда указанное
значение.</p>


<!--\indexC{s.global}-->
<!--\indexC{r.global}-->
<!--\indexC{definitial}-->
<p>\begin{code:lisp}
(define s.global s.init)
(define r.global r.init)
|\ForLayout{display}{\vskip-0.4\baselineskip}|
(define-syntax definitial
  (syntax-rules ()
   ((definitial name value)
    (allocate 1 s.global
     (lambda (a* ss)
       (set! r.global (update r.global 'name (car a*)))
       (set! s.global (update ss (car a*) value)) ) ) ) ) )
\end{code:lisp}</p>

<p>\noindent
Макрос <code><span class="func">defprimitive</span></code> определяет глобальные функции.</p>


<!--\indexC{defprimitive}-->
<p>\begin{code:lisp}
(define-syntax defprimitive
  (syntax-rules ()
   ((defprimitive name value arity)
    (definitial name
     (allocate 1
      s.global
      (lambda (a* ss)
        (set! s.global (expand-store (car a*) ss))
        (create-function (car a*)
         (lambda (v* s k)
           (if (= arity (length v*))
               (value v* s k)
               (wrong "Incorrect arity" 'name ) )) ) ) ) ) ) ) )
\end{code:lisp}</p>

<p>По уже сложившейся традиции, определим глобальные переменные для истины, лжи
и пустого списка:</p>

<p>\begin{code:lisp}
(definitial t (create-boolean #t))
(definitial f (create-boolean #f))
(definitial nil the-empty-list)
\end{code:lisp}</p>

<p>В качестве примера определения примитивов покажем предикат и арифметическую
операцию. Они проверяют типы аргументов, извлекают значения, выполняют
соответствующие действия и упаковывают результат во внутреннее представление.</p>

<p>\begin{code:lisp}
(defprimitive <=
  (lambda (v* s k)
    (if (and (eq? ((car v*)  'type) 'number)
             (eq? ((cadr v*) 'type) 'number) )
        (k (create-boolean (<= ((car v*) 'value)
                               ((cadr v*) 'value) )) s)
        (wrong "Numbers required" '<=) ) )
  2 )
|\ForLayout{display}{\vskip-0.5\baselineskip}|
(defprimitive *
  (lambda (v* s k)
    (if (and (eq? ((car v*)  'type) 'number)
             (eq? ((cadr v*) 'type) 'number) )
        (k (create-number (* ((car v*) 'value)
                             ((cadr v*) 'value) )) s)
        (wrong "Numbers required" '*) ) )
  2 )
\end{code:lisp}</p>

<h3 id="assignment/implementation/ssect:dotted-pairs">Точечные пары</h3>

<p>Впервые точечные пары внутри нашего интерпретатора Scheme не представляются
родными точечными парами Scheme, на котором он написан.</p>

<p>Так как у нас есть функция <code><span class="func">allocate-pair</span></code>, то определить <code><span class="func">cons</span></code>
легко:</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>


<!--\indexC{cons}-->
<p>\begin{code:lisp}
(defprimitive cons
  (lambda (v* s k)
    (allocate-pair (car v*) (cadr v*) s k) )
  2 )
\end{code:lisp}</p>

<p>\noindent
С чтением и модификацией тоже нет проблем:</p>


<!--\indexC{car}-->
<!--\indexC{set-cdr"!}-->
<p>\begin{code:lisp}
(defprimitive car
  (lambda (v* s k)
    (if (eq? ((car v*) 'type) 'pair)
        (k (s ((car v*) 'car)) s)
        (wrong "Not a pair" (car v*)) ) )
  1 )
|\ForLayout{display}{\vskip-0.5\baselineskip}|
(defprimitive set-cdr!
  (lambda (v* s k)
    (if (eq? ((car v*) 'type) 'pair)
        (let ((pair (car v*)))
          (k pair ((pair 'set-cdr) s (cadr v*))) )
        (wrong "Not a pair" (car v*)) ) )
  2 )
\end{code:lisp}</p>

<p>Все значения представляются таким образом, что узнать их тип не составляет труда
— достаточно передать объекту сообщение <code><span class="func">type</span></code>. Поэтому написать предикат
<code><span class="func">pair?</span></code> тоже просто, надо только не забыть перевести результат сравнения
во внутреннее представление.</p>


<!--\indexC{pair"?}-->
<p>\begin{code:lisp}
(defprimitive pair?
  (lambda (v* s k)
    (k (create-boolean (eq? ((car v*) 'type) 'pair)) s) )
  1 )
\end{code:lisp}</p>

<p>\ForLayout{display}{\endgroup}% \lstset *skipamount</p>

<p>\subsection{Функция сравнения}%
\label{assignment/implementation/ssect:comparisons}</p>

<p>Одной из задач данного интерпретатора является иллюстрация реализации предиката
эквивалентности — <code><span class="func">eqv?</span></code>. Он проверяет, являются ли два объекта
взаимозаменимыми. Сначала он сравнивает типы объектов, затем, если они
совпадают, он проводит собственно сравнение. Символы должны иметь одинаковое
имя. Логические значения и числа должны быть одинаковыми. Точечные пары и
функции должны иметь одинаковые адреса.</p>


<!--\indexCS{eqv"?}{реализация}-->
<p>\begin{code:lisp}
(defprimitive eqv?
  (lambda (v* s k)
    (k (create-boolean
        (if (eq? ((car v*) 'type) ((cadr v*) 'type))
            (case ((car v*) 'type)
              ((null) #t)
              ((boolean)
               (((car v*) 'boolify)
                (((cadr v*) 'boolify) #t #f)
                (((cadr v*) 'boolify) #f #t) ) )
              ((pair)
               (and (= ((car v*) 'car) ((cadr v*) 'car))
                    (= ((car v*) 'cdr) ((cadr v*) 'cdr)) ) )
              ((symbol)
               (eq? ((car v*) 'name) ((cadr v*) 'name)) )
              ((number)
               (= ((car v*) 'value) ((cadr v*) 'value)) )
              ((function)
               (= ((car v*) 'tag) ((cadr v*) 'tag)) )
              (else #f) )
            #f ) )
       s ) )
  2 )
\end{code:lisp}</p>

<p>Собственно, единственная причина, по которой мы сохраняем адреса функций
(а точнее, замыканий) внутри объектов — это сравнение функций с помощью
<code><span class="func">eqv?</span></code>. Таким образом, вместо решения сложной проблемы эквивалентности
функций достаточно ответить на простой вопрос о равенстве адресов, которые суть
просто числа. Заметьте, что при сравнении точечных пар мы тоже сравниваем лишь
адреса компонент, а не их содержимое. Итого, <code><span class="func">eqv?</span></code> выполняется за
предсказуемое постоянное время, в отличие от <code><span class="func">equal?</span></code>.</p>

<p>Функция <code><span class="func">eqv?</span></code> похожа на обобщённую, только она содержит все методы внутри,
а в остальном — всё та же диспетчеризация по типу аргумента. Благодаря
выбранному представлению данных мы можем быстро провести проверку на
согласованность типов и перейти непосредственно к сравнению значений или
адресов, которое чаще всего тоже выполняется быстро (длинной арифметике
не повезло).</p>

<p>
\subsection{Запускаем интерпретатор}%
\label{assignment/implementation/ssect:starting}</p>

<p>Наконец, всё готово для запуска нашего интерпретатора. Главный цикл вызывает
<code><span class="func">evaluate</span></code> с рекурсивным продолжением, которое обеспечивает непрерывность
сознания интерпретатора, передавая следующему вызову память предыдущего.</p>


<!--\indexC{chapter4-interpreter}-->
<p>\begin{code:lisp}
(define (chapter4-interpreter)
  (define (toplevel s)
    (evaluate (read) r.global s
              (lambda (v ss)
                (display (transcode-back v ss))
                (toplevel ss) ) ) )
  (toplevel s.global) )
\end{code:lisp}</p>


<!--\indexR{представление!значений}-->
<p>Главной особенностью данного интерпретатора является отличие представления
данных интерпретируемого языка от представления данных в языке реализации.
Особенно разительно отличаются точечные пары и, следовательно, списки, поэтому
мы вынуждены воспользоваться функцией <code><span class="func">transcode-back</span></code> для преобразования
результата вычислений в нечто понятное <code><span class="func">display</span></code>, чтобы его можно было
вывести на экран. Эту вспомогательную функцию вполне можно сразу объединить
с примитивом <code><span class="func">display</span></code>.</p>


<!--\indexC{transcode-back}-->
<p>\begin{code:lisp}
(define (transcode-back v s)
  (case (v 'type)
    ((null)     '())
    ((boolean)  ((v 'boolify) #t #f))
    ((symbol)   (v 'name))
    ((number)   (v 'value))
    ((pair)     (cons (transcode-back (s (v 'car)) s)
                      (transcode-back (s (v 'cdr)) s) ))
    ((function) v)  ; почему бы и нет?
    (else       (wrong "Unknown type" (v 'type))) ) )
\end{code:lisp}</p>

<h2 id="assignment/sect:io-and-memory">Ввод-вывод и память</h2>


<!--\indexR{потоки ввода-вывода}-->
<p>Теперь поговорим о вводе-выводе. Если ограничиться одним потоком ввода и одним
потоком вывода (то есть функциями <code><span class="func">display</span></code> и <code><span class="func">read</span></code>), то достаточно
добавить каждой функции интерпретатора ещё два аргумента и передавать через них
эти потоки. Поток ввода содержит всё, что программа может прочитать, а поток
вывода содержит всё, что она туда написала. Можно даже предположить, что эти
потоки являются единственным средством связи программы с внешним миром.</p>

<p>Поток вывода можно легко представить списком пар (\ii{память}, \ii{значение}),
которые передаются функции <code><span class="func">transcode-back</span></code>. Но как представить поток ввода?
Хитрость здесь в том, что мы можем вводить и точечные пары со списками, а они
не могут существовать отдельно от памяти. Поэтому очевидно, что в случае чтения
точечных пар необходимо сохранять в памяти их компоненты. Переводчиком будет
служить функция <code><span class="func">transcode</span></code>, которая принимает значение языка реализации
(обозначим его <code><span class="func">c</span></code>), память и продолжение. Она переводит это значение
в представление реализуемого языка и передаёт его продолжению вместе с новым
состоянием памяти.</p>


<!--\indexC{transcode}-->
<p>\begin{code:lisp}
(define (transcode c s k)
  (cond
    ((null? c)    (k the-empty-list s))
    ((boolean? c) (k (create-boolean c) s))
    ((symbol? c)  (k (create-symbol c) s))
    ((number? c)  (k (create-number c) s))
    ((pair? c)
     (transcode (car c)
                s
                (lambda (a ss)
                  (transcode (cdr c)
                             ss
                             (lambda (d sss)
                               (allocate-pair a d sss k) ) ) ) ) )
    (else (wrong "Not supported" c)) ) )
\end{code:lisp}</p>

<p>На этом мы остановимся, так как дальнейшая реализация слишком объёмна, чтобы
приводить её здесь полностью: помимо примитивов <code><span class="func">read</span></code> и <code><span class="func">display</span></code>,
необходимо в каждой функции, которую мы написали до этого, расширить набор
аргументов <code><span class="func">e</span></code>, <code><span class="func">r</span></code>, <code><span class="func">s</span></code>, <code><span class="func">k</span></code> ещё двумя: <code><span class="func">i</span></code> и <code><span class="func">o</span></code>, через
которые и передавать потоки ввода-вывода подобно памяти (потому что они, как и
память, должны быть доступны отовсюду).</p>

<h2 id="assignment/sect:quotation">Семантика цитирования</h2>


<!--\indexR{семантика!цитирования}-->
<p>Наверное, вы уже заметили, что в этот раз мы как-то обошли стороной
цитирование. Форма <code><span class="func">quote</span></code> раньше всегда записывалась элементарно, но только
потому, что представление значений в интерпретируемом языке совпадало
с представлением значений в самом интерпретаторе. Теперь это не так, поэтому
определять <code><span class="func">quote</span></code> следующим образом нельзя:</p>

<p>\begin{code:lisp}
(define (evaluate-quote v r s k)  |\dialect{Ошибка!}|
  (k v s) )
\end{code:lisp}</p>

<p>Здесь ошибочно считается, что <code><span class="func">v</span></code> — это именно то значение, которое
необходимо вернуть. В смысле, конечно, это именно то, что надо, но это значение
записано на языке, которого наш интерпретатор не понимает. В предыдущих главах
интерпретатор пользовался языком реализации, но теперь ему необходим переводчик
— <code><span class="func">transcode</span></code>. Поэтому (более-менее) правильное определение цитирования
выглядит так:</p>


<!--\indexC{evaluate-quote}-->
<p>\begin{code:lisp}
(define (evaluate-quote c r s k)
  (transcode c s k) )
\end{code:lisp}</p>


<!--\indexR{цитаты!композициональность}-->
<!--\indexR{композициональность!цитат}-->
<p>Такое определение цитирования <em class="term">композиционально</em> — его смысл зависит
только от аргумента <code><span class="func">c</span></code>, оно не учитывает контекст (значения других
переменных). Но, к сожалению, точный смысл таких цитат немного отличается от
того, который обычно подразумевается в Лиспе и Scheme. Рассмотрим выражение
<code><span class="func">(quote (a . b))</span></code>. По определению оно <em>в точности</em> эквивалентно
<code><span class="func">(cons 'a 'b)</span></code>.\footnote*{Ещё точнее: \ic{'(a . b) {\equals} `(,'a . ,'b)}.}
Когда мы цитируем составной объект вроде точечной пары <code><span class="func">(a . b)</span></code>, мы создаём
новую пару в памяти. Таким образом, такое цитирование — это лишь краткая
запись для наших <code><span class="func">create-</span></code>функций. Поэтому ничуть не удивительно, что
следующее выражение возвращает ложь:</p>

<p>\begin{code:lisp}
(let ((foo (lambda () '(f o o))))
  (eq? (foo) (foo)) )
\end{code:lisp}</p>


<!--\indexR{эквивалентность!цитат}-->
<!--\indexR{цитаты!эквивалентность}-->
<!--\indexR{мемоизация!цитат}-->
<p>Функция <code><span class="func">foo</span></code> каждый раз создаёт новый список; все создаваемые значения
независимы, различны в смысле <code><span class="func">eq?</span></code>. Если мы хотим, чтобы данное выражение
всегда возвращало истину, нам необходимо доработать <code><span class="func">evaluate-quote</span></code> так,
чтобы она возвращала идентичные значения, а не эквивалентные; для этого она
должна запоминать всё, что возвращала ранее. Это называется <em class="term">мемоизация</em>.
Одной из причин желательности такого поведения является то, что если в языке нет
побочных эффектов и <code><span class="func">eq?</span></code>, то нельзя отличить идентичные объекты от просто
эквивалентных, поэтому нет никакого смысла тратить память на бесполезные копии
эквивалентных объектов, когда можно обойтись одним экземпляром.</p>

<p>Конечно, если допускать побочные эффекты, то дело меняется, но всё же обычно
считается, что цитаты уникальны — как числа, символы и логические значения.</p>


<!--\indexC{evaluate-memo-quote}-->
<!--\indexC*{shared-memo-quotations}{*shared-memo-quotations*}-->
<p>\begin{code:lisp}
(define *shared-memo-quotations* '())
(define evaluate-memo-quote
  (lambda (c r s k)
    (let ((couple (assoc c *shared-memo-quotations*)))
      (if (pair? couple)
          (k (cdr couple) s)
          (transcode c s (lambda (v ss)
                           (set! *shared-memo-quotations*
                                 (cons (cons c v)
                                       *shared-memo-quotations* ) )
                           (k v ss) )) ) ) ) )
\end{code:lisp}</p>

<p>\phantomlabel{assignment/quotation/par:transform}
<!--\indexR{преобразование!перенос цитат}-->
Однако, такой вариант, во-первых, требует побочных эффектов и глобальной
переменной, чего хотелось бы избежать, а во-вторых, учёт используемых цитат
вполне можно выполнить и заранее, за что компилятор скажет нам спасибо: сначала
мы переносим вычисление цитат в самое начало программы, затем заменяем все
обращения к цитатам ссылками на переменные, хранящие вычисленные ранее значения.
На предыдущем примере это выглядит так:</p>

<p>{\def\T{\hbox to 0pt{$\leadsto$}}
\begin{code:lisp}
(let ((foo (lambda () '(f o o))))    (define quote35 '(f o o))
  (eq? (foo) (foo)) )             |\T|   (let ((foo (lambda () quote35)))
                                       (eq? (foo) (foo)) )
\end{code:lisp}}</p>

<p>В итоге цитаты обретают должный смысл, а <code><span class="func">evaluate-quote</span></code> остаётся такой же
простой.</p>

<p>Можно было бы пойти и дальше, полностью избавившись от неоднозначностей,
связанных с цитированием составных объектов, сделав их создание явным:</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>

<p>\begin{code:lisp}
(define quote36 (cons 'o '())
(define quote37 (cons 'o quote36)
(define quote38 (cons 'f quote37)
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(let ((foo (lambda () quote38)))
  (eq? (foo) (foo)) )
\end{code:lisp}</p>

<p>И ещё дальше, на всякий случай гарантируя правильное цитирование символов
вручную:</p>

<p>\begin{code:lisp}
(define symbol39 (string->symbol "o"))
(define symbol40 (string->symbol "f"))
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(define quote36 (cons symbol39 '())
(define quote37 (cons symbol39 quote36)
(define quote38 (cons symbol40 quote37)
|\ForLayout{display}{\vskip-0.333\baselineskip}|
(let ((foo (lambda () quote38)))
  (eq? (foo) (foo)) )
\end{code:lisp}</p>

<p>Пожалуй, на этом остановимся. На языке ассемблера или Си строки можно
представлять непосредственно, так что было бы глупо разбивать их на отдельные
символы — а то так ведь можно и до элементарных частиц дойти!</p>

<p>В конце концов, композициональное определение цитирования оказывается
приемлемым, так как имеет простую формулировку, которая хоть и отличается по
смыслу от традиционного понимания цитирования, но это легко поправимо простым
дополнительным преобразованием программ.</p>


<!--\indexR{гомоиконичность}-->
<p>Однако, унифицированное представление кода и данных может сыграть с нами злую
шутку. С одной стороны это удобно: читать и данные, и программы с помощью одной
функции <code><span class="func">read</span></code>. Для того, чтобы она могла отличить формы-данные от
форм-программ, как раз и существует специальная форма <code><span class="func">quote</span></code>. Но в том-то
и дело, что после <code><span class="func">quote</span></code> данные становятся частью программы. Рассмотрим
пример:</p>

<p>\ForLayout{display}{\endgroup}</p>


<!--\indexC{vowel<=}-->
<p>\begin{code:lisp}
(define vowel<=
  (let ((vowels '(#\a #\e #\i #\o #\u)))
    (lambda (c1 c2)
      (memq c2 (memq c1 vowels)) ) ) )
|\ForLayout{display}{\vskip-\baselineskip}|
(set-cdr! (vowel<= #\a #\e) '())
(vowel<= #\o #\u) |\is| |\ii{?}|
\end{code:lisp}</p>

<p>При интерпретации этой программы есть высокая вероятность получить не <code><span class="func">\#t</span></code>,
а ошибку. И если после этого мы распечатаем определение <code><span class="func">vowel<=</span></code> (или
если бы <code><span class="func">vowels</span></code> была глобальной), то увидим следующее:</p>

<p>\begin{code:lisp}
(define vowel1<=
  (let ((vowels '(#\a #\e)))
    (lambda (c1 c2)
      (memq c2 (memq c1 vowels)) ) ) )
\end{code:lisp}</p>


<!--\indexR{свёртка констант}-->
<!--\indexR{константы}-->
<p>Ой, мы нечаянно кусок программы! Аналогично можно добавлять элементы в список
<code><span class="func">vowels</span></code> или изменять их. Правда, такие трюки можно проделывать только
в интерпретаторе; в случае компилятора мы скорее всего получим ошибку. Дело
в том, что если глобальная переменная <code><span class="func">vowel<=</span></code> неизменяема, то все формы
вроде <code><span class="func">(vowel<= \#\bslash a \#\bslash e)</span></code> могут быть вычислены ещё на
этапе компиляции, чем компилятор и пользуется, подставляя вместо них сразу
готовый результат. Такая оптимизация называется <em class="term">свёрткой констант</em>
(\english{constant folding}), её обобщением является техника частичных
вычислений <span class="cite">[<a href="z1_bibliography.xhtml#jgs93">jgs93</a>]</span>.</p>

<p>Компилятор также может решить подставить константы и в само определение функции
<code><span class="func">vowel<=</span></code> ради небольшого ускорения:</p>

<p>\begin{code:lisp}
(define vowel2<=
  (lambda (c1 c2)
    (case c1
      ((\#a) (memq c2 '(#\a #\e #\i #\o #\u)))
      ((\#e) (memq c2 '(#\e #\i #\o #\u)))
      ((\#i) (memq c2 '(#\i #\o #\u)))
      ((\#o) (memq c2 '(#\o #\u)))
      ((\#u) (eq? c2 #\u))
      (else  #f) ) ) )
\end{code:lisp}</p>


<!--\indexR{склеивание цитат}-->
<!--\indexR{цитаты!склеивание}-->
<p>Теперь выражения <code><span class="func">(eq? (cdr (vowel<= \#\bslash a \#\bslash e)) (vowel<=
\#\bslash e \#\bslash i))</span></code> имеет неопределённое значение. С одной стороны,
оно не должно быть истиной, так как сравниваемые значения принадлежат явно
различным цитатам. С другой стороны, иногда оно всё же истинно: компиляторы
часто оставляют за собой право оптимизировать расположение констант в памяти,
накладывая их друг на друга и превращая исходную программу в следующую:</p>

<p>\begin{code:lisp}
(define quote82 (cons #\u '()))
(define quote81 (cons #\o quote82))
(define quote80 (cons #\i quote81)
(define quote79 (cons #\e quote80)
(define quote78 (cons #\a quote79)</p>

<p>(define vowel3<=
  (lambda (c1 c2)
    (case c1
      ((\#a) (memq c2 quote78))
      ((\#e) (memq c2 quote79))
      ((\#i) (memq c2 quote80))
      ((\#o) (memq c2 quote81))
      ((\#u) (eq? c2 #\u))
      (else  #f) ) ) )
\end{code:lisp}</p>


<!--\indexR{константы}-->
<!--\indexR{связывание!неизменяемое}-->
<p>Такая оптимизация влияет на разделяемые цитаты и ломает <code><span class="func">eq?</span></code>. Есть простой
способ избежать всех этих проблем: запретить изменять цитаты. Именно так и
поступают Scheme и <span class="logo">Common Lisp</span>. Но они делают это мягко, в общем случае считая
результат изменения значения цитаты неопределённым.</p>

<p>Можно поступить более жёстко, запретив изменение цитат синтаксически:</p>


<!--\indexC{evaluate-immutable-quote}-->
<!--\indexC{immutable-transcode}-->
<!--\indexC{allocate-immutable-pair}-->
<!--\indexC{create-immutable-pair}-->
<p>\begin{code:lisp}
(define (evaluate-immutable-quote c r s k)
  (immutable-transcode c s k) )</p>

<p>(define (immutable-transcode c s k)
  (cond
    ((null? c)    (k the-empty-list s))
    ((pair? c)
     (immutable-transcode
      (car c) s (lambda (a ss)
                  (immutable-transcode
                   (cdr c) ss (lambda (d sss)
                                (allocate-immutable-pair
                                 a d sss k ) ) ) ) ) )
    ((boolean? c) (k (create-boolean c) s))
    ((symbol? c)  (k (create-symbol c) s))
    ((number? c)  (k (create-number c) s))
    (else (wrong "Not supported" c)) ) )</p>

<p>(define (allocate-immutable-pair a d s k)
  (allocate 2 s
   (lambda (a* ss)
     (k (create-immutable-pair (car a*) (cadr a*))
        (update (update ss (car a*) a) (cadr a*) d) ) ) ) )</p>

<p>(define (create-immutable-pair a d)
  (lambda (msg)
    (case msg
      ((type)    'pair)
      ((boolify) (lambda (x y) x))
      ((set-car) (lambda (s v) (wrong "Immutable pair")))
      ((set-cdr) (lambda (s v) (wrong "Immutable pair")))
      ((car)     a)
      ((cdr)     d) ) ) )
\end{code:lisp}</p>

<p>В таком случае любая попытка модифицировать цитату обречена на провал. Подобным
образом можно ввести неизменяемые строки (как это сделано, например, в Mesa),
неизменяемые векторы и т. д.</p>


<!--\indexR{цитаты!циклических объектов}-->
<!--\indexR{циклические структуры данных}-->
<p>Подводя итог, лучше воспользоваться мудростью поколений и, как советуют Scheme и
<span class="logo">Common Lisp</span>, стараться не изменять значения цитат. Но это не последняя из
проблем, вызываемых цитированием. Мы уже упоминали методику «склеивания»
цитат, приводящую к физическому наложению данных. А можно ли намеренно создать
цитату с таким эффектом? Есть как минимум два способа это сделать: макросы и
программируемый поток ввода.</p>


<!--\indexR{макросимволы}-->
<p>В <span class="logo">Common Lisp</span> можно вводить специальные макросимволы, при чтении которых
вызываются определённые процедуры. Например, <code><span class="func">'</span></code> является именно
макросимволом, оборачивающим следующее прочитанное выражение в <code><span class="func">quote</span></code>. Или
\ic{\#.\ii{выражение}}, вместо которого подставляется значение \ii{выражения};
то есть следующее за <code><span class="func">\#.</span></code> выражение считывается, вычисляется%
\footnote{Окружение и продолжение вычислений выбираются на усмотрение
реализации.} и его значение подставляется вместо всей конструкции. В итоге, мы
можем написать так:</p>

<p>\begin{code:lisp}
(define bar (quote #.(let ((list '(0 1)))     |\dialect<span class="logo">Common Lisp</span>|
                       (set-cdr! (cdr list) list)
                       list )))
\end{code:lisp}</p>

<p>\noindent
После этого переменная <code><span class="func">bar</span></code> будет содержать бесконечный список из
чередующихся нулей и единиц. С помощью <code><span class="func">\#.</span></code> мы процитировали пару, чей
<code><span class="func">cddr</span></code> равен ей самой. В CLtL2 <span class="cite">[<a href="z1_bibliography.xhtml#ste90">ste90</a>]</span> прямым текстом написано, что
<code><span class="func">\#.</span></code> и существует для ввода таких неудобных значений. Если мы захотим
реализовать такое поведение у себя, то это немного усложнит трансформацию
программ (которая выносит вычисление цитат в начало), так как она должна будет
учитывать возможность циклов.</p>

<p>Хорошая новость: в Scheme так писать нельзя, так как <code><span class="func">read</span></code>
не программируется и макросимволы не поддерживаются. Плохая новость: в Scheme
есть просто макросы, с помощью которых можно добиться того же результата. Форма
<code><span class="func">define-syntax</span></code>, правда, такого не позволяет, поэтому мы используем
<code><span class="func">define-abbreviation</span></code> — макрос для определения макросов, который детально
рассматривается в девятой главе. \seePage[chapter:macros]</p>


<!--\indexC{cycle}-->
<p>\begin{code:lisp}
(define-abbreviation (cycle n)
  (let ((c (iota n)))           ; <code><span class="func">(iota 3)</span></code> {\is} <code><span class="func">(0 1 2 3)</span></code>
    (set-cdr! (last-pair c) c)  ; <code><span class="func">(last-pair '(1 2 3))</span></code> {\is} <code><span class="func">(3)</span></code>
    `(quote ,c) ) )
(define bar (cycle 2))
\end{code:lisp}</p>

<p>% ## -- чтобы TeX не считал #n за аргумент команды
<!--\indexE{##n##@\ic{\#\ii{n}\#}, \ic{\#\ii{n}=}}-->
Таким образом в Scheme определяется циклический список из нулей и единиц,
подставляемый в цитату, которой инициализируется переменная <code><span class="func">bar</span></code>. Мы
не можем написать такой список прямым текстом в определении <code><span class="func">bar</span></code>, так как
<code><span class="func">read</span></code> Scheme не умеет считывать циклические данные. В <span class="logo">Common Lisp</span> это
возможно с помощью макросимволов \ic{\#\ii{n}=} и \ic{\#\ii{n}\#}\footnote{Здесь
считываемый объект ссылается на самого себя. Следовательно, функция <code><span class="func">read</span></code>
должна уметь создать в памяти точечную пару, «зациклить» её и подставить адрес
на место макроса. Ей также желательно быть достаточно сообразительной, чтобы
не попасть впросак на чём-нибудь вроде <code><span class="func">\#1=\#1\#</span></code>.}:</p>

<p>\begin{code:lisp}
(define bar #1=(0 1 . #1#))
\end{code:lisp}</p>

<p>В настоящее время в Scheme подобные списки нельзя записывать непосредственно
в виде <em class="term">литералов</em>, только создавать вручную за несколько шагов. Поэтому и
цитировать подобные структуры можно только лишь с помощью ухищрений вроде
макросов.</p>

<p>Девятая глава будет посвящена подробному рассмотрению макросов, их возможностей,
ограничений и вызываемых ими проблем. \seePage[chapter:macros]</p>

<h2 id="assignment/sect:conclusions">Заключение</h2>

<p>Данная глава содержит колоссальное количество советов и описанных подводных ям.
Глобальные переменные таят множество неоднозначностей, которых становится ещё
больше с появлением модулей. Универсального определения равенства нет даже
в математике, что уж говорить о программировании. Наконец, цитирование также
отнюдь не такое простое, каким кажется; от витиеватых цитат стоит
воздерживаться.</p>

<h2 id="assignment/sect:exercises">Упражнения</h2>

<p>\begin{exercise}\label{assignment/ex:pure-min-max}
Определите чистую (без побочных эффектов) функцию <code><span class="func">min-max</span></code>.
\end{exercise}</p>

<p>\begin{exercise}\label{assignment/ex:lambda-cons}
<!--\indexR{чисто функциональные структуры данных}-->
<!--\indexR{точечные пары!чисто функциональные}-->
Точечные пары, которые мы реализовали с помощью замыканий, реагируют на
сообщения-символы. Запретите модификацию пар (<code><span class="func">set-car!</span></code> и <code><span class="func">set-cdr!</span></code>)
и реализуйте их, используя исключительно <code><span class="func">lambda</span></code>-формы.
\end{exercise}</p>

<p>\begin{exercise}\label{assignment/ex:destructive-eq}
Определите <code><span class="func">eq?</span></code> для точечных пар с помощью <code><span class="func">set-car!</span></code> или <code><span class="func">set-cdr!</span></code>.
\end{exercise}</p>

<p>\begin{exercise}\label{assignment/ex:form-or}
<!--\indexR{поиск с возвратом}-->
<!--\indexC{or}-->
Определите новую специальную форму <code><span class="func">(or $\alpha$ $\beta$)</span></code>, которая
возвращает значение $\alpha$, если оно приводится к истине; иначе <code><span class="func">or</span></code>
откатывает все побочные эффекты вычисления $\alpha$ и возвращает
значение $\beta$.
\end{exercise}</p>

<p>\begin{exercise}\label{assignment/ex:previous-value}
Присваивание в текущем варианте возвращает только что присвоенное значение.
Перепишите <code><span class="func">set!</span></code> так, чтобы она возвращала значение переменной до
присваивания.
\end{exercise}</p>

<p>\begin{exercise}\label{assignment/ex:apply/cc}
Определите функции <code><span class="func">apply</span></code> и <code><span class="func">call/cc</span></code> для интерпретатора из этой главы.
\end{exercise}</p>

<p>\begin{exercise}\label{assignment/ex:dotted}
Встройте в интерпретатор поддержку функций переменной арности (с точечным
аргументом).
\end{exercise}</p>

<p></body>
</html>
