<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru"></p>

<p><body>
\chapter{Квинтэссенция объектной системы}\label{chapter:objects}</p>

<p>\initial{0.5ex}{0.25ex}{О}{\kern0.5ex бъекты!} Ах, что бы мы без них делали? В этой
главе рассматривается реализация объектной системы, повсеместно используемой
в данной книге. Мы намеренно разберём лишь часть её возможностей, дабы
не перегружать изложение несущественными деталями. Действительно, хотелось бы
ограничиться тем, что Франсуа Рабле называл <em class="term">substantifique moelle</em>, —
сердцевиной объектной системы, её квинтэссенцией.</p>


<!--\indexE{Meroon@\protect\MeroonMeroonet}-->
<p>Эта объектная система называется {\Meroon}.\footnote*{Вообще так звали
плюшевого мишку моего сына, но если хотите, можете считать это имя акронимом и
придумать ему какую-нибудь расшифровку.} Подобные системы весьма сложны и
требуют существенных усилий, чтобы оставаться одновременно эффективными и
переносимыми. Как результат, её архитектура во многом продиктована, а кое-где и
искажена тревогами о переносимости. Поэтому здесь мы будем рассматривать более
аккуратную уменьшенную версию {\Meroon}, называемую {\Meroonet}.%
\footnote*{Полные исходные коды обеих систем — {\Meroon} и {\Meroonet} —
можно найти на сервере, адрес которого приведён на
странице \pageref{pref/sect:source}.}</p>

<div class="bigskip"/>


<!--\indexR{объекты}-->
<p>Лисп уже долгое время идёт рука об руку с объектами. Именно на Лиспе изначально
был реализован Smalltalk — один из первых объектно-ориентированных языков.
С тех пор Лисп, являясь прекрасным инструментом разработки, послужил колыбелью
для множества исследований на тему объектов. Упомянем лишь пару из них: Flavors,
которая разрабатывалась в компании Symbolics как GUI-фреймворк, давшая миру идею
множественного наследования; Loops, созданная в Xerox PARC, благодаря которой
появились обобщённые функции. Кульминацией работ в этих направлениях являются
CLOS (<span class="logo">Common Lisp</span> Object System) и {\TELOS} (The <span class="logo">EuLisp</span> Object System). Они
объединяют большинство возможностей своих предшественников, но главной их
заслугой является введение объектов в систему типов языка. Таким образом эти
системы стали истинно объектно-ориентированными — в них всё состоит из
объектов.</p>

<p>По сравнению с другими языками, для объектных систем Лиспа характерны следующие
две особенности:</p>

<p>\begin{itemize}
  \item Обобщённые функции, а также мультиметоды, реализующие механизм
        <em>множественной диспетчеризации</em>.</p>

<p>
<!--\indexR{множественная диспетчеризация}-->

<!--\indexR{диспетчеризация!множественная}-->

<!--\indexR{мультиметоды}-->

<!--\indexR{методы!мультиметоды}-->
        Отправка сообщения записывается как \ic{(<i>сообщение</i>
        <i>аргументы</i>...)}, что синтаксически идентично вызову
        функции: \ic{(<i>функция</i> <i>аргументы</i>...)}. Мультиметоды же
        не предполагают, что получателем сообщения будет один-единственный
        объект, хоть чаще всего это именно так. Вместо этого методы
        считаются функциями классов существенных аргументов
        (дискриминантов). Например, вывод в поток числа в шестнадцатеричном
        виде не является методом исключительно чисел или только потоков,
        поведение данного метода определяется декартовым произведением
        типов: $\text{число} \times \text{поток}$.</p>

<p>  \item Рефлексия.</p>

<p>
<!--\indexR{метаобъектный протокол}-->

<!--\indexR{рефлексия}-->

<!--\indexR{интроспекция}-->
        Рефлексия — это способность системы осознавать собственную
        структуру. Такие системы реализуют понятие <em class="term">метаклассов</em>.
        Классы объектов в них сами являются полноценными объектами —
        экземплярами классов, называемых метаклассами, которые, в свою
        очередь, тоже являются объектами, и так далее. Спецификация
        этих метаобъектов именуется <em>метаобъектным протоколом</em>. Им
        определяется широта рефлексивных возможностей данной объектной
        системы: например, от простой интроспекции до полноценной
        самомодификации. Всё это даёт возможность точного и обратимого
        представления любых объектов в виде строк байтов, что необходимо
        для сохранения их в файлах, базах данных или передачи по сети.
        Кроме того, интроспекция чрезвычайно полезна при разработке как
        инструмент отладки кода, может существенно помочь компиляторам
        \seePage[macros/usage/ssect:code-walk], а также незаменима
        в распределённых системах <span class="cite">[<a href="z1_bibliography.xhtml#que94">que94</a>]</span>.
\end{itemize}</p>


<!--\indexE{Meroon@\protect\MeroonMeroonet!возможности}-->
<p>Нашим же вкладом в историю ООП в Лиспе станет {\Meroonet}. Будем надеяться, что
поставленные ограничения не оставят в тени отличные возможности данной системы.
Среди них:</p>

<p>\begin{itemize}
  \item Объектами {\Meroonet} можно выразить любые значения Scheme
        (включая векторы) без каких-либо ограничений на наследование.</p>

<p>  \item {\Meroonet} — это рефлексивная объектная система, где каждый
        класс является отдельным полноценным объектом, полностью доступным
        для изучения. Проблема бесконечной регрессии решается подобно
        ObjVlisp \cite{coi87,bc87}.</p>

<p>  \item Поддерживаются обобщённые функции <em>а-ля</em> CLOS <span class="cite">[<a href="z1_bibliography.xhtml#bdg+88">bdg+88</a>]</span>,
        но без мультиметодов.</p>

<p>  \item Очень эффективная реализация перечисленных возможностей.
\end{itemize}</p>

<p>Существует множество разнообразных объектных систем для семейства Лиспа в общем
и Scheme в частности, например, описанные в \cite{ar88,kes88,coi87,mnc+89,del89,
kdrb92}. {\Meroonet} отличается от них в нескольких аспектах:</p>

<p>\begin{itemize}
  \item Как было сказано ранее, {\Meroonet} реализует обобщённые функции
        Common Loops <span class="cite">[<a href="z1_bibliography.xhtml#bkk+86">bkk+86</a>]</span>, но не мультиметоды.</p>

<p>  \item Как и ObjVlisp, {\Meroonet} представляет классы полноценными
        объектами, что положительно сказывается на возможностях рефлексии.</p>

<p>  \item
<!--\indexR{множественное наследование}-->

<!--\indexR{наследование!множественное}-->
        {\Meroonet} презирает множественное наследование! Как только его
        семантика будет лучше изучена, а сформулированные в <span class="cite">[<a href="z1_bibliography.xhtml#dhhm92">dhhm92</a>]</span>
        проблемы — решены, тогда {\Meroonet} пересмотрит свою позицию.
        Возможно.</p>

<p>  \item Объекты {\Meroonet} непрерывны, то есть представляются векторами.
        Такая форма позволяет единообразно выражать любые типы данных,
        не привязываясь к конкретному языку и его конструкциям
        \cite{qc88,que95,que90a}.
\end{itemize}</p>

<p>Помимо собственно описания {\Meroonet}, мы также обсудим причины, по которым
было принято то или иное архитектурное решение. Некоторые из них продиктованы
выбором Scheme в качестве языка реализации. Эти решения, конечно же, могли бы
быть другими, если бы {\Meroonet} разрабатывалась, к примеру, для Си. Желая
упростить повествование, мы будем рассматривать реализацию снизу вверх, вводя
новые функции по мере необходимости. Описание возможностей {\Meroonet} здесь
приводится вместе с деталями их реализации, но вы также можете пользоваться
краткой документацией из третьей главы. \seePage[escape/actors/ssect:review]</p>

<h2 id="objects/sect:foundation">Основы</h2>


<!--\indexR{представление!объектов \protect\Meroonet}-->
<!--\indexR{классы!идентификаторы}-->
<!--\indexR{циклические структуры данных}-->
<p>Первое архитектурное решение касается способа представления объектов
{\Meroonet}. Для этого были выбраны непрерывные наборы значений. Такие структуры
данных в Scheme называются векторами. Первый элемент вектора (с индексом ноль)
будет хранить идентификатор класса, что позволяет легко определить, какому
классу принадлежит любой рассматриваемый объект. Наиболее очевидная реализация
такой связи — это прямая ссылка на соответствующий класс (на самый конкретный
из классов, которым принадлежит объект), но вместо этого мы пронумеруем классы и
будем ссылаться на них по этим номерам. Такой подход упростит вывод объектов на
экран с помощью стандартных средств Scheme, так как классы — это весьма
громоздкие объекты, чья внутренняя структура не особо интересна в данном
случае.\footnote*{Кроме того такой подход немного помогает сборщику мусора:
ему теперь надо проверять и запоминать на одну ссылку меньше.} Также классы
могут содержать циклические ссылки, а стандартная функция <code><span class="func">display</span></code> с ними
не во всех реализациях дружит и может выводить их, мягко говоря, странно. Позже,
при рассмотрении обобщённых функций и предикатов принадлежности, появятся и иные
причины для предпочтения чисел в качестве идентификаторов классов.</p>

<p>Однако, если классы пронумерованы, то нам однозначно понадобится способ
получения нужного класса по его номеру. Для этого все классы помещаются
в вектор. К сожалению, в Scheme (в отличие от <span class="logo">Common Lisp</span>) векторы
не расширяются автоматически, поэтому для простоты мы формально ограничим
максимально возможное количество классов, однако явно контролировать
фактическое соблюдение установленного ограничения не будем. Переменная
<code><span class="func">*class-number*</span></code> будет хранить индекс первого элемента в векторе
<code><span class="func">*classes*</span></code>, который ещё не занят каким-нибудь классом. Пока что это ноль,
но {\Meroonet} использует некоторое количество классов для своих нужд, поэтому
со временем начальное значение <code><span class="func">*class-number*</span></code> увеличится. Кроме того,
внутренний код {\Meroonet} можно считать абсолютно корректным, поэтому
<code><span class="func">number->class</span></code> не будет проверять, действительно ли переданное ей значение
является допустимым идентификатором класса.</p>


<!--\indexC*{maximal-number-of-classes}{*maximal-number-of-classes*}-->
<!--\indexC*{classes}{*classes*}-->
<!--\indexC*{class-number}{*class-number*}-->
<!--\indexC{number->class}-->
<pre>(define *class-number* 0)
(define *maximal-number-of-classes* 100)
(define *classes* (make-vector *maximal-number-of-classes* #f))</p>

<p>(define (number->class n)
  (vector-ref *classes* n) )</pre>


<!--\indexR{классы!имена}-->
<!--\indexR{переопределение!классов}-->
<!--\indexR{классы!переопределение}-->
<p>Обращаться к классам по номерам как-то невежливо, гораздо удобнее будет дать им
всем имена. Таким образом, анонимных классов не существует. Более того, их имена
должны быть известны статически, то есть классы нельзя динамически создавать
на лету. Функция <code><span class="func">->Class</span></code> преобразует символ в одноимённый класс. И снова,
для простоты в ней используется банальный линейный поиск, что приводит
к интересному побочному эффекту: если определить два класса с одинаковыми
именами, то <code><span class="func">->Class</span></code> гарантированно вернёт более новый из них. Это позволяет
в некотором смысле переопределять классы, но это «слабое» переопределение,
поэтому без веской причины лучше так не делать.</p>


<!--\indexC*{Class}{->Class}-->
<pre>(define (->Class name)
  (let scan ((index (- *class-number* 1)))
    (and (>= index 0)
         (let ((c (vector-ref *classes* index)))
           (if (eq? name (Class-name c))
               c
               (scan (- index 1)) ) ) ) ) )</pre>

<p>Обобщённые функции уже <em>обязаны</em> иметь имена. Они будут храниться в списке
<code><span class="func">*generics*</span></code>. Функция <code><span class="func">->Generic</span></code> преобразует символ в соответствующую
обобщённую функцию. (Причины такого решения обсудим чуть позже.)</p>


<!--\indexC*{Generic}{->Generic}-->
<pre>(define *generics* (list))</p>

<p>(define (->Generic name)
  (let lookup ((l *generics*))
    (if (pair? l)
        (if (eq? name (Generic-name (car l)))
            (car l)
            (lookup (cdr l)) )
        #f ) ) )</pre>

<h2 id="objects/sect:repr-obj">Представление объектов</h2>


<!--\indexR{представление!объектов \protect\Meroonet}-->
<!--\indexR{индексированные поля}-->
<!--\indexR{поля!индексированные}-->
<p>Как было сказано ранее, объекты {\Meroonet} представляются векторами. Мы хотим
иметь возможность представить любое значение Scheme в виде объекта {\Meroonet},
а для этого придётся что-то делать с самими векторами.\footnote*{Конечно, как
вариант, можно было бы схитрить и воспользоваться тем, что любой объект
{\Meroonet} — это уже фактически вектор, только из-за ссылки на класс
в начале следует вносить небольшую поправку при индексации.} Предлагается
следующее решение: ввести индексированные поля, хранящие несколько значений
вместо обычного одного. Эта идея была реализована ещё в Smalltalk <span class="cite">[<a href="z1_bibliography.xhtml#gr83">gr83</a>]</span>,
но там возникают некоторые трудности с наследованием от классов, содержащих
индексированные поля. {\Meroonet} не имеет подобного недостатка.</p>


<!--\indexR{представление!строк}-->
<p>Ещё одна проблема касается строк: ради эффективности они обычно считаются
примитивным типом данных. Тем не менее, принципиально их всё же можно понимать
как векторы символов — и не то, чтобы это было такой уж плохой идеей в свете
Юникода, где один символ может занимать вплоть до четырёх байтов. Однако,
в Scheme строкам нельзя добавить новые поля, так что неэффективные явные векторы
остаются единственным возможным вариантом представления строк в виде объектов
{\Meroonet}.</p>


<!--\indexR{поля!обычные}-->
<p>В {\Meroonet} поля бывают двух видов: обычные (представляемые объектами класса
<code><span class="func">Mono-Field</span></code>) и индексированные (им соответствует класс <code><span class="func">Poly-Field</span></code>).
Обычное поле является просто элементом вектора-объекта, тогда как
индексированное реализуется подобно строкам в Паскале: сначала идёт количество
элементов этого поля, затем собственно элементы. Рассмотрим наглядный пример.
Предположим, определён класс точек:</p>

<pre>(define-class Point Object (x y))</pre>

<p>Далее, пусть классу <code><span class="func">Point</span></code> соответствует номер 7; тогда значение точки,
созданной формой <code>(make-Point 11 22)</code>, представляется вектором <code>\#(7 11
22)</code>. Многоугольник можно определить как последовательность точек,
представляющих его вершины, перечисленные в некотором порядке обхода. Если
сделать класс <code><span class="func">Polygon</span></code> наследником <code><span class="func">Point</span></code>, то дополнительную пару
координат можно понимать как некую опорную точку фигуры (центр, например).</p>

<pre>(define-class Polygon Point ((* side)))</pre>


<!--\indexE{=@<code><span class="func">=</span></code> (в \protect\Meroon)}-->
<!--\indexE{*@<code><span class="func">*</span></code> (в \protect\Meroon)}-->
<p>Это пример расширенного синтаксиса описания полей, в таком случае их имена
записываются в скобках. Перед обычными полями ставится знак равенства, а перед
индексированными — звёздочка.\footnote*{Звёздочка используется в качестве
символа повторения, как это принято в нотации регулярных выражений, где данный
символ означает замыкание Клини.} Если нам понадобятся цветные многоугольники,
то соответствующий класс можно определить вот так:</p>

<pre>(define-class ColoredPolygon Polygon ((= color)))</pre>

<p>Каждое определение класса формирует для него личную армию функций, главной среди
которых является функция-конструктор, создающая соответствующие объекты. Её имя
состоит из префикса <code><span class="func">make-</span></code> и имени класса. Каждый создаваемый объект должен
иметь чётко определённое начальное состояние, то есть значения всех полей. Для
индексированных полей необходимо также указать их размер, который записывается
перед перечислением соответствующих значений. Рассмотрим, к примеру, создание
оранжевого треугольника (многоугольника с тремя вершинами) и получаемый
в результате вектор:</p>

<pre>(make-ColoredPolygon
  11                      ; $x$
  22                      ; $y$
  3 (make-Point 44 55)    ; 3 стороны
    (make-Point 66 77)
    (make-Point 88 99)
  'orange )               ; цвет</p>

<p>|$\to$| #(9             ; <code>(Class-number ColoredPolygon-class)</code>
       11          ; <code><span class="func">x</span></code>
       22          ; <code><span class="func">y</span></code>
       3           ; длина <code><span class="func">side</span></code>
       #(7 44 55)  ; <code><span class="func">side</span></code>$[0]$
       #(7 66 77)  ; <code><span class="func">side</span></code>$[1]$
       #(7 88 99)  ; <code><span class="func">side</span></code>$[2]$
       orange )    ; <code><span class="func">color</span></code></pre>


<!--\indexR{смещение}-->
<!--\indexR{индексы!в \protect\MeroonMeroonet}-->
<!--\indexC*{starting-offset}{*starting-offset*}-->
<!--\indexE{Scheme!проблемы типизации}-->
<!--\indexC{Object"?}-->
<p>Любой объект {\Meroonet} — это вектор, в котором первый элемент содержит
идентификатор класса данного объекта. Настало время немного упорядочить
терминологию; номер элемента вектора-объекта будем называть <em class="term">смещением</em>,
а к элементам индексированных полей будем обращаться по <em class="term">индексам</em>. Итак,
в объектах как минимум один элемент зарезервирован под внутренние нужды системы,
поэтому смещения полей класса будут начинаться со значения
<code><span class="func">*starting-offset*</span></code>. Тип объекта всегда можно узнать с помощью функции
<code><span class="func">object->class</span></code>.\footnote*{Эта функция аналогична функции <code><span class="func">class-of</span></code> из
<span class="logo">Common Lisp</span>, <span class="logo">EuLisp</span> и <span class="logo">ISLisp</span>. Как обычно, мы назвали её по-другому,
чтобы избежать ложных ассоциаций и позволить использовать несколько объектных
систем одновременно.} Выяснить, является ли некоторое значение объектом,
помогает предикат <code><span class="func">Object?</span></code>. К сожалению, Scheme не позволяет определять
новые типы данных, отличные от существующих. Можно хитрить и мудрить, но все
составные значения в конечном итоге принципиально остаются векторами либо
списками. Поэтому <code><span class="func">Object?</span></code> успешно распознаёт все объекты {\Meroonet}, но
при этом считает таковыми также любые векторы, начинающиеся на целое число.</p>


<!--\indexC{Object"?}-->
<!--\indexC{object->class}-->
<pre>(define *starting-offset* 1)</p>

<p>(define (object->class o)
  (vector-ref *classes* (vector-ref o 0)) )</p>

<p>(define (Object? o)
  (and (vector? o)
       (integer? (vector-ref o 0)) ) )</pre>


<!--\indexR{соглашения именования}-->
<!--\indexE{o @\protect<code><span class="func">o</span></code> (объекты)}-->
<!--\indexE{i @\protect<code><span class="func">i</span></code> (индексы)}-->
<!--\indexE{v @\protect<code><span class="func">v</span></code> (значения)}-->
<p>Завершим данное вступление, пожалуй, перечнем обозначений, которые будут
использоваться в этой главе:</p>

<p>\begin{center}\begin{tabular}{rl}
    <code><span class="func">o</span></code> & объекты  \\
    <code><span class="func">v</span></code> & значения \\
    <code><span class="func">i</span></code> & индексы
\end{tabular}\end{center}</p>

<h2 id="objects/sect:def-class">Определение классов</h2>


<!--\indexC{define-class}-->
<p>Классы определяются с помощью формы <code><span class="func">define-class</span></code>, принимающей три
аргумента:</p>

<p>\begin{enumerate}
  \item имя определяемого класса;
  \item имя его суперкласса;
  \item перечень собственных полей.
\end{enumerate}</p>


<!--\indexR{наследование}-->
<!--\indexR{классы!наследование}-->
<p>Создаваемый класс наследует все поля своего суперкласса, а также любые методы
обобщённых функций, определённые для него. В некоторых языках состояние (поля)
и поведение (методы) класса могут наследоваться отдельно друг от друга.</p>

<p>Синтаксис формы <code><span class="func">define-class</span></code> следующий:</p>

<pre>(define-class <i>имя-класса</i> <i>имя-суперкласса</i> (<i>поля</i>...))</pre>

<p>Поле в списке полей обозначается или просто своим именем (в таком случае это
будет обычное поле), или списком из имени и знака равенства (для обычных полей)
или звёздочки (для индексированных).</p>


<!--\indexR{функции!сопутствующие}-->
<!--\indexR{сопутствующие функции}-->
<!--\indexR{соглашения именования!сопутствющих функций}-->
<p>Кроме того, при определении класса автоматически создаются несколько
сопутствующих функций. (Надеюсь, они вам понравятся!)</p>

<p>\begingroup
\ForLayout{display}{\expandafter\setlist[itemize]{itemsep=\smallskipamount}}
\begin{itemize}
  \item
<!--\indexR{предикаты}-->
<!--\indexR{функции!предикаты}-->

<!--\indexR{классы!предикаты}-->
        <em class="term">Предикат</em>, распознающий объекты данного класса. Его имя,
        как принято в Scheme, состоит из имени класса и знака вопроса.</p>

<p>  \item
<!--\indexR{аллокаторы}-->
<!--\indexR{функции!аллокаторы}-->

<!--\indexR{классы!аллокаторы}-->
        <em class="term">Аллокатор</em>, создающий новые экземпляры класса, но
        не инициализирующий поля. Их начальные значения могут быть
        абсолютно любыми. Размеры индексированных полей при этом всё
        равно должны быть известны, поэтому аллокатор принимает столько
        аргументов-чисел, сколько у класса индексированных полей. Имя
        аллокатора состоит из префикса <code><span class="func">allocate-</span></code> и имени класса.</p>

<p>  \item
<!--\indexR{конструкторы}-->
<!--\indexR{функции!конструкторы}-->

<!--\indexR{классы!конструкторы}-->
        <em class="term">Конструктор</em>, который создаёт объекты класса с инициализированными
        полями. Значениям, составляющим индексированное поле, предшествует
        их количество. Имя конструктора состоит из префикса <code><span class="func">make-</span></code> и
        имени класса.</p>

<p>  \item
<!--\indexR{аксессоры}-->
<!--\indexR{функции!аксессоры}-->

<!--\indexR{поля!аксессоры полей}-->

<!--\indexR{классы!аксессоры}-->

<!--\indexR{селекторы}-->
<!--\indexR{геттеры}-->

<!--\indexR{мутаторы}-->
<!--\indexR{сеттеры}-->
        <em class="term">Аксессоры</em> для доступа к обычным и индексированным полям
        объектов. Каждому полю выдаётся один аксессор чтения (также
        называемый селектором или геттером), чьё имя состоит из имени
        класса и имени поля, разделённых дефисом. Соответствующий
        аксессор записи (сеттер или мутатор) называется аналогично,
        только начинается на <code><span class="func">set-</span></code> и, как обычно, заканчивается на
        восклицательный знак, чтобы подчеркнуть тот факт, что он изменяет
        состояние памяти. Аксессоры индексированных полей принимают
        дополнительный аргумент — индекс.</p>

<p>  \item Вдобавок ко всему, для каждого индексированного поля класса
        создаётся функция, чьё имя составлено из имени селектора и
        суффикса <code><span class="func">-length</span></code>. Очевидно, она возвращает длину
        соответствующего поля.
\end{itemize}
\endgroup</p>


<!--\indexR{рефлексия}-->
<p>Для поддержки рефлексии определяемый класс сам является объектом класса
<code><span class="func">Class</span></code>, представленным в программе глобальной переменной с именем, состоящим
из имени класса и суффикса <code><span class="func">-class</span></code>. В качестве примера рассмотрим функции и
переменные,\footnote*{Несмотря на то, что индексированные поля состоят из
нескольких значений, имена им лучше давать в единственном числе. Тогда выражения
вида \ic{(ColoredPolygon-side <i>o</i> <i>i</i>)} читаются естественнее:
«<i>i</i>-я сторона цветного многоугольника <i>o</i>». Слово <code><span class="func">sides</span></code>
выглядело бы тут странно, ведь мы обращаемся к одной стороне, а не нескольким.}
генерируемые формой <code>(define-class ColoredPolygon Point (color))</code>.</p>

<pre>(ColoredPolygon? o)                              |\,$\to$ \icc{логическое значение}|
(allocate-ColoredPolygon sides-number)                |$\to$ \icc{многоугольник}|
(make-ColoredPolygon x y sides-number sides... color) |$\to$ \icc{многоугольник}|
|\ForLayout{display}{\vskip-\baselineskip}|
(ColoredPolygon-x o)                                  |$\to$ \icc{значение}|
(ColoredPolygon-y o)                                  |$\to$ \icc{значение}|
(ColoredPolygon-side o index)                         |$\to$ \icc{значение}|
(ColoredPolygon-color o)                              |$\to$ \icc{значение}|</p>

<p>(set-ColoredPolygon-x! o value)                       |$\to$ \icc{не определено}|
(set-ColoredPolygon-y! o value)                       |$\to$ \icc{не определено}|
(set-ColoredPolygon-side! o value index)              |$\to$ \icc{не определено}|
(set-ColoredPolygon-color! o value)                   |$\to$ \icc{не определено}|</p>

<p>(ColoredPolygon-side-length o)                        |$\to$ \icc{число}|</p>

<p>ColoredPolygon-class                                  |$\to$ \icc{класс}|</pre>


<!--\indexCS{define-class}{состояние}-->
<!--\indexC{define-meroonet-macro}-->
<p>Специальная форма <code><span class="func">define-class</span></code>, создающая классы, реализуется в виде
макроса; к сожалению, со всеми вытекающими из этого последствиями. Первым из
них является то, что макрос <code><span class="func">define-class</span></code> обладает внутренним состоянием
— иерархией наследования, — но макросистема Scheme стандарта {\RnRS}
такого не позволяет. Поэтому предполагается, что существует макрос
<code><span class="func">define-meroonet-macro</span></code>, который может без ограничений определять всё
необходимое. Этот <em>интерфейс</em> является единственной непереносимой частью
{\Meroonet}, которую приходится писать вручную для каждой реализации Scheme.</p>


<!--\indexR{аксессоры!синтаксис}-->
<!--\indexR{синтаксис!аксессоров}-->
<!--\indexR{макросы!внутреннее состояние}-->
<p>А так ли необходимо глобальное состояние для <code><span class="func">define-class</span></code>? Ответ: да; для
{\Meroonet} в текущем виде, по крайней мере. И вот почему: вместе с классом
создаётся набор функций-аксессоров. При создании <code><span class="func">Point</span></code> автоматически
определяются функции <code><span class="func">Point-x</span></code> и <code><span class="func">Point-y</span></code> для доступа к полям <code><span class="func">x</span></code>
и <code><span class="func">y</span></code>. Когда же мы определяем его наследника <code><span class="func">Polygon</span></code>, {\Meroonet}
создаёт для этих полей новые аксессоры <code><span class="func">Polygon-x</span></code> и <code><span class="func">Polygon-y</span></code> вместо
того, чтобы просто оставить пользователю старые родительские. Определение
<code><span class="func">Polygon</span></code> не содержит описания полей своего суперкласса, об их количестве и
именах можно узнать только из определения самого класса <code><span class="func">Point</span></code>.
Следовательно, для правильной работы макроса <code><span class="func">define-class</span></code> требуется вести
учёт и где-то хранить родственные связи классов — это и есть то самое
внутреннее состояние.</p>

<p>\phantomlabel{objects/def-class/par:accessors}
Данного неудобства можно было бы избежать, применив другой подход к именованию
аксессоров. Например, если не упоминать в них имя класса: называть аксессоры
поля <code><span class="func">x</span></code> просто <code><span class="func">get-x</span></code> и <code><span class="func">set-x!</span></code>. В этом случае определение класса
<code><span class="func">Polygon</span></code> будет вынуждено модифицировать определение функции <code><span class="func">get-x</span></code>,
чтобы она знала, где в экземплярах <code><span class="func">Polygon</span></code> лежит поле <code><span class="func">x</span></code>. Наиболее
простой способ реализации такого поведения — это сделать аксессоры
обобщёнными функциями, для которых определяются методы всех классов, имеющих
соответствующие поля. Так сделано, например, в CLOS, где при определении поля
(слота) можно указать имя обобщённой функции, которой будет добавлен
метод-геттер (или сеттер, или оба сразу). В таком случае, очевидно, обобщённые
функции будут изменяемыми, что не совсем удобно при компиляции из-за усложнения
статического анализа кода и проведения оптимизаций.</p>

<p>Поэтому было решено сделать аксессоры обычными неизменяемыми функциями, что
гарантирует возможность оптимизаций вроде инлайнинга. Конечно, такое решение
тоже не лишено недостатков. Во-первых, функции <code><span class="func">Point-x</span></code> и <code><span class="func">Polygon-x</span></code>
не обязательно эквивалентны. По сути, они обе извлекают одно и то же
поле <code><span class="func">x</span></code>, но ведь первая делает это для точек, а вторая — для
многоугольников. Кажется логичным требовать, чтобы форма <code>(Polygon-x
(make-Point 11 22))</code> вызывала ошибку типизации, поэтому аксессоры <code><span class="func">Point-x</span></code>
и <code><span class="func">Polygon-x</span></code> должны быть разными. Кроме философских затруднений, у данного
решения есть и более прагматичное следствие: такой подход генерирует много
глобальных переменных и функций. Это может огорчить компьютеры с небольшим
объёмом памяти, но программы пишутся в первую очередь для людей, а у нас нет
особых проблем с запоминанием любого количества фактов, если они тщательно
систематизированы, подобно именам наших сопутствующих функций.</p>

<p>Знание полей суперклассов (инкапсулированное во внутреннем состоянии макроса
<code><span class="func">define-class</span></code>) полезно не только при создании аксессоров: если компилятору
статически известны количество и порядок всех полей, то он может генерировать
более эффективный код для аллокаторов и конструкторов. Чуть позже мы обсудим
это в деталях.</p>

<p>В свете рассмотренных соображений, для {\Meroonet} применяется следующее
решение: определение класса приводит к созданию экземпляра класса <code><span class="func">Class</span></code> и
размещению данного объекта в глобальной иерархии классов. Всё это будет делать
функция <code><span class="func">register-class</span></code>. Сопутствующие функции будут генерироваться функцией
<code><span class="func">Class-generate-related-names</span></code>. Итого, <code><span class="func">define-class</span></code> можно определить
примерно следующим образом:</p>


<!--\indexCS{define-class}{в двух мирах}-->
<pre>(define-meroonet-macro (define-class name super-name
                                     own-fields )
  (let ((class (register-class name super-name own-fields)))
    (Class-generate-related-names class) ) )</pre>

<p>\phantomlabel{objects/def-class/par:two-worlds}
<!--\indexR{макросы!компиляция}-->
<!--\indexR{компиляция!макросов}-->
Такое определение ведёт себя не совсем верно при компиляции, так как здесь
смешиваются этапы макрораскрытия и исполнения программ. Класс создаётся и
вводится в иерархию наследования во время раскрытия макросов, тогда как
сопутствующие функции создаются во время исполнения раскрытого кода.
Предположим, мы компилируем файл, содержащий определение класса <code><span class="func">Polygon</span></code>.
В конечном итоге получается файл с расширением <code><span class="func">*.o</span></code> (для компиляторов в Си
вроде KCL <span class="cite">[<a href="z1_bibliography.xhtml#yh85">yh85</a>]</span>, Scheme$\to$C <span class="cite">[<a href="z1_bibliography.xhtml#bar89">bar89</a>]</span> или Bigloo <span class="cite">[<a href="z1_bibliography.xhtml#ser94">ser94</a>]</span>) или
какой-нибудь <code><span class="func">*.fasl</span></code>-файл для других компиляторов. Как бы то ни было, в этом
файле останется лишь откомпилированный код раскрытых выражений, то есть
определения сопутствующих функций. Собственно класс создаётся только в памяти
компилятора во время раскрытия макросов, но не в памяти той лисп-системы,
к которой будет подключен <code><span class="func">*.o</span></code>-файл или которая динамически загрузит
<code><span class="func">*.fasl</span></code>-образ. Классы просто испаряются после того, как компилятор закончит
свою работу.</p>


<!--\indexR{множественные миры}-->
<!--\indexR{единый мир}-->
<!--\indexE{Scheme!глобальные переменные}-->
<p>Так что если мы хотим иметь поддержку рефлексии, то объекты-классы должны
создаваться в мире программ. Однако, если и сами классы будут определяться
тогда же, то их сопутствующие функции нельзя будет генерировать, потому как
этот процесс должен выполняться во время макрораскрытия,\footnote*{Вспомните,
что в Scheme нельзя ни создавать, ни обращаться к переменным с динамически
вычисляемыми именами. Все имена всех используемых переменных после раскрытия
макросов должны быть записаны прямым текстом.} но ему необходим перечень всех
полей класса. Следовательно, класс должен существовать в обоих мирах: и при
раскрытии макросов, и после него. В качестве приятного дополнения, такой подход
заодно позволит определять подклассы вместе с их суперклассами в одном общем
файле. В случае, когда мы имеем дело c единым миром
\seePage[macros/preparation/ssect:unique], {\Meroonet} может попытаться создать
класс дважды: первый раз при раскрытии макросов, а второй — при исполнении
раскрытого кода. Чтобы избежать такого поведения,\footnote*{{\Meroonet}
не придаёт чёткого смысла переопределению классов, поэтому не стоит лишний раз
искушать судьбу.} применяется следующий хитрый трюк: пусть определена глобальная
переменная <code><span class="func">*last-defined-class*</span></code>, тогда если во время раскрытия макросов
в неё поместить ссылку на первый попавшийся класс, то в едином мире это значение
перейдёт в мир программ, а во множественных мирах переменная сохранит исходное
значение. Это позволит узнать, когда определяемый класс не требуется создавать
повторно.</p>


<!--\indexC*{last-defined-class}{*last-defined-class*}-->
<pre>(define *last-defined-class* #f)</p>

<p>(define-meroonet-macro (define-class name super-name own-fields)
  (set! *last-defined-class* #f)
  (let ((class (register-class name super-name own-fields)))
    (set! *last-defined-class* class)
    `(begin
       (if (not *last-defined-class*)
         (register-class ',name ',super-name ',own-fields) )
       ,(Class-generate-related-names class) ) ) )</pre>

<p>
\subsubsection{Прочие затруднения}\label{objects/def-class/sssect:other}</p>


<!--\indexCS{define-class}{порядок определений}-->
<p>Продолжая иллюстрировать трудности использования макросов в реальных проектах
(на примере {\Meroonet}), стоит ещё раз задуматься о важности порядка раскрытия
для макросов со внутренним состоянием наподобие <code><span class="func">define-class</span></code>. Рассмотрим
следующую форму:</p>

<pre>(begin (define-class Point Object (x y))
       (define-class Polygon Point ((* side))) )</pre>

<p>Если раскрытие производится слева направо, то класс <code><span class="func">Point</span></code> определяется до
класса <code><span class="func">Polygon</span></code> и всё замечательно. Если же порядок будет противоположным,
то класс <code><span class="func">Polygon</span></code> определить не получится, не имея на руках его суперкласса.
Эту проблему, в принципе, можно обойти, если отложить создание <code><span class="func">Polygon</span></code> до
момента раскрытия определения <code><span class="func">Point</span></code>. Тогда определение <code><span class="func">Polygon</span></code>
фактически станет пустым, а форма, создающая <code><span class="func">Point</span></code>, должна будет раскрыться
в определения обоих классов в правильном порядке.</p>


<!--\indexR{макросы!компиляция!раздельная}-->
<!--\indexR{классы!прототипы}-->
<p>А что если <code><span class="func">Point</span></code> и <code><span class="func">Polygon</span></code> определяются в одном файле, а класс
<code><span class="func">Colored\-Polygon</span></code> — в другом? Теперь-то уже никак не отвертеться, все
поля суперкласса надо каким-то образом извлечь и передать между файлами.
{\Meroonet} не забивает себе голову подобными трудностями и просто требует,
чтобы все зависимые друг от друга классы компилировались вместе. {\Meroon} же
применяет ещё одну хитрость. Каждый родительский класс должен быть или ранее
определён в этом же файле, или помечен ключевым словом <code><span class="func">:prototype</span></code>. Такая
форма лишь\footnote{На самом деле в {\Meroon} всё немного сложнее: модификатор
<code><span class="func">:prototype</span></code> раскрывается в проверку того, что к моменту исполнения программы
реальный класс был создан и написанный прототип ему соответствует.} помещает
соответствующий класс в иерархию наследования, но не генерирует никаких функций.
Выглядит это вот так:</p>


<!--\indexC*{prototype}{:prototype}-->
<!--\indexCS{define-class}{<code><span class="func">:prototype</span></code>}-->
<pre>(define-class Polygon Point ((* side)) :prototype)
(define-class ColoredPolygon Polygon (color))</pre>


<!--\indexR{модули}-->
<p>Наиболее правильным решением, пожалуй, будет поддержка модулей с механизмом
импорта/экспорта, позволяющим указать, что надо каждому модулю для компиляции и
откуда это брать. В принципе это сводится к тому, что внутреннее состояние
компилятора выносится в некую базу данных, которая используется для разрешения
неудовлетворённых зависимостей между определениями.</p>

<h2 id="objects/sect:repr-class">Представление классов</h2>


<!--\indexR{представление!классов \protect\Meroonet}-->
<!--\indexR{классы}-->
<p>Классы {\Meroonet} представляются объектами {\Meroonet}. Такой подход
значительно облегчает реализацию рефлексивных возможностей объектной системы.
Метаметоды также легче писать, оперируя структурой классов напрямую, а
не косвенно опираясь на наследование. Методы, переносящие объекты с одного
компьютера на другой, или, например, универсальные методы вывода объектов
на экран очевидно удобнее определять, имея полное представление о структуре
обрабатываемых объектов, об устройстве их классов. Прародителем всех объектов
является класс <code><span class="func">Object</span></code> — корень иерархии наследования. Все классы сами
являются экземплярами класса <code><span class="func">Class</span></code>. Поля представляются объектами классов
<code><span class="func">Mono-Field</span></code> и <code><span class="func">Poly-Field</span></code>, наследников <code><span class="func">Field</span></code>.</p>

<p>В процессе раскрытия определений классов используется множество вспомогательных
функций, работающих с предопределёнными классами: <code><span class="func">Mono-Field?</span></code>,
<code><span class="func">make-Poly-Field</span></code> и т. д. Значит ли это, что сопутствующие функции класса
становятся доступными после его определения? Например, сможем ли мы использовать
в определениях других классов функцию <code><span class="func">make-Point</span></code> после того, как определим
класс <code><span class="func">Point</span></code>? Для текущей версии <code><span class="func">define-class</span></code> ответ на этот вопрос
отрицательный, так как <code><span class="func">make-Point</span></code> создаётся не в процессе раскрытия, а уже
во время исполнения раскрытого кода. Такой подход несколько усложняет реализацию
метаклассов при компиляции, но {\Meroonet} обходит стороной эту проблему.</p>

<p>Стараясь не перегружать классы, мы помещаем в них лишь самое необходимое: имя,
числовой идентификатор, список полей, ссылку на суперкласс, список
идентификаторов подклассов. Этот перечень дочерних классов пригодится для
реализации обобщённых функций. Список хранит номера вместо прямых ссылок
с целью избежать зацикливания. Итого, <code><span class="func">Class</span></code> — класс всех классов —
определяется следующим образом:</p>


<!--\indexC{Class}-->
<pre>(define-class Class Object
  ( name number fields superclass subclass-numbers ) )</pre>


<!--\indexR{поля}-->
<p>Поля классов, естественно, тоже являются объектами {\Meroonet}. Поле
характеризуется своим видом, именем и классом, которому оно принадлежит. Здесь
ссылка на класс тоже сделана числом, чтобы поля можно было нормально
распечатывать. Таким образом, имеем:</p>


<!--\indexC{Field}-->
<!--\indexC{Mono-Field}-->
<!--\indexC{Poly-Field}-->
<pre>(define-class Field Object (name defining-class-number))
(define-class Mono-Field Field ())
(define-class Poly-Field Field ())</pre>

<p>Наконец, иногда может потребоваться хозяин поля собственной персоной, а
не только его номер. Мы всегда очень вежливы и точно знаем, кто нам нужен,
поэтому следующая функция не утруждает себя излишними проверками:</p>


<!--\indexC{Field-defining-class}-->
<pre>(define (Field-defining-class field)
  (number->class (careless-Field-defining-class-number field)) )</pre>


<!--\indexR{раскрутка (bootstrapping)}-->
<p>Конечно, на самом деле все эти классы не получится определить до того, как
{\Meroonet} будет загружена, но и загрузить {\Meroonet} без них тоже не выйдет.
Чтобы разорвать данный порочный круг, придётся определить их вручную:</p>


<!--\indexC{Object-class}-->
<!--\indexC{Class-class}-->
<!--\indexC{Generic-class}-->
<!--\indexC{Mono-Field-class}-->
<!--\indexC{Poly-Field-class}-->
<pre>(define Object-class
  (vector
   1                            ; это класс
   'Object                      ; имя
   0                            ; номер
   '()                          ; поля
   #f                           ; нет суперкласса
   '(1 2 3)                     ; дочерние классы
   ) )</p>

<p>(define Class-class
  (vector
   1                                   ; это тоже класс
   'Class                              ; имя
   1                                   ; номер
   (list                               ; поля
    (vector 4 'name             1)     ; смещение 1
    (vector 4 'number           1)     ; смещение 2
    (vector 4 'fields           1)     ; смещение 3
    (vector 4 'superclass       1)     ; смещение 4
    (vector 4 'subclass-numbers 1) )   ; смещение 5
   Object-class                        ; суперкласс
   '()
   ) )</p>

<p>(define Generic-class
  (vector
   1
   'Generic
   2
   (list
    (vector 4 'name           2)
    (vector 4 'default        2)
    (vector 4 'dispatch-table 2)
    (vector 4 'signature      2) )
    Object-class
    '()
    ) )</p>

<p>(define Field-class
  (vector
   1
   'Field
   3
   (list
    (vector 4 'name                  3)
    (vector 4 'defining-class-number 3) )
   Object-class
   '(4 5)
   ) )</p>

<p>(define Mono-Field-class
  (vector 1
          'Mono-Field
          4
          (careless-Class-fields Field-class)
          Field-Class
          '() ) )</p>

<p>(define Poly-Field-class
  (vector 1
          'Poly-Field
          5
          (careless-Class-fields Field-class)
          Field-Class
          '() ) )</pre>

<p>Затем классы ставятся на положенные места:</p>

<pre>(vector-set! *classes* 0 Object-class)
(vector-set! *classes* 1 Class-class)
(vector-set! *classes* 2 Generic-class)
(vector-set! *classes* 3 Field-class)
(vector-set! *classes* 4 Mono-Field-class)
(vector-set! *classes* 5 Poly-Field-class)</p>

<p>(set! *class-number* 6)</pre>


<!--\indexR{аксессоры!\protect<code><span class="func">careless-</span></code>}-->
<p>Так как {\Meroonet} основана на иерархии классов, которую сама же определяет,
некоторые функции (вроде аксессоров <code><span class="func">Class-number</span></code> и <code><span class="func">Class-fields</span></code>)
требуются ещё до того, как они будут созданы. С этой целью мы определим их
эквиваленты, начинающиеся на <code><span class="func">careless-</span></code>. Имена говорят сами за себя: данные
функции никак не проверяют свои аргументы; это приемлемо, так как они
используются лишь внутри {\Meroonet}, где всё находится под контролем.</p>

<pre>(define (careless-Class-name class)
  (vector-ref class 1) )
(define (careless-Class-number class)
  (vector-ref class 2) )
(define (careless-Class-fields class)
  (vector-ref class 3) )
(define (careless-Class-superclass class)
  (vector-ref class 4) )</p>

<p>(define (careless-Field-name field)
  (vector-ref field 1) )
(define (careless-Field-defining-class-number field)
  (vector-ref field 2) )</pre>

<h2 id="objects/sect:accomp">Сопутствующие функции</h2>

<p>Формирование имён этих функций значительно облегчит следующее вспомогательное
определение:</p>


<!--\indexC{symbol-concatenate}-->
<pre>(define (symbol-concatenate . names)
  (string->symbol (apply string-append (map symbol->string names))) )</pre>


<!--\indexR{сопутствующие функции!варианты определения}-->
<p>Навскидку можно придумать два варианта конструирования функций, сопутствующих
определениям классов. В первом случае их код помещается непосредственно
в соответствующие определения; во втором же эти определения сводятся к формам,
генерирующим необходимые замыкания во время исполнения. Второй вариант позволяет
отделить неизменяемую часть функций, что облегчает их понимание и реализацию, но
уменьшает эффективность, так как вызываемые функции не будут фиксированы на
этапе компиляции, что усложняет оптимизацию. Различия двух подходов отлично
видны на примере аллокатора класса <code><span class="func">Polygon</span></code>:</p>

<pre>(define allocate-Polygon
        (lambda (size)
          (let ((o (make-vector (+ 1 2 1 size))))
            (vector-set! o 0 (careless-Class-number Polygon-class))
            (vector-set! o 3 size)
            o ) ) )</p>

<p>(define allocate-Polygon (make-allocator Polygon-class))</pre>

<p>В первом случае компилятору статически известно, что аллокатор является унарной
функцией, а его тело состоит из вызовов тривиальных библиотечных функций вроде
аксессоров векторов. Следовательно, это прекрасный кандидат на инлайнинг и его,
например, можно сразу компилировать в виде макроса Си. Но вот второе определение
ничего не говорит об арности. Фактически, нельзя даже с уверенностью сказать,%
\footnote*{Лисп вообще не гарантирует, что вычисление этой формы будет
завершено, а в Scheme она вполне может вернуть несколько значений вместо
предполагаемого одного.} будет ли с переменной <code><span class="func">allocate-Polygon</span></code> связана
функция или что-то другое. Но несмотря на это, мы всё равно изберём второй
путь, так как первый сложнее устроен и его описание более запутанно, а кроме
того, он требует существенно больше памяти как при компиляции, так и
в результирующем коде. Итак, сопутствующие функции будут генерироваться вот так:</p>


<!--\indexC{Class-generate-related-names}-->
<pre>(define (Class-generate-related-names class)
  (let* ((name (Class-name class))
         (class-variable-name (symbol-concatenate name '-class))
         (predicate-name      (symbol-concatenate name '?))
         (maker-name          (symbol-concatenate 'make- name))
         (allocator-name      (symbol-concatenate 'allocate- name)) )
   `(begin
      (define ,class-variable-name (->Class ',name))
      (define ,predicate-name (make-predicate ,class-variable-name))
      (define ,maker-name     (make-maker     ,class-variable-name))
      (define ,allocator-name (make-allocator ,class-variable-name))
      ,@(map (lambda (field) (Field-generate-related-names field class))
             (Class-fields class) )
      ',(Class-name class) ) ) )</pre>

<h3 id="objects/accomp/ssect:pred">Предикаты</h3>


<!--\indexR{сопутствующие функции!предикаты}-->
<!--\indexR{предикаты}-->
<!--\indexR{проверки типов}-->
<!--\indexR{динамическая типизация}-->
<p>Для каждого класса {\Meroonet} определяется предикат, способный отличать объекты
данного класса и его наследников от всех остальных. Необычайно важно, чтобы этот
предикат работал с максимально возможной скоростью, так как Scheme — это язык
с динамической типизацией, где типы постоянно проверяются и перепроверяются. При
компиляции иногда можно предсказать\footnote{Например, форма <code><span class="func">define-method</span></code>
явно указывает тип дискриминирующего аргумента.} тип объекта, объединить
некоторые проверки, извлечь необходимую информацию из пользовательских
определений или даже потребовать полной типобезопасности программ, например,
предоставив функции, возвращающие типы своих аргументов.</p>


<!--\indexC{meroonet-error}-->
<!--\indexR{обработка ошибок!в \protect\Meroonet}-->
<p>Проверка принадлежности объекта классу является фундаментальной операцией языка,
выполняемой предикатом <code><span class="func">is-a?</span></code>. Ради быстродействия <code><span class="func">is-a?</span></code> предполагает,
что его аргумент действительно является объектом, а класс — классом.
Следовательно, нельзя свободно применять <code><span class="func">is-a?</span></code> к чему попало.
В противоположность ему, предикаты, связанные с конкретными классами, более
устойчивы: они сразу отбраковывают аргументы, который не похожи на объекты
{\Meroonet}. Наконец, полезным будет ещё один, самый строгий предикат,
убеждающийся в принадлежности объекта указанному классу и выводящий понятное
сообщение об ошибке в случае несовпадения. Так как в Scheme нет\footnote{%
По крайней мере, в стандарте \RnRS, который взят за основу в этой книге.}
стандартного механизма обработки ошибок, то {\Meroonet} сообщает о них, вызывая
функцию <code><span class="func">meroonet-error</span></code>, которая\textdots\ не определена — гарантированно
переносимый способ получить ошибку!</p>


<!--\indexC{make-predicate}-->
<!--\indexC{is-a"?}-->
<!--\indexC{check-class-membership}-->
<pre>(define (make-predicate class)
  (lambda (o) (and (Object? o)
                   (is-a? o class) )) )</p>

<p>(define (is-a? o class)
  (let up ((c (object->class o)))
    (or (eq? class c)
        (let ((sc (careless-Class-superclass c)))
          (and sc (up sc)) ) ) ) )</p>

<p>(define (check-class-membership o class)
  (if (not (is-a? o class))
    (meroonet-error "Wrong class" o class)
    #t ) )</pre>

<p>Предикат <code><span class="func">is-a?</span></code> имеет вычислительную сложность $O(n)$, так как сначала
проверяется класс объекта, затем его суперкласс, затем суперкласс суперкласса
и так далее. Но это в худшем случае; чаще всего достаточно одной проверки,
реже — двух-трёх.</p>

<p>Стоит отметить, что в формулировке предиката <code><span class="func">is-a?</span></code> заботливо оставлены
грабли в виде возможной бесконечной регрессии. Мы их успешно обошли, использовав
функцию <code><span class="func">careless-Class-superclass</span></code> для получения суперкласса вместо
кажущейся более логичной <code><span class="func">Class-superclass</span></code>. Разница между ними в том, что
первая функция предполагает, что её аргумент является классом. В контексте
<code><span class="func">is-a?</span></code> мы не особо рискуем, делая подобные предположения. Но вот вторая
функция обязана быть более аккуратной, и она наверняка проверяет, что её
аргумент — это действительно класс. Естественно, это приведёт к рекурсивному
вызову <code><span class="func">is-a?</span></code>, что самым печальным образом скажется на производительности
{\Meroonet}.</p>

<h3 id="objects/accomp/ssect:allocator">Аллокатор без инициализации</h3>


<!--\indexR{сопутствующие функции!аллокаторы}-->
<!--\indexR{аллокаторы}-->
<p>{\Meroonet} предоставляет два вида аллокаторов. Первый, называемый просто
аллокатором, лишь выделяет в памяти место под объекты, не утруждая себя его
инициализацией. Второй, именуемый конструктором, создаёт объекты с чётко
определёнными значениями полей. Аналогичные понятия есть и в Scheme:
<code><span class="func">cons</span></code> — это конструктор точечных пар; <code><span class="func">vector</span></code> создаёт и
инициализирует векторы. Существует также и другой способ получить новый вектор
— функция <code><span class="func">make-vector</span></code>, если ей передать только один аргумент, возвращает
вектор указанного размера с неопределённым содержимым. {\Meroonet} поддерживает
обе разновидности.</p>


<!--\indexR{неопределённое значение}-->
<!--\indexR{неинициализированные переменные}-->
<!--\indexR{переменные!неинициализированные}-->
<p>Аллокаторы создают объекты с неопределённым начальным состоянием. Существует как
минимум два варианта понимания неопределённости. По причинам, связанным
со сборкой мусора (если сборщики не пользуются некоторыми хитростями,
см. <span class="cite">[<a href="z1_bibliography.xhtml#bw88">bw88</a>]</span>), неопределённое состояние часто понимается как неизвестное для
пользователя языка, но вполне определённое для реализации. У такого подхода есть
два подварианта, различающиеся семантикой используемых значений.</p>

<p>\begin{itemize}
  \item
<!--\indexC*{uninitialized}{\#<uninitialized>}-->
        Неопределённые поля могут быть помечены специальной сущностью
        <code><span class="func">\#<uninitialized></span></code>, которая показывает отсутствие значения.
        Сама она не является значением в строгом смысле, поэтому попытка
        прочитать содержимое такого поля приводит к ошибке.</p>

<p>  \item Если реализация не поддерживает подобные сущности, то она
        может записывать в поле произвольное нормальное значение.
        В Лиспе, например, это зачастую <code><span class="func">nil</span></code>, в Le_Lisp —
        <code><span class="func">t</span></code>, многие реализации Scheme используют <code><span class="func">\#f</span></code>.
        Следовательно, пользователь не может полагаться на какие-либо
        конкретные начальные значения неинициализированных полей, но
        обращения к ним не будут принципиальной ошибкой.
\end{itemize}</p>

<p>И есть ещё третья интерпретация — известная как «С-style», — по которой
обращение к неинициализированному полю приводит к неопределённым последствиям.
Поэтому от греха подальше лучше вообще никогда не пытаться читать
неинициализированные поля. Такое понимание неинициализированности очень удобно
для разработчиков языка, но отнюдь не для его пользователей, потому как термин
«неопределённое поведение» может означать действительно <em>что угодно</em>.
Возьмём, например, какой-нибудь аксессор чтения. Очевидно, его быстродействие
должно быть максимально высоким, поэтому сам он принципиально не проверяет, что
и откуда там считывается. А так как реализация ничего не гарантирует в случае
неинициализированных полей, то в зависимости от настроения и текущей фазы
Луны она может как выбросить мерзкую, но кристально понятную ошибку <code><span class="func">"Bus
error, core dumped"</span></code>, так и молча выдать какой-нибудь мусор, который программа
примет за чистую монету. Вся ответственность за чтение неинициализированных
полей возлагается на пользователей — справедливо, но очень опасно.</p>

<p>Первый подход (с <code><span class="func">\#<uninitialized></span></code>) требует, чтобы обращение к полю,
которое не было инициализировано, вызывало ошибку. Очевидно, это условие
необходимо проверять всякий раз, когда производится обращение к потенциально
неинициализированному полю <span class="cite">[<a href="z1_bibliography.xhtml#que93b">que93b</a>]</span>. Второй вариант, равно как и третий,
не нуждается в лишних проверках.</p>

<p>Сишный вариант, конечно, является наиболее эффективным с точки зрения скорости,
так как выделенную память не надо ни инициализировать, ни очищать. Если собрать
все эти утверждения воедино, то станет очевидным парадоксальный факт: в итоге
изначально инициализированные объекты оказываются эффективнее, нежели объекты
без инициализации. Это для пользователя начальные значения полей не имеют
смысла, но реализация обязана помещать туда конкретные значения вроде
<code><span class="func">\#<uninitialized></span></code>; с таким же успехом она могла бы заполнять их чем-то
более осмысленным. Наконец, чаще всего поля, не инициализированные при создании
объекта, всё равно инициализируются впоследствии — а это двойная работа.
В некоторых случаях её можно простить, но когда все значения известны заранее,
глупо не использовать явную инициализацию, формирующую объект за один проход
вместо двух.</p>

<p>CLOS понимает неопределённость в первом смысле и гарантирует обнаружение ошибок
доступа к неинициализированным полям. В Scheme есть формы, для реализации
которых может потребоваться понятие неинициализированных переменных.
\seePage[lisp1-2-omega/recusion/ssect:uninitialized] По нашей задумке,
{\Meroonet} должна быть способна полностью эмулировать Scheme, а значит, иметь
какой-то механизм представления таких переменных. Но дабы не усложнять
реализацию, мы будем просто заполнять неинициализированные поля
значением <code><span class="func">\#f</span></code>.</p>


<!--\indexR{объекты!неинициализированные}-->
<!--\indexR{побочные эффекты}-->
<p>Концепция аллокации без инициализации имеет смысл только для изменяемых
объектов. Это очень важное замечание, так как неизменяемые значения проще
определить математически, чем объекты, имеющие состояние, что помогает при их
сравнении. \seePage[assignment/side-effects/ssect:equality] Кроме того,
неизменяемые объекты гораздо лучше оптимизируются в силу того, что все их поля
неизменны. Возьмём, например, функцию <code><span class="func">make-allocator</span></code>, которая определена
чуть ниже. В ней используется форма <code>(Class-number class)</code>, значение которой
вполне можно было бы вычислить заранее и подставить напрямую (как это сделано
для <code>(Class-fields class)</code>), если бы номер класса был неизменной величиной.
Но из-за возможности переименования классов мы вынуждены выяснять его каждый
раз заново.</p>

<p>Функция <code><span class="func">make-allocator</span></code> создаёт аллокаторы. Она берёт класс и возвращает
функцию, принимающую список натуральных чисел, соответствующих длине каждого
индексированного поля этого класса. Полученная функция сначала определяет
размеры необходимого участка памяти (длину вектора), складывая длины всех полей.
Откуда она про них узнает? Их список извлекается из класса методом
<code><span class="func">Class-fields</span></code>. После того, как требуемый кусок памяти наконец получен, ему
необходимо придать форму, записав в соответствующие места длины всех
индексированных полей. Для этого организуется второй цикл, проходящий по всем
полям класса и отслеживающий текущее смещение в выделенной области памяти.
Наконец, получившийся «скелет» объекта связывается со своим классом и
возвращается из аллокатора.</p>


<!--\indexC{make-allocator}-->
<pre>(define (make-allocator class)
  (let ((fields (Class-fields class)))
    (lambda sizes
      ;; вычисляем размер создаваемого объекта
      (let ((room (let iter ((fields fields)
                             (sizes sizes)
                             (room *starting-offset*) )
                    (if (pair? fields)
                        (cond ((Mono-Field? (car fields))
                               (iter (cdr fields) sizes (+ 1 room)) )
                              ((Poly-Field? (car fields))
                               (iter (cdr fields) (cdr sizes)
                                     (+ 1 (car sizes) room) ) ) )
                        room ) )))
        (let ((o (make-vector room #f)))
          ;; формируем родственные связи объекта и его скелет
          (vector-set! o 0 (Class-number class))
          (let iter ((fields fields)
                     (sizes sizes)
                     (offset *starting-offset*) )
            (if (pair? fields)
                (cond ((Mono-Field? (car fields))
                       (iter (cdr fields) sizes (+ 1 offset)) )
                      ((Poly-Field? (car fields))
                       (vector-set! o offset (car sizes))
                       (iter (cdr fields) (cdr sizes)
                             (+ 1 (car sizes) offset) ) ) )
                o ) ) ) ) ) ) )</pre>

<p>\ForLayout{display}{\clearpage}</p>

<p>Следует сделать несколько замечаний касательного этого кода:</p>

<p>\begin{enumerate}
  \item Аллокаторы единственным аргументом принимают список длин полей.
        Следовательно, они неявно требуют создания в памяти этого списка,
        состоящего из точечных пар, — чтобы выделить память, вначале
        требуется выделить память! Позже мы рассмотрим способ этого избежать.</p>

<p>  \item Лишние элементы данного списка просто игнорируются, не вызывая
        никаких ошибок.</p>

<p>  \item Аллокатор дважды проходит по одному и тому же списку полей класса.
        Это не сильно эффективно, особенно для классов без индексированных
        полей, чей размер неизменен. Этот недочёт впоследствии тоже будет
        исправлен.</p>

<p>  \item Если не дай бог указанный размер индексированного поля будет
        отрицательным, то необходимый объём памяти будет вычислен неверно и
        пользователь рано или поздно получит какое-то малопонятное сообщение
        об ошибке. Это не очень хорошо, поэтому следует выполнять явную
        проверку и заранее выводить своё, вменяемое сообщение.</p>

<p>  \item Поля могут быть только экземплярами классов <code><span class="func">Mono-Field</span></code> или
        <code><span class="func">Poly-Field</span></code>. Пользовательские классы полей при такой реализации
        добавить невозможно.
\end{enumerate}</p>

<h3 id="objects/accomp/ssect:maker">Аллокатор с инициализацией</h3>


<!--\indexR{сопутствующие функции!конструкторы}-->
<!--\indexR{конструкторы}-->
<!--\indexR{специализация!конструкторов}-->
<!--\indexR{индексированные поля}-->
<!--\indexR{поля!индексированные}-->
<p>Конструкторы классов определяются похожим образом, но мы немного оптимизируем
создание объектов небольших размеров. В Scheme аллокаторы (вроде
<code><span class="func">make-vector</span></code> или <code><span class="func">make-string</span></code>) принимают размер создаваемого объекта,
а также необязательное значение-заполнитель, которым инициализируется по
умолчанию его содержимое. Конструкторы (наподобие <code><span class="func">cons</span></code>, <code><span class="func">vector</span></code> или
<code><span class="func">string</span></code>) принимают соответствующее количество значений для всех полей
создаваемых объектов. Так как в векторе или строке только одно индексированное
поле, то его длина без проблем определяется по количеству аргументов, переданных
конструктору. У нас же таких полей может быть несколько, так что если не вводить
для их инициализации особый синтаксис, то соответствующие длины необходимо
указывать явно. В {\Meroonet} они записываются перед перечислением содержимого
подобных полей. Итого, цветной многоугольник с тремя сторонами создаётся
следующим образом:</p>

<pre>(make-ColoredPolygon 'x 'y 3 'Point0 'Point1 'Point2 'color)</pre>

<p>Для аллокаторов с инициализацией мы применим следующий подход: все аргументы
собираются в один общий список <code><span class="func">params</span></code>; затем создаётся вектор, в который
укладываются элементы этого списка вместе с номером класса. После этого остаётся
только проверить, что структура созданного объекта корректна с точки зрения
{\Meroonet}. Для этого мы пройдёмся по всем аргументам и полям класса, убеждаясь
в том, что все поля инициализированы. Если всё хорошо, то сконструированный
объект возвращается из функции. Такой подход проще (и, вероятно, быстрее), чем
кажущийся более естественным предыдущий, где аргументы проверяются до того,
как объект создаётся в памяти.</p>


<!--\indexC{make-maker}-->
<pre>(define (make-maker class)
  (or (make-fix-maker class)
      (let ((fields (Class-fields class)))
        (lambda params
          ;; создаём объект
          (let ((o (apply vector (Class-number class) params)))
            ;; проверяем его скелет
            (let check ((fields fields)
                        (params params)
                        (offset *starting-offset*) )
              (if (pair? fields)
                  (cond ((Mono-Field? (car fields))
                         (check (cdr fields) (cdr params) (+ 1 offset)) )
                        ((Poly-Field? (car fields))
                         (check (cdr fields)
                                (list-tail (cdr params) (car params))
                                (+ 1 (car params) offset) ) ) )
                  o ) ) ) ) ) ) )</pre>

<p>Этот аллокатор тоже игнорирует лишние аргументы, но он всё ещё не особо
эффективен, так как аргументы собираются в список, который тут же превращается
в вектор. Далее, из-за того, что для проверки структуры создаваемого объекта
используется список <code><span class="func">params</span></code>, а не полученный вектор, будет весьма непросто
убедить компилятор в том, что этот список бесполезен и его можно не создавать.
Поэтому мы прикрутим к <code><span class="func">make-maker</span></code> небольшой костыль, чтобы исправить
ситуацию хотя бы для объектов, не имеющих индексированных полей.</p>

<p>\ForLayout{display}{\begingroup\lstset{belowskip=\smallskipamount}}</p>


<!--\indexC{make-fix-maker}-->
<p>\begin{code:lisp}[label=objects/accomp/maker/src:fix-maker]
(define (make-fix-maker class)
  (define (static-size? fields)
    (if (pair? fields)
        (and (Mono-Field? (car fields))
             (static-size? (cdr fields)) )
        #t ) )
  (let ((fields (Class-fields class)))
    (and (static-size? fields)
         (let ((size (length fields))
               (cn (Class-number class)) )
           (case size
             ((0)  (lambda ()              (vector cn)))
             ((1)  (lambda (a)             (vector cn a)))
             ((2)  (lambda (a b)           (vector cn a b)))
             ((3)  (lambda (a b c)         (vector cn a b c)))
             ((4)  (lambda (a b c d)       (vector cn a b c d)))
             ((5)  (lambda (a b c d e)     (vector cn a b c d e)))
             ((6)  (lambda (a b c d e f)   (vector cn a b c d e f)))
             ((7)  (lambda (a b c d e f g) (vector cn a b c d e f g)))
             (else #f) ) ) ) ) )</pre>

<p>\ForLayout{display}{\endgroup}</p>

<p>Таким образом, конструкторы классов, имеющих менее девяти неиндексированных
полей, будут эффективными функциями с фиксированной арностью. Если класс
не содержит индексированных полей, но в нём слишком много обычных, то для него
тоже применяется стратегия со списком и явной проверкой. Кстати, если вы
заметили, для индексированных полей эта проверка выполняется весьма элегантным
образом с помощью <code><span class="func">list-tail</span></code> и <code><span class="func">cdr</span></code>: если в списке окажется недостаточно
элементов, то одна из этих функций выдаст ошибку, так как они обе неприменимы
к слишком коротким (в том числе пустым) спискам. Для небольших же объектов эта
проверка тождественна обычной проверке арности. Естественно, подобное
разнообразие стратегий отлова одной и той же ошибки означает нарушение
единообразия сообщений о ней, что не очень красиво выглядит, но повсеместная
реализация данных удобств раздула бы исходный код {\Meroonet} более чем на
четверть.</p>

<p>Действительно эффективно создавать объекты {\Meroonet} можно только при
непосредственной поддержке этой системы самим языком. Нелепостей вроде функции
выделения памяти, требующей для работы сравнимого объёма памяти, можно избежать,
например, имея в распоряжении внутреннюю функцию, создающую аллокаторы вида
<code>(vector cn a b c ...)</code>.</p>

<h3 id="objects/accomp/ssect:access">Аксессоры</h3>


<!--\indexR{сопутствующие функции!аксессоры}-->
<!--\indexR{аксессоры}-->
<p>Для каждого поля класса в {\Meroonet} определяются вспомогательные функции,
позволяющие читать, писать и узнавать длину этого поля, если оно индексировано.
Определения данных функций генерируются подфункцией
<code><span class="func">Field-generate-related-names</span></code>:</p>

<p>\ForLayout{display}{\begingroup\lstset{aboveskip=\smallskipamount}}</p>


<!--\indexC{Field-generate-related-names}-->
<pre>(define (Field-generate-related-names field class)
  (let* ((fname (careless-Field-name field))
         (cname (Class-name class))
         (cname-variable (symbol-concatenate cname '-class))
         (reader-name (symbol-concatenate cname '- fname))
         (writer-name (symbol-concatenate 'set- reader-name '!)) )
    `(begin
       (define ,reader-name
         (make-reader
          (retrieve-named-field ,cname-variable ',fname) ) )
       (define ,writer-name
         (make-writer
          (retrieve-named-field ,cname-variable ',fname) ) )
       ,@(if (Poly-Field? field)
             `((define ,(symbol-concatenate reader-name '-length)
                 (make-lengther
                  (retrieve-named-field ,cname-variable ',fname) ) ))
             '() ) ) ) )</pre>

<p>\ForLayout{display}{\endgroup}</p>

<p>Как и для всех остальных сопутствующих классам функций, код аксессоров
извлекается из соответствующих замыканий, а не генерируется напрямую.
Конструкторы <code><span class="func">make-reader</span></code>, <code><span class="func">make-writer</span></code> и <code><span class="func">make-lengther</span></code> принимают
поле и возвращают необходимые замыкания. Так как аксессоры создаются
динамически, данные функции вынуждены обращаться к глобальной переменной,
содержащей информацию о классе, и искать там нужное поле по имени; для этого
используется функция <code><span class="func">retrieve-named-field</span></code>:</p>


<!--\indexC{retrieve-named-field}-->
<pre>(define (retrieve-named-field class name)
  (let search ((fields (careless-Class-fields class)))
    (and (pair? fields)
         (if (eq? name (careless-Field-name (car fields)))
             (car fields)
             (search (cdr fields)) ) ) ) )</pre>

<h3 id="objects/accomp/ssect:read">Чтение полей</h3>


<!--\indexR{специализация!аксессоров}-->
<p>Так как поля бывают двух видов: индексированные и обычные, то и аксессоры должны
производиться в двух вариантах, различающихся арностью. Также сейчас самое время
заметить, что смещения полей, расположенных до конца первого индексированного
поля, не зависят от определения класса. Функция <code><span class="func">make-reader</span></code>, создающая
аксессоры чтения, конечно же, не должна забывать о данной возможности
оптимизации. Мы воспользуемся списком полей класса для проверки неизменности
смещения обрабатываемого поля. Если это так, то <code><span class="func">make-reader</span></code> сгенерирует
соответствующий специализированный аксессор; в противном случае будет
использована стандартная функция, построенная на основе универсального аксессора
<code><span class="func">field-value</span></code>. Таким образом, все поля, имеющие фиксированные смещения,
получат более эффективные аксессоры.</p>


<!--\indexR{проверки типов}-->
<p>Аксессоры типобезопасны — они проверяют, соответствует ли класс передаваемых
им объектов родительскому классу поля, с которым связан конкретный аксессор. За
это отвечает функция <code><span class="func">check-class-membership</span></code>, рассмотренная ранее. Более
того, аксессоры индексированных полей должны проверять запрашиваемые индексы на
соответствие размерам этих полей. С этим им поможет функция
<code><span class="func">check-index-range</span></code>.</p>


<!--\indexC{make-reader}-->
<!--\indexC{check-index-range}-->
<pre>(define (make-reader field)
  (let ((class (Field-defining-class field)))
    (let skip ((fields (careless-Class-fields class))
               (offset *starting-offset*) )
      (if (eq? field (car fields))
          (cond ((Mono-Field? (car fields))
                 (lambda (o)
                   (check-class-membership o class)
                   (vector-ref o offset) ) )
                ((Poly-Field? (car fields))
                 (lambda (o i)
                   (check-class-membership o class)
                   (check-index-range i o offset)
                   (vector-ref o (+ offset 1 i)) ) ) )
          (cond ((Mono-Field? (car fields))
                 (skip (cdr fields) (+ 1 offset)) )
                ((Poly-Field? (car fields))
                 (cond ((Mono-Field? field)
                        (lambda (o)
                          (field-value o field) ) )
                       ((Poly-Field? field)
                        (lambda (o i)
                          (field-value o field i) ) ) ) ) ) ) ) ) )</p>

<p>(define (check-index-range i o offset)
  (let ((size (vector-ref o offset)))
    (if (not (and (<= 0 i) (< i size)))
        (meroonet-error "Index out of range" i size)
        #t ) ) )</pre>

<p>Для доступа к остальным полям, находящимся за первым индексированным,
применяется функция <code><span class="func">field-value</span></code>. Она является обобщённой в смысле
универсальности — позволяет получить доступ к любому полю любого класса.
Реализуется она всё же как нормальная, не обобщённая функция, потому что
{\Meroonet} всё равно не позволяет пользователям определять свои классы
полей. Естественно, у функции <code><span class="func">field-value</span></code> есть сестра-близнец
<code><span class="func">set-field-value!</span></code>. Им обеим необходимо уметь динамически вычислять
смещения полей в произвольном объекте, так что соответствующий код вынесен
в отдельную функцию <code><span class="func">compute-field-offset</span></code>.</p>


<!--\indexC{compute-field-offset}-->
<!--\indexC{field-value}-->
<pre>(define (compute-field-offset o field)
  (let ((class (Field-defining-class field)))
    ;; <code>(assume (check-class-membership o class))</code>
    (let skip ((fields (careless-Class-fields class))
               (offset *starting-offset*) )
      (if (eq? field (car fields)) offset
          (cond ((Mono-Field? (car fields))
                 (skip (cdr fields) (+ 1 offset)) )
                ((Poly-Field? (car fields))
                 (skip (cdr fields)
                       (+ 1 offset (vector-ref o offset)) ) ) ) ) ) ) )
|\ForLayout{display}{\vskip-\baselineskip}|
(define (field-value o field . i)
  (let ((class (Field-defining-class field)))
    (check-class-membership o class)
    (let ((fields (careless-Class-fields class))
          (offset (compute-field-offset o field)) )
      (cond ((Mono-Field? field)
             (vector-ref o offset) )
            ((Poly-Field? field)
             (check-index-range (car i) o offset)
             (vector-ref o (+ offset 1 (car i))) ) ) ) ) )</pre>

<h3 id="objects/accomp/ssect:write">Запись в поля</h3>


<!--\indexC{putprop}-->
<!--\indexR{соглашения именования!сеттеров}-->
<p>Определения аксессоров записи полностью аналогичны аксессорам чтения и
не представляют существенных трудностей. Единственная функция, достойная
внимания, — это <code><span class="func">set-field-value!</span></code>, имеющая немного странную сигнатуру.
Обычно порядок аргументов сеттера повторяет порядок в геттере, только в конце
дописывается новое значение поля. Сравните, например, <code><span class="func">car</span></code> и <code><span class="func">set-car!</span></code>.
Но в случае {\Meroonet} необязательный индекс нарушает эту стройную систему,
поэтому и был выбран порядок\footnote{Если вы ещё не забыли, что такое списки
свойств, то наверяка вспомните и то, что аргументы <code><span class="func">putprop</span></code> располагаются
в точно таком же порядке.} <code>(o v field . i)</code>.</p>


<!--\indexC{make-writer}-->
<!--\indexC{set-field-value"!}-->
<pre>(define (make-writer field)
  (let ((class (Field-defining-class field)))
    (let skip ((fields (careless-Class-fields class))
               (offset *starting-offset*) )
      (if (eq? field (car fields))
          (cond ((Mono-Field? (car fields))
                 (lambda (o v)
                   (check-class-membership o class)
                   (vector-set! o offset v) ) )
                ((Poly-Field? (car fields))
                 (lambda (o i v)
                   (check-class-membership o class)
                   (check-index-range i o offset)
                   (vector-set! o (+ offset 1 i) v) ) ) )
          (cond ((Mono-Field? (car fields))
                 (skip (cdr fields) (+ 1 offset)) )
                ((Poly-Field? (car fields))
                 (cond ((Mono-Field? field)
                        (lambda (o v)
                          (set-field-value! o v field) ) )
                       ((Poly-Field? field)
                        (lambda (o i v)
                          (set-field-value! o v field i)|\:|)|\:|)|\:|)|\:|)|\:%
                                                      |)|\:|)|\:|)|\:|)|\:|)
|\ForLayout{display}{\vskip-\baselineskip}|
(define (set-field-value! o v field . i)
  (let ((class (Field-defining-class field)))
    (check-class-membership o class)
    (let ((fields (careless-Class-fields class))
          (offset (compute-field-offset o field)) )
      (cond ((Mono-Field? field)
             (vector-set! o offset v) )
            ((Poly-Field? field)
             (check-index-range (car i) o offset)
             (vector-set! o (+ offset 1 (car i)) v) ) ) ) ) )</pre>

<p>Немаловажным моментом является стиль именования сеттеров. Здесь используется
префикс <code><span class="func">set-</span></code>, подобно <code><span class="func">set-cdr!</span></code>. В принципе, можно было бы использовать
и суффикс <code><span class="func">-set!</span></code>, как в <code><span class="func">vector-set!</span></code>, но у префикса есть определённые
преимущества: так сразу понятно, что данная функция модифицирует объекты. Да и
читаются имена в этом случае естественнее.</p>

<h3 id="objects/accomp/ssect:len">Длина полей</h3>

<p>Каждое индексированное поле получает особую функцию, позволяющую узнать его
длину в конкретном объекте. Устроены эти функции так же, как и остальные
аксессоры: если возможно, то генерируется оптимизированный вариант, иначе
используется универсальная функция <code><span class="func">field-length</span></code>.</p>


<!--\indexC{make-lengther}-->
<!--\indexC{field-length}-->
<pre>(define (make-lengther field)
  ;; <code>(assume (Poly-Field? field))</code>
  (let ((class (Field-defining-class field)))
    (let skip ((fields (careless-Class-fields class))
               (offset *starting-offset*) )
      (if (eq? field (car fields))
          (lambda (o)
            (check-class-membership o class)
            (vector-ref o offset) )
          (cond ((Mono-Field? (car fields))
                 (skip (cdr fields) (+ 1 offset)) )
                ((Poly-Field? (car fields))
                 (lambda (o)
                   (field-length o field)) ) ) ) ) ) )</p>

<p>(define (field-length o field)
  (let* ((class  (Field-defining-class field))
         (fields (careless-Class-fields class))
         (offset (compute-field-offset o field)) )
    (check-class-membership o class)
    (vector-ref o offset) ) )</pre>

<h2 id="objects/sect:create-class">Создание классов</h2>

<p>Форма <code><span class="func">define-class</span></code> на самом деле не создаёт объект, представляющий
определяемый класс. Она перепоручает эту работу функции <code><span class="func">register-class</span></code>.
Эта функция уже выделяет память и вызывает <code><span class="func">Class-initialize!</span></code>, чтобы
заполнить её осмысленными данными, полученными в результате анализа определения
класса и его родословной. После формирования дескрипторов полей (с чем помогает
функция <code><span class="func">parse-fields</span></code>) класс помещается на подобающее ему место в иерархии
наследования. Наконец, функция <code><span class="func">update-generics</span></code> рассказывает всем обобщённым
функциям о пополнении в семействе, обеспечивая корректное наследование методов.</p>


<!--\indexC{register-class}-->
<!--\indexC{Class-initialize"!}-->
<pre>(define (register-class name super-name own-fields)
  (Class-initialize! (allocate-Class)
                     name
                     (->Class super-name)
                     own-fields ) )</p>

<p>(define (Class-initialize! class name superclass own-fields)
  ;; инициализируем поля класса
  (set-Class-number!           class *class-number*)
  (set-Class-name!             class name)
  (set-Class-superclass!       class superclass)
  (set-Class-subclass-numbers! class '())
  (set-Class-fields!
   class (append (Class-fields superclass)
                 (parse-fields class own-fields) ) )
  ;; помещаем его в иерархию
  (set-Class-subclass-numbers!
   superclass
   (cons *class-number* (Class-subclass-numbers superclass)) )
  (vector-set! *classes* *class-number* class)
  (set! *class-number* (+ 1 *class-number*))
  ;; передаём в наследство методы родителей
  (update-generics class)
  class )</pre>

<p>\ForLayout{display}{\smallskip}</p>


<!--\indexR{переопределение!полей}-->
<p>Описания полей в определениях классов разбираются функцией <code><span class="func">parse-fields</span></code>.
Она проводит синтаксический анализ полученного списка дескрипторов. Каждый
дескриптор может быть или просто именем, или списком. Если это список, то он
может начинаться лишь на знак равенства или звёздочку. Любая другая форма записи
приводит к <code><span class="func">meroonet-error</span></code>. {\Meroonet} не позволяет переопределять
наследуемые поля; функция <code><span class="func">check-conflicting-name</span></code> гарантирует соблюдение
данного запрета. С повторением имён собственных полей {\Meroonet} поступает
так же, как и с повторным определением классов: никак.</p>


<!--\indexC{parse-fields}-->
<!--\indexC{check-conflicting-name}-->
<pre>(define (parse-fields class own-fields)
  (define (Field-initialize! field name)
    (check-conflicting-name class name)
    (set-Field-name! field name)
    (set-Field-defining-class-number! field (Class-number class))
    field )</p>

<p>  (define (parse-Mono-Field name)
    (Field-initialize! (allocate-Mono-Field) name) )</p>

<p>  (define (parse-Poly-Field name)
    (Field-initialize! (allocate-Poly-Field) name) )</p>

<p>  (if (pair? own-fields)
      (cons (cond
             ((symbol? (car own-fields))
              (parse-Mono-Field (car own-fields)) )
             ((pair? (car own-fields))
              (case (caar own-fields)
                ((=) (parse-Mono-Field (cadr (car own-fields))))
                ((*) (parse-Poly-Field (cadr (car own-fields))))
                (else (meroonet-error
                       "Erroneous field description"
                       (car own-fields) )) ) ) )
            (parse-fields class (cdr own-fields)) )
      '() ) )</p>

<p>(define (check-conflicting-name class fname)
  (let check ((fields (careless-Class-fields (Class-superclass class))))
    (if (pair? fields)
        (if (eq? (careless-Field-name (car fields)) fname)
            (meroonet-error "Duplicated field name" fname)
            (check (cdr fields)) )
        #t ) ) )</pre>

<p>
\section{Предопределённые сопутствующие функции}%
\label{objects/sect:predef-accomp}</p>


<!--\indexR{раскрутка (bootstrapping)}-->
<!--\indexR{сопутствующие функции}-->
<!--\indexR{функции!сопутствующие}-->
<p>На данный момент мы описали практически всё, что необходимо для определения
новых классов, за исключением одной маленькой детали. В самом деле,
рассмотренные определения не заработают без функций, сопутствующих классам
<code><span class="func">Class</span></code>, <code><span class="func">Field</span></code> и т. д. Форму <code><span class="func">define-class</span></code> нельзя использовать,
пока эти функции не будут определены, но проблема в том, что именно
<code><span class="func">define-class</span></code> и должна их определить. Опять мы оказались в порочном кругу.</p>

<p>Как обычно, разрывается такой круг волевым усилием, заключающемся в «ручном»
определении всех необходимых функций. Не требуется определять их все, достаточно
будет лишь минимально необходимого набора. Также можно не проводить каких-либо
проверок вроде того, что <code><span class="func">Class-class</span></code> — это действительно класс, и т. п.
Если всё сделать правильно, то после этого можно будет передать
<code><span class="func">define-class</span></code> описания предопределённых классов и получить на выходе код,
совпадающий с приведённым в начале главы с точностью до номеров классов.
Единственное правило, которое требуется неукоснительно соблюдать: предикаты
определяются первыми, геттеры — перед сеттерами, аллокаторы — в последнюю
очередь. Ах да, и функции для класса <code><span class="func">Class</span></code> должны быть определены перед
аналогичными для остальных классов. Здесь приведена лишь часть необходимых
определений, так как их полный список малоинтересен.</p>


<!--\indexC{allocate-Class}-->
<!--\indexC{allocate-Poly-Field}-->
<pre>(define Class?   (make-predicate Class-class))
(define Generic? (make-predicate Generic-class))
(define Field?   (make-predicate Field-class))</p>

<p>(define Class-name
  (make-reader (retrieve-named-field Class-class 'name)))
(define set-Class-name!
  (make-writer (retrieve-named-field Class-class 'name)))
(define Class-number
  (make-reader (retrieve-named-field Class-class 'number)) )
(define set-Class-subclass-numbers!
  (make-writer (retrieve-named-field Class-class 'subclass-numbers)) )</p>

<p>(define make-Class (make-maker Class-class))
(define allocate-Class (make-allocator Class-class))</p>

<p>(define Generic-name
  (make-reader (retrieve-named-field Generic-class 'name)) )</p>

<p>(define allocate-Poly-Field (make-allocator Poly-Field-class))</pre>


<!--\indexR{переопределение!классов}-->
<p>Вот теперь <code><span class="func">define-class</span></code> полностью готова к использованию. Осторожно:
не следует тут же бежать «правильно» переопределять классы <code><span class="func">Object</span></code>,
<code><span class="func">Class</span></code> и другие. Во-первых, из-за того, что <code><span class="func">define-class</span></code>
не идемпотентна,\footnote*{Правда, здесь можно схитрить и сбросить
<code><span class="func">*class-number*</span></code> в ноль перед переопределением встроенных классов. Только
определять их надо в точно таком же порядке, как ранее вручную, чтобы номера
остались неизменными.} вы получите шесть новых классов, а предыдущие шесть так
и останутся бессмысленно болтаться в памяти. Во-вторых, компилятор не особо
обрадует переопределение всех сопутствующих функций, до этого считавшихся
неизменными.</p>

<h2 id="objects/sect:generics">Обобщённые функции</h2>


<!--\indexR{обобщённые функции}-->
<!--\indexR{обмен сообщениями}-->
<!--\indexR{функции!обобщённые}-->
<!--\indexR{сообщения}-->
<p>Обобщённые функции появились в результате адаптации идеи отправки сообщений
(родом из объектно-ориентированных языков) к функциональному миру Лиспа.
В Smalltalk <span class="cite">[<a href="z1_bibliography.xhtml#gr83">gr83</a>]</span> сообщения посылаются следующим образом:</p>

<p>\begin{code}[escapeinside=||]
<i>получатель</i> <i>сообщение</i>: <i>аргументы</i>...
\end{code}</p>


<!--\indexC{send}-->
<!--\indexC{=>}-->
<p>Как известно, абсолютно любой язык можно превратить в Лисп, просто добавив
в него побольше скобочек! Первые попытки перенести обмен сообщениями в Лисп
использовали специальные ключевые слова наподобие <code><span class="func">send</span></code> или <code><span class="func">=></span></code>
(Planner <span class="cite">[<a href="z1_bibliography.xhtml#hs75">hs75</a>]</span>):</p>

<pre>(send <i>получатель</i> <i>сообщение</i> <i>аргументы</i>...)</pre>


<!--\indexR{диспетчеризация}-->
<!--\indexR{диспетчеризация!множественная}-->
<!--\indexR{мультиметоды}-->
<!--\indexR{методы!мультиметоды}-->
<p>Получателями сообщений, естественно, являются объекты. Smalltalk позволяет
отправить сообщение только одному конкретному объекту; в этом языке нельзя
попросить несколько объектов совместно обработать какое-либо сообщение. Но
даже в Лиспе легко увидеть огромное множество функций вроде банального
сложения, чьи действия зависят от типа более чем одного объекта. И правда,
целые числа складываются одним способом, дроби и комплексные числа —
другим, у сложения чисел с плавающей запятой есть свои особенности. Если
аргументы имеют различные типы, то их необходимо как-то свести к общему
знаменателю; подходящий алгоритм приведения зависит от типов всех аргументов,
а не только первого. Методы — это способы обработки конкретного сообщения
конкретным объектом. Их обобщением на случай нескольких ответственных за
обработку объектов являются <em class="term">мультиметоды</em>. Однако, предыдущий синтаксис
отправки сообщений ставит единственного получателя в привилегированное
положение, поэтому Common Loops <span class="cite">[<a href="z1_bibliography.xhtml#bkk+86">bkk+86</a>]</span> был предложен более подходящий
вариант:</p>

<pre>(<i>сообщение</i> <i>объекты</i>...)</pre>

<p>Ключевое слово <code><span class="func">send</span></code> исчезло, а вместо него на место функции стало само
сообщение — следовательно, это сообщение должно быть настоящей функцией.
Точный смысл таких функций зависит от типов получателей сообщения, поэтому они
называются <em class="term">обобщёнными</em>. Обобщённые функции полагаются при выборе действий
на свои аргументы, причём они обладают существенной свободой их трактовки:</p>


<!--\indexR{дискриминант}-->
<!--\indexR{обобщённые функции!дискриминант}-->
<p>\begin{enumerate}
  \item Обобщённая функция сама определяет, какие аргументы влияют на её
        выбор. Такие аргументы называются <em class="term">дискриминантами</em>.</p>

<p>  \item Дискриминантом не обязательно является первый аргумент.</p>

<p>  \item Дискриминантов может быть несколько, как в случае со сложением.
\end{enumerate}</p>

<p>Короче говоря, обобщённые функции обобщают идею обмена сообщениями. Именно
в таком виде эта идея реализована в {\Meroonet}. С одной поправкой: мы решили
не включать в неё мультиметоды. Вспомните, ведь они ни разу не понадобились при
объяснениях в этой книге. По мнению <span class="cite">[<a href="z1_bibliography.xhtml#kr90">kr90</a>]</span>, мультиметоды действительно
необходимы лишь в {5\,\%} случаев. Это не настолько важная или невообразимо
сложная для реализации функциональность, чтобы заострять здесь на ней особое
внимание.</p>

<p>У вас вполне может возникнуть вопрос, применимы ли вообще подобные обобщения
к объектам, ведь они являются «суверенными» сущностями, которые вполне
способны самостоятельно разобраться, как им вызывать свои же методы. Мы не будем
детально обсуждать данный вопрос в силу его философского характера. Достаточно
отметить, что обобщённые функции полностью скрывают объектно-ориентированный
аспект производимых ими действий: это просто функции, а не какой-то хитрый
оператор <code><span class="func">send</span></code>. Не важно, анализируют ли они типы аргументов или организуют
обмен сообщениями между объектами — для пользователя они выглядят как
функции, вызываются как функции и работают как функции. Хотя, естественно,
с точки зрения реализации разница определённо есть. Рассмотрим обобщённую
функцию <i>g</i>, чьим дискриминантом является первый аргумент. Каждый её вызов
\ic{(<i>g</i> <i>аргументы</i>...)} на самом деле может раскрываться в обращения
к замыканию вида \ic{(lambda args (apply send (car args) <i>g</i> (cdr args)))},
что однозначно сказывается на производительности.</p>


<!--\indexR{функции!функторы}-->
<!--\indexR{объекты!вызываемые}-->
<!--\indexR{объекты!функторы}-->
<!--\indexR{функторы}-->
<!--\indexE{Scheme!и обобщённые функции}-->
<!--\indexR{обобщённые функции!в Scheme}-->
<p>Как же реализовать обобщённые функции на Scheme? С одной стороны, весьма
желательно, чтобы для них работала <code><span class="func">apply</span></code>, а это возможно лишь при условии,
что обобщённые функции будут реализованы как функции Scheme. С другой стороны,
не хотелось бы терять рефлексивные возможности, предоставляемые {\Meroonet},
для чего необходимо оставить обобщённые функции объектами класса <code><span class="func">Generic</span></code>.
Итого, они должны стать одновременно объектами <em>и</em> функциями, то есть
<em class="term">функторами</em> — вызываемыми объектами. CLOS и Oaklisp \cite{lp86,lp88}
поддерживают эту концепцию непосредственно.</p>


<!--\indexR{представление!обобщённых функций}-->
<p>Без сомнения, обобщённые функции являются объектами, так как у них есть
состояние — текущий набор поддерживаемых методов. Поэтому мы реализуем их
следующим образом, пусть он и не особо оптимален. Каждая обобщённая функция
представляется парой из объекта {\Meroonet} и функции Scheme, чьё имя совпадает
с именем обобщённой функции. Эта функция запомнит свой объект в замыкании, чтобы
иметь возможность добраться до него в любом контексте. С другой стороны,
данный объект будет доступен не только изнутри замыкания, что обеспечивает
возможность добавления новых методов. Однако, для этого потребуется найти нужный
объект обобщённой функции, для чего всем им потребуются некоторые идентификаторы
(следовательно, обобщённые функции не могут быть анонимными). Глобальные
переменные не используются потому, что это бы позволило локальным переменным
(нечаянно) скрывать объекты, необходимые для корректной работы {\Meroonet}.</p>

<p>\ForLayout{display}{\clearpage}</p>

<p>Определения обобщённых функций имеют следующий синтаксис:</p>


<!--\indexC{define-generic}-->
<pre>(define-generic (<i>имя</i> <i>переменные</i>...) |$[$<i>тело-по-умолчанию</i>$]$|)</pre>


<!--\indexR{обобщённые функции!сигнатуры}-->
<!--\indexR{методы!сигнатуры}-->
<p>\noindent
Первой указывается форма вызова функции и её дискриминант (получатель сообщения
в терминах Smalltalk). Дискриминант записывается в скобках. Вся оставшася часть
определения образует тело метода по умолчанию. В языке, где все значения
являются объектами, это было бы аналогично определению метода для самого общего
класса значений — <code><span class="func">Object</span></code>. Но в нашем случае ещё остаются обычные
значения Scheme, которые, очевидно, не являются объектами, поэтому метод по
умолчанию необходимо также применять ко всем значениям, провалившим проверку
<code><span class="func">Object?</span></code>. Такой подход облегчает интеграцию {\Meroonet} и Scheme, а также
позволяет пользователю отлавливать ошибки типизации. Ещё одним достоинством
{\Meroonet} является поддержка всех возможных сигнатур обобщённых функций,
включая точечные переменные. Естественно, методов это тоже касается.</p>

<p>Класс <code><span class="func">Generic</span></code> определяется следующим образом:</p>


<!--\indexC{Generic}-->
<pre>(define-class Generic Object
  ( name default dispatch-table signature ) )</pre>


<!--\indexC*{Generic}{->Generic}-->
<p>Поиском обобщённых функций по именам занимается функция <code><span class="func">->Generic</span></code>. Поле
<code><span class="func">default</span></code> содержит метод по умолчанию, чьё тело или явно определяется
пользователем, или содержит автоматически сгенерированную заглушку с сообщением
об ошибке. Сохранённая сигнатура понадобится для проверки арности добавляемых
методов на совместимость. Это очень важная проверка, так как, во-первых, вызовы
обобщённых функций и так уже достаточно зависят от контекста — набора
определённых методов, — добавление ещё одной степени свободы в виде арности
только усложнит восприятие программ. Во-вторых, единообразие сигнатур методов
позволяет эффективнее реализовывать вызовы обобщённых функций, см. <span class="cite">[<a href="z1_bibliography.xhtml#kr90">kr90</a>]</span>.</p>


<!--\indexR{таблица диспетчеризации}-->
<!--\indexR{диспетчеризация!таблица диспетчеризации}-->
<p>Внутреннее состояние обобщённой функции состоит из единственного вектора, чьи
индексы соответствуют номерам классов. Этот вектор хранит все определённые
методы данной функции и называется <em class="term">таблицей диспетчеризации</em> (dispatch
table). Алгоритм вызова обобщённых функций теперь очевиден: номер класса
дискриминанта — это индекс требуемого метода в таблице диспетчеризации
обобщённой функции. Такой механизм выбора невероятно быстр, но эта скорость
приобретается ценой повышенного потребления памяти: суммарно все такие векторы
составляют матрицу $m \times n$, где $m$ и $n$ — это количество всех
используемых программе классов и обобщённых функций соответственно. Однако, чаще
всего в таких таблицах очень много пустых ячеек, что открывает возможности для
оптимизации, см. например \cite{vh94,que93b}.</p>


<!--\indexCS{define-generic}{арность методов}-->
<p>Методы обобщённых функций (включая умолчательный) всегда имеют фиксированную
арность, даже когда у функции есть точечная переменная. Например, если
обобщённая функция <code><span class="func">f</span></code> определена вот так:</p>

<pre>(define-generic (f a (b) . c) (g b a c))</pre>

<p>\noindent
то её метод по умолчанию будет таким:</p>

<pre>(lambda (a b c) (g b a c))</pre>

<p>Остальные методы также должны иметь арность, совместимую с <code>(a b c)</code>.
Функция, представляющая <code><span class="func">f</span></code> в мире Scheme, получает сигнатуру, идентичную
написанной в определении <code><span class="func">f</span></code>:</p>

<pre>(lambda (a b . c) ((determine-method G127 b) a b c))</pre>

<p>Значение переменной <code><span class="func">G127</span></code>\footnote{Так как <code><span class="func">define-generic</span></code> — это
макрос, то во избежание коллизий все имена переменных генерируются <code><span class="func">gensym</span></code>.}
— это тот самый объект класса <code><span class="func">Generic</span></code>, представляющий обобщённую
функцию <code><span class="func">f</span></code> со стороны {\Meroonet}; в нём лежит таблица диспетчеризации, из
которой <code><span class="func">determine-method</span></code> достаёт соответствующие методы. Ввиду того, что
не все значения Scheme являются объектами, перед поиском метода необходимо
убедиться в том, что дискриминант — это действительно объект {\Meroonet}.</p>


<!--\indexC{determine-method}-->
<pre>(define (determine-method generic o)
  (if (Object? o)
      (vector-ref (Generic-dispatch-table generic)
                  (vector-ref o 0) )
      (Generic-default generic) ) )</pre>

<p>Сами же обобщённые функции определяются следующим образом:
%
<!--\indexC{define-generic}-->
\begin{code:lisp}
(define-meroonet-macro (define-generic call . body)
  (parse-variable-specifications
   (cdr call)
   (lambda (discriminant variables)
     (let ((generic (gensym)))      ; соблюдаем гигиену
       `(define ,(car call)
          (let ((,generic (register-generic
                           ',(car call)
                           (lambda ,(flat-variables variables)
                             ,(if (pair? body)
                                  `(begin . ,body)
                                  `(meroonet-error
                                    "No method" ',(car call)
                                    . ,(flat-variables variables) ) ) )
                           ',(cdr call) )))
            (lambda ,variables
              ((determine-method ,generic ,(car discriminant))
               . ,(flat-variables variables) ) ) ) ) ) ) ) )</pre>

<p>Функция <code><span class="func">parse-variable-specifications</span></code> анализирует список аргументов,
определяет в нём дискриминант и корректирует его синтаксис в соответствии
с правилами Scheme. Эта функция используется как в <code><span class="func">define-generic</span></code>, так и
в <code><span class="func">define-method</span></code>. Полученные два значения она передаёт своему второму
аргументу. Ради простоты функция <code><span class="func">parse-variable-specifications</span></code> определена
слегка небрежно: она не проверяет, единственен ли дискриминант.</p>


<!--\indexC{parse-variable-specifications}-->
<pre>(define (parse-variable-specifications specifications k)
  (if (pair? specifications)
      (parse-variable-specifications
       (cdr specifications)
       (lambda (discriminant variables)
         (if (pair? (car specifications))
             (k (car specifications)
                (cons (caar specifications) variables) )
             (k discriminant (cons (car specifications) variables))|\:|)|\:|)|\:|)
      (k #f specifications) ) )</pre>

<p>Вслед за списком аргументов конструируется тело обобщённой функции, после чего
функция <code><span class="func">register-generic</span></code> создаёт итоговый объект {\Meroonet}. Эта функция
позволяет скрыть (на уровне макроса <code><span class="func">define-generic</span></code>) детали реализации
обобщённых функций, в частности, список <code><span class="func">*generics*</span></code>. Она же создаёт таблицу
диспетчеризации, все ячейки которой изначально содержат метод по умолчанию —
именно этот метод должен вызываться, если нет более подходящего. Размер таблицы
диспетчеризации зависит от общего количества классов, а не текущего на момент
создания обобщённой функции: при определении новых классов во всех таблицах
должны добавляться новые ячейки. Так как у нас максимальное количество классов
фиксировано, то достаточно будет просто зарезервировать вектор соответствующего
размера.</p>


<!--\indexC{register-generic}-->
<pre>(define (register-generic generic-name default signature)
  (let* ((dispatch-table (make-vector *maximal-number-of-classes*
                                      default ))
         (generic (make-Generic generic-name
                                default
                                dispatch-table
                                signature )) )
    (set! *generics* (cons generic *generics*))
    generic ) )</pre>

<p>Функция <code><span class="func">flat-variables</span></code> собирает все аргументы в простой список и
преобразует точечную переменную в обычную. Это преобразование используется при
определении всех методов.</p>


<!--\indexC{flat-variables}-->
<pre>(define (flat-variables variables)
  (if (pair? variables)
      (cons (car variables) (flat-variables (cdr variables)))
      (if (null? variables) variables (list variables)) ) )</pre>

<p>
\subsubsection{Ещё немного об определениях классов}%
\label{objects/generics/sssect:class-def}</p>


<!--\indexR{наследование!методов}-->
<p>Как вы помните, при определении класса вызывается функция <code><span class="func">update-generics</span></code>.
Её задача заключается в распространении методов суперкласса на объекты
создаваемого класса. Если для ранее определённого класса <code><span class="func">Point</span></code> существует
метод <code><span class="func">show</span></code>, то логично будет сделать так, чтобы его подкласс
<code><span class="func">ColoredPoint</span></code> тоже обладал этим методом. Для этого потребуется обновить
таблицы диспетчеризации всех обобщённых функций, которые были определены на
момент создания нового класса.</p>


<!--\indexC{update-generics}-->
<pre>(define (update-generics class)
  (let ((superclass (Class-superclass class)))
    (for-each
     (lambda (generic)
       (vector-set! (Generic-dispatch-table generic)
                    (Class-number class)
                    (vector-ref (Generic-dispatch-table generic)
                                (Class-number superclass) ) ) )
     *generics* ) ) )</pre>

<h2 id="objects/sect:method">Методы</h2>


<!--\indexR{методы}-->
<p>Методы определяются с помощью формы <code><span class="func">define-method</span></code>. Её синтаксис схож
с <code><span class="func">define</span></code>, только список аргументов метода выглядит так же, как и
в <code><span class="func">define-generic</span></code>: аргумент-дискриминант записывается в скобках вместе
с именем класса, для которого определяется данный метод.</p>


<!--\indexC{define-method}-->
<pre>(define-method (<i>имя</i> <i>переменные</i>...) <i>формы</i>...)</pre>

<p>Обобщённые функции являются объектами, чьё поведение можно динамически
расширять, определяя новые методы с помощью <code><span class="func">define-method</span></code>. Следовательно,
обобщённые функции изменяемы, что несколько усложняет оптимизацию их вызовов,
если только в языке нет возможности полностью или частично зафиксировать
иерархию классов (подобно ключевому слову <code><span class="func">sealed</span></code> в Dylan <span class="cite">[<a href="z1_bibliography.xhtml#app92b">app92b</a>]</span>),
чтобы можно было спокойно провести её статический анализ. Другим решением будет
сделать обобщённые функции неизменяемыми, но для этого необходимы функторы,
которых в стандартном Scheme нет.</p>

<p>C арностью методов мы уже разобрались, когда рассматривали определение
обобщённых функций и методов по умолчанию. Кроме этого надо не забыть
распространить определяемый метод не только на непосредственно указанный класс,
но также и на все его подклассы, для которых данный метод не был определён
ранее.</p>


<!--\indexC{super}-->
<!--\indexC{call-next-method}-->
<p>Единственной оставшейся проблемой является реализация возможности, которая
в Smalltalk называется <code><span class="func">super</span></code>, а в CLOS — <code><span class="func">call-next-method</span></code>. Имеется
в виду возможность для метода подкласса вызвать одноимённый метод суперкласса
(который иначе для подкласса недоступен). Форма <code>(call-next-method)</code> может
использоваться только внутри определений методов и означает вызов
соответствующего суперметода с теми же\footnote{В отличие от CLOS, мы запретили
изменять аргументы вызова суперметода, так как иначе стало бы возможным заменить
дискриминант абсолютно любым объектом, что противоречит самой идее суперметодов,
а также мешает восприятию кода как людьми, так и компиляторами.} аргументами,
что и у вызывающего метода. Естественно, суперметодами класса <code><span class="func">Object</span></code>
являются методы по умолчанию.</p>


<!--\indexR{методы!предметоды}-->
<!--\indexR{предварительный метод}-->
<p>Функция <code><span class="func">call-next-method</span></code> определяется локально в теле метода и реализуется
аналогична рассмотренной ранее <code><span class="func">determine-method</span></code>: нужный метод извлекается
из таблицы диспетчеризации соответствующей обобщённой функции по номеру класса,
просто в этот раз используется суперкласс рассматриваемого объекта. Внимание:
по причинам, связанным с потенциальными особенностями макрораскрытия
\seePage[objects/def-class/par:two-worlds], невозможно гарантированно знать
номера классов до начала исполнения программы. Поэтому мы поступим следующим
образом. Форма <code><span class="func">define-method</span></code> сначала определит предварительный метод,
принимающий класс и обобщённую функцию; он должен будет вернуть замыкание,
содержащее код настоящего метода. Затем, во время исполнения, этот предметод
будет вызван с корректными аргументами, а полученное замыкание — установлено
на его место. Всё это помещается в функцию <code><span class="func">register-method</span></code>, чтобы скрыть
детали реализации и не перегружать ими определение макроса <code><span class="func">define-method</span></code>.</p>


<!--\indexC{define-method}-->
<pre>(define-meroonet-macro (define-method call . body)
  (parse-variable-specifications
   (cdr call)
   (lambda (discriminant variables)
     (let ((g (gensym)) (c (gensym)))
       `(register-method
         ',(car call)
         (lambda (,g ,c)
           (lambda ,(flat-variables variables)
             (define (call-next-method)
               ((if (Class-superclass ,c)
                    (vector-ref (Generic-dispatch-table ,g)
                                (Class-number (Class-superclass ,c)) )
                    (Generic-default ,g) )
                . ,(flat-variables variables) ) )
             . ,body ) )
         ',(cadr discriminant)
         ',(cdr call) ) ) ) ) )</pre>

<p>\phantomlabel{objects/method/par:func-eq}
<!--\indexR{сравнение!функций}-->
<!--\indexR{функции!сравнение}-->
Функция <code><span class="func">register-method</span></code> определяет необходимый класс и обобщённую функцию,
преобразует предметод в нормальный метод, проверяет согласованность его
сигнатуры и сигнатуры обобщённой функции, после чего, наконец, устанавливает
метод в таблицу диспетчеризации. Проверку согласованности, в принципе, можно
было бы выполнить ещё при раскрытии макросов, но для этого макрос
<code><span class="func">define-method</span></code> должен помнить все определённые на момент раскрытия
обобщённые функции — короче говоря, мы бы получили те же сложности
с состоянием, что и у <code><span class="func">define-class</span></code>. Так как эта проверка весьма проста,
выполняется всего лишь один раз и в дальнейшем никак не влияет на быстродействие
обобщённых функций, то её с чистой совестью можно провести во время исполнения
программы. Заметьте, что при обновлении методов функции сравниваются
с помощью <code><span class="func">eq?</span></code>.</p>


<!--\indexC{register-method}-->
<!--\indexC{check-signature-compatibility}-->
<pre>(define (register-method generic-name pre-method class-name signature)
  (let* ((generic (->Generic generic-name))
         (class (->Class class-name))
         (new-method (pre-method generic class))
         (dispatch-table (Generic-dispatch-table generic))
         (old-method (vector-ref dispatch-table
                                 (Class-number class) )) )
    (check-signature-compatibility generic signature)
    (let propagate ((cn (Class-number class)))
      (let ((content (vector-ref dispatch-table cn)))
        (if (eq? content old-method)
            (begin
              (vector-set! dispatch-table cn new-method)
              (for-each propagate
               (Class-subclass-numbers (number->Class cn))|\:|)|\:|)|\:|)|\:%
                                                             |)|\:|)|\:|)|\:|)</p>

<p>(define (check-signature-compatibility generic signature)
  (define (coherent-signatures? la lb)
    (if (pair? la)
        (if (pair? lb)
            (and (or
                  ;; совпадают дискриминанты
                  (and (pair? (car la)) (pair? (car lb)))
                  ;; совпадают аргументы
                  (and (symbol? (car la)) (symbol? (car lb))) )
              (coherent-signatures? (cdr la) (cdr lb)) )
            #f )
        (or (and (null? la) (null? lb))
            ;; совпадает точечная переменная
            (and (symbol? la) (symbol? lb)) ) ) )</p>

<p>  (if (not (coherent-signatures? signature
                                 (Generic-signature generic) ))
    (meroonet-error "Incompatible signature" generic signature)
    #t ) )</pre>

<h2 id="objects/sect:conclusions">Заключение</h2>

<p>В рассмотренных программах много чего можно улучшить как в плане повышения
быстродействия, так и для улучшений рефлексивных качеств объектной системы.
Ещё одной возможностью, достойной внимания, является встраивание {\Meroonet}
в реализацию языка, что открыло бы дорогу множеству других оптимизаций, а также
сделало бы Scheme по-настоящему объектно-ориентированным. Именно из этих
соображений <span class="logo">EuLisp</span>, ILOG Talk, <span class="logo">Common Lisp</span> и многие другие поддерживают
концепцию объектов непосредственно, делая их базовыми понятиями языка.</p>


<h2 id="objects/sect:exercises">Упражнения</h2>

<h5 class="exercise" id="objects/ex:precise-predicate">Упражнение <span class="seq">0.0</span></h5>
<p>Улучшите определение предиката <code><span class="func">Object?</span></code>, чтобы он чётче различал объекты и
значения Scheme.</p>


<h5 class="exercise" id="objects/ex:clone">Упражнение <span class="seq">0.0</span></h5>
<p>Напишите обобщённую функцию <code><span class="func">clone</span></code>, копирующую объекты {\Meroonet}. Пусть
она выполняет «поверхностное копирование» (shallow copy): содержимое полей
исходного объекта можно просто перенести в копию без рекурсивных вызовов
<code><span class="func">clone</span></code>.</p>


<h5 class="exercise" id="objects/ex:metaclass">Упражнение <span class="seq">0.0</span></h5>
<p>{\Meroonet} позволяет определять новые типы классов — метаклассы, являющиеся
наследниками <code><span class="func">Class</span></code>. Реализуйте метакласс, чьими экземплярами будут классы,
подсчитывающие количество своих объектов.</p>


<h5 class="exercise" id="objects/ex:field-reflection">Упражнение <span class="seq">0.0</span></h5>
<p>Классам и полям {\Meroonet} не помешало бы чуть больше рефлексии. Добавьте им
дополнительные поля, ссылающиеся на сопутствующие функции: предикат и оба
аллокатора для классов; геттеры, сеттеры и измерители длины для полей.</p>


<h5 class="exercise" id="objects/ex:auto-generic">Упражнение <span class="seq">0.0</span></h5>
<p>CLOS не требует обязательного существования обобщённой функции для определения
её метода. Доработайте <code><span class="func">define-method</span></code> так, чтобы она создавала необходимую
обобщённую функцию на лету, если она ещё не была определена.</p>


<h5 class="exercise" id="objects/ex:next-method">Упражнение <span class="seq">0.0</span></h5>
<!--\indexC{next-method"?}-->
<p>Некоторые объектные системы, вроде CLOS и \TELOS, наряду с <code><span class="func">call-next-method</span></code>
имеют также предикат <code><span class="func">next-method?</span></code>, возвращающий ложь, когда следующий
суперметод не определён. Эта рефлексивная возможность позволяет последовательно
выполнить всю цепочку суперметодов, не рискуя при этом вызвать метод по
умолчанию, потенциально приводящий к ошибке. Научите <code><span class="func">define-method</span></code>
определять функцию <code><span class="func">next-method?</span></code>.</p>

<p>\ForLayout{display}{\clearpage}</p>

<p>\section*{Рекомендуемая литература}\label{objects/sect:recommended-reading}</p>

<p>Диалект T <span class="cite">[<a href="z1_bibliography.xhtml#ar88">ar88</a>]</span> предлагает иной подход к объектам в Scheme. Если вам
понравилась идея метаобъектов, то сперва стоит взглянуть на вот эту статью
о рефлексии в ObjVlisp: <span class="cite">[<a href="z1_bibliography.xhtml#coi87">coi87</a>]</span>, а после уже приниматься за изучение
метаобъектного протокола CLOS <span class="cite">[<a href="z1_bibliography.xhtml#kdrb92">kdrb92</a>]</span>.</p>

<p></body>
</html>
