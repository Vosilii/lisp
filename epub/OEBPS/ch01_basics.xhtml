<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru">

<head>
    <link rel="stylesheet" type="text/css" href="zz_lisp.css"/>
</head>

<body>

<h1 id="chapter:basics"><span class="seq">Глава 1.</span> Основы интерпретации</h1>

<p><span class="initial"><span class="letter">В</span> этой главе</span> описывается базовый интерпретатор, идеи
которого проходят красной нитью через большую часть этой книги. Он намеренно
сделан простым и более близким к Scheme, чем к Лиспу; это позволит нам
в дальнейшем описывать Лисп в терминах Scheme. Мы коснёмся следующих тем в этой
вводной главе: сути интерпретации; известной пары функций <code><span class="func">eval</span></code> и
<code><span class="func">apply</span></code>; ожидаемых свойств окружений и функций. Короче говоря, мы начнём
рассматривать здесь то, что будем изучать подробнее в следующих главах, надеясь,
что вас не отпугнёт пропасть незнания по обе стороны моста, которым мы пойдём.</p>

<div class="bigskip"/>

<p>Интерпретатор и его варианты будут написаны на Scheme без использования
каких-либо существенных особенностей данного диалекта.</p>

<p>В книгах по Лиспу редко когда отказываются от нарциссического соблазна описать
Лисп с помощью Лиспа. Начало традиции положило первое руководство по
<span class="logo">Lisp 1.5</span> <span class="cite">[<a href="z1_bibliography.xhtml#mae+62">MAE<sup>+</sup>62</a>]</span>, и впоследствии такой подход широко распространился.
Вот лишь малая часть существующих примеров:
<span class="cite">[<a href="z1_bibliography.xhtml#rib69">Rib69</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#gre77">Gre77</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#que82">Que82</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#cay83">Cay83</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#cha80">Cha80</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#sj93">SJ93</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#rey72">Rey72</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#gor75">Gor75</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#ss75">SS75</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#all78">All78</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#mcc78b">McC78b</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#lak80">Lak80</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#hen80">Hen80</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#bm82">DM82</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#cli84">Cli84</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#fw84">FW84</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#drs84">dRS84</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#as85">AS85</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#r3r86">R3R86</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#mas86">Mas86</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#dyb87">Dyb87</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#wh89">WH89</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#kes88">Kes88</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#lf88">LF88</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#dil88">Dil88</a>]</span>,
<span class="cite">[<a href="z1_bibliography.xhtml#kam90">Kam90</a>]</span>.</p>

<p>Эти интерпретаторы довольно сильно разнятся, как языками, которые они реализуют
и используют для реализации, так и, что более важно, целями, которые они
преследуют. Например, интерпретатор из <span class="cite">[<a href="z1_bibliography.xhtml#lak80">Lak80</a>]</span> показывает, как объекты
и концепции компьютерной графики естественным образом реализуются на Лиспе;
а интерпретатор, описываемый в <span class="cite">[<a href="z1_bibliography.xhtml#bm82">BM82</a>]</span>, создан для явного замера сложности
интерпретируемых программ.</p>

<!--\indexR{язык!реализации}-->
<!--\indexR{язык!реализуемый}-->
<p>Язык, <em>используемый</em> для реализации, тоже играет немалую роль. Если в нём
есть присваивание и доступ к памяти (<code><span class="func">set-car!</span></code> и <code><span class="func">set-cdr!</span></code>), это даёт
б\'{о}льшую свободу и делает исходный код интерпретатора более компактным. Мы
получаем возможность описать язык в терминах, которые близки к машинным
инструкциям. И, как и с машинными инструкциями, несмотря на то, что такое
описание может быть непросто составить, не возникает никаких сомнений в том, что
именно делает каждая конкретная строка. Даже если подобное описание занимает
больше места, чем высокоуровневое, оно даёт более точное понимание смысла
происходящего при интерпретации — для нас важно именно это.</p>

<p>\begin{figure}\centering
\input{figures/fig1.1}
\caption{Уровни сложности.}\label{basics/fig:richness-plot}
\end{figure}</p>

<p>На рисунке \ref{basics/fig:richness-plot} показано сравнение уровней сложности
определяющего (по оси <span class="math"><span class="var">x</span></span>) и
определяемого (по оси <span class="math"><span class="var">y</span></span>)
языков для некоторых из интерпретаторов. Здесь хорошо виден ход развития наших
знаний со временем: всё
более сложные проблемы решаются с использованием всё более ограниченных
возможностей. Эта книга соответствует вектору, который начинается использованием
высокоуровневого Лиспа для реализации Scheme, а заканчивается реализацией
высокоуровневого Лиспа с помощью одного лишь λ-исчисления.</p>


<h2 id="basics/sect:evaluation"><span class="seq">1.1.</span> Вычисления</h2>

<!--\indexC{eval}-->
<!--\indexR{вычислитель}-->
<p>Важнейшая часть интерпретатора Лиспа находится в одной функции, вокруг которой
крутится все остальное. Эта функция, называемая <code><span class="func">eval</span></code>, принимает на вход
программу, а на выходе даёт результат её исполнения. Явное наличие исполнителя
кода отнюдь не случайно, а, наоборот, является характерной и намеренно
реализованной чертой Лиспа.</p>

<!--\indexR{язык!универсальный}-->
<!--\indexR{универсальный язык}-->
<!--\indexR{машина Тьюринга}-->
<!--\indexR{Тьюринга, машина}-->
<p>Язык программирования называется <em class="term">универсальным</em>, если он не уступает
в выразительных возможностях машине Тьюринга. Так как машина Тьюринга довольно
примитивна, то несложно разработать язык, который бы удовлетворял этому условию;
действительно, сложнее будет придумать язык, который был бы полезным, но при
этом не был бы полным по Тьюрингу.</p>

<!--\indexR{тезис Чёрча}-->
<!--\indexR{Чёрча, тезис}-->
<p>В соответствии с тезисом Чёрча, любая вычислимая функция может быть записана на
любом тьюринг-полном языке. Интерпретатор Лиспа можно представить как такую
функцию, которая принимает программы и возвращает результаты их исполнения. Так
что если такая функция вообще существует, её можно записать на любом
тьюринг-полном языке. Следовательно, функцию-вычислитель Лиспа <code><span class="func">eval</span></code> можно
записать в частности на том же самом Лиспе. В этом нет никаких противоречий,
точно так же, к примеру, можно реализовать Фортран на Фортране.</p>

<p>Но что делает Лисп уникальным (и оправдывает явное описание <code><span class="func">eval</span></code>), так это
небольшой размер кода интерпретатора: обычно от одной до двадцати страниц
в зависимости от детализации.<a class="footref" href="zz_footnotes.xhtml#foot1.1"><sup>1</sup></a> Это результат желания сделать язык последовательным,
с минимальным количеством исключений из правил, и, что самое главное, с простым,
но выразительным синтаксисом.</p>

<!--\indexCS{eval}{свойства}-->
<p>Сам факт существования <code><span class="func">eval</span></code>, а также возможность её описания на Лиспе
имеют несколько интересных следствий.</p>

<ul>
    <li><p>Можно изучить Лисп или прочитав руководство (в котором описываются
        все доступные функции), или изучив собственно функцию <code><span class="func">eval</span></code>.
        Второй подход сложен тем, что надо уже знать Лисп для того, чтобы
        понять описание <code><span class="func">eval</span></code>; но ведь знание Лиспа по идее должно быть
        <em>следствием</em> изучения <code><span class="func">eval</span></code>, нежели <em>предпосылкой</em> для
        него. На самом деле, достаточно знать лишь ту часть Лиспа, которая
        используется для описания <code><span class="func">eval</span></code>. Кроме того, язык, определяемый
        одной <code><span class="func">eval</span></code>, не является всем Лиспом: он есть лишь сутью языка,
        в нём реализованы только специальные формы и немного примитивных
        функций.</p>

        <p>Тем не менее, в возможности изучать язык двумя разными, но всё же
        связанными путями лежит несомненный плюс Лиспа.</p></li>

    <li><p>Тот факт, что <code><span class="func">eval</span></code> написана на Лиспе, значит также и то, что
        среда разработки является составной частью языка и не требует
        значительных накладных расходов. Под средой разработки понимаются
        такие вещи как отладчик, трассировщик или возможность обратного
        хода <span class="cite">[<a href="z1_bibliography.xhtml#lie87">Lie87</a>]</span>. Практически, реализация таких инструментов —
        это лишь доработка <code><span class="func">eval</span></code>, к примеру, чтобы она выводила
        сообщения при вызове функций, приостанавливала вычисления
        в интересующих местах и так далее.</p>

        <p>Долгое время среда разработки с такими возможностями была уникальной
        для Лиспа. Но и сегодня то, что <code><span class="func">eval</span></code> может быть описана на самом
        Лиспе, даёт возможность легко экспериментировать с новыми вариантами
        реализации вычислений или отладки.</p></li>

    <li><p>Наконец, сама по себе <code><span class="func">eval</span></code> способна быть инструментом
        программирования. Достаточно спорным инструментом, так как
        использование <code><span class="func">eval</span></code> требует присутствия в памяти целого
        интерпретатора или компилятора во время исполнения кода; но ещё
        более серьёзной проблемой является невозможность применения в таком
        случае некоторых оптимизаций. Другими словами, использование
        <code><span class="func">eval</span></code> имеет свою цену. В некоторых случаях её использование
        полностью оправдано, к примеру, когда Лисп используется для описания
        и реализации метаязыков.</p>

        <p>Кроме ощутимой стоимости использования, семантика <code><span class="func">eval</span></code> часто
        неоднозначна. Именно поэтому она вообще не входила в стандарт до
        ревизии R<sup>5</sup>RS <span class="cite">[<a href="z1_bibliography.xhtml#cr91b">CR91b</a>, <a href="z1_bibliography.xhtml#kcr98">KCR98</a>]</span>.
        <span class="see">[см. <a href="ch8_evaluation_and_reflection.xhtml">8 главу</a>]</span></p></li>
</ul>


<h2 id="basics/sect:basic-evaluator"><span class="seq">1.2.</span> Базовый вычислитель</h2>

<!--\indexR{переменные!свободные}-->
<!--\indexR{переменные!связанные}-->
<!--\indexR{свободные переменные}-->
<!--\indexR{связывающие формы}-->
<!--\indexR{форма!связывающая}-->
<!--\indexR{окружение}-->
<!--\indexC{evaluate}-->
<p>Будем различать в программе <em class="term">свободные</em> и <em class="term">связанные переменные</em>.
Переменная свободна, если ни одна связывающая форма (вроде <code><span class="special">let</span></code> или
<code><span class="special">lambda</span></code>) не связывает её с каким-либо значением. В противном случае она
называется связанной. Соответственно, свободные переменные могут иметь любое
значение, и нельзя определённо сказать, какое именно, не выходя за рамки
функции. Структура данных, которая связывает переменные с их значениями,
называется <em class="term">окружением</em>. Таким образом, функция <code><span class="func">evaluate</span></code><a class="footref" href="zz_footnotes.xhtml#foot1.2"><sup>2</sup></a> имеет два аргумента: программу и окружение, в котором она
должна быть исполнена:</p>

<pre>(<span class="special">define</span> (<span class="func">evaluate</span> <span class="var">exp</span> <span class="var">env</span>) ... )</pre>


<h2 id="basics/sect:evaluating-atoms"><span class="seq">1.3.</span> Вычисляем атомы</h2>

<p>Одна из ключевых особенностей Лиспа состоит в том, что программы записываются
теми же конструкциями, что и остальные данные. Но так как любая запись
подразумевает определённые условности, поговорим о таких условностях для записи
программ. Главные соглашения: переменные записываются символами (своими
именами), а вызовы функций — списками, где первый элемент — это вызываемая
функция, а остальные — её аргументы.</p>

<!--\indexR{атом}-->
<p>Как и любой другой компилятор, <code><span class="func">evaluate</span></code> начинает свою работу
с синтаксического анализа переданного ей выражения, чтобы выяснить, что именно
оно означает. В этом смысле, название раздела не совсем правильное: мы
рассматриваем не буквально вычисление атомов, а интерпретацию программ,
состоящих из атомов. Сейчас важно отличать саму программу от её представления
(письмо от листа бумаги, на котором оно написано). Функция <code><span class="func">evaluate</span></code>
работает с представлением программ, по нему она узнаёт предписываемые программой
действия и выполняет их.</p>

<!--\indexC{atom"?}-->
<pre>(<span class="special">define</span> (<span class="func">evaluate</span> <span class="var">exp</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">exp</span>)   <span class="comment">; <code>(<span class="func">atom?</span> <span class="var">exp</span>)</code> ≡ <code>(<span class="func">not</span> (<span class="func">pair?</span> <span class="var">exp</span>))</code></span>
      ...
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">exp</span>)
        ...
        (<span class="syntax">else</span> ...) ) ) )</pre>

<p>Если выражение не является списком, то это скорее всего символ, или число, или
какая-нибудь строка. Если это всё же символ, то он представляет
<em class="term">переменную</em>, а её значение хранится в окружении:</p>

<pre>(<span class="special">define</span> (<span class="func">evaluate</span> <span class="var">exp</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">exp</span>)
      (<span class="special">if</span> (<span class="func">symbol?</span> <span class="var">exp</span>) (<span class="func">lookup</span> <span class="var">exp</span> <span class="var">env</span>) <span class="var">exp</span>)
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">exp</span>)
        ...
        (<span class="syntax">else</span> ...) ) ) )</pre>

<p>Функция <code><span class="func">lookup</span></code> (которая рассматривается подробнее в разделе <a href="#basics/sect:repr-the-env">1.5</a>) знает, как отыскать значение
переменной в окружении. Вот её прототип:</p>

<!--\indexC{lookup}-->
<pre>(<span class="func">lookup</span> <i>переменная</i> <i>окружение</i>) <span class="math"><span class="binop">→</span></span> <i>значение</i></pre>

<!--\indexR{переменные!связь с символами}-->
<!--\indexR{символы!связь с переменными}-->
<p>Как видим, здесь происходит неявное преобразование символа в переменную. Если
быть более дотошным, тогда вместо <code>(<span class="func">lookup</span> <span class="var">exp</span> <span class="var">env</span>)</code> надо записать что-то
вроде:</p>

<pre>... (<span class="func">lookup</span> (<span class="func">symbol-&gt;variable</span> <span class="var">exp</span>) <span class="var">env</span>) ...</pre>

<!--\indexR{приведение типов}-->
<!--\indexR{объекты!второго класса}-->
<p>В таком случае мы явно говорим, что символ <code><span class="var">exp</span></code>, чьим значением является имя
переменной, должен быть превращён в переменную. Также это подчёркивает тот факт,
что функция <code><span class="func">symbol-&gt;variable</span></code><a class="footref" href="zz_footnotes.xhtml#foot1.3"><sup>3</sup></a> вовсе не переводит <code><span class="func">exp</span></code> сам
в себя; она превращает синтаксическую сущность (символ) в семантическую
(переменную). В действительности, переменные — это лишь воображаемые объекты,
которым язык и программист дали какие-то имена, и которые ради удобства
используются в форме имён. Способ представления имён также выбран из соображений
удобства, так как Лисп имеет базовый тип символов. В данном случае
<code><span class="func">symbol-&gt;variable</span></code> ничего не делает, хотя на самом деле могла бы применяться
какая-нибудь другая форма записи имени переменной, например: строка, состоящая
из знака доллара и имени переменной; в этом случае, конечно же,
<code><span class="func">symbol-&gt;variable</span></code> будет сложнее.</p>

<p>Если бы переменные действительно были лишь воображаемыми, то <code><span class="func">lookup</span></code>
не знала бы как обрабатывать свой первый аргумент, так как она ожидает нечто
«материальное». Так что нам надо преобразовать переменную в её программное
представление, какой-нибудь уникальный ключ, по которому <code><span class="func">lookup</span></code> сможет
отыскать переменную в окружении. Так что ещё точнее было бы записать:</p>

<pre>... (<span class="func">lookup</span> (<span class="func">variable-&gt;key</span> (<span class="func">symbol-&gt;variable</span> <span class="var">exp</span>)) <span class="var">env</span>) ...</pre>

<p>Однако, врождённая лень лисперов настаивает на использовании символов для
ключей. Так что <code><span class="func">variable-&gt;key</span></code> — это лишь обратная функция
к <code><span class="func">symbol-&gt;variable</span></code>, и их последовательное применение
никак не изменяет <code><span class="var">exp</span></code>.</p>

<!--\indexR{автоцитирование}-->
<!--\indexR{механизм автоцитирования}-->
<p>Если выражение атомарное (то есть не является списком) и не является символом,
то соблазнительно его считать представлением какой-нибудь константы
с соответствующим значением. Такое поведение называется механизмом
<em class="term">автоцитирования</em>. Автоцитируемый объект не требует явного цитирования и
имеет собственное значение. За примерами можно обратиться к <span class="cite">[<a href="z1_bibliography.xhtml#cha96">Cha96</a>]</span>.</p>

<p>Но является ли такое поведение правильным? Во-первых, не всегда атомарные
объекты обозначают сами себя. Например, строка <code>"a?b:c"</code> могла бы означать
вызов компилятора Си, затем вызов получившейся программы и подстановку
возвращаемого ей значения вместо этой строки.</p>

<p>С другими объектами (вроде функций) вообще не понятно, как именно их
<em>вычислять</em>. К примеру, ясно, что значением переменной <code><span
class="var">car</span></code> является
функция, возвращающая левый элемент пары, но что является значением самой
функции <i>car</i>? Чаще всего попытки вычисления значения функции считаются
ошибочными.</p>

<!--\indexC{()}-->
<!--\indexR{пустой список, \protect<code><span class="func">()</span></code>}-->
<p>Другой пример проблемного значения — пустой список <code><span class="hash">()</span></code>.
Судя по тому, что это список, он должен означать вызов функции. Вот только в нём нет
ни аргументов, ни самой функции. Такая запись в Scheme запрещена и является
синтаксической ошибкой.</p>

<p>Поэтому необходимо очень аккуратно анализировать программу и автоцитировать
только те данные, для которых это явно стоить делать, например: числа, строки
и знаки.
<span class="see">[см. раздел <a href="#basics/evaluating-forms/ssect:quoting">1.4.1</a>]</span>
Так что мы записываем следующее:</p>

<pre>(<span class="special">define</span> (<span class="func">evaluate</span> <span class="var">exp</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">exp</span>)
      (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">exp</span>) (<span class="func">lookup</span> <span class="var">exp</span> <span class="var">env</span>))
            ((<span class="special">or</span> (<span class="func">number?</span> <span class="var">exp</span>) (<span class="func">string?</span> <span class="var">exp</span>) (<span class="func">char?</span> <span class="var">exp</span>)
                 (<span class="func">boolean?</span> <span class="var">exp</span>) (<span class="func">vector?</span> <span class="var">exp</span>) )
             <span class="var">exp</span> )
            (<span class="syntax">else</span> (<span class="special">wrong</span> <span class="string">"Cannot evaluate"</span> <span class="var">exp</span>)) )
      ... ) )</pre>

<!--\indexR{ошибки!варианты обработки}-->
<!--\indexC{wrong}-->
<p id="basic/atoms/para:the-first-error">В этом фрагменте кода виден первый случай,
когда могут возникнуть ошибки. Большая часть лисп-систем имеет свои собственные механизмы
обработки исключительных ситуаций, которые непросто сделать переносимыми. В случае ошибки
мы вызываем <code><span class="special">wrong</span></code><a class="footref" href="zz_footnotes.xhtml#foot1.4"><sup>4</sup></a> и передаём ей первым аргументом строку. В строке находится
текстовое описание ошибки, а следующие за ней аргументы несут дополнительную информацию о том, что
вызвало проблему. Системы с зачаточным механизмом обработки ошибок обычно
в случае проблем выдают какие-то непонятные надписи вроде <code><span class="string">"Bus
error: core dumped"</span></code> и умирают. Другие останавливают текущие вычисления и
возвращаются к диалоговому режиму. А третьи могут связывать с вычисляемым выражением
специальный обработчик исключений, который перехватит брошенный объект,
описывающий ошибку, и будет уже по нему решать, что делать дальше.
<span class="see">[см. раздел <a href="ch7_compilation.xhtml#compilation/sect:exception">7.9</a>]</span>
В некоторых случаях даже реализуется подобие экспертной системы, которая анализирует ошибку,
вызвавший её код и выдаёт пользователю варианты её исправления. В общем, сложно сказать однозначно,
что следует делать в случае ошибки.</p>


<h2><span class="seq">1.4.</span> Вычисляем формы</h2>

<!--\indexR{специальные формы}-->
<!--\indexR{форма!специальная}-->
<!--\indexR{Лисп!специальные формы}-->
<p>Каждый язык имеет некоторое количество «неприкасаемых» синтаксических
конструкций: их нельзя адекватно переопределить и вообще не стоит трогать.
В Лиспе такие конструкции называются <em class="term">специальными формами</em>. Они
представляются списками, где первый элемент — это определённый символ,
принадлежащий множеству <em class="term">специальных операторов</em> (или синтаксических
ключевых слов, как их называют в Scheme).</p>

<!--\indexR{функции!примитивы}-->
<!--\indexR{примитивы}-->
<!--\indexR{диалекты Лиспа}-->
<p>Конкретный диалект Лиспа характеризуется набором специальных форм и библиотекой
примитивных функций (эти функции нельзя определить на самом диалекте, так как
они тесно связаны с реализацией; например, для Scheme это
<code><span class="func">call/cc</span></code>).</p>

<p>В некотором понимании, Лисп является лишь прикладным λ-исчислением
вместе с расширяющим его набором специальных форм. Специфика каждого конкретного
диалекта Лиспа лежит только в этом наборе. В Scheme используется минимальный
набор специальных операторов (<code><span class="special">quote</span></code>,
<code><span class="special">if</span></code>,
<code><span class="special">set!</span></code> и
<code><span class="special">lambda</span></code>),
тогда как <span class="logo">Common Lisp</span> (CLtL2 <span class="cite">[<a
href="z1_bibliography.xhtml#ste90">Ste90</a>]</span>) определяет более тридцати, описывая
таким образом случаи, когда может быть сгенерирован высокоэффективный машинный
код.</p>

<p>Так как специальные формы записываются буквально, то их синтаксический анализ
прост, хватит одного <code><span class="syntax">case</span></code>-выражения: надо лишь смотреть на первый элемент
списка. Если форма начинается не со специального оператора, то она означает
применение функции. В данный момент мы ограничимся лишь небольшим подмножеством
специальных форм: <code><span class="special">quote</span></code>, <code><span class="special">if</span></code>, <code><span class="special">begin</span></code>, <code><span class="special">set!</span></code> и <code><span class="special">lambda</span></code>.
(В следующих главах мы введём другие, более специализированные формы.)</p>

<!--\indexC{evaluate}-->
<pre>(<span class="special">define</span> (<span class="func">evaluate</span> <span class="var">e</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">atom?</span> <span class="var">e</span>)
      (<span class="syntax">cond</span> ((<span class="func">symbol?</span> <span class="var">e</span>) (<span class="func">lookup</span> <span class="var">e</span> <span class="var">env</span>))
            ((<span class="special">or</span> (<span class="func">number?</span> <span class="var">e</span>)(<span class="func">string?</span> <span class="var">e</span>)(<span class="func">char?</span> <span class="var">e</span>)
                 (<span class="func">boolean?</span> <span class="var">e</span>)(<span class="func">vector?</span> <span class="var">e</span>) ) <span class="var">e</span>)
            (<span class="syntax">else</span> (<span class="special">wrong</span> <span class="string">"Cannot evaluate"</span> <span class="var">e</span>)) )
      (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
        ((<span class="var">quote</span>)  (<span class="func">cadr</span> <span class="var">e</span>))
        ((<span class="var">if</span>)     (<span class="special">if</span> (<span class="func">evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span>)
                      (<span class="func">evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span>)
                      (<span class="func">evaluate</span> (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">env</span>) ))
        ((<span class="var">begin</span>)  (<span class="func">eprogn </span>(<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span>))
        ((<span class="var">set!</span>)   (<span class="func">update!</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span> (<span class="func">evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span>)))
        ((<span class="var">lambda</span>) (<span class="func">make-function</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">env</span>))
        (<span class="syntax">else</span>     (<span class="func">invoke</span> (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e</span>) <span class="var">env</span>)
                          (<span class="func">evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span>) )) ) ) )</pre>

<!--\indexR{синтаксис!if@\protect<code><span class="func">if</span></code>}-->
<p>Чтобы упростить определение, синтаксический анализ оставлен минимальным: мы
не проверяем, правильно ли записаны цитаты, действительно ли
<code><span class="special">if</span></code> передано
три аргумента<a class="footref" href="zz_footnotes.xhtml#foot1.5"><sup>5</sup></a>
и так далее. Мы априори считаем
интерпретируемые программы синтаксически корректными.</p>


<h3 id="basics/evaluating-forms/ssect:quoting"><span class="seq">1.4.1.</span> Цитирование</h3>

<!--\indexC{quote}-->
<!--\indexE{M-выражения}-->
<!--\indexE{S-выражения}-->
<!--\indexR{программы!как данные}-->
<!--\indexR{значения!как программы}-->
<!--\indexR{цитаты}-->
<p>Специальная форма <code><span class="special">quote</span></code> позволяет записать значение, которое без
цитирования было бы спутано с каким-нибудь выражением. Такой механизм необходим,
если программы тоже являются типом данных в языке — надо же как-то
различать, где записана программа, а где данные. Если бы был выбран другой
синтаксис, то эта проблема бы не возникла. К примеру, изначально в Лиспе
планировались M-выражения <span class="cite">[<a href="z1_bibliography.xhtml#mcc60">McC60</a>]</span> для записи действий над данными, а сами
данные должно были записываться S-выражениями. Это решило бы проблему
разделения кода и данных, но сделало бы невозможными вменяемые макросы —
очень полезную вещь для расширения синтаксиса. Как бы то ни было, M-выражения
долго не прожили <span class="cite">[<a href="z1_bibliography.xhtml#mcc78a">McC78a</a>]</span>, программы и данные стали записываться
исключительно S-выражениями. Поэтому в Лиспе есть специальная форма <code><span class="special">quote</span></code>,
служащая для разделения кода и данных.</p>

<p>Суть цитирования состоит в возврате выражения, следующего за ключевым словом,
«как есть», без его вычисления. Это чётко видно в следующем фрагменте кода:</p>

<pre>... (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
      ((<span class="var">quote</span>) (<span class="func">cadr</span> <span class="var">e</span>)) ... ) ...</pre>


<!--\indexR{цитаты!явные и неявные}-->
<p>Также интересен вопрос: а есть ли разница между явным и неявным цитированием,
например, между <code><span class="num">33</span></code> и <code><span class="num">'33</span></code>, или между<a href="zz_footnotes.xhtml#foot1.6"><sup>6</sup></a> <code>#(<span class="var">fa</span> <span class="var">do</span> <span class="var">sol</span>)</code> и
<code>'#(<span class="var">fa</span> <span class="var">do</span> <span class="var">sol</span>)</code>? Если первое сравнение происходит между непосредственными
значениями и тут вроде бы всё очевидно, то во втором случае сравниваются
составные объекты (хоть для Лиспа они и являются формально атомами). Можно легко
придумать несколько возможных трактовок данного выражения. Цитирование
возвращает аргумент как значение, но сама запись <code>#(<span class="var">fa</span> <span class="var">do</span> <span class="var">sol</span>)</code> могла бы
возвращать каждый раз новый вектор из трёх символов. Другими словами, <code>#(<span class="var">fa</span> <span class="var">do</span> <span class="var">sol</span>)</code> могла бы быть просто сокращённой записью выражения <code>(<span class="func">vector</span> <span class="var">'fa</span> <span class="var">'do</span> <span class="var">'sol</span>)</code>, которое, конечно же, будет означать совсем иное, нежели <code>'#(<span class="var">fa</span> <span class="var">do</span> <span class="var">sol</span>)</code>, и тем более <code>(<span class="func">vector</span> <span class="var">fa</span> <span class="var">do</span> <span class="var">sol</span>)</code>. Мы вернёмся к этой проблеме позже
<span class="see">[см. раздел <a href="ch04_assignment_and_side_effects.xhtml#assignment/sect:quotation">4.5</a>]</span>, потому что, как видите, не так просто
определиться, какой именно смысл придавать цитированию.</p>


<h3 id="basics/evaluating-forms/ssect:alternatives"><span class="seq">1.4.2.</span> Ветвление</h3>

<!--\indexC{if}-->
<p>Вспомним, как работает условный оператор <code><span class="special">if</span></code>: эта форма вычисляет свой
первый аргумент (<em class="term">условие</em>), затем в зависимости от результата вычислений
выбирает, возвращать значение второго аргумента (<em class="term">следствия</em>) или третьего
(<em class="term">альтернативы</em>). Эта идея выражается следующим кодом:</p>

<pre>... (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
      ((<span class="var">if</span>) (<span class="special">if</span> (<span class="func">evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span>)
                (<span class="func">evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span>)
                (<span class="func">evaluate</span> (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">env</span>) )) ... ) ...</pre>

<!--\indexR{представление!логических значений}-->
<!--\indexR{логические значения}-->
<p>Эта программа не совсем точно учитывает представление логических значений. Явно
видно, что здесь смешиваются два языка: Scheme (или хотя бы что-то неотличимо
похожее на него) и Scheme (или что-то довольно похожее). Причём мы определяем
второй в терминах первого. Так что между ними присутствуют примерно те же
отношения, что и между Паскалем (на котором написана первая реализация {\TeX}) и
самой системой {\TeX} <span class="cite">[<a href="z1_bibliography.xhtml#knu84">Knu84</a>]</span>. Соответственно, нет ни единого повода
считать способы представления логических значений в этих языках одинаковыми.</p>

<p>Функция <code><span class="func">evaluate</span></code> возвращает значения определяемого языка. Они априори никак
не связаны с логическими значениями языка, используемого для реализации. Следуя
соглашению о том, что любой объект, не равный логической <em class="term">лжи</em>, должен
считаться логической <em class="term">истиной</em>, мы запишем:</p>

<pre>... (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
      ((<span class="var">if</span>) (<span class="special">if</span> (<span class="func">not</span> (<span class="func">eq?</span> (<span class="func">evaluate</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span>) <span class="var">the-false-value</span>))
                (<span class="func">evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span>)
                (<span class="func">evaluate</span> (<span class="func">cadddr</span> <span class="var">e</span>) <span class="var">env</span>) )) ... ) ...</pre>

<!--\indexC{the-false-value}-->
<p>Здесь считается, что переменная <code><span class="var">the-false-value</span></code> хранит значение <em class="term">лжи</em>
определяемого языка, выраженное в терминах определяющего. Вариантов выбора
такого представления много, например, сделаем так:</p>

<pre>(<span class="special">define</span> <span class="var">the-false-value</span> (<span class="func">cons</span> <span class="string">"false"</span> <span class="string">"boolean"</span>))</pre>

<p>В этом случае всё будет замечательно, так как <code><span class="func">eq?</span></code> в Scheme сравнивает
не значения, а адреса, и, соответственно, любое другое значение никак нельзя
будет спутать со значением переменной <code><span class="var">the-false-value</span></code>.</p>

<!--\indexC{()}-->
<!--\indexC{NIL}-->
<!--\indexR{пустой список, \protect<code><span class="func">()</span></code>}-->
<p>Вопрос представления логических значений вовсе не тривиален. В истории Лиспа
полно споров на тему различий между булевым значением <em class="term">ложь</em>, пустым
списком <code><span class="hash">()</span></code> и символом <code><span class="var">NIL</span></code>. Наиболее чёткая позиция по этому вопросу:
<em class="term">ложь</em> это не <code><span class="hash">()</span></code> (в конце концов, это всего лишь пустой список), и они
оба тем более не имеют никакого отношения к символу, составленному из букв
<tt>N</tt>, <tt>I</tt> и <tt>L</tt>.</p>

<p>Такую позицию занимает и Scheme; об этом всё же смогли договориться за пару
недель до принятия стандарта IEEE <span class="cite">[<a href="z1_bibliography.xhtml#iee91">IEE91</a>]</span>.</p>

<p>Так что в Scheme теперь всё хорошо (разве что <code><span class="hash">()</span></code> по-английски всё ещё
читается как <em>nil</em>!). В изначальном Лиспе <em class="term">ложь</em>, <code><span class="hash">()</span></code> и <code><span class="var">NIL</span></code>
— это один и тот же символ. В Le_Lisp <code><span class="var">NIL</span></code> это переменная со
значением <code><span class="hash">()</span></code>, а пустой список (вместе с пустым символом <code><span class="var">||</span></code>)
используется в качестве <em class="term">лжи</em>.</p>


<h3 id="basics/evaluating-forms/ssect:sequence"><span class="seq">1.4.3.</span> Последовательность</h3>


<!--\indexC{begin}-->
<!--\indexC{progn}-->
<p>Существует специальная форма, позволяющая вычислить группу форм последовательно
и в определённом порядке. Как и старые добрые блоки <code>begin ... end</code> из
семейства языков Алгола, в Scheme эта форма называется <code><span class="special">begin</span></code>; в других
Лиспах она обычно зовётся <code><span class="special">progn</span></code> — обобщенная версия <code><span class="special">prog1</span></code>,
<code><span class="special">prog2</span></code> и т. д. Собственно организацию последовательности мы перепоручаем
функции <code><span class="func">eprogn</span></code>.</p>

<!--\indexC{eprogn}-->
<pre>... (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
      ((<span class="var">begin</span>) (<span class="func">eprogn</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span>)) ... ) ...

(<span class="special">define</span> (<span class="func">eprogn</span> <span class="var">exps</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">exps</span>)
      (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">exps</span>))
          (<span class="special">begin</span> (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">exps</span>) <span class="var">env</span>)
                 (<span class="func">eprogn</span> (<span class="func">cdr</span> <span class="var">exps</span>) <span class="var">env</span>) )
          (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">exps</span>) <span class="var">env</span>) )
      <span class="hash">'()</span> ) )</pre>

<p>Такое определение последовательных вычислений не допускает разночтений. Стоит
обратить внимание на хвостовую рекурсию при вычислении последней формы
последовательности. Вычисления построены так, что последний вызов <code><span class="func">evaluate</span></code>
заменяет собой всю рекурсивную цепочку вызовов <code><span class="func">eprogn</span></code>. (О хвостовой
рекурсии мы позже поговорим подробнее.
<span class="see">[см. раздел <a href="ch03_escape_and_return.xhtml#escape/pr-cont/ssect:tail-recusion">3.6.2</a>]</span>)</p>


<!--\indexCS{begin}{возвращаемое значение}-->
<!--\indexR{возвращаемые значения!формы (begin)@формы \protect<code><span class="func">(begin)</span></code>}-->
<!--\indexC{empty-begin}-->
<p>Ещё одним интересным моментом является то, чт\'{о} возвращается при вычислении
формы <code>(<span class="special">begin</span>)</code>. Сейчас это пустой список. Но почему именно <code><span class="hash">()</span></code>, почему
не что-то другое, вроде <code><span class="var">:3</span></code> или <code>(<span class="var">^_^</span>)</code>? Мы выбрали пустой список по
привычке, доставшейся в наследство от Лиспа: в любой непонятной ситуации
возвращай <code><span class="var">nil</span></code>. Но в мире, где <em class="term">ложь</em>, <code><span class="var">nil</span></code> и <code><span class="hash">()</span></code> — это
совершенно различные вещи, что из них лучше подходит на роль <em>ничего</em>?
Поэтому пусть в нашем языке вычисление <code>(<span class="special">begin</span>)</code> будет возвращать специальное
значение <code><span class="var">empty-begin</span></code>, которое определяется как (почти) случайное число
<code><span class="num">813</span></code> <span class="cite">[<a href="z1_bibliography.xhtml#leb05">Leb05</a>]</span>.</p>

<!--\indexC{eprogn}-->
<!--\indexC{empty-begin}-->
<pre>(<span class="special">define</span> (<span class="func">eprogn</span> <span class="var">exps</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">exps</span>)
      (<span class="special">if</span> (<span class="func">pair?</span> (<span class="func">cdr</span> <span class="var">exps</span>))
          (<span class="special">begin</span> (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">exps</span>) <span class="var">env</span>)
                 (<span class="func">eprogn</span> (<span class="func">cdr</span> <span class="var">exps</span>) <span class="var">env</span>) )
          (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">exps</span>) <span class="var">env</span>) )
      <span class="var">empty-begin</span> ) )

(<span class="special">define</span> <span class="var">empty-begin</span> <span class="num">813</span>)</pre>

<!--\indexR{синтаксис!begin@<code><span class="func">(begin)</span></code>}-->
<!--\indexC*{unspecified}{\#<unspecified>}-->
<p>Корни нашей проблемы в том, что <code><span class="special">begin</span></code> <em>обязана</em> вернуть какое-то
значение. Как и Scheme, определяемый язык может не придавать какого-либо смысла
форме <code>(<span class="special">begin</span>)</code>; мы можем или допускать такое написание и возвращать любое
удобное значение, или же не допускать и считать ошибкой. Идеальный вариант:
вообще не использовать <code><span class="special">begin</span></code> без аргументов, так как не определено, что
именно получится в результате. Некоторые реализации имеют специальный объект:
<code><span class="hash">#&lt;unspecified&gt;</span></code>, который возвращается в случае, когда нет ничего более
подходящего. Обычно единственное, что с ним можно сделать — это вывести на
печать. (Не следует путать этот объект с псевдозначением у неопределённых
переменных. <span class="see">[см. раздел <a href="ch02_lisp_1_2_omega.xhtml#lisp1-2-omega/recusion/ssect:uninitialized">2.6.5</a>]</span>)</p>

<div class="bigskip"/>

<!--\indexR{язык!чисто функциональный}-->
<!--\indexR{побочные эффекты}-->
<p>Последовательное вычисление выражений бесполезно в чисто функциональных языках
(где функции не имеют побочных эффектов). Действительно, какой в таком случае
смысл что-то вычислять и не использовать возвращаемые значения? Но иногда
в этом может быть смысл. Представим себе игру, написанную на чисто
функциональном языке; очевидно, что вычисления занимают какое-то время
вне зависимости от того, используются ли их результаты или нет; и нас может
интересовать именно этот «побочный эффект» — замедление работы, — а
не получаемые результаты. Тогда можно последовательно что-то вычислять,
например, чтобы скорость игры была адекватна рефлексам игрока (если только
компилятор не посчитает себя самым умным и не удалит «бесполезный» код).</p>

<!--\indexCS{begin}{необходимость}-->
<p>Так как в Scheme есть операции ввода-вывода, которые имеют побочные эффекты, то
для нас есть смысл пользоваться формой <code><span class="special">begin</span></code>, потому как очевидно, что
лучше сначала задать вопрос (с помощью <code><span class="func">display</span></code>), а потом прочитать ответ
(с помощью <code><span class="func">read</span></code>), чем сделать наоборот. Здесь-то как раз и нужно
упорядочить вычисления. Но не только <code><span class="special">begin</span></code> может их упорядочивать.
Например, условный оператор может:</p>

<pre>(<span class="special">if</span> <span class="math"><span class="var">α</span></span> <span class="math"><span class="var">β</span></span> <span class="math"><span class="var">β</span></span>) <span class="math"><span class="binop">≡</span></span> (<span class="special">begin</span> <span class="math"><span class="var">α</span></span> <span class="math"><span class="var">β</span></span>)</pre>

<p id="basics/forms/sequence/par:gensym-puzzle">
И <code><span class="special">lambda</span></code> тоже может<a class="footref" href="zz_footnotes.xhtml#foot1.7"><sup>7</sup></a>:</p>

<pre>(<span class="special">begin</span> <span class="math"><span class="var">α</span></span> <span class="math"><span class="var">β</span></span>) <span class="math"><span class="binop">≡</span></span> ((<span class="special">lambda</span> (<i>void</i>) <span class="math"><span class="var">β</span></span>) <span class="math"><span class="var">α</span></span>)</pre>

<p>Как видно из этого примера, в Scheme <code><span class="special">begin</span></code> не является необходимой
специальной формой, так как её поведение можно проэмулировать с помощью
функций благодаря тому, что при вызове функции её аргументы вычисляются перед
исполнением тела (передача аргументов <em class="term">по значению</em>).</p>


<h3 id="basics/evaluating-forms/ssect:assignment"><span class="seq">1.4.4.</span> Присваивание</h3>

<!--\indexC{set"!}-->
<!--\indexR{присваивание}-->
<!--\indexR{соглашения именования!побочных эффектов}-->
<p>Как и во многих других языках, в нашем диалекте значения переменных можно
менять. Изменение значения переменной называется <em class="term">присваиванием</em>. Так как
значение переменной надо изменять в её окружении, то мы оставляем эту проблему
функции <code><span class="func">update!</span></code>.<a href="zz_footnotes.xhtml#foot1.8"><sup>8</sup></a>
Её настоящая суть объясняется позже, в разделе <a href="ch04_assignment_and_side_effects.xhtml#assignment/implementation/ssect:environment">4.3.3</a>.</p>

<pre>... (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
      ((<span class="var">set!</span>) (<span class="func">update!</span> (<span class="func">cadr</span> <span class="var">e</span>) <span class="var">env</span>
                       (<span class="func">evaluate</span> (<span class="func">caddr</span> <span class="var">e</span>) <span class="var">env</span>))) ... ) ...</pre>

<p>Присваивание выполняется в два шага: сначала вычисляется новое значение, потом
новое значение заменяет старое. Стоит заметить, что обновлённая переменная
не является значением данной формы. Мы ещё вернёмся к вопросу о возвращаемом
значении операции присваивания. <span class="see">[см. <a href="ch04_assignment_and_side_effects.xhtml">4 главу</a>]</span>
Пока только запомните, что стандартом оно не определено.</p>


<h3 id="basics/evaluating-forms/ssect:abstraction"><span class="seq">1.4.5.</span> Абстракция</h3>

<!--\indexR{абстракция}-->
<p>Функции (также называемые <em class="term">процедурами</em> в Scheme) являются результатом
вычисления специальной формы <code><span class="special">lambda</span></code>, чьё имя ссылается на понятие
<em class="term">абстракции</em> в λ-исчислении. Работу по созданию функции мы
поручаем функции <code><span class="func">make-function</span></code>, которой передаём всё необходимое: список
аргументов, тело функции и текущее окружение.</p>

<pre>... (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
      ((<span class="var">lambda</span>) (<span class="func">make-function</span> (<span class="func">cadr</span> <span class="var">e</span>) (<span class="func">cddr</span> <span class="var">e</span>) <span class="var">env</span>)) ... ) ...</pre>


<h3 id="basics/evaluating-forms/ssect:application"><span class="seq">1.4.6.</span> Аппликация</h3>

<!--\indexR{аппликация}-->
<!--\indexR{комбинация}-->
<!--\indexR{терм!функциональный}-->
<!--\indexR{функциональный терм}-->
<p>Если первый элемент списка не является специальным оператором, то такой список
означает применение функции, которое в λ-исчислении называется
<em class="term">аппликацией</em> или <em class="term">комбинацией</em>. Функция, полученная в результате
вычисления первого элемента, применяется к аргументам, которые мы получим,
вычислив остальные элементы списка. Эти действия описываются следующим кодом:</p>

<pre>... (<span class="syntax">case</span> (<span class="func">car</span> <span class="var">e</span>)
      (<span class="syntax">else</span> (<span class="func">invoke</span> (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">e</span>) <span class="var">env</span>)
                    (<span class="func">evlis</span> (<span class="func">cdr</span> <span class="var">e</span>) <span class="var">env</span>) )) ) ...</pre>

<p>Вспомогательная функция <code><span class="func">evlis</span></code> принимает список
выражений и возвращает список соответствующих им значений. Она определяется следующим образом:</p>

<!--\indexC{evlis}-->
<pre>(<span class="special">define</span> (<span class="func">evlis</span> <span class="var">exps</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">exps</span>)
      (<span class="func">cons</span> (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">exps</span>) <span class="var">env</span>)
            (<span class="func">evlis</span> (<span class="func">cdr</span> <span class="var">exps</span>) <span class="var">env</span>) )
      <span class="hash">'()</span> ) )</pre>

<p>Далее работает функция <code><span class="func">invoke</span></code>, которая применяет свой
первый аргумент (функцию; если это не так, она сообщает об ошибке) ко второму (списку её
аргументов) и возвращает результат вычислений. В общем, <code><span class="func">invoke</span></code> похожа на привычную <code><span class="func">apply</span></code>, разве что требует явного
указания окружения.
(Далее в разделе <a href="#basics/sect:representing-functions">1.6</a> мы рассмотрим подробнее непростые
взаимоотношения функций и окружений.)</p>


<h4>Ещё немного об <code><span class="func">evaluate</span></code></h4>

<!--\indexR{порядок вычислений!термов аппликации}-->
<p>Рассмотренное описание языка является более-менее точным. Мы не разобрали лишь
несколько вспомогательных функций: <code><span class="func">lookup</span></code> и <code><span class="func">update!</span></code>, отвечающие за
окружения, и <code><span class="func">make-function</span></code> вместе с <code><span class="func">invoke</span></code>, занимающиеся функциями.
Но даже сейчас нам уже многое известно об <code><span class="func">evaluate</span></code>. Например, наш диалект
имеет единое пространство имён, понятие объекта в нём распространяется вообще
на всё (как в Lisp<sub>1</sub>  <span class="see">[см. <a href="ch02_lisp_1_2_omega.xhtml">2 главу</a>]</span>), в том числе и на функции.
Но мы до сих пор не знаем порядок вычисления аргументов.</p>

<p>В нашем случае он зависит от порядка вычисления аргументов у <code><span class="func">cons</span></code>, которая
используется в <code><span class="func">evlis</span></code>. Но мы легко можем указать любой понравившийся нам
порядок, например, слева направо:</p>

<pre>(<span class="special">define</span> (<span class="func">evlis</span> <span class="var">exps</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">exps</span>)
      (<span class="syntax">let</span> ((<span class="var">argument1</span> (<span class="func">evaluate</span> (<span class="func">car</span> <span class="var">exps</span>) <span class="var">env</span>)))
        (<span class="func">cons</span> <span class="var">argument1</span> (<span class="func">evlis</span> (<span class="func">cdr</span> <span class="var">exps</span>) <span class="var">env</span>)) )
      <span class="hash">'()</span> ) )</pre>

<p>Без введения новых специальных конструкций<a class="footref" href="zz_footnotes.xhtml#foot1.9"><sup>9</sup></a>
мы уточнили поведение определяемого языка. Первая часть книги направлена именно на это: уточнение
определяемого языка с помощью всё более ограниченных возможностей, что снижает зависимость
описания от языка, используемого для определения.</p>


<h2 id="basics/sect:repr-the-env"><span class="seq">1.5.</span> Представление окружений</h2>

<!--\indexE{A-список}-->
<!--\indexR{А-список}-->
<!--\indexR{ассоциативный список}-->
<p>Окружения связывают переменные с их значениями. Обычно в Лиспе подобные связи
представляются <em class="term">ассоциативными списками</em>, также называемыми
<em class="term">А-списками</em>. Мы тоже будем представлять окружения как А-списки,
связывающие переменные и значения. Для простоты имена переменных будем
представлять символами.</p>

<p>Таким образом, функции <code><span class="func">lookup</span></code> и
<code><span class="func">update!</span></code> определяются элементарно:</p>

<!--\indexC{lookup}-->
<pre>(<span class="special">define</span> (<span class="func">lookup</span> <span class="var">id</span> <span class="var">env</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">env</span>)
      (<span class="special">if</span> (<span class="func">eq?</span> (<span class="func">caar</span> <span class="var">env</span>) <span class="var">id</span>)
          (<span class="func">cdar</span> <span class="var">env</span>)
          (<span class="func">lookup</span> <span class="var">id</span> (<span class="func">cdr</span> <span class="var">env</span>)) )
      (<span class="special">wrong</span> <span class="string">"No such binding"</span> <span class="var">id</span>) ) )</pre>

<p>Тут мы видим второй тип<a class="footref" href="zz_footnotes.xhtml#foot1.10"><sup>10</sup></a>
возможных ошибок, появляющихся при попытке узнать значение неизвестной переменной. Мы опять лишь
вызовем <code><span class="special">wrong</span></code>, чтобы сообщить о проблеме наверх.</p>

<!--\indexR{автоцитирование}-->
<p>Когда компьютеры были большими, а память была маленькой,<a class="footref" href="zz_footnotes.xhtml#foot1.11"><sup>11</sup></a> для переменных часто применялось
<em class="term">автоцитирование</em>. Если с переменной не было связано какое-либо значение,
то этим значением становился символ с именем переменной. Было бы очень обидно
видеть, как понятия переменной и символа, которые мы так усердно разделяли,
опять смешиваются и перепутываются.</p>

<p>Хотя это несомненно удобно — никогда не вызывать ошибок, но такой идеальный
мир имеет большой недостаток: задача программы не в том, чтобы работать без
ошибок, а в том, чтобы выполнять то, для чего она предназначена. В этом смысле
ошибки играют роль перил: если мы на них натыкаемся, то это значит, мы идём
куда-то не туда. Ошибки должны быть обнаружены как можно раньше, чтобы как
можно быстрее их исправить. Следовательно, использование автоцитирования —
плохое решение, потому что оно скрывает некоторые ошибки, которые могли бы быть
исправлены раньше.</p>

<p>Функция <code><span class="func">update!</span></code> изменяет окружение, так что, скорее всего, тоже может
вызвать такую же ошибку: нельзя изменить значение неизвестной переменной. Мы
обсудим, следует ли ей так поступать, когда будем говорить о глобальном
окружении.</p>

<!--\indexC{update"!}-->
<pre>(<span class="special">define</span> (<span class="func">update!</span> <span class="var">id</span> <span class="var">env</span> <span class="var">value</span>)
  (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">env</span>)
      (<span class="special">if</span> (<span class="func">eq?</span> (<span class="func">caar</span> <span class="var">env</span>) <span class="var">id</span>)
          (<span class="special">begin</span> (<span class="func">set-cdr!</span> (<span class="func">car</span> <span class="var">env</span>) <span class="var">value</span>)
                 <span class="var">value</span>)
          (<span class="func">update!</span> <span class="var">id</span> (<span class="func">cdr</span> <span class="var">env</span>) <span class="var">value</span>) )
      (<span class="special">wrong</span> <span class="string">"No such binding"</span> <span class="var">id</span>) ) )</pre>

<!--\indexCS{set"!}{возвращаемое значение}-->
<!--\indexR{присваивание!возвращаемое значение}-->
<!--\indexR{возвращаемые значения!присваивания}-->
<p>Возвращаемое значение функции <code><span class="func">update!</span></code> выбрано с учётом того, что это
значение станет значением всего выражения присваивания. В Scheme это значение
не определено. Строго говоря, программам не следует полагаться на какое-то
значение, но, тем не менее, мы вынуждены выбирать, что именно будем возвращать
в нашем случае. Например:</p>

<ol>
  <li>только что присвоенное значение (так сделано сейчас);</li>

  <li>предыдущее значение переменной (могут быть проблемы с инициализацией,
    первым присваиванием);</li>

  <li><!--\indexC*{UFO}{\#<UFO>}\label{basics/s:env/ufo}-->
    объект «неопределённое значение», некий <code><span class="hash">#&lt;UFO&gt;</span></code>,
    используемый исключительно как индикатор неопределённого
    значения;</li>

  <li>значение формы с неопределённым значением, вроде
    <code><span class="func">set-cdr!</span></code> в Scheme.</li>
</ol>

<!--\indexR{окружение!как тип данных}-->
<p>Окружения — это составной абстрактный тип данных. Мы уже можем извлекать и
изменять их части с помощью соответствующих функций; но ещё надо уметь
создавать новые окружения и добавлять в них новые части.</p>

<!--\indexR{окружение!начальное}-->
<p>Изначально в окружении ничего нет. Это записывается просто:</p>

<!--\indexC{env.init}-->
<pre>(<span class="special">define</span> <span class="var">env.init</span> <span class="hash">'()</span>)</pre>

<p>(Чуть позже, в разделе <a href="#basics/sect:representing-functions">1.6</a>, мы сделаем его
не таким необитаемым.)</p>

<p>Когда вызывается функция, для неё создаётся новое окружение, в котором её
аргументы связаны со своими фактическими значениями. Функция <code><span class="func">extend</span></code>
расширяет окружение <code><span class="var">env</span></code> переменными <code><span class="var">variables</span></code> с соответствующими
значениями <code><span class="var">values</span></code>.</p>

<!--\indexC{extend}-->
<pre>(<span class="special">define</span> (<span class="func">extend</span> <span class="var">env</span> <span class="var">variables</span> <span class="var">values</span>)
  (<span class="syntax">cond</span> ((<span class="func">pair?</span> <span class="var">variables</span>)
         (<span class="special">if</span> (<span class="func">pair?</span> <span class="var">values</span>)
             (<span class="func">cons</span> (<span class="func">cons</span> (<span class="func">car</span> <span class="var">variables</span>) (<span class="func">car</span> <span class="var">values</span>))
                   (<span class="func">extend</span> <span class="var">env</span> (<span class="func">cdr</span> <span class="var">variables</span>) (<span class="func">cdr</span> <span class="var">values</span>)) )
             (<span class="special">wrong</span> <span class="string">"Too few values"</span>) ) )
        ((<span class="func">null?</span> <span class="var">variables)</span>
         (<span class="special">if</span> (<span class="func">null?</span> <span class="var">values</span>)
             <span class="var">env</span>
             (<span class="special">wrong</span> <span class="string">"Too many values"</span>) ) )
        ((<span class="func">symbol?</span> <span class="var">variables</span>) (<span class="func">cons</span> (<span class="func">cons</span> <span class="var">variables</span> <span class="var">values</span>) <span class="var">env</span>)) ) )</pre>

<!--\indexR{список аргументов}-->
<!--\indexR{синтаксис!списка аргументов}-->
<!--\indexR{переменные!точечные}-->
<!--\indexR{точечные переменные}-->
<p>Главная сложность состоит в том, что нам надо проанализировать все варианты
записи &lt;<i>списка аргументов</i>&gt;, какие разрешены в Scheme.<a class="footref"
href="zz_footnotes.xhtml#foot1.12"><sup>12</sup></a> Список
аргументов может быть представлен не только обычным списком символов, но и
точечным: заканчивающимся не на <code><span class="hash">()</span></code>, а на определённый символ
(<em class="term">точечную переменную</em>). Более формально список аргументов описывается
следующей грамматикой:</p>


<table id="ch1-table-grammar">
    <tr><td>&lt;<i>список аргументов</i>&gt;</td><td>::=</td><td><code><span class="hash">()</span></code></td></tr>
    <tr><td/><td>|</td><td>&lt;<i>переменная</i>&gt;</td></tr>
    <tr><td/><td>|</td><td><code>(<span class="normal">&lt;<i>переменная</i>&gt;</span> . <span class="normal">&lt;<i>список аргументов</i>&gt;</span>)</code></td></tr>
    <tr><td>&lt;<i>переменная</i>&gt;</td><td><span class="math"><span class="binop">∈</span></span></td><td><span class="Vset">Символы</span></td></tr>
</table>

<p>Когда мы расширяем окружение, количество значений переменных должно
соответствовать количеству их имён. Обычно их поровну, но если список
оканчивается на точечную (или <em class="term"><span class="math"><span class="var">n</span></span>-арную</em>) переменную, то она связывается
со списком всех оставшихся аргументов. Как бы то ни было, возможны две ошибки:
или значений больше, чем переменных, или наоборот.</p>


<h2 id="basics/sect:representing-functions"><span class="seq">1.6.</span> Представление функций</h2>

<p>Наверное, проще всего представлять функции с помощью функций. Естественно, это
не тавтология, и читать следует так: «функции определяемого языка проще всего
представлять функциями языка определения». Это сильно упрощает механизм вызова:
функция <code><span class="func">invoke</span></code> должна лишь проверить, действительно ли её первый аргумент
является функцией: чем-то, что можно вызвать.</p>


<!--\indexC{invoke}-->
<pre>(define (invoke fn args)
  (if (procedure? fn) (fn args)
      (wrong "Not a function" fn) ) )</pre>

<p>Проще некуда. Даже может возникнуть вопрос, зачем вообще нужна отдельная
функция, когда весь этот код можно было встроить сразу в <code><span class="func">evaluate</span></code>. Причина,
по которой так сделано, в том, что мы показываем структуру будущих
интерпретаторов, а в них <code><span class="func">invoke</span></code> будет уже не такой простой. Кстати,
попробуйте сейчас выполнить упражнения \ref{basics/ex:def-call/cc}
и \ref{basics/ex:def-apply}.</p>


<!--\indexR{аппликация!порядок вычисления термов}-->
<!--\indexR{порядок вычислений!термов аппликации}-->
<p>Также у нас появляется новый тип ошибок, возникающих при попытке вызвать
невызываемое. Сейчас мы обрабатываем такие ошибки в момент применения функции
к уже вычисленным аргументам, но мы могли бы предупреждать пользователя раньше.
В таком случае нам необходимо задать порядок вычисления элементов формы вызова
функции:</p>

<p>\begin{enumerate}
  \item вычислить элемент на месте функции;

  \item если это не функция, сообщить об ошибке;

  \item вычислить аргументы слева направо;

  \item сравнить количество аргументов с арностью функции
        и, если они не совпадают, то сообщить об ошибке.
\end{enumerate}</p>

<p>Вычислять аргументы слева направо кажется логичным для людей, читающих слева
направо. Это и запрограммировать легче, в итоге порядок прост и понятен.
Сложности возникают только у компилятора, потому что если ему захочется поменять
этот порядок (например, чтобы эффективнее использовать регистры процессора), то
он будет вынужден доказать, что это не изменит смысла программы.</p>

<p>Конечно, мы могли бы действовать эффективнее, проверяя арность ещё раньше:</p>

<p>\begin{enumerate}
  \item вычислить элемент на месте функции;

  \item если это не функция, сообщить об ошибке, иначе запомнить ожидаемое
        количество аргументов;

  \item вычислять аргументы слева направо до тех пор, пока их количество
        согласуется с арностью функции, в случае проблем сообщить об ошибке;

  \item применить функцию к аргументам.\footnote*{Функция могла бы потом
        ещё проверять на правильность типы переданных аргументов, но это
        не имеет отношения к механизму вызова.}
\end{enumerate}</p>

<p>Стандарт <span class="logo">Common Lisp</span> требует, чтобы аргументы вычислялись строго слева
направо, но с целью оптимизации позволяет вычислять функциональный элемент
списка до или после остальных.</p>

<p>Scheme же не накладывает условий на порядок вычисления всех элементов формы
вызова функции, включая сам элемент-функцию. Так как ограничений нет, то
компилятор волен выбирать любой устраивающий его порядок.
\seePage[denotational/sect:eval-order] А пользователь, в свою очередь, не может
рассчитывать на какой-либо определённый порядок вычислений и должен использовать
<code><span class="func">begin</span></code>, чтобы задать необходимый порядок явно.</p>

<p>Считается плохим стилем использовать вызовы функций, чтобы получить побочные
эффекты в нужной последовательности. Поэтому следует избегать выражений вроде
<code><span class="func">(f (set! f $\pi$) (set! f $\pi'$))</span></code>, где неясно, какая же функция будет
вызвана на самом деле. Ошибки, возникающие в подобных случаях, очень сложно
отлавливать.</p>

<p>
\subsection*{Окружение исполнения функций}</p>


<!--\indexR{окружение!исполнения тела функции}-->
<p>Применение функции сводится к вычислению выражений, составляющих её тело,
в окружении, где аргументы функции связаны со значениями, переданными при вызове
функции. Вспомните, что при вызове <code><span class="func">make-function</span></code> мы передали всё
необходимое для этого, находящееся в распоряжении <code><span class="func">evaluate</span></code>. В оставшейся
части этого раздела мы будем разбирать используемые при вычислениях окружения,
в программах они будут набраны \ii{курсивом}.</p>

<p>
\subsubsection{Минимальное окружение}</p>

<p>Для начала рассмотрим минимально возможное окружение:</p>


<!--\indexC{make-function}-->
<pre>(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend |\ii{env.init}| variables values)) ) )</pre>


<!--\indexE{K@\protect\comb{K}, комбинатор}-->
<!--\indexR{комбинаторы!K@\protect\comb{K}}-->
<p>В строгом соответствии с ранее описанным соглашением, тело функции вычисляется
в окружении, где аргументы функции связаны с переданными значениями. Например,
получив в результате вызова <code><span class="func">make-function</span></code> комбинатор \comb{K}, определяемый
как <code><span class="func">(lambda (a b) a)</span></code>, мы можем его вызвать следующим образом:</p>

<pre>(K 1 2) |\is| 1</pre>

<p>Но есть и неприятность: функция может использовать только свои аргументы и
локальные переменные, потому что мы определили \ii{env.init} как пустое
окружение. В нём нет даже базовых функций из глобального окружения вроде
<code><span class="func">car</span></code> или <code><span class="func">cons</span></code>.</p>

<p>
\subsubsection{Улучшенное окружение}</p>

<p>Хорошо, попробуем улучшить наше определение следующим образом:</p>

<pre>(define (make-function variables body env)
  (lambda (values)
    (eprogn body (extend |\ii{env.global}| variables values)) ) )</pre>

<p>Замечательно, теперь наши функции имеют доступ к глобальному окружению и всем
его функциям. А что если мы попробуем определить взаимно рекурсивные функции?
Также, какой результат даст программа слева (справа она же с раскрытыми
макросами)?</p>

<p>{\def\E{\hbox to 0pt{\kern0.3em$\equals$}}
\begin{code:lisp}
(let ((a 1))            ((lambda (a)
  (let ((b (+ 2 a)))       ((lambda (b)
    (list a b) ) )   |\E|         (list a b) )
                            (+ 2 a) ) )
                         1 )
\end{code:lisp}}</p>

<p>Давайте рассмотрим по шагам, как вычисляется это выражение:</p>

<pre>((lambda (a) ((lambda (b) (list a b)) (+ 2 a))) 1)|\begin{where}
                                                   \- \ii{env.global}
                                                   \end{where}|
|\equals| ((lambda (b) (list a b)) (+ 2 a))|\begin{where}
                                            \- a {\is} 1
                                            \- \ii{env.global}
                                            \end{where}|
|\equals| (list a b)|\begin{where}
                     \- b {\is} 3
                     \- \ii{env.global}
                     \end{where}|</pre>

<p>Тело внутренней функции <code><span class="func">(lambda (b) (list a b))</span></code> выполняется в окружении,
полученном расширением глобального окружения переменной <code><span class="func">b</span></code>. Всё верно. Но
в этом окружении нет необходимой переменной <code><span class="func">a</span></code>!</p>

<p>
\subsubsection{Улучшенное окружение (вторая попытка)}</p>

<p>Так как нам надо видеть переменную <code><span class="func">a</span></code> во внутренней функции, то достаточно
будет передать <code><span class="func">invoke</span></code> текущее окружение, а она в свою очередь передаст его
вызываемой функции. Чтобы реализовать эту идею, надо немного подправить
<code><span class="func">evaluate</span></code> и <code><span class="func">invoke</span></code>; чтобы не путать эти определения с предыдущими,
пусть они начинаются на <code><span class="func">d.</span></code>:</p>


<!--\indexC{d.evaluate}-->
<!--\indexC{d.invoke}-->
<!--\indexC{d.make-function}-->
<pre>(define (d.evaluate e env)
  (if (atom? e) ...
      (case (car e)
        ...
        ((lambda) (d.make-function (cadr e) (cddr e) env))
        (else     (d.invoke (d.evaluate (car e) env)
                            (evlis (cdr e) env)
                            env )) ) ) )</p>

<p>(define (d.invoke fn args env)
  (if (procedure? fn)
      (fn args env)
      (wrong "Not a function" fn) ) )</p>

<p>(define (d.make-function variables body |\ii{def.env}|)
  (lambda (values |\ii{current.env}|)
    (eprogn body (extend |\ii{current.env}| variables values)) ) )</pre>

<p>В этом определении стоит заметить, что передача окружения определения <code><span class="func">env</span></code>
через переменную \ii{def.env} бессмысленна, так как при вызове используется лишь
текущее окружение \ii{current.env}.</p>


<!--\indexR{стек!вызовов}-->
<p>Давайте теперь ещё раз рассмотрим пример, приведённый выше. Сейчас переменные
не пропадают:</p>

<pre>((lambda (a) ((lambda (b) (list a b)) (+ 2 a))) 1)|\begin{where}
                                                   \- \ii{env.global}
                                                   \end{where}|
|\equals| ((lambda (b) (list a b)) (+ 2 a))|\begin{where}
                                            \- a {\is} 1
                                            \- \ii{env.global}
                                            \end{where}|
|\equals| (list a b)|\begin{where}
                     \- b {\is} 3
                     \- a {\is} 1
                     \- \ii{env.global}
                     \end{where}|</pre>

<p>Заодно мы явно видим <em>стек вызовов</em>: каждая связывающая форма сначала
укладывает свои новые переменные поверх текущего окружения, а потом убирает их
оттуда после окончания вычислений.</p>

<p>
\subsubsection{Исправляем проблему}</p>

<p>Но даже при таком определении всё ещё есть проблемы. Рассмотрим следующий
пример:</p>

<pre>(((lambda (a)
     (lambda (b) (list a b)) )
  1 )
 2 )</pre>

<p>Функция <code><span class="func">(lambda (b) (list a b))</span></code> создаётся в окружении, где <code><span class="func">a</span></code> связана
со значением <code><span class="func">1</span></code>, но в момент вызова в окружении будет присутствовать
только <code><span class="func">b</span></code>. Таким образом, мы опять потеряли переменную <code><span class="func">a</span></code>.</p>

<p>Без сомнения, вы заметили, что в определении <code><span class="func">d.make-function</span></code> присутствуют
два окружения: окружение определения \ii{def.env} и окружение исполнения
\ii{current.env}. В жизни функции есть два важных события: её создание и
её вызов(ы). Очевидно, что создаётся функция только однажды, а вызываться может
несколько раз; или вообще никогда не вызываться. Следовательно,
единственное\footnote{На самом деле, здесь можно использовать любое необходимое
окружение. См. про форму <code><span class="func">closure</span></code> на
странице \pageref{assignement/assignement/para:closure}.} окружение, которое мы
однозначно можем связать с функцией, — это окружение, в котором она была
создана. Вернёмся к исходным определениям функций <code><span class="func">evaluate</span></code> и <code><span class="func">invoke</span></code>,
но в этот раз функцию <code><span class="func">make-function</span></code> запишем следующим образом:</p>


<!--\indexC{make-function}-->
<p>\begin{code:lisp}[label=basics/representing-functions/fixing/src:inject-current-env]
(define (make-function variables body |\ii{env}|)
  (lambda (values)
    (eprogn body (extend |\ii{env}| variables values)) ) )</pre>

<p>Теперь все приведённые примеры работают нормально. В частности, пример выше
вычисляется следующим образом:</p>

<pre>(((lambda (a) (lambda (b) (list a b))) 1) 2)|\begin{where}
                                             \- \ii{env.global}
                                             \end{where}|
|\equals| ((lambda (b) (list a b))|\begin{where}
                                   \- a {\is} 1
                                   \- \ii{env.global}
                                   \end{where}|
    2 )|\begin{where}
        \- \ii{env.global}
        \end{where}|
|\equals| (list a b)|\begin{where}
                     \- b {\is} 2
                     \- a {\is} 1
                     \- \ii{env.global}
                     \end{where}|</pre>


<!--\indexR{абстракция!замыкание}-->
<!--\indexR{абстракция!значение}-->
<!--\indexR{возвращаемые значения!абстракций}-->
<!--\indexR{замыкания (closures)}-->
<p>Форма <code><span class="func">(lambda (b) (list a b))</span></code> создаётся в глобальном окружении, расширенном
переменной <code><span class="func">a</span></code>. Когда эта функция вызывается, она расширяет окружение своего
создания переменной <code><span class="func">b</span></code>, таким образом, тело функции будет вычисляться
в окружении, где обе переменные <code><span class="func">a</span></code> и <code><span class="func">b</span></code> присутствуют. После того, как
функция вернёт результат, исполнение продолжается в глобальном окружении. Мы
будем называть значение абстракции <em class="term">замыканием</em> (closure), потому что при
создании этого значения тело функции становится замкнутым в окружении своего
определения.</p>

<p>Стоит отметить, что сейчас <code><span class="func">make-function</span></code> сама использует замыкания языка
определения. Это не является обязательным, как мы покажем далее в третьей главе.
\seePage[escape/actors/ssect:functions] Функция <code><span class="func">make-function</span></code> возвращает
замыкания, а это — характерная черта функциональных языков программирования.</p>

<p>
\subsection{Динамическая и лексическая области видимости}%
\label{basics/representing-functions/ssect:dynamic-and-lexical-binding}</p>

<p>Из этого разговора об окружениях можно сделать два вывода. Во-первых, ясно,
что с окружениями не всё так просто. Любое вычисление всегда производится
в каком-то окружении, следовательно, необходимо эффективно реализовывать их
использование. В третьей главе рассматриваются более сложные вещи вроде
раскрутки стека и соответствующей формы <code><span class="func">unwind-protect</span></code>, которые потребуют
от нас ещё более точного контроля над окружениями.</p>


<!--\indexR{лексическое связывание}-->
<!--\indexR{динамическое связывание}-->
<!--\indexR{связывание!лексическое}-->
<!--\indexR{связывание!динамическое}-->
<!--\indexR{Лисп!лексический}-->
<!--\indexR{Лисп!динамический}-->
<p>Второй момент связан с двумя рассмотренными в предыдущем разделе вариантами,
которые являются примерами <em class="term">лексического</em> и <em class="term">динамического
связывания</em>\footnote{В объектно-ориентированных языках под динамическим
связыванием обычно понимается механизм выбора метода объекта на основе его
реального типа во время исполнения программы, в противоположность статическому
связыванию, при котором метод выбирается компилятором исходя из типа переменной,
которая хранит рассматриваемый объект.} (также применяются термины лексическая и
динамическая область видимости). В <em>лексическом</em> Лиспе функция выполняется
в окружении своего определения, расширенном собственными переменными, тогда как
в <em>динамическом</em> — расширяет текущее окружение, окружение своего вызова.</p>

<p>Сейчас в моде лексическое связывание, но это не значит, что у динамического нет
будущего. С одной стороны, именно динамическое связывание применяется
в некоторых довольно популярных языках вроде \TeX <span class="cite">[<a href="z1_bibliography.xhtml#knu84">knu84</a>]</span>,
Emacs Lisp\trnote{Начиная с Emacs Lisp v.\,24 и Perl 5, эти языки имеют и
лексические переменные.} <span class="cite">[<a href="z1_bibliography.xhtml#llst93">llst93</a>]</span>, Perl <span class="cite">[<a href="z1_bibliography.xhtml#ws91">ws91</a>]</span>.</p>

<p>С другой стороны, сама идея динамической области видимости является важной
концепцией программирования. Она соответствует установке связей перед
выполнением вычислений и гарантированному автоматическому удалению этих связей
после завершения вычислений.</p>


<!--\indexR{исключения}-->
<!--\indexR{поиск с возвратом}-->
<p>Такую стратегию можно эффективно применять, например, в искусственном
интеллекте. В этом случае сначала выдвигается некая гипотеза, затем из неё
вырабатываются следствия. Как только система натыкается на противоречие, то
гипотезу следует отвергнуть и перейти к следующей. Это называется <em class="term">поиском
с возвратом</em>. Если следствия гипотез хранятся без использования побочных
эффектов, например, в А-списках, то отвержение гипотезы автоматически и без
проблем утилизирует и все её следствия. Но если для этого используются
глобальные переменные, массивы и т. д., то тогда за ненужной гипотезой
приходится долго убирать, вспоминая, каким же было состояние памяти в момент
формулировки гипотезы и какие его части можно откатить до старых значений, чтобы
ничего не сломать! Динамическая область видимости позволяет гарантировать
существование переменной с определённым значением на время и только во время
вычислений, независимо от того, будут они успешны или нет. Это свойство также
широко используется при обработке исключений.</p>


<!--\indexR{область видимости}-->
<p><em class="term">Область видимости</em> переменной — это, можно сказать, географическое
понятие в программе: местность, где переменная встречается и её можно
использовать. В чистом Scheme (не обременённом полезными, но не абсолютно
необходимыми вещами вроде <code><span class="func">let</span></code>) есть только одна связывающая форма:
<code><span class="func">lambda</span></code>. Это единственная форма, вводящая новые переменные и предоставляющая
им область видимости в рамках определяемой функции. В динамическом же Лиспе
область видимости в принципе не может быть ограничена функцией. Рассмотрим
следующий пример:</p>

<pre>(define (foo x) (list x y))
(define (bar y) (foo 1991))</pre>

<p>В лексическом Лиспе переменная <code><span class="func">y</span></code> в <code><span class="func">foo</span></code>\footnote{О происхождении
<em>foo</em> см. <span class="cite">[<a href="z1_bibliography.xhtml#ray91">ray91</a>]</span>.} — это всегда ссылка на глобальную
переменную <code><span class="func">y</span></code>, которая не имеет никакого отношения к <code><span class="func">y</span></code> внутри <code><span class="func">bar</span></code>.
В динамическом же Лиспе переменная <code><span class="func">y</span></code> из <code><span class="func">bar</span></code> будет видима в <code><span class="func">foo</span></code>
внутри <code><span class="func">bar</span></code>, потому что в момент вызова <code><span class="func">foo</span></code> переменная <code><span class="func">y</span></code> уже
находилась в текущем окружении. Следовательно, если мы дадим глобальной <code><span class="func">y</span></code>
значение <code><span class="func">0</span></code>, то получим следующие результаты:</p>

<pre>(define y 0)
(list (bar 100) (foo 3)) |\is| ((1991 0) (3 0))   ; в динамическом Лиспе
(list (bar 100) (foo 3)) |\is| ((1991 100) (3 0)) ; в лексическом Лиспе</pre>


<!--\indexR{свободные переменные!и области видимости}-->
<p>Заметьте, что в динамическом Лиспе <code><span class="func">bar</span></code> понятия не имеет о том, что
в <code><span class="func">foo</span></code> используется её же локальная переменная <code><span class="func">y</span></code>, а <code><span class="func">foo</span></code> не знает
о том, в каком именно окружении следует искать значение своей свободной
переменной <code><span class="func">y</span></code>. Просто <code><span class="func">bar</span></code> при вызове положила в текущее окружение
переменную <code><span class="func">y</span></code>, а внутренняя функция <code><span class="func">foo</span></code> нашла её в своём
текущем окружении. Непосредственно перед выходом <code><span class="func">bar</span></code> уберёт свою <code><span class="func">y</span></code> из
окружения, и глобальная переменная <code><span class="func">y</span></code> снова станет видна.</p>

<p>Конечно, если не использовать свободные переменные, то нет особой разницы между
динамической и лексической областями видимости.</p>

<p>Лексическое связывание получило своё имя потому, что в данном случае достаточно
иметь только код функции, чтобы с уверенностью отнести каждую используемую в ней
переменную к одному из двух классов: или переменная находится внутри связывающей
формы и является локальной, или же это глобальная переменная. Это чрезвычайно
просто: достаточно взять исходный код, взять карандаш (или мышку) и поставить
его кончик на переменную, значение которой нас интересует, после чего следует
вести карандаш справа налево, снизу вверх до тех пор, пока не встретим первую
связывающую форму. Динамическое же связывание названо в честь концепции
<em class="term">динамического времени жизни</em> переменных, которую мы будем рассматривать
позже. \seePage[escape/forms/ssect:dynamic]</p>

<p>Scheme поддерживает только лексические переменные. <span class="logo">Common Lisp</span> поддерживает
оба типа с одинаковым синтаксисом. Синтаксис <span class="logo">EuLisp</span> и <span class="logo">ISLisp</span> разделяет эти
два типа переменных, и они находятся в отдельных пространствах имён.
\seePage[lisp1-2-omega/sect:namespaces]</p>


<!--\indexR{область видимости!конфликт имён}-->
<!--\indexR{переменные!сокрытие имён}-->
<!--\indexR{сокрытие переменных}-->
<!--\indexR{сокрытие переменных|seealso{области видимости}}-->
<p>Область видимости переменной может прерываться. Такое случается, когда одна
переменная <em class="term">скрывает</em> другую из-за того, что обе имеют одинаковое имя.
Лексические области видимости вкладываются друг в друга, скрывая переменные
с совпадающими именами из внешних областей. Этот известный «блокирующий»
порядок разрешения конфликтов унаследован от Алгола 60.</p>

<p>Под влиянием λ-исчисления, в честь которого названа специальная
форма <code><span class="func">lambda</span></code> <span class="cite">[<a href="z1_bibliography.xhtml#per79">per79</a>]</span>, <span class="logo">Lisp 1.0</span> был сделан динамическим, но вскоре
Джон Маккарти осознал, что он ожидал получить от следующего выражения
<code><span class="func">(2 3)</span></code>, а не <code><span class="func">(1 3)</span></code>:</p>

<pre>(let ((a 1))
  ((let ((a 2)) (lambda (b) (list a b)))
   3 ) )</pre>


<!--\indexCS{function}{для замыканий}-->
<!--\indexCS{lambda}{как ключевое слово}-->
<p>Эта аномалия (не осмелюсь назвать её ошибкой) была исправлена введением новой
специальной формы <code><span class="func">function</span></code>. Она принимала <code><span class="func">lambda</span></code>-форму и создавала
<em class="term">замыкание</em> — функцию, связанную с окружением, в котором она определена.
При вызове замыкания вместо текущего окружения расширялось окружение
определения, замкнутое внутри него. Вместе с изменениями <code><span class="func">d.evaluate</span></code> и
<code><span class="func">d.invoke</span></code>, форма <code><span class="func">function</span></code>\footnote{Наша имитация не совсем точна, так
как существует немало диалектов Лиспа (вроде CLtL1 <span class="cite">[<a href="z1_bibliography.xhtml#ste84">ste84</a>]</span>), где
<code><span class="func">lambda</span></code> — это не специальный оператор, а только ключевое слово-маркер
вроде <code><span class="func">else</span></code> внутри <code><span class="func">cond</span></code> и <code><span class="func">case</span></code>. В этом случае <code><span class="func">d.evaluate</span></code>
может вообще не знать ни о какой <code><span class="func">lambda</span></code>. Иногда даже накладываются
ограничения на положение <code><span class="func">lambda</span></code>-форм, разрешающие им находиться только
внутри <code><span class="func">function</span></code> и в определениях функций.} выражается так:</p>


<!--\indexC{d.invoke}-->
<!--\indexC{d.make-function}-->
<!--\indexC{d.make-closure}-->
<p>\begin{code:lisp}[label=basics/repr-func/dyn-and-lex-bind/src:closure-eval]
(define (d.evaluate e env)
  (if (atom? e) ...
      (case (car e)
        ...
        ((function)   ; Синтаксис: \ic{(function (lambda \ii{аргументы} \ii{тело}))}
         (let* ((f   (cadr e))
                (fun (d.make-function (cadr f) (cddr f) env)) )
           (d.make-closure fun env) ) )
        ((lambda) (d.make-function (cadr e) (cddr e) env))
        (else     (d.invoke (d.evaluate (car e) env)
                            (evlis (cdr e) env)
                            env )) ) ) )</p>

<p>(define (d.invoke fn args env)
  (if (procedure? fn)
      (fn args env)
      (wrong "Not a function" fn) ) )</p>

<p>(define (d.make-function variables body env)
  (lambda (values current.env)
    (eprogn body (extend current.env variables values)) ) )</p>

<p>(define (d.make-closure fun env)
  (lambda (values current.env)
    (fun values env) ) )</pre>


<!--\indexR{переменные!специальные}-->
<!--\indexC{special}-->
<p>Но это ещё не конец всей истории. <code><span class="func">function</span></code> — это лишь костыль, на
который опиралась хромая реализация Лиспа. С созданием первых компиляторов стало
ясно, что с точки зрения производительности у лексической области видимости есть
(ожидаемое при компиляции) преимущество: можно сгенерировать код для более-менее
прямого доступа к любой переменной, а не динамически отыскивать её значение
заново каждый раз. Тогда по умолчанию стали делать все переменные лексическими,
за исключением тех, которые были явно помечены как динамические или, как тогда
их называли, <em class="term">специальные</em>. Выражение \ic{(declare (special \ii{x}))}
являлось командой компиляторам <span class="logo">Lisp 1.5</span>, \CommonLisp, Maclisp и других,
говорившей, что переменная \ii{x} ведёт себя «особенно».</p>


<!--\indexR{ссылочная прозрачность}-->
<p>Эффективность была не единственной причиной принятия такого решения. Другой
причиной была потеря <em class="term">ссылочной прозрачности</em> (\english{referential
transparency}). Ссылочная прозрачность — это свойство языка, заключающееся
в том, что замена в программе любого выражения его эквивалентом никак не изменит
поведение этой программы (оба варианта программы или вернут одно и то же
значение, или вместе застрянут в бесконечном цикле). Например:</p>

<pre>(let ((x (lambda () 1))) (x)) |\eq| ((let ((x (lambda () 1))) x)) |\eq| 1</pre>

<p>В общем случае ссылочная прозрачность теряется, если язык позволяет побочные
эффекты. Чтобы она сохранилась и при наличии побочных эффектов, необходимо
точнее определить понятие эквивалентных выражений. Scheme обладает ссылочной
прозрачностью, если не использовать присваивания, функции с побочными эффектами
и продолжения. \seeEx[escape/ex:crazy-cc] Это свойство желаемо и в наших
программах, если мы хотим сделать их по-настоящему повторно используемыми, как
можно менее зависимыми от контекста использования.</p>


<!--\indexR{переменные!безымянные}-->
<!--\indexR{альфа@$\alpha$-конверсия}-->
<p>Локальные переменные функций вроде <code><span class="func">(lambda (u) (+ u u))</span></code> иногда называются
<em>безымянными</em>. Их имена ничего не значат и могут быть абсолютно
произвольными. Функция <code><span class="func">(lambda (n347) (+ n347 n347))</span></code> — это та же
самая\footnote{В терминах λ-исчисления подобная замена имён называется
$\alpha$-конверсией.} функция, что и <code><span class="func">(lambda (u) (+ u u))</span></code>.</p>

<p>Мы ожидаем, что в языке будет сохраняться этот инвариант. Но это невозможно
в динамическом Лиспе. Рассмотрим следующий пример:</p>


<!--\indexC{map}-->
<pre>(define (map fn l)  ; или <code><span class="func">mapcar</span></code>, как кому нравится
  (if (pair? l)
      (cons (fn (car l)) (map fn (cdr l)))
      '() ) )</p>

<p>(let ((l '(a b c)))
  (map (lambda (x) (list-ref l x))
       '(2 1 0)))</pre>

<p>(Функция \ic{(list-ref $\ell$ \ii{n})} возвращает \ii{n}-й элемент
списка $\ell$.)</p>

<p>В Scheme мы бы получили <code><span class="func">(c b a)</span></code>, но в динамическом Лиспе результатом будет
<code><span class="func">(0 0 0)</span></code>! Причина: свободная переменная <code><span class="func">l</span></code> в функции <code><span class="func">(lambda (x)
(list-ref l x))</span></code>, имя которой уже занято локальной переменной <code><span class="func">l</span></code>
в <code><span class="func">map</span></code>.</p>

<p>Это затруднение можно решить, просто изменив конфликтующие имена. Например,
достаточно будет переименовать какую-нибудь из двух <code><span class="func">l</span></code>. Например, ту,
которая внутри <code><span class="func">map</span></code>, потому что это более разумно. Но какое имя выбрать,
чтобы эта проблема не возникла снова? Если приписывать спереди к имени каждой
переменной номер паспорта программиста, а сзади — текущее \UNIX-время, то
это, конечно, значительно снизит вероятность коллизий, но читабельность программ
будет оставлять желать лучшего.</p>

<p>В начале восьмидесятых годов сложилась довольно неприятная ситуация: студентов
учили Лиспу на примере интерпретаторов, но их понимание областей видимости
отличалось от понимания компиляторов. В 1975 году Scheme <span class="cite">[<a href="z1_bibliography.xhtml#ss75">ss75</a>]</span> показал,
что интерпретатор и компилятор возможно примирить, поместив обоих в мир, где все
переменные лексические. <span class="logo">Common Lisp</span> забил последний гвоздь в гроб этой
проблемы, постановив, что <em>хорошее</em> понимание — это понимание
компилятора, а для него удобнее лексические переменные. Интерпретатор должен
был подчиниться новым правилам. Растущий успех Scheme и других функциональных
языков, вроде ML и компании, популяризовал новый подход сначала в языках
программирования, а затем и в умах людей.</p>

<p>
\subsection{Дальнее и ближнее связывание}%
\label{basics/representing-functions/ssect:deep-or-shallow}</p>


<!--\indexR{дальнее (deep) связывание}-->
<!--\indexR{связывание!дальнее (deep)}-->
<!--\indexCS{lookup}{стоимость}-->
<p>Но не всё так просто заканчивается. Разработчики языков нашли способы ускорить
поиск значений динамических переменных. Если окружения представлены
ассоциативными списками, то время на поиск значения переменной (стоимость вызова
<code><span class="func">lookup</span></code>) линейно зависит от длины списка.\footnote*{К счастью, статистика
показывает, что переменные, располагающиеся ближе к началу списка, используются
чаще тех, что находятся глубоко внутри. Кстати, ещё стоит отметить, что
лексические окружения в среднем меньше по размеру, чем динамические, так как
последним необходимо хранить все переменные, участвующие в вычислениях, включая
одноимённые <span class="cite">[<a href="z1_bibliography.xhtml#bak92a">bak92a</a>]</span>.} Такой подход называется <em class="term">глубоким</em> или
<em class="term">дальним связыванием</em> (deep binding), так как значения динамических
переменных обычно располагаются на некотором удалении от текущего локального
окружения.</p>


<!--\indexR{ближнее (shallow) связывание}-->
<!--\indexR{связывание!ближнее (shallow)}-->
<!--\indexE{Cval}-->
<p>Существует и другой метод, называемый <em class="term">поверхностным</em> или <em class="term">ближним
связыванием</em> (shallow binding). Суть его в том, что переменная напрямую связана
с местом, где хранится её значение в текущий момент, без привязки к окружению.
Проще всего это реализовать, положив это значение в специальное поле символа,
соответствующего этой переменной; это поле называют <code><span class="func">Cval</span></code> или <em class="term">ячейкой
значения</em> (value cell). В таком случае стоимость <code><span class="func">lookup</span></code> постоянна или около
того: требуется лишь одна косвенная адресация и, может быть, сдвиг. Так как
бесплатный сыр бывает только в мышеловке, то стоит отметить, что вызов функции
при использовании этого метода выходит дороже, потому что требуется сначала
где-то сохранить старые значения аргументов, затем записать новые значения
в поля соответствующих символов. А потом, что самое важное, после выхода из
функции старые значения в символах необходимо восстановить обратно, а это может
помешать оптимизации хвостовой рекурсии. (Хотя есть варианты: <span class="cite">[<a href="z1_bibliography.xhtml#sj93">sj93</a>]</span>.)</p>

<p>Изменив структуру окружений, мы сможем частично проэмулировать\footnote{Здесь мы
не реализуем присваивание переменным, захваченным замыканиями. Об этом можно
почитать в <span class="cite">[<a href="z1_bibliography.xhtml#bcsj86">bcsj86</a>]</span>.} ближнее связывание. Но с оговорками: список
аргументов не может быть точечным (так будет легче его разбирать) и мы не будем
проверять арность функций. Новые функции будем обозначать префиксом <code><span class="func">s.</span></code>,
чтобы не путать их с другими.</p>


<!--\indexC{s.make-function}-->
<!--\indexC{s.lookup}-->
<!--\indexC{s.update"!}-->
<pre>(define (s.make-function variables body env)
  (lambda (values current.env)
    (let ((old-bindings
           (map (lambda (var val)
                  (let ((old-value (getprop var 'apval)))
                    (putprop var 'apval val)
                    (cons var old-value) ) )
                variables
                values ) ))
      (let ((result (eprogn body current.env)))
        (for-each (lambda (b) (putprop (car b) 'apval (cdr b)))
                  old-bindings )
        result ) ) ) )</p>

<p>(define s.lookup id env
  (getprop id 'apval) )</p>

<p>(define s.update! id env value
  (putprop id 'apval value) )</pre>


<!--\indexC{putprop}-->
<!--\indexC{getprop}-->
<p>В Scheme функции <code><span class="func">putprop</span></code> и <code><span class="func">getprop</span></code> не входят в стандарт, так как здесь
не любят неэффективные глобальные побочные эффекты, но тем не менее, даже
в <span class="cite">[<a href="z1_bibliography.xhtml#as85">as85</a>]</span> есть аналогичные <code><span class="func">put</span></code> и <code><span class="func">get</span></code>.
\seeEx[lisp1-2-omega/ex:write-put/get-prop]</p>


<!--\indexR{списки свойств}-->
<!--\indexR{символы!списки свойств}-->
<!--\indexE{P-список}-->
<!--\indexR{хеш-таблицы}-->
<p>С помощью этих функций мы эмулируем наличие у символов поля,\footnote*{Это поле
названо в честь <code><span class="func">apval</span></code> из <span class="cite">[<a href="z1_bibliography.xhtml#mae+62">mae+62</a>]</span>. \seePage[lisp1-2-omega/par:apval]
Тогда значения полей действительно хранились в наивных P-списках.} где хранится
значение одноимённой переменной. Независимо от их настоящей реализации,%
\footnote*{Эти функции проходят по списку свойств символа (его P-списку,
от property) до тех пор, пока не найдут нужное. Скорость поиска, соответственно,
линейно зависит от длины списка, если только не применяются хеш-таблицы.} будем
считать, что они выполняются за постоянное время.</p>

<p>Заметьте, что в этой реализации абсолютно не используется окружение определения
<code><span class="func">env</span></code>. Поэтому для поддержки замыканий нам потребуется изменить реализацию
<code><span class="func">make-closure</span></code>, так как она теперь не имеет доступа к окружению определения
(ввиду его отсутствия). При создании замыкания необходимо просмотреть тело
функции, выделить все свободные переменные и правильно их сохранить внутри
замыкания. Мы реализуем это позже.</p>


<!--\indexE{rerooting}-->
<p>Дальнее связывание облегчает смену окружений и многозадачность, теряя в скорости
поиска переменных. Ближнее связывание ускоряет поиск переменных, но теряет
в скорости вызова функций. Генри Бейкеру <span class="cite">[<a href="z1_bibliography.xhtml#bak78">bak78</a>]</span> удалось объединить эти два
подхода в технику под названием <em class="term">rerooting</em>.</p>

<p>Наконец, не забывайте, что ближнее и дальнее связывание — это лишь способы
реализации, они никак не влияют на само понятие связывания.</p>

<h2 id="basics/sect:global-environment">Глобальное окружение</h2>


<!--\indexR{библиотека!функций}-->
<!--\indexR{Лисп!примитивы}-->
<p>Пустое глобальное окружение — это печально, поэтому большинство лисп-систем
предоставляют <em>библиотеки</em> функций. Например, в глобальном окружении
<span class="logo">Common Lisp</span> (CLtL1) около 700 функций, у Le_Lisp их более 1500,
у {\ZetaLisp} — более 10\,000. Без библиотек Лисп был бы лишь прикладным
λ-исчислением, в котором нельзя даже распечатать полученные результаты.
Библиотеки очень важны для конечного пользователя. Специальные формы — это
строительные кирпичики для разработчиков интерпретаторов, но для конечного
пользователя такими кирпичиками являются функции библиотек. По-видимому, именно
отсутствие в чистом Лиспе таких банальных вещей вроде библиотеки
тригонометрических функций прочно укоренило мысль о непригодности Лиспа для
«серьёзных программ». Как говорится в <span class="cite">[<a href="z1_bibliography.xhtml#sla61">sla61</a>]</span>, возможность символьного
интегрирования или дифференцирования — это, конечно, замечательно, но кому
нужен язык, где нет даже синуса или тангенса?</p>

<p>Мы ожидаем, что все привычные функции вроде <code><span class="func">cons</span></code>, <code><span class="func">car</span></code> и т. п. будут
доступны в глобальном окружении. Также можно туда поместить несколько простых
констант вроде логических значений и пустого списка.</p>

<p>Для этого мы определим пару макросов. Исключительно для удобства, потому что мы
о них ещё даже не говорили.\footnote*{Согласитесь, было бы странным втискивать
всю книгу в первую главу.} Макросы — это довольно сложная и важная вещь сами
по себе, так что им посвящена собственная глава. \seePage[chapter:macros]</p>

<p>Эти два макроса облегчат наполнение глобального окружения. Само глобальное
окружение является расширением начального окружения <code><span class="func">env.init</span></code>.</p>

<p>\ForLayout{display}{\begingroup
\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>


<!--\indexC{env.global}-->
<!--\indexC{definitial}-->
<!--\indexC{defprimitive}-->
<pre>(define env.global env.init)
|\ForLayout{display}{\vskip-0.4\baselineskip}|
(define-syntax definitial
  (syntax-rules ()
    ((definitial name)
     (begin (set! env.global (cons (cons 'name 'void) env.global))
            'name ) )
    ((definitial name value)
     (begin (set! env.global (cons (cons 'name value) env.global))
            'name ) ) ) )
|\ForLayout{display}{\vskip-0.4\baselineskip}|
(define-syntax defprimitive
  (syntax-rules ()
    ((defprimitive name value arity)
     (definitial name
        (lambda (values)
          (if (= arity (length values))
              (apply value values)      ; Родная <code><span class="func">apply</span></code> Scheme
              (wrong "Incorrect arity" (list 'name values)|\:|)|\:|)|\:|)|\:|)|\:|)|\:|)|\:|)</pre>


<!--\indexC{the-false-value}-->
<p>Несмотря на то, что стандарт Scheme этого не требует, мы определим несколько
полезных констант. Заметим, что <code><span class="func">t</span></code> — это переменная в определяемом Лиспе,
а <code><span class="func">\#t</span></code> — это значение из определяющего Лиспа. Оно подходит, так как любое
значение, не совпадающее с <code><span class="func">the-false-value</span></code>, является <em class="term">истиной</em>.</p>

<pre>(definitial t #t)
(definitial f the-false-value)
(definitial nil '())</pre>

<p>\ForLayout{display}{\endgroup}</p>


<!--\indexR{синтаксис!для \protect<code><span class="func">\#t</span></code> и <code><span class="func">\#f</span></code>}-->
<!--\indexR{логические значения}-->
<p>Хотя это удобно — иметь глобальные переменные с настоящими объектами для
данных сущностей, но есть и другое решение: особый синтаксис. Scheme использует
<code><span class="func">\#t</span></code> и <code><span class="func">\#f</span></code>, подставляя вместо них логические <em class="term">истину</em> и
<em class="term">ложь</em>. В этом есть определённый смысл:</p>

<p>\begin{enumerate}
  \item Они всегда видимы: <code><span class="func">\#t</span></code> означает <em class="term">истину</em> в любом
        контексте, даже тогда, когда локальная переменная
        названа <code><span class="func">t</span></code>.

  \item Значение <code><span class="func">\#t</span></code> невозможно изменить, но многие интерпретаторы
        позволят изменить значение глобальной переменной <code><span class="func">t</span></code>.
\end{enumerate}</p>

<p>Например, выражение <code><span class="func">(if t 1 2)</span></code> вернёт <code><span class="func">2</span></code>, если оно вычисляется
в следующем окружении: <code><span class="func">(let ((t \#f)) (if t 1 2))</span></code>.</p>


<!--\indexC{eq?}-->
<p>Существует много способов ввести такой синтаксис. Наиболее простой способ —
это вшить значения <code><span class="func">t</span></code> и <code><span class="func">f</span></code> в вычислитель:</p>

<pre>(define (evaluate e env)
  (if (atom? e)
      (cond ((eq? e 't) #t)
            ((eq? e 'f) #f)
            ...
            ((symbol? e) (lookup e env))
            ...
            (else (wrong "Cannot evaluate" exp)) )
      ... ) )</pre>


<!--\indexR{инлайнинг!функций}-->
<!--\indexR{встраивание!функций}-->
<!--\indexR{функции!встраиваемые}-->
<!--\indexR{связывание!изменяемое}-->
<!--\indexR{связывание!неизменяемое}-->
<p>Также мы могли бы ввести понятия <em class="term">изменяемого</em> и <em class="term">неизменяемого</em>
связывания. Неизменяемые переменные отвергаются присваиванием. Ничто и никогда
не сможет изменить значение неизменяемой переменной. Такая концепция существует,
хоть и не всегда явно, во многих системах. Например, существуют так называемые
<em class="term">инлайн-функции</em> (также известные как <em class="term">подставляемые</em> или
<em class="term">встраиваемые</em>), вызов которых можно полностью заменить прямой подстановкой
их тела. \seePage[fast/fast/integrating/par:inlining]</p>

<p>Чтобы можно было спокойно подставить вместо <code><span class="func">(car x)</span></code> код функции,
возвращающей левый элемент точечной пары <code><span class="func">x</span></code>, необходимо быть абсолютно
уверенным в том, что значение глобальной переменной <code><span class="func">car</span></code> никогда не менялось
и не поменяется в будущем. Посмотрите, какая беда случается, если это не так:</p>

<pre>(set! my-global (cons 'c 'd))
   |\is| (c . d)
(set! my-test (lambda () (car my-global)))
   |\is| #<MY-TEST procedure>
(begin (set! car cdr)
       (set! my-global (cons 'a 'b))
       (my-test) )
   |\is| |\ii{?????}|</pre>

<p>К счастью, в результате может получиться только <code><span class="func">a</span></code> или <code><span class="func">b</span></code>. Если
<code><span class="func">my-test</span></code> использует значение <code><span class="func">car</span></code> на момент определения, то мы
получим <code><span class="func">a</span></code>. Если же <code><span class="func">my-test</span></code> будет использовать текущее
значение <code><span class="func">car</span></code>, то ответом будет <code><span class="func">b</span></code>. Полезным будет также сравнить в этом
аспекте <code><span class="func">my-test</span></code> и <code><span class="func">my-global</span></code>: обычно первый вариант поведения ожидается
от <code><span class="func">my-test</span></code> при использовании компилятора, тогда как для <code><span class="func">my-global</span></code>
нормальным считается именно второй вариант.
\seePage[lisp1-2-omega/recusion/simple/code:redefine]</p>


<!--\indexC{foo}-->
<!--\indexC{bar}-->
<!--\indexC{fib}-->
<!--\indexC{fact}-->
<p>Также мы добавим несколько рабочих переменных\footnote{К сожалению, сейчас они
ещё и инициализируются. Эта ошибка будет исправлена позже.} в глобальное
окружение, так как сейчас у нас нет способа динамически создавать переменные.
По статистике, предлагаемые имена составляют приблизительно {96,037\,\%}
используемых при тестировании свеженаписанных интерпретаторов.</p>

<p>%\ForLayout{display}{\begingroup
%\lstset{aboveskip=\smallskipamount, belowskip=\smallskipamount}}</p>

<pre>(definitial foo)
(definitial bar)
(definitial fib)
(definitial fact)</pre>

<p>%\ForLayout{display}{\endgroup}</p>

<p>Наконец, определим несколько примитивных функций (не все, потому что такие
полные списки — это хорошее снотворное). Главная сложность состоит
в соединении механизмов вызова функций определяемого и определяющего языков.
Зная, что аргументы собираются нашим интерпретатором в список, достаточно просто
применить
к нему <code><span class="func">apply</span></code>.\footnote*{Можно только порадоваться за наш выбор не называть
<code><span class="func">invoke</span></code> «<code><span class="func">apply</span></code>».} Заметьте, что арность функций будет соблюдаться,
так как мы включили проверку в определение макроса <code><span class="func">defprimitive</span></code>.</p>

<pre>(defprimitive cons cons 2)
(defprimitive car car 1)
(defprimitive set-cdr! set-cdr! 2)
(defprimitive + + 2)
(defprimitive eq? eq? 2)
(defprimitive < < 2)</pre>

<h2 id="basics/sect:starting-the-interpreter">Запускаем интерпретатор</h2>

<p>Нам осталось показать только одну вещь: дверь в наш новый мир.</p>


<!--\indexC{chapter1-scheme}-->
<pre>(define (chapter1-scheme)
  (define (toplevel)
    (display (evaluate (read) env.global))
    (toplevel) )
  (toplevel) )</pre>

<p>Поскольку наш интерпретатор ещё мал и неопытен, но подаёт большие надежды,
предлагаем вам в качестве упражнения написать функцию, позволяющую из него
выйти.</p>

<h2 id="basics/sect:conclusions">Заключение</h2>


<!--\indexR{язык!и смысл программ}-->
<p>Действительно ли мы сейчас определили язык?</p>


<!--\indexR{смысл программ}-->
<!--\indexR{программы!смысл}-->
<p>Нет никаких сомнений в том, что мы можем запустить <code><span class="func">evaluate</span></code>, передать ей
выражение, и она вскоре вернёт результат вычислений. Но сама функция
<code><span class="func">evaluate</span></code> не имеет никакого смысла без языка своего определения, а если
у нас нет определения языка определения, то мы вообще ни в чём не можем
быть уверены. Так как каждый лиспер является дальним родственником барона
Мюнхгаузена, то, наверное, будет достаточно взять в качестве языка определения
тот, который мы только что определили. Следовательно, у нас есть язык $L$,
определённый функцией <code><span class="func">evaluate</span></code>, написанной на языке $L$. Такой язык
является решением следующего уравнения относительно $L$:
%
\begin{equation*}
  \forall\pi \in \Vset{Программы}\colon
    L\text{<code><span class="func">(evaluate (quote $\pi$) env.global)</span></code>} \equiv L\pi
\end{equation*}</p>

<p>Исполнение любой программы $\pi$, написанной на $L$ (обозначается как $L\pi$),
должно вести себя так же (то есть давать тот же результат или никогда
не завершаться), как и выражение <code><span class="func">(evaluate (quote $\pi$) env.global)</span></code> на
том же языке $L$. Одним из занимательных следствий этого утверждения является
то, что <code><span class="func">evaluate</span></code> способна\footnote{После того, как мы раскроем все
используемые макросы и сокращения вроде <code><span class="func">let</span></code>, <code><span class="func">case</span></code>, <code><span class="func">define</span></code>
и т. д. Потом надо будет ещё поместить в глобальное окружение функции
<code><span class="func">evaluate</span></code>, <code><span class="func">evlis</span></code> и др.} проинтерпретировать сама себя. Следовательно,
следующие выражения эквивалентны:</p>

<pre>(evaluate (quote |$\pi$|) env.global) |\eq|
  |\eq| (evaluate (quote (evaluate (quote |$\pi$|) env.global)) env.global)</pre>

<p>Есть ли ещё решения приведённого уравнения? Да, и их великое множество! Как мы
видели раньше, определение <code><span class="func">evaluate</span></code> вовсе не обязательно указывает порядок
вычислений. Множество других свойств языка, используемого для определения,
бессознательно <em>наследуются</em> определяемым языком. Мы, по сути, ничего
не можем о них сказать, но все эти варианты претендуют на решение указанного
уравнения. Вместе с многочисленными тривиальными решениями. Рассмотрим,
к примеру, язык $L_{2001}$, любая программа на котором возвращает $2001$. Даже
такой язык удовлетворяет этому уравнению. Поэтому для определения настоящих
языков необходимы другие методы, их мы рассмотрим в следующих главах.</p>

<h2 id="basics/sect:exercises">Упражнения</h2>

<p>\begin{exercise}\label{basics/ex:tracer}
<!--\indexR{трассировка}-->
Модифицируйте функцию <code><span class="func">evaluate</span></code> так, чтобы она стала трассировщиком. Все
вызовы функций должны выводить на экран фактические аргументы и возвращаемый
результат. Легко представить себе дальнейшее развитие этого инструмента
в пошаговый отладчик, вдобавок позволяющий изменять порядок выполнения
отлаживаемой программы.
\end{exercise}</p>

<p>\begin{exercise}\label{basics/ex:excess-recursion}
Если функции <code><span class="func">evlis</span></code> передаётся список из одного выражения, она делает
один лишний рекурсивный вызов. Придумайте способ, как избавиться от него.
\end{exercise}</p>

<p>\begin{exercise}\label{basics/ex:new-extend}
Предположим, новая функция <code><span class="func">extend</span></code> определена так:</p>


<!--\indexC{extend}-->
<pre>(define (extend env names values)
  (cons (cons names values) env) )</pre>

<p>Определите соответствующие функции <code><span class="func">lookup</span></code> и <code><span class="func">update!</span></code>. Сравните их
с ранее рассмотренными.
\end{exercise}</p>

<p>\begin{exercise}\label{basics/ex:racks}
<!--\indexR{ближнее (shallow) связывание}-->
<!--\indexR{связывание!ближнее (shallow)}-->
<!--\indexE{rack}-->
В работе <span class="cite">[<a href="z1_bibliography.xhtml#ss80">ss80</a>]</span> предлагается другой механизм ближнего связывания, названный
<em class="term">rack</em>. Символ связывается с полем, хранящим не единственное значение, а
стек значений. В каждый момент времени значением переменной является находящаяся
на вершине стека величина. Перепишите функции <code><span class="func">s.make-function</span></code>,
<code><span class="func">s.lookup</span></code> и <code><span class="func">s.update!</span></code> для реализации этой идеи.
\end{exercise}</p>

<p>\begin{exercise}\label{basics/ex:liar-liar!}
<!--\indexR{представление!логических значений}-->
Если вы ещё не заметили, то в определение функции <code><span class="func"><</span></code> вкралась ошибка! Ведь
эта функция должна возвращать логические значения определяемого языка, а
не определяющего. Исправьте это досадное недоразумение.
\end{exercise}</p>

<p>\begin{exercise}\label{basics/ex:def-list}
Определите функцию <code><span class="func">list</span></code>.
\end{exercise}</p>

<p>\begin{exercise}\label{basics/ex:def-call/cc}
Для обожающих продолжения: определите <code><span class="func">call/cc</span></code>.
\end{exercise}</p>

<p>\begin{exercise}\label{basics/ex:def-apply}
Определите функцию <code><span class="func">apply</span></code>.
\end{exercise}</p>

<p>\begin{exercise}\label{basics/ex:def-end}
Определите функцию <code><span class="func">end</span></code>, позволяющую выйти из интерпретатора, разработанного
в этой главе.
\end{exercise}</p>

<p>\begin{exercise}\label{basics/ex:slowpoke}
<!--\indexR{уровни интерпретации}-->
<!--\indexR{интерпретация!уровневая}-->
Сравните скорость Scheme и <code><span class="func">evaluate</span></code>. Затем сравните скорость <code><span class="func">evaluate</span></code>
и <code><span class="func">evaluate</span></code>, интерпретируемой с помощью <code><span class="func">evaluate</span></code>.
\end{exercise}</p>

<p>\begin{exercise}\label{basics/ex:no-gensym}
Ранее мы смогли успешно определить <code><span class="func">begin</span></code> через <code><span class="func">lambda</span></code>
\seePage[basics/forms/sequence/par:gensym-puzzle], но для этого нам
потребовалось использовать функцию <code><span class="func">gensym</span></code>, чтобы избежать коллизий имён
переменных. Переопределите <code><span class="func">begin</span></code> в таком же духе, но без использования
<code><span class="func">gensym</span></code>.
\end{exercise}</p>

<p>
\section*{Рекомендуемая литература}</p>

<p>Все работы по интерпретаторам, приведённые в начале этой главы, являются
довольно интересными, но если вы не можете столько читать, то вот наиболее
стоящие из них:
\begin{itemize}
  \item среди «$\lambda$-papers»: <span class="cite">[<a href="z1_bibliography.xhtml#ss78a">ss78a</a>]</span>;

  \item самая короткая в мире статья, которая содержит полный интерпретатор
        Лиспа: <span class="cite">[<a href="z1_bibliography.xhtml#mcc78b">mcc78b</a>]</span>;

  \item «нестрого формальное» описание интерпретации: <span class="cite">[<a href="z1_bibliography.xhtml#rey72">rey72</a>]</span>;

  \item местная книга Бытия: <span class="cite">[<a href="z1_bibliography.xhtml#mae+62">mae+62</a>]</span>.
\end{itemize}</p>

</body>
</html>
